<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:type" content="website">
<meta property="og:title" content="外心人D的博客">
<meta property="og:url" content="https://bubbleboy11.github.io/page/2/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">359</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/20/go-de-goroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/20/go-de-goroutine/" class="post-title-link" itemprop="url">go的goroutine</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-19T16:21:41Z">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-04 13:56:24" itemprop="dateModified" datetime="2021-10-04T13:56:24Z">2021-10-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>场景一：<br>不允许后面的逻辑，必需要等前面的完成才能执行<br>场景二：<br>批量操作相同的信息，批量发送信息</p>
<p>Goroutine Thread<br>内存占⽤ 2KB -&gt; 1GB 从 8k 开始，服务端程序上限很多是 8M(⽤ulimit -a 可看)，调⽤多会 stack overflow<br>Context switch ⼏⼗ NS 级 1-2 us<br>由谁管理 Go runtime 操作系统<br>通信⽅式 CSP/传统共享内存 传统共享内存<br>ID 有，⽤户⽆法访问 有<br>抢占 1.13 以前需主动让出 1.14 开始可由信号中断  | 内核抢占</p>
<p>简介<br>因为并发程序要考虑很多的细节，以保证对共享变量的正确访问，使得并发编程在很多情况下变得很复杂。<br>但是Go语言在开发并发时，是比较简洁的。它通过channel来传递数据。数据竞争这个问题在golang的设计上就进行了规避了。</p>
<blockquote>
<p>Don’t communicate by sharing memory; share memory by communicating.<br>不要通过共享内存来通信；通过通信来实现共享内存</p>
</blockquote>
<p>Go语言用2种手段来实现并发程序，goroutine和channel，其支持顺序通信进程（communication sequential processes），简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中，值会在不同的运行实例（goroutine）中传递。</p>
<p>在并发系统中，对goroutine的切换时机和运行结果就没有唯一的保证性。<br>在go语言中，我们采用channel来进行goroutine之间的通信，能更容易的保证结果的一致性<br>多个协程可以在一个或多个线程上运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -race xx.go</span><br></pre></td></tr></tbody></table></figure>

<p>查看运行是否有数据访问冲突</p>
<p>每一个线程 下面都有一个 Go自己实现的协程处理器<br>然后下面就是协程队列<br>Processor就会依次运行协程</p>
<p>go会监听这个队列如果一个时间段这个队列数量还是没有发生变化,golang就会吧当前的goroutine放到当前队列的队尾</p>
<p>当某一个协程被系统中断,processor就会吧这个协程,放到其他空闲的线程上</p>
<p>初学者可以完全将协程理解为线程，但是用起来比线程更加简单，占用的资源也更少。<br>通常在一个进程里启动上万个线程就已经不堪重负，但是 Go 语言允许你启动百万协程也可以轻松应付。</p>
<p>A goroutine is a lightweight thread managed by the Go runtime.<br>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>在Go语言中，每一个并发的执行单元就叫做goroutine。<br>每个goroutine都对应一个非常简单的模型：它是一个并发的执行函数，并且在多个并发的goroutine间，资源是共享的。goroutine非常轻量，创建的开销很少。</p>
<p>goroutine 语法格式：在函数前加上一个关键字：<code>go</code>。Go 语言就能送给调试器运行启动一个新的协程，函数调用将成为这个协程的入口。<br>不需要在定义时区分是否是异步函数，python才需要<br>调度器在合适的点进行切的</p>
<p>go routine 可能的切换点</p>
<ul>
<li>I/0, select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用（有时）</li>
<li><code>runtime.Gosched()</code></li>
<li>只是参考，不能保证切换，不能保证在其他地方不切换<br>go语言调度器开的线程数一般不会超过机器的CPU核数</li>
</ul>
<p>值得注意的是这里的 go 关键字语法和前面的 defer 关键字语法是一样的，它后面跟了一个匿名函数，然后还要带上一对<code>()</code>，表示对匿名函数的调用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></tbody></table></figure>

<p>starts a new goroutine running 开启一个新的 goroutine:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></tbody></table></figure>

<p>The evaluation of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.<br>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。<br>Goroutines run in the same address space, so access to shared memory must be synchronized. 同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<p>The <code>sync</code> package provides useful primitives, although you won’t need them much in Go as there are other primitives. (See the next slide.)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="comment">// 等待十秒输出</span></span><br><span class="line">fmt.Println(<span class="string">"I am here"</span>) <span class="comment">// I am here</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">}()</span><br><span class="line"><span class="comment">// 这里直接输出，不会等待十秒</span></span><br><span class="line">fmt.Println(<span class="string">"I am here"</span>) <span class="comment">// I am here</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">    say(<span class="string">"hello"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"In main"</span>)</span><br><span class="line">    <span class="keyword">go</span> longSleep()</span><br><span class="line">    <span class="keyword">go</span> shortSleep()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"sleep "</span>)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * <span class="number">1e9</span>)<span class="comment">//ns，符号 1e9 表示 1 乘 10 的 9 次方，e=指数</span></span><br><span class="line">    fmt.Println(<span class="string">"the end of main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longSleep</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"longSleep begin"</span>)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"longSleep end"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortSleep</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"shortSleep begin"</span>)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"shortSleep end"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">In main</span><br><span class="line">sleep</span><br><span class="line">longSleep begin</span><br><span class="line">shortSleep begin</span><br><span class="line">shortSleep end</span><br><span class="line">longSleep end</span><br><span class="line">the end of main</span><br></pre></td></tr></tbody></table></figure>

<p>main() ，longSleep() 和 shortSleep() 这3个函数都是独立的处理单元按顺序启动，然后开始并行运行。为了模拟<br>运算时间的损耗，我们使用了sleep()函数，这个函数可以按照指定时间来暂停函数或协程执行。</p>
<p>如果我们不在main()函数中sleep()较长的时间，那么main() 函数结束时，其他协程运行的程序也会结束。main()程序退出，它不会等待任何其他非main协程的结束。<br>协程是独立的处理单元，一旦陆续启动一些协程，就无法确定他们是什么时候正在开始运行的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGoroutine</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1999</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"run in child goroutine"</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"run in grand child goroutine"</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">                fmt.Println(<span class="string">"run in grand grand child goroutine"</span>)</span><br><span class="line">            }()</span><br><span class="line">        }()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine will quit"</span>)</span><br><span class="line">}</span><br><span class="line">-------</span><br><span class="line">run in main goroutine</span><br><span class="line">run in child goroutine</span><br><span class="line">run in grand child goroutine</span><br><span class="line">run in grand grand child goroutine</span><br><span class="line">main goroutine will quit</span><br></pre></td></tr></tbody></table></figure>

<p>main 函数运行在主协程(main goroutine)里面，上面的例子中我们在主协程里面启动了一个子协程，子协程又启动了一个孙子协程，孙子协程又启动了一个曾孙子协程。这些协程之间似乎形成了父子、子孙、关系，但是实际上协程之间并不存在这么多的层级关系，在 Go 语言里只有一个主协程，其它都是它的子协程，子协程之间是平行关系。</p>
<p>上面的代码中主协程睡眠了 1s，等待子协程们执行完毕。如果将睡眠的这行代码去掉，将会看不到子协程运行的痕迹</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="built_in">run</span> <span class="keyword">in</span> main goroutine</span><br><span class="line">main goroutine will quit</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为主协程运行结束，其它协程就会立即消亡，不管它们是否已经开始运行</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span>{</span><br><span class="line">    fmt.Println(<span class="string">"p"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">}</span><br><span class="line">没有打印输出 因为主协程运行结束，其它协程来不及执行完就会立即消亡，不管它们是否已经开始运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span>{</span><br><span class="line">    fmt.Println(<span class="string">"p"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">main</span><br><span class="line">没有打印输出p，主死从随，因为主协程运行结束，其它协程就会立即消亡，不管它们是否已经开始运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">p ，主协程挂起<span class="number">1</span>秒钟，从的协程立刻执行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">q</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(<span class="string">"dead circle"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> q()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>) <span class="comment">// 如果不加这个 因为go开了协程 mian函数本身也是一个协程，如果main退出整个函数就退出了，程序中断</span></span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">... 一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            fmt.Println(<span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">... 一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">                time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">只有打印了这几个，一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">...</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">                <span class="comment">// 主死从随</span></span><br><span class="line">                time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line">...</span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">92</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">...</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">79</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">                time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">69</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">96</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">84</span></span><br><span class="line">这样就没有重复，不按顺序是协程谁先调度谁后调度是系统内部，不是先启动就先运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10000</span> == <span class="number">0</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"%d goroutine started\n"</span>, i) <span class="comment">// IO操作里面切换，有等待的过程</span></span><br><span class="line">    }</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码将会无休止地创建协程，每个协程都在睡眠，为了确保它们都是活的，协程会 1s 钟醒过来一次。在我的个人电脑上，这个程序创建了千万个协程还没有到上限，观察内存发现占用还不到 1G，这意味着每个协程的内存占用还不到 100 字节。</p>
<p>go的协程和 python的协程-网上有些人可能喜欢拿web框架来做性能对比<br>go的 gin begoo-flask/ django 性能对比 这个不科学的 uwsgi 协程<br>go的 gin begoo-flask/ django + gevent性能对比<br>tornado sanic fastapi/ asyncio 协程库我们就不再使用python的线程来对比<br>只要大家懂了任何一门语言的协程，其他语言的协程都很好理解 GMP<br>大家都开启100W个协程<br>使用的简单性- go 启动一个协程</p>
<p><code>WaitGroup</code> 实现等待某个协程或协程组结束完成的同步操作。父线程调用 <code>Add</code> 方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用 <code>Done</code> 方法 goroutine 内完成任务-1。同时，主线程里可以调用 <code>Wait</code> 方法阻塞至所有线程结束、计数归零。但在使用时要注意:<br>Add的数量和Done的调用数量必须相等。<br>另外，就是WaitGroup结构一旦定义就不能复制的原因。<br> WaitGroup在需要等待多个任务结束再返回的业务来说还是很有用的，但现实中用的更多的可能是，先等待一个协程组，若所有协程组都正确完成，则一直等到所有协程组结束；若其中有一个协程发生错误，则告诉协程组的其他协程，全部停止运行（本次任务失败）以免浪费系统资源。<br>该场景WaitGroup是无法实现的，那么该场景该如何实现呢，就需要用到通知机制，其实也可以用channel来实现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup{}</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        res += val</span><br><span class="line">        wg.Done() <span class="comment">// goroutine 内完成任务-1</span></span><br><span class="line">    }(i)</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(res) <span class="comment">// 45</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup{}</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        res += val</span><br><span class="line">        wg.Done()</span><br><span class="line">    }(i)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把这个注释掉你会发现，什么结果你都可能拿到</span></span><br><span class="line"><span class="comment">// wg.Wait()</span></span><br><span class="line">fmt.Println(res) <span class="comment">// 1 或者 15</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<p>如何解决主的goroutine在子协程结束后自动结束，主协程不用睡眠</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动1个协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 运行完减一个</span></span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span>  {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">5</span>) <span class="comment">// 启动5个协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> f(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        total = total + <span class="number">1</span></span><br><span class="line">        <span class="comment">//1. 从 total 取出值</span></span><br><span class="line">        <span class="comment">//2. 将 total+1</span></span><br><span class="line">        <span class="comment">//3. 将 total+1 的计算结果放入到total中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// 100000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>并发会产生的问题 -竞争</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        total = total - <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> sub()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// -36827</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 按理说： 最后的结果应该是0</span></span><br><span class="line"><span class="comment">2. 实际的情况：</span></span><br><span class="line"><span class="comment">  1. 不是0</span></span><br><span class="line"><span class="comment">  2. 每次的运行结果还不一样 54779、-29729</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">=== RUN   TestCounter</span><br><span class="line">time:  <span class="number">2071910</span></span><br><span class="line">--- PASS: TestCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">28</span>: <span class="number">4398</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    nowTime := time.Now().UnixNano()</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">    tTime := time.Now().UnixNano()</span><br><span class="line">    fmt.Println(<span class="string">"time: "</span>, (tTime - nowTime))</span><br><span class="line">}</span><br><span class="line">=== RUN   TestCounter</span><br><span class="line">time:  <span class="number">2071910</span></span><br><span class="line">--- PASS: TestCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">28</span>: <span class="number">4334</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    nowTime := time.Now().UnixNano()</span><br><span class="line">    <span class="keyword">var</span> nut sync.Mutex</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            nut.Lock()</span><br><span class="line">            <span class="keyword">defer</span> nut.Unlock()</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">    tTime := time.Now().UnixNano()</span><br><span class="line">    fmt.Println(<span class="string">"time: "</span>, (tTime - nowTime))</span><br><span class="line">}</span><br><span class="line">=== RUN   TestMutCounter</span><br><span class="line">time:  <span class="number">2151931</span></span><br><span class="line">--- PASS: TestMutCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">48</span>: <span class="number">5000</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<p>互斥写锁 <code>Mutex</code> 同步协程 同步数据 解决并发问题</p>
<p>能不用锁就别用锁 - 性能</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mutex</span><span class="params">()</span></span> {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">    <span class="comment">// 你的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        lock.Lock() <span class="comment">// 先把门锁上</span></span><br><span class="line">        total = total + <span class="number">1</span></span><br><span class="line">        <span class="comment">//1. 从 total 取出值</span></span><br><span class="line">        <span class="comment">//2. 将 total+1</span></span><br><span class="line">        <span class="comment">//3. 将 total+1 的计算结果放入到total中</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 放开锁，直接加defer 会报错？</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        lock.Lock() <span class="comment">// 先把门锁上</span></span><br><span class="line">        total = total - <span class="number">1</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 放开锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> sub()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>绝大多数的web系统来说 都是读多写少<br>有1w个人同时读数据库 A读的时候 B能读吗？ 为什么要加锁呢 一定要加锁 写和读上面加同一把锁<br>并发严重下降， B读了一个数据 不会对C读数据产生影响吗？ 一定是写和读之间造成的<br>读写锁 <code>RWLock</code> 尽量用，读之间不会产生影响，写和读之间才会产生影响<br>• 尽量用 defer 来释放锁，防止panic没有释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RwMutex</span><span class="params">()</span></span>  {</span><br><span class="line">    <span class="comment">// 加读锁</span></span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以加写锁</span></span><br><span class="line">    rwLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    fmt.Println(<span class="string">"开始读取数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">    fmt.Println(<span class="string">"读取成功"</span>)</span><br><span class="line">    rwLock.RUnlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">-</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">等了<span class="number">10</span>秒钟再打印下面的</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">fatal error: all goroutines are asleep - deadlock! 因为<span class="number">6</span>个协程实际上只有<span class="number">5</span>个</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    fmt.Println(<span class="string">"开始读取数据"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"读取成功"</span>)</span><br><span class="line">    rwLock.RUnlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.Lock() <span class="comment">// 没有wLock</span></span><br><span class="line">    fmt.Println(<span class="string">"开始修改数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"修改成功"</span>)</span><br><span class="line">    rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> write()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">等了<span class="number">10</span>秒钟再打印下面的</span><br><span class="line">修改成功</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.Lock() <span class="comment">// 没有wLock</span></span><br><span class="line">    fmt.Println(<span class="string">"开始修改数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"修改成功"</span>)</span><br><span class="line">    rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> write()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br></pre></td></tr></tbody></table></figure>

<p>锁不可重入：lock 之后，即便是同一个线程(goroutine)，也无法再次加锁（写递归函数要小心）</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可重入例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Failed1</span><span class="params">()</span></span>  {</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句会死锁</span></span><br><span class="line">    <span class="comment">// 但是如果你只有一个goroutine，那么这一个会导致程序崩溃</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>• 锁不可升级：加了读锁之后，如果试图加写锁，锁不升级</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可升级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Failed2</span><span class="params">()</span></span>  {</span><br><span class="line">    rwMutex.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwMutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句会死锁</span></span><br><span class="line">    <span class="comment">// 但是如果你只有一个goroutine，那么这一个会导致程序崩溃</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="子协程异常退出"><a href="#子协程异常退出" class="headerlink" title="子协程异常退出"></a>子协程异常退出</h4><p>在使用子协程时一定要特别注意保护好每个子协程，确保它们正常安全的运行。因为子协程的异常退出会将异常传播到主协程，直接会导致主协程也跟着挂掉，然后整个程序就崩溃了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"run in child goroutine"</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"run in grand child goroutine"</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">                fmt.Println(<span class="string">"run in grand grand child goroutine"</span>)</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"wtf"</span>)</span><br><span class="line">            }()</span><br><span class="line">        }()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine will quit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">run in main goroutine</span><br><span class="line">run in child goroutine</span><br><span class="line">run in grand child goroutine</span><br><span class="line">run in grand grand child goroutine</span><br><span class="line"><span class="built_in">panic</span>: wtf</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">34</span> [running]:</span><br><span class="line">main.main.func1<span class="number">.1</span><span class="number">.1</span>()</span><br><span class="line">    /Users/qianwp/<span class="keyword">go</span>/src/github.com/pyloque/practice/main.<span class="keyword">go</span>:<span class="number">14</span> +<span class="number">0x79</span></span><br><span class="line">created by main.main.func1<span class="number">.1</span></span><br><span class="line">    /Users/qianwp/<span class="keyword">go</span>/src/github.com/pyloque/practice/main.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0x75</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们看到主协程最后一句打印语句没能运行就挂掉了，主协程在异常退出时会打印堆栈信息。从堆栈信息中可以了解到是哪行代码引发了程序崩溃。</p>
<p>为了保护子协程的安全，通常我们会在协程的入口函数开头增加 <code>recover()</code> 语句来恢复协程内部发生的异常，阻断它传播到主协程导致程序崩溃。<code>recover</code> 语句必须写在 <code>defer</code> 语句里面。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="comment">// log error</span></span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="协程死循环"><a href="#协程死循环" class="headerlink" title="协程死循环"></a>协程死循环</h4><p>前面我们通过 <code>recover()</code> 函数可以防止个别协程的崩溃波及整体进程。但是如果有个别协程死循环了会导致其它协程饥饿得到不运行么？下面我们来做一个实验</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    n := <span class="number">7</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"dead loop goroutine start"</span>)</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">            } <span class="comment">// 死循环</span></span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"main goroutine running"</span>)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line">run in main goroutine</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>通过调整上面代码中的变量 n 的值可以发现一个有趣的现象，当 n 值大于 7 时，主协程将没有机会得到运行，而如果 n 值为 7、2、1，主协程依然可以每秒输出一次。要解释这个现象就必须深入了解协程的运行原理 cpu逻辑核心数量  我选8也能打印主协程？</p>
<h4 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h4><p>一个进程内部可以运行多个线程，而每个线程又可以运行很多协程。<br>线程要负责对协程进行调度，保证每个协程都有机会得到执行。<br>当一个协程睡眠时，它要将线程的运行权让给其它的协程来运行，而不能持续霸占这个线程。<br>同一个线程内部最多只会有一个协程正在运行。</p>
<p>线程的调度是由操作系统负责的，调度算法运行在内核态，而协程的调用是由 Go 语言的运行时负责的，调度算法运行在用户态。</p>
<p>协程可以简化为三个状态，运行态、就绪态和休眠态。<br>同一个线程中最多只会存在一个处于运行态的协程，<br>就绪态的协程是指那些具备了运行能力但是还没有得到运行机会的协程，它们随时会被调度到运行态，<br>休眠态的协程还不具备运行能力，它们是在等待某些条件的发生，比如 IO 操作的完成、睡眠时间的结束等。</p>
<p>操作系统对线程的调度是抢占式的，也就是说单个线程的死循环不会影响其它线程的执行，每个线程的连续运行受到时间片的限制。</p>
<p>Go 语言运行时对协程的调度并不是抢占式的。如果单个协程通过死循环霸占了线程的执行权，那这个线程就没有机会去运行其它协程了，你可以说这个线程假死了。不过一个进程内部往往有多个线程，假死了一个线程没事，全部假死了才会导致整个进程卡死。</p>
<p>每个线程都会包含多个就绪态的协程形成了一个就绪队列，如果这个线程因为某个别协程死循环导致假死，那这个队列上所有的就绪态协程是不是就没有机会得到运行了呢？Go 语言运行时调度器采用了 work-stealing 算法，当某个线程空闲时，也就是该线程上所有的协程都在休眠（或者一个协程都没有），它就会去其它线程的就绪队列上去偷一些协程来运行。也就是说这些线程会主动找活干，在正常情况下，运行时会尽量平均分配工作任务。</p>
<h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><p>默认情况下，Go 运行时会将线程数会被设置为机器 CPU 逻辑核心数。同时它内置的 <code>runtime</code> 包提供了 <code>GOMAXPROCS(n int)</code> 函数允许我们动态调整线程数，注意这个函数名字是全大写，Go 语言的设计者就是这么任性，该函数会返回修改前的线程数，如果参数 n &lt;=0 ，就不会产生修改效果，等价于读操作。线程数不是协程数，改的越大，越能承受更多的死循环</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 读取默认的线程数</span></span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">// 设置线程数为 10</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 读取当前的线程数</span></span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获取当前的协程数量可以使用 runtime 包提供的 <code>NumGoroutine()</code> 方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(runtime.NumGoroutine()) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(runtime.NumGoroutine()) <span class="comment">// 11</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">// [10694344 6434193 10546265 8131522 8812068 8852472 10570023 0 0 3704848]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">                runtime.Gosched() <span class="comment">// 手动交出控制权，别的也有机会运行，总有机会又调度给自己</span></span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">//[8696348 8301481 9040898 1115475 0 7329666 5930928 10650591 0 9584546]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">                runtime.Gosched() <span class="comment">// 手动交出控制权，别的也有机会运行，总有机会又调度给自己</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">//panic: runtime error: index out of range [10] with length 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(*a)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    *a++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    fmt.Println(a) <span class="comment">// 1 协程来不及运行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(*a)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    *a++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 2</span></span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="keyword">go</span> run -race <span class="number">3.</span><span class="keyword">go</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE竞争</span><br><span class="line">Read at <span class="number">0x00c0000ac078</span> by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/rose/<span class="keyword">go</span>/src/learngo/lang/channel/<span class="number">3</span>/<span class="number">3.</span><span class="keyword">go</span>:<span class="number">24</span> +<span class="number">0xee</span></span><br><span class="line"></span><br><span class="line">Previous write at <span class="number">0x00c0000ac078</span> by goroutine <span class="number">7</span>:</span><br><span class="line">  main.(*atomicInt).increment()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">struct</span> {</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    a.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> a.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> a.value</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    a.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> a.lock.Unlock() <span class="comment">//defer的正确用法</span></span><br><span class="line">    a.value++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a.get()) <span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要在一段代码端同步，那就变成一个匿名函数就好了，出这块代码区释放，代码区对a.value进行保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.lock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> a.lock.Unlock() <span class="comment">//defer的只控制这个匿名函数体</span></span><br><span class="line">        <span class="comment">//............</span></span><br><span class="line">        a.value++</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a.get()) <span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p><code>sync.Map</code>并发安全 map<br>• key 和 value 类型都是<code>interface{}</code>。意味着你要搞各种类型断言</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := sync.Map{}</span><br><span class="line">m.Store(<span class="string">"cat"</span>, <span class="string">"Tom"</span>)</span><br><span class="line">m.Store(<span class="string">"mouse"</span>, <span class="string">"Jerry"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里重新读取出来的，就是</span></span><br><span class="line">val, ok := m.Load(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(val.(<span class="keyword">string</span>))) <span class="comment">// 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>sync.Once</code>：只执行一次，一般用来解决一些初始化的需求</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法，不管调用几次，只会输出一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintOnce</span><span class="params">()</span></span> {</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"只输出一次"</span>)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    PrintOnce()</span><br><span class="line">    PrintOnce()</span><br><span class="line">    PrintOnce()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">只输出一次</span><br></pre></td></tr></tbody></table></figure>

<h4 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a><code>sync.Pool</code></h4><ol>
<li>优先从自己的缓存里面返回数据；</li>
<li>如果不够了，就创建一个新的，使用传入的New 回调；</li>
<li>在 GC 的时候，sync.Pool 会被清空</li>
</ol>
<p>sync.Pool 的缺陷：</p>
<ol>
<li>没有超时机制</li>
<li>无法限制内存使用量</li>
<li>GC 全部清掉</li>
</ol>
<p>sync.Pool 的一般使用步骤（以user为例）</p>
<ol>
<li>定义 user 结构体</li>
<li>为 user 加上 Reset 方法。该方法用于重置对象，<br>接收器是指针；</li>
<li>定义一个 sync.Pool</li>
<li>调用 Get 方法</li>
<li>使用defer 保证放回去 pool</li>
<li>重置 user</li>
<li>执行业务逻辑</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般来说，复用对象都要求我们取出来之后，</span></span><br><span class="line"><span class="comment">// 重置里面的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Reset</span><span class="params">(name <span class="keyword">string</span>, email <span class="keyword">string</span>)</span></span>  {</span><br><span class="line">    u.Email = email</span><br><span class="line">    u.Name = name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    pool := sync.Pool{</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>{}{</span><br><span class="line">            <span class="keyword">return</span> &amp;user{}</span><br><span class="line">    }}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get 返回的是 interface{}，所以需要类型断言</span></span><br><span class="line">    u := pool.Get().(*user)</span><br><span class="line">    <span class="comment">// defer 还回去</span></span><br><span class="line">    <span class="keyword">defer</span> pool.Put(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 紧接着重置 u 这个对象</span></span><br><span class="line">    u.Reset(<span class="string">"Tom"</span>, <span class="string">"my_email@qq.com"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下边就是使用 u 来完成你的业务逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/20/go-de-channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/20/go-de-channel/" class="post-title-link" itemprop="url">go的channel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-19T16:21:41Z">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-24 10:18:52" itemprop="dateModified" datetime="2021-09-24T10:18:52Z">2021-09-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>协程都是独立运行的，他们之间没有通信。</p>
<p>不同的并行协程之间交流的方式有两种，一种是通过共享变量，但是不建议这么做。<br>另一种是通过队列。Go 语言鼓励使用先入先出(FIFO)的队列的形式来交流，它单独为协程之间的队列数据交流定制了特殊的语法类型 —— channle通道，可以通过它来进行goroutine之间的通信，可以避免共享内存的坑。通道是并发安全、用来传递数据的的数据结构，它类似于内存消息队列，允许很多的协程并发对通道进行读写。接收的数据和发送的数据的顺序是一致的。</p>
<p>通过它并发核心单元就可以发送或者接收数据进行通讯(communication)</p>
<p>channel的通信保证了同步性。<br>同一时间只有一个协程可以访问数据，所以不会出现数据竞争，设计时就是这样的。</p>
<p>如果把协程比喻成小岛，那通道就是岛屿之间的交流桥梁管道，数据搭乘通道从一个协程流转到另一个协程。</p>
<p>通道是协程的输入和输出。<br>作为协程的输出，通道是一个容器，它可以容纳数据。<br>作为协程的输入，通道是一个生产者，它可以向协程提供数据。<br>通道作为容器是有限定大小的，满了就写不进去，空了就读不出来。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。<br>一个 goroutine 可以向另一 goroutine 定向发送消息。通道一般作为不同的协程交流的媒介，在同一个协程里它也是可以使用的。<br>channel 本身还需关联了一个类型，channel 可以发送数据的类型，限定进入通道的数据的类型。<br>例如: 发送 int 类型消息的 channel 写作 <code>chan int</code> 。函数也可以类型。</p>
<p>四种通道类型</p>
<p>Channel三种类型的定义。格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelType = ( <span class="string">"chan"</span> | <span class="string">"chan"</span> <span class="string">"&lt;-"</span> | <span class="string">"&lt;-"</span> <span class="string">"chan"</span> ) ElementType .</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单向通道 一次只能读写一个元素。<br>操作符是箭头 <code>&lt;-</code> 用于指定通道的方向，发送或接收。(箭头的指向就是数据的流向)</li>
</ul>
<p>把箭头 <code>&lt;-</code> 写在通道变量的右边就是写通道，<br>只发送的channel，只能向channel写数据</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan4 <span class="keyword">chan</span> &lt;-<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">chan4 := <span class="built_in">make</span>(<span class="keyword">chan</span> &lt;-<span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>把箭头写在通道变量 chan 的左边就是读通道。<br>只接收的channel，只能从channel读取数据</p>
<p>receive 操作符<br><code>&lt;- ch</code>用来从channel ch中接收数据，这个表达式会一直被block，直到有数据可以接收。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan4 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">chan4 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//初始化</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果没有指定方向，那么是双向通道，既可以接收数据，也可以发送数据。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只可以用来发送 float64 类型的数据给channel</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只可以从channel接收 int 类型的数据</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">msg &lt;- <span class="number">1</span></span><br><span class="line">msg &lt;- <span class="number">1</span></span><br><span class="line">data := &lt;-msg <span class="comment">// invalid operation: &lt;-msg (receive from send-only type chan&lt;- int)</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">msg &lt;- <span class="number">1</span> <span class="comment">// invalid operation: msg &lt;- 1 (send to receive-only type &lt;-chan int)</span></span><br></pre></td></tr></tbody></table></figure>


<p><code>&lt;-</code>总是优先和最左边的类型结合。(The <code>&lt;-</code> operator associates with the leftmost chan possible)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="keyword">int</span>    <span class="comment">// 等价 chan&lt;- (chan int)</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 chan&lt;- (&lt;-chan int)</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 &lt;-chan (&lt;-chan int)</span></span><br><span class="line"><span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>总结：make 初始化三种类型: slice, map和channel<br>像 map 和 slice 数据类型一样, channel必须先创建再使用:</li>
<li>channel是引用类型，和其他引用类型一样，channel 的空值为 <code>nil</code> ，使用 <code>==</code> 可以对类型相同的 channel 进行比较，只有指向相同对象或同为 nil 时，才返回 true。</li>
</ul>
<p>操作    值为 nil 的 channel    被关闭的 channel    正常的 channel<br>close    panic                 panic             成功关闭<br>c&lt;-    无select永远阻塞，有select不会阻塞                 panic            阻塞或成功发送<br>&lt;-c    永远阻塞                 永远不阻塞         阻塞或成功接收</p>
<ul>
<li>必须通过make初始化的，否则会出现永久阻塞的现象。</li>
</ul>
<p><code>make</code>的第一个参数需要是关键字chan，之后跟着允许限定通道可以容纳交换的数据类型</p>
<p><code>make</code>初始化Channel的第二个参数指定缓存的大小、容量：<code>ch := make(chan int, 100)</code>。</p>
<p>容量(capacity)代表Channel容纳的最多的元素的数量，</p>
<h3 id="无（非）缓冲型通道"><a href="#无（非）缓冲型通道" class="headerlink" title="无（非）缓冲型通道"></a>无（非）缓冲型通道</h3><p>没有设置容量，或者容量设置为0，</p>
<p>缺省情况下，不管是存消息还是取消息，都会挂起当前goroutine，发送和接收会一直阻塞着，除非另外一端已经准备好。只有sender和receiver都准备好了后它们的通讯(communication)才会发生。<br>发送端发送数据写操作会阻塞直到有其它协程接收方来从当前通道中读取当前通道接收数据。<br>无缓冲区的channel永远不会存数据，只负责数据的流通。</p>
<p>总是处于既满又空的状态。<br>这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p>
<p>通道空了，读操作就会阻塞，协程也会进入睡眠，直到有其它协程写通道装进了数据才会被唤醒。如果有多个协程的读操作阻塞了，一个写操作也只会唤醒一个协程。</p>
<p>从无缓冲channel取数据，必须要有数据流进来才可以，否则当前协程阻塞<br>数据流入无缓冲channel，如果没有其他goroutine来拿走这个数据，那么当前协程阻塞<br>注意：<br>同步的channel不能只在一个协程中发送和接收，因为会被永远阻塞，数据不能到接收方那里。</p>
<h3 id="有缓存"><a href="#有缓存" class="headerlink" title="有缓存"></a>有缓存</h3><p>有可能不发生阻塞，发送方则会阻塞直到发送的值被拷贝到缓冲区内；并且缓存未满，则send会被执行不会阻塞；<br>如果缓冲区已满。接收方在有值可以接收之前会一直阻塞。<br>send写操作就会阻塞，协程就会进入休眠，直到有其它协程某个接收方读通道挪出了空间，协程才会被唤醒。如果有多个协程的写操作都阻塞了，一个读操作只会唤醒一个协程。</p>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>在 Go 语言里不存在无界通道，每个通道都是有限定最大容量的，缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendStmt = Channel <span class="string">"&lt;-"</span> Expression .</span><br><span class="line">Channel = Expression .</span><br></pre></td></tr></tbody></table></figure>

<p>通道作为容器，它可以像切片一样，使用 <code>cap()</code> 和 <code>len()</code> 全局函数获得通道的容量和当前内部的元素个数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch); i++ {</span><br><span class="line">        ch &lt;- i <span class="comment">// 写通道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(ch) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">var</span> value <span class="keyword">int</span> = &lt;-ch <span class="comment">// 读通道</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>在通讯(communication)开始前channel和expression必须先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { c &lt;- <span class="number">3</span> + <span class="number">4</span> }()</span><br><span class="line">i := &lt;-c</span><br><span class="line">fmt.Println(i) <span class="comment">// 7</span></span><br></pre></td></tr></tbody></table></figure>

<p>send被执行前(proceed)通讯(communication)一直被阻塞着。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 申明</span></span><br><span class="line"><span class="keyword">if</span> msg != <span class="literal">nil</span> {</span><br><span class="line">    fmt.Println(<span class="string">"not nil"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 初始化不带缓冲区的整型通道</span></span><br><span class="line">msg &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg // fatal error: all goroutines are asleep - deadlock! 没有缓冲的channel 在没有启动一个接收者之前，放数据到msg中的时候会阻塞的，阻塞之前会获取一把锁，这把锁是要等到数据被接收之后释放，但是没有接收者就没法释放锁</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">msg1 &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg</span></span><br><span class="line">msg1 &lt;- <span class="number">2</span> <span class="comment">// 发送值 2 到通道 msg fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 取数据: 将箭头右边的值放到左边</span></span><br><span class="line">        data := &lt;- msg <span class="comment">//  从通道 msg 接收数据，并将数据赋值给 data</span></span><br><span class="line">        fmt.Println(data) <span class="comment">// </span></span><br><span class="line">    }()</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line"><span class="keyword">var</span> msg1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 初始化 缓冲区大小为1的整型通道</span></span><br><span class="line">msg1 &lt;- <span class="number">1</span> <span class="comment">// 1 放入 msg 这个 channel 中</span></span><br><span class="line">data1 := &lt;- msg1 <span class="comment">// 将箭头右边的值放到左边，从 msg 这个 channel 取数据放到 data</span></span><br><span class="line">fmt.Println(data1) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-msg1) <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// 初始化  缓冲区大小为2</span></span><br><span class="line"><span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line"><span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 获取这两个数据</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">var</span> value = rand.Intn(<span class="number">100</span>) <span class="comment">// 0到n之间的整数</span></span><br><span class="line">        ch &lt;- value</span><br><span class="line">        fmt.Printf(<span class="string">"send %d\n"</span>, value)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        value := &lt;-ch</span><br><span class="line">        fmt.Printf(<span class="string">"recv %d\n"</span>, value)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 子协程循环读</span></span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    <span class="comment">// 主协程循环写</span></span><br><span class="line">    send(ch)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">send <span class="number">81</span></span><br><span class="line">send <span class="number">87</span></span><br><span class="line">recv <span class="number">81</span></span><br><span class="line">recv <span class="number">87</span></span><br><span class="line">send <span class="number">47</span></span><br><span class="line">recv <span class="number">47</span></span><br><span class="line">send <span class="number">59</span></span><br><span class="line">recv <span class="number">59</span></span><br><span class="line">send <span class="number">81</span></span><br><span class="line">recv <span class="number">81</span></span><br><span class="line">send <span class="number">18</span></span><br><span class="line">recv <span class="number">18</span></span><br></pre></td></tr></tbody></table></figure>

<p>没有缓冲 但channel中有数据 写就会被阻塞，但消费了 还能在写入</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> production(dataCh)</span><br><span class="line">    <span class="keyword">go</span> consume(dataCh)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">production</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> data := &lt;-ch:</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">=== RUN   TestService</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">997</span></span><br><span class="line"><span class="number">998</span></span><br><span class="line"><span class="number">999</span></span><br><span class="line">--- PASS: TestService (<span class="number">3.00</span>s)</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ichan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> {</span><br><span class="line">    str = <span class="string">"hello world"</span></span><br><span class="line">    ichan &lt;- <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-ichan  <span class="comment">//这里有值，下面才会运行</span></span><br><span class="line">    fmt.Println(str) <span class="comment">// hello world</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 阻塞主进程，防止未处理完的子协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> chan1 { <span class="comment">// 如果data的缓冲区为空，这个协程会一直阻塞，除非被channel被close</span></span><br><span class="line">            fmt.Println(d)</span><br><span class="line">        }</span><br><span class="line">        quit &lt;- <span class="literal">true</span></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    chan1 &lt;- <span class="number">1</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    chan1 &lt;- <span class="number">4</span></span><br><span class="line">    chan1 &lt;- <span class="number">5</span></span><br><span class="line">    <span class="built_in">close</span>(chan1) <span class="comment">// 用完需要关闭，否则goroutine会被死锁，因为上面用range，它是不等到信道关闭是不会结束读取的</span></span><br><span class="line">    &lt;-quit       <span class="comment">// 解除阻塞</span></span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 使用计数来等待指定事件完成。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    msg &lt;- <span class="number">2</span> <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数值</span></span><br><span class="line">    <span class="keyword">go</span> consume(msg) <span class="comment">// 通过启动协程消费channel</span></span><br><span class="line">    <span class="comment">// Wait() 阻塞等待所有的写通道协程结束，待计数值变成零，Wait() 才会返回</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>{</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// 计数值减一</span></span><br><span class="line">    data := &lt;- queue</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>{</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    data := &lt;- queue</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>happens-before 特性</p>
<p>无缓冲时，接收 happens-before 发送<br>任何情况下，发送 happens-before 接收<br>close happens-before 接收</p>
<h3 id="通过for-range获取channel的数据"><a href="#通过for-range获取channel的数据" class="headerlink" title="通过for range获取channel的数据"></a>通过for range获取channel的数据</h3><p>除了可以遍历数组、切片、字典，还可以遍历通道，取代箭头操作符。<br>当通道空了，循环会暂停阻塞，<br>当通道关闭时，阻塞停止，循环也跟着结束了。<br>当循环结束时，我们就知道通道已经关闭了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">    }()</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span> {</span><br><span class="line">            c &lt;- i</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"Finished"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">Finished</span><br></pre></td></tr></tbody></table></figure>

<p><code>range c</code>遍历读取到的迭代值为Channel中发送的值，它会一直迭代直到channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在 <code>for …… range</code> 那一行</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span> 为什么会打印<span class="number">2</span>，因为<span class="number">2</span>发送的msg，执行<span class="keyword">for</span>循环的第二轮，打印完<span class="number">2</span>关闭</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!执行<span class="keyword">for</span>循环的第三轮，从空的通道循环</span><br></pre></td></tr></tbody></table></figure>

<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>内建的close方法关闭Channel。<br>通道如果没有显式关闭，当它不再被程序使用的时候，会自动关闭被垃圾回收掉。<br>不过优雅的程序应该将通道看成资源，显式关闭每个不再使用的资源是一种良好的习惯。<br>你可以在多个goroutine从/往 一个channel 中 receive/send 数据，不必考虑额外的同步措施。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg) <span class="comment">// 让for循环正常结束，不报错</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>channel关闭后sender的receiver操作。</p>
<p>往一个已经被close关闭的channel中继续发送写数据会导致 <code>panic: send on closed channel</code>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    time.Sleep(time.Hour)</span><br><span class="line">}()</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">c &lt;- <span class="number">3</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></tbody></table></figure>


<p>已经关闭的channel，<br>读取一个已经关闭的无缓冲通道会立即返回通道类型的「零值」<br>读取一个已经关闭的有缓存的能够继续接收读取已发送的数据不会被阻塞、不会产生 <code>panic</code>，且能读出 channel 中还未被读取的消息，直到已发送的数据接收读取完为止后，再读取立即返回channel中具体类型的零值(zero value)。</p>
<p>如果通道里的元素是整型的，读操作是不能通过返回值来确定通道是否关闭的。<br>关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 2</span></span><br><span class="line">value := &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 3</span></span><br><span class="line">value = &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 4</span></span><br><span class="line">value = &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">--</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>通道关闭，依然可以读取数据，<br>通过<code>range</code>读取，channel关闭后for循环直到数据读取完为止，自动跳出不报错：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">// 睡眠1秒钟后，2发送给msg，通道关闭，依然可以读取数据，直到数据读取完为止</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">--</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></tbody></table></figure>

<p>channel的 receive支持 multi-valued assignment<br>语句可以将值赋值给一个或者两个变量。<br>用一个额外的返回参数来检查channel是否关闭。判断值是零值还是正常读取的值<br>如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;-ch</span><br><span class="line">x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok = &lt;-ch</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">i, ok := &lt;-c</span><br><span class="line">fmt.Printf(<span class="string">"%d, %t"</span>, i, ok) <span class="comment">// 0, false</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        fmt.Println(data, ok)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="无缓存空间"><a href="#无缓存空间" class="headerlink" title="无缓存空间"></a>无缓存空间</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelWithCache</span><span class="params">()</span></span>  {</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        ch &lt;- <span class="string">"Hello, first msg from channel"</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        ch &lt;- <span class="string">"Hello, second msg from channel"</span></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    msg := &lt;- ch</span><br><span class="line">    fmt.Println(time.Now().String() + msg)</span><br><span class="line">    msg = &lt;- ch</span><br><span class="line">    fmt.Println(time.Now().String() + msg)</span><br><span class="line">    <span class="comment">// 因为前面我们先睡了2秒，所以其实会有一个已经在缓冲了</span></span><br><span class="line">    <span class="comment">// 当我们尝试输出的时候，这个输出间隔就会明显小于1秒</span></span><br><span class="line">    <span class="comment">// 我电脑上的几次实验，差距都在1ms以内</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelWithoutCache</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 不带缓冲</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        ch &lt;- <span class="string">"Hello, msg from channel"</span></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里比较容易写成 msg &lt;- ch，编译会报错</span></span><br><span class="line">    msg := &lt;- ch</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    channelWithoutCache()</span><br><span class="line">    channelWithCache()</span><br><span class="line">    <span class="comment">// Hello, msg from channel</span></span><br><span class="line">    <span class="comment">// 2021-09-21 10:48:50.5593955 +0800 CST m=+3.023493701Hello, first msg from channel</span></span><br><span class="line">    <span class="comment">// 2021-09-21 10:48:50.5849771 +0800 CST m=+3.049075301Hello, second msg from channel</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    Channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">            Channel &lt;- <span class="literal">true</span></span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ {</span><br><span class="line">        &lt;-Channel</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(Channel)</span><br><span class="line">----</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            n := &lt;-chan1 <span class="comment">// 闭包，引用了chan1</span></span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">没有打印<span class="number">3</span>，来不及打印主协程挂了</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            n := &lt;-chan1 <span class="comment">// 闭包，引用了chan1</span></span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-c) <span class="comment">// 不能写chan1 会undefined: chan1，worker函数用不了</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> worker(chan1)</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %d\n"</span>, id, &lt;-c)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, chan1)</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received <span class="number">1</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">2</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> channels [<span class="number">10</span>]<span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 通道作为数组的类型</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">        <span class="keyword">go</span> worker(i, channels[i])</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">9</span> received j</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> channels [<span class="number">10</span>]<span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 通道作为数组的类型</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">        <span class="keyword">go</span> worker(i, channels[i])</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">8</span> received I</span><br><span class="line">Worker <span class="number">9</span> received J</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> chan1 {</span><br><span class="line">            fmt.Println(d)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(chan1)</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> { <span class="comment">// 双向通道作为函数返回值</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 协程里面处理通道，不然worker函数会没返回通道，新协程会阻塞</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, &lt;-c)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> channels [<span class="number">10</span>]<span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 通道作为数组的类型</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] = createWorker(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">9</span> received J</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">8</span> received I</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>,id, &lt;-c)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferedChannel</span><span class="params">()</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// 有缓存</span></span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">    c &lt;- <span class="string">'a'</span></span><br><span class="line">    c &lt;- <span class="string">'b'</span></span><br><span class="line">    c &lt;- <span class="string">'c'</span></span><br><span class="line">    c &lt;- <span class="string">'d'</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    bufferedChannel()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">0</span> received b</span><br><span class="line">Worker <span class="number">0</span> received c</span><br><span class="line">Worker <span class="number">0</span> received d</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferedChannel</span><span class="params">()</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">    c &lt;- <span class="string">'a'</span></span><br><span class="line">    c &lt;- <span class="string">'b'</span></span><br><span class="line">    c &lt;- <span class="string">'c'</span></span><br><span class="line">    c &lt;- <span class="string">'d'</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    bufferedChannel()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">0</span> received b</span><br><span class="line">Worker <span class="number">0</span> received c</span><br><span class="line">Worker <span class="number">0</span> received d</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %d\n"</span>, id, &lt;-c)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelClose</span><span class="params">()</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">    c &lt;- <span class="string">'a'</span></span><br><span class="line">    c &lt;- <span class="string">'b'</span></span><br><span class="line">    c &lt;- <span class="string">'c'</span></span><br><span class="line">    c &lt;- <span class="string">'d'</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    channelClose()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received <span class="number">97</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">98</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">99</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">100</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        n, ok := &lt;-c</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %d\n"</span>, id, n)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelClose</span><span class="params">()</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">    c &lt;- <span class="string">'a'</span></span><br><span class="line">    c &lt;- <span class="string">'b'</span></span><br><span class="line">    c &lt;- <span class="string">'c'</span></span><br><span class="line">    c &lt;- <span class="string">'d'</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    channelClose()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received <span class="number">97</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">98</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">99</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelClose</span><span class="params">()</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">    c &lt;- <span class="string">'a'</span></span><br><span class="line">    c &lt;- <span class="string">'b'</span></span><br><span class="line">    c &lt;- <span class="string">'c'</span></span><br><span class="line">    c &lt;- <span class="string">'d'</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    channelClose()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received <span class="number">97</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">98</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">99</span></span><br><span class="line">Worker <span class="number">0</span> received <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock! 不关闭通道consume遍历空通道阻塞</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>如官方的例子中通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</span><br><span class="line">        sum += v</span><br><span class="line">    }</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c 把 sum 发送到通道 c</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    s := []<span class="keyword">int</span>{<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>}</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c 从通道 c 中接收 一直处于阻塞状态，直至计算结果发送到channel中。</span></span><br><span class="line">    fmt.Println(x, y, x+y) <span class="comment">// -5 17 12</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>channel可以用在goroutine之间的同步。<br>下面的例子中main goroutine通过done channel等待worker完成任务。<br>worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 通知任务已完成</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    <span class="comment">// 等待任务完成</span></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="通道写安全"><a href="#通道写安全" class="headerlink" title="通道写安全"></a>通道写安全</h4><p>上面提到向一个已经关闭的通道执行写操作会抛出异常，这意味着我们在写通道时一定要确保通道没有被关闭。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        i++</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    value := &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">    value = &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    send(ch)</span><br><span class="line">}</span><br><span class="line">---------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br></pre></td></tr></tbody></table></figure>

<p>那如何确保呢？Go 语言并不存在一个内置函数可以判断出通道是否已经被关闭。即使存在这样一个函数，当你判断时通道没有关闭，并不意味着当你往通道里写数据时它就一定没有被关闭，并发环境下，它是可能被其它协程随时关闭的。</p>
<p>确保通道写安全的最好方式是由负责写通道的协程自己来关闭通道，读通道的协程不要去关闭通道。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> send(ch)</span><br><span class="line">    recv(ch)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个方法确实可以解决单写多读的场景，可要是遇上了多写单读的场合该怎么办呢？任意一个读写通道的协程都不可以随意关闭通道，否则会导致其它写通道协程抛出异常。这时候就必须让其它不相干的协程来干这件事，这个协程需要等待所有的写通道协程都结束运行后才能关闭通道。那其它协程要如何才能知道所有的写通道已经结束运行了呢？这个就需要使用到内置 <code>sync</code> 包提供的 <code>WaitGroup</code> 对象，它使用计数来等待指定事件完成。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// 计数值减一</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">4</span> {</span><br><span class="line">        i++</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="number">2</span>)       <span class="comment">// 增加计数值</span></span><br><span class="line">    <span class="keyword">go</span> send(ch, wg) <span class="comment">// 写</span></span><br><span class="line">    <span class="keyword">go</span> send(ch, wg) <span class="comment">// 写</span></span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    <span class="comment">// Wait() 阻塞等待所有的写通道协程结束，待计数值变成零，Wait() 才会返回</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"等待返回值"</span>)</span><br><span class="line">    fmt.Println(&lt;-msg)</span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        queue &lt;- <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line">等待返回值</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg) <span class="comment">// 双向的通道可以转换为单向的通道</span></span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>


<h4 id="使用Channel等待任务结束"><a href="#使用Channel等待任务结束" class="headerlink" title="使用Channel等待任务结束"></a>使用Channel等待任务结束</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> {</span><br><span class="line">    in   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">worker</span></span> {</span><br><span class="line">    w := worker{</span><br><span class="line">        in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 无缓存</span></span><br><span class="line">        done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>), <span class="comment">// 无缓存</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> doWork(id, w.in, w.done)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i] = createWorker(i)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i].in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">        &lt;- workers[i].done <span class="comment">// 如果done没有数据 这里会阻塞</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i].in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">        &lt;- workers[i].done <span class="comment">// 如果done没有数据 这里会阻塞</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Millisecond) <span class="comment">// 去掉sleep</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chanDemo()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">8</span> received I</span><br><span class="line">Worker <span class="number">9</span> received J</span><br></pre></td></tr></tbody></table></figure>

<p>缺点：顺序打印，不如不用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> {</span><br><span class="line">    in   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">bool</span> <span class="comment">// done用于接收，这样来替换 time.Sleep(time.Millisecond)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">worker</span></span> {</span><br><span class="line">    w := worker{</span><br><span class="line">        in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 无缓存</span></span><br><span class="line">        done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>), <span class="comment">// 无缓存</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> doWork(id, w.in, w.done)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i] = createWorker(i)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> _, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        &lt;-worker.done</span><br><span class="line">        &lt;-worker.done</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// time.Sleep(time.Millisecond) // 去掉sleep</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chanDemo()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">9</span> received J</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">8</span> received I</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="comment">// "time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> {</span><br><span class="line">    in   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// done func()</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">worker</span></span> {</span><br><span class="line">    w := worker{</span><br><span class="line">        in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 无缓存</span></span><br><span class="line">        done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>), <span class="comment">// 无缓存</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> doWork(id, w.in, w.done)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i] = createWorker(i)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> _, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        &lt;-worker.done</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> _, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        &lt;-worker.done</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// time.Sleep(time.Millisecond) // 去掉sleep</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chanDemo()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">8</span> received I</span><br><span class="line">Worker <span class="number">9</span> received J</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">2</span> received C</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> {</span><br><span class="line">    in   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// done chan bool</span></span><br><span class="line">    wg *sync.WaitGroup <span class="comment">// 指针才能使用同一个wg</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">        wg.Done()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>, wg *sync.WaitGroup)</span> <span class="title">worker</span></span> {</span><br><span class="line">    w := worker{</span><br><span class="line">        in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 无缓存</span></span><br><span class="line">        wg: wg, <span class="comment">// 无缓存</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> doWork(id, w.in, wg)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i] = createWorker(i, &amp;wg) <span class="comment">// 所有的要用同一个wg 所以传指针</span></span><br><span class="line">    }</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chanDemo()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">9</span> received J</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">8</span> received I</span><br><span class="line">Worker <span class="number">7</span> received H</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="keyword">int</span>, w worker)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> w.in {</span><br><span class="line">        fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, id, n)</span><br><span class="line">        w.done()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> {</span><br><span class="line">    in   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    done <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>, wg *sync.WaitGroup)</span> <span class="title">worker</span></span> {</span><br><span class="line">    w := worker{</span><br><span class="line">        in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">        done: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            wg.Done()</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">go</span> doWork(id, w)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        workers[i] = createWorker(i, &amp;wg)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'a'</span> + i</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i, worker := <span class="keyword">range</span> workers {</span><br><span class="line">        worker.in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    chanDemo()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">Worker <span class="number">7</span> received h</span><br><span class="line">Worker <span class="number">3</span> received d</span><br><span class="line">Worker <span class="number">4</span> received e</span><br><span class="line">Worker <span class="number">2</span> received c</span><br><span class="line">Worker <span class="number">1</span> received b</span><br><span class="line">Worker <span class="number">6</span> received g</span><br><span class="line">Worker <span class="number">8</span> received i</span><br><span class="line">Worker <span class="number">9</span> received j</span><br><span class="line">Worker <span class="number">0</span> received a</span><br><span class="line">Worker <span class="number">0</span> received A</span><br><span class="line">Worker <span class="number">4</span> received E</span><br><span class="line">Worker <span class="number">5</span> received f</span><br><span class="line">Worker <span class="number">5</span> received F</span><br><span class="line">Worker <span class="number">9</span> received J</span><br><span class="line">Worker <span class="number">1</span> received B</span><br><span class="line">Worker <span class="number">2</span> received C</span><br><span class="line">Worker <span class="number">3</span> received D</span><br><span class="line">Worker <span class="number">6</span> received G</span><br><span class="line">Worker <span class="number">7</span> received H</span><br><span class="line">Worker <span class="number">8</span> received I</span><br></pre></td></tr></tbody></table></figure>

<p>通道内部结构<br>Go 语言的通道内部结构是一个循环数组，通过读写偏移量来控制元素发送和接受。它为了保证线程安全，内部会有一个全局锁来控制并发。对于发送和接受操作都会有一个队列来容纳处于阻塞状态的协程。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount <span class="keyword">uint</span>  <span class="comment">// 通道有效元素个数</span></span><br><span class="line">    dataqsize <span class="keyword">uint</span>   <span class="comment">// 通道容量，循环数组总长度</span></span><br><span class="line">    buf unsafe.Pointer <span class="comment">// 数组地址</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// 内部元素的大小</span></span><br><span class="line">    closed <span class="keyword">uint32</span> <span class="comment">// 是否已关闭 0或者1</span></span><br><span class="line">    elemtype *_type <span class="comment">// 内部元素类型信息</span></span><br><span class="line">    sendx <span class="keyword">uint</span> <span class="comment">// 循环数组的写偏移量</span></span><br><span class="line">    recvx <span class="keyword">uint</span> <span class="comment">// 循环数组的读偏移量</span></span><br><span class="line">    recvq waitq <span class="comment">// 阻塞在读操作上的协程队列</span></span><br><span class="line">    sendq waitq <span class="comment">// 阻塞在写操作上的协程队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">// 全局锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>队列在本质上是使用共享变量加锁的方式来实现的，共享变量才是并行交流的本质。</p>
<p>请不要认为 Go 语言的通道很神奇，Go 语言只是对通道设计了一套便于使用的语法糖，让这套数据结构显的平易近人。它在内部实现上和其它语言的并发队列大同小异。</p>
<hr>
<h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">2000</span>)) * time.Millisecond)</span><br><span class="line">            <span class="comment">// Sprintf 不会打印，把想要打印的结果作为一个字符串返回</span></span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">"message %d"</span>, i)</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := msgGen()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">message <span class="number">0</span></span><br><span class="line">message <span class="number">1</span></span><br><span class="line">message <span class="number">2</span></span><br><span class="line">message <span class="number">3</span></span><br><span class="line">message <span class="number">4</span></span><br><span class="line">message <span class="number">5</span></span><br><span class="line">message <span class="number">6</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">()</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">2000</span>)) * time.Millisecond)</span><br><span class="line">            <span class="comment">// Sprintf 不会打印，把想要打印的结果作为一个字符串返回</span></span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">"message %d"</span>, i)</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen()</span><br><span class="line">    m2 := msgGen()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m1)</span><br><span class="line">        fmt.Println(&lt;-m2)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">message <span class="number">0</span></span><br><span class="line">message <span class="number">0</span></span><br><span class="line">message <span class="number">1</span></span><br><span class="line">message <span class="number">1</span></span><br><span class="line">message <span class="number">2</span></span><br><span class="line">message <span class="number">2</span></span><br><span class="line">message <span class="number">3</span></span><br><span class="line">message <span class="number">3</span></span><br><span class="line">message <span class="number">4</span></span><br><span class="line">message <span class="number">4</span></span><br><span class="line">message <span class="number">5</span></span><br><span class="line">message <span class="number">5</span></span><br><span class="line">message <span class="number">6</span></span><br><span class="line">message <span class="number">6</span></span><br><span class="line">...</span><br><span class="line">等第一个服务生成一个结果后，第二个服务生成结果后再运行第一个服务，交替进行</span><br></pre></td></tr></tbody></table></figure>

<p>服务/任务</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">2000</span>)) * time.Millisecond)</span><br><span class="line">            <span class="comment">// Sprintf 不会打印，把想要打印的结果作为一个字符串返回</span></span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">"service %s: message %d"</span>, name, i)</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m1)</span><br><span class="line">        fmt.Println(&lt;-m2)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">4</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service2: message <span class="number">5</span></span><br><span class="line">...</span><br><span class="line">等第一个服务生成一个结果后，第二个服务生成结果后再运行第一个服务，交替进行</span><br></pre></td></tr></tbody></table></figure>

<p>同时等待多个服务：两种方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">2000</span>)) * time.Millisecond)</span><br><span class="line">            <span class="comment">// Sprintf 不会打印，把想要打印的结果作为一个字符串返回</span></span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">"service %s: message %d"</span>, name, i)</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个通道哪个协程先发数据给第三个通道c，c里面就是谁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(c1, c2 <span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            c &lt;- &lt;-c1 <span class="comment">// c1取出数据来发送给c</span></span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            c &lt;- &lt;-c2 <span class="comment">// c2取出数据来发送给c</span></span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 两个channel服务句柄，发给第三个channel，用第三个统一接收数据</span></span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m := fanIn(m1, m2)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">7</span></span><br><span class="line">...</span><br><span class="line">第一个服务和第二个服务并发执行，不交替</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanInBySelect</span><span class="params">(c1, c2 <span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 在确定通道个数参数的情况下 select实现只开一个协程</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> m := &lt;-c1:</span><br><span class="line">                c &lt;- m</span><br><span class="line">            <span class="keyword">case</span> m := &lt;-c2:</span><br><span class="line">                c &lt;- m</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m := fanInBySelect(m1, m2)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chs ...<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs { <span class="comment">// 对每一个通道都开一个协程</span></span><br><span class="line">        <span class="comment">// 第一次循环得到的ch后还没来得及在go协程发送和接收，go协程运行在for当前循环之后运行，第二次循环得到的ch又再次赋值给ch，ch全局只有1份，循环走完第二轮之后，ch一直就是第二轮循环的的通道ch2，接下来所有的go func都从c2取数据，生成</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                c &lt;- &lt;-ch</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m := fanIn(m1, m2)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">service service2: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">5</span></span><br><span class="line">service service2: message <span class="number">6</span></span><br><span class="line">service service2: message <span class="number">7</span></span><br><span class="line">...</span><br><span class="line">没有service1</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chs ...<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs { <span class="comment">// 对每一个通道都开一个协程</span></span><br><span class="line">        chCopy := ch <span class="comment">// chCopy作用域在花括号里面，有几次循环几个通道就会有几个chCopy，</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                c &lt;- &lt;-chCopy</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m := fanIn(m1, m2)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chs ...<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs { <span class="comment">// 对每一个通道都开一个协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                c &lt;- &lt;-in</span><br><span class="line">            }</span><br><span class="line">        }(ch) <span class="comment">// 值传递</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m := fanIn(m1, m2)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">-----</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    m3 := msgGen(<span class="string">"service3"</span>)</span><br><span class="line">    <span class="comment">//m := fanIn(m1, m2)</span></span><br><span class="line">    m := fanIn(m1, m2, m3)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service3: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service3: message <span class="number">1</span></span><br><span class="line">service service3: message <span class="number">2</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service3: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service3: message <span class="number">4</span></span><br><span class="line">service service2: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">service service3: message <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="并发任务的控制"><a href="#并发任务的控制" class="headerlink" title="并发任务的控制"></a>并发任务的控制</h3><p>非阻塞等待</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonBlockingWait</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span>{</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> m, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m1 := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    m2 := msgGen(<span class="string">"service2"</span>)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(&lt;-m1)</span><br><span class="line">        <span class="keyword">if</span> m, ok := nonBlockingWait(m2); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"no message from service2"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service2: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service2: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">no message from service2</span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">no message from service2</span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">no message from service2</span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service2: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>超时机制</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeoutWait</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> m, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeout): <span class="comment">// 超过时间还等不到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">if</span> m, ok := timeoutWait(m, <span class="number">2</span>*time.Second); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">service service1: message <span class="number">4</span></span><br><span class="line">service service1: message <span class="number">5</span></span><br><span class="line">service service1: message <span class="number">6</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(<span class="number">5000</span>)) * time.Millisecond) <span class="comment">// 2000 改成 5000</span></span><br><span class="line">            <span class="comment">// Sprintf 不会打印，把想要打印的结果作为一个字符串返回</span></span><br><span class="line">            c &lt;- fmt.Sprintf(<span class="string">"service %s: message %d"</span>, name, i)</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">if</span> m, ok := timeoutWait(m, <span class="number">2</span>*time.Second); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">1</span></span><br><span class="line">service service1: message <span class="number">2</span></span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">3</span></span><br><span class="line">timeout</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>任务中断/退出</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := msgGen(<span class="string">"service1"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ { <span class="comment">// 只循环5次</span></span><br><span class="line">        <span class="keyword">if</span> m, ok := timeoutWait(m, time.Second); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">timeout</span><br><span class="line"><span class="number">5</span>秒钟后结束了，main结束协程也结束</span><br></pre></td></tr></tbody></table></figure>

<p>优雅退出</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">(name <span class="keyword">string</span>, done <span class="keyword">chan</span> <span class="keyword">struct</span>{})</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Intn(<span class="number">5000</span>)) * time.Millisecond):</span><br><span class="line">                <span class="comment">// 如果5秒钟之后还没有收到done，就产生一个数据</span></span><br><span class="line">                c &lt;- fmt.Sprintf(<span class="string">"service %s: message %d"</span>, name, i)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done: <span class="comment">// 5秒钟之内收到了done</span></span><br><span class="line">                fmt.Println(<span class="string">"cleaning up"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// 主动退出</span></span><br><span class="line">            }</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">    m := msgGen(<span class="string">"service1"</span>, done)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">if</span> m, ok := timeoutWait(m, time.Second); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    done &lt;- <span class="keyword">struct</span>{}{}      <span class="comment">// 第一个{}是结构的定义，第二个{}是结构的初始化</span></span><br><span class="line">    time.Sleep(time.Second) <span class="comment">// 送了struct{}{}给通道done，主协程不挂而是休息，给协程足够的时间清理退出</span></span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">timeout</span><br><span class="line">cleaning up</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">msgGen</span><span class="params">(name <span class="keyword">string</span>, done <span class="keyword">chan</span> <span class="keyword">struct</span>{})</span> <span class="title">chan</span> <span class="title">string</span></span> {</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(time.Duration(rand.Intn(<span class="number">5000</span>)) * time.Millisecond):</span><br><span class="line">                <span class="comment">// 如果5秒钟之后还没有收到done，就产生一个数据</span></span><br><span class="line">                c &lt;- fmt.Sprintf(<span class="string">"service %s: message %d"</span>, name, i)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done: <span class="comment">// 5秒钟之内收到了done</span></span><br><span class="line">                fmt.Println(<span class="string">"cleaning up"</span>)</span><br><span class="line">                time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">                fmt.Println(<span class="string">"cleaning done"</span>)</span><br><span class="line">                done &lt;- <span class="keyword">struct</span>{}{} <span class="comment">// done可以发</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// 主动退出</span></span><br><span class="line">            }</span><br><span class="line">            i++</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">    m := msgGen(<span class="string">"service1"</span>, done)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">if</span> m, ok := timeoutWait(m, time.Second); ok {</span><br><span class="line">            fmt.Println(m)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    done &lt;- <span class="keyword">struct</span>{}{} <span class="comment">// 第一个{}是结构的定义，第二个{}是结构的初始化</span></span><br><span class="line">    &lt;-done             <span class="comment">// 收到才退出</span></span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">service service1: message <span class="number">0</span></span><br><span class="line">timeout</span><br><span class="line">cleaning up</span><br><span class="line">cleaning done</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//接受任务</span></span><br><span class="line">    taskChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">    resChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="comment">//关闭任务</span></span><br><span class="line">    closeChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">            taskChannel &lt;- i</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(taskChannel) <span class="comment">// 关掉也可以接收</span></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> Task(taskChannel, resChannel, closeChannel)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="comment">//当接收到5个值以后，说明5个任务都执行完成了</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">            &lt;-closeChannel</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(resChannel)</span><br><span class="line">        <span class="built_in">close</span>(closeChannel) </span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假如获取不完，一直在 for循环channel时，当resChannel关闭以后会退出循环</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> resChannel {</span><br><span class="line">        fmt.Println(<span class="string">"res:"</span>, r)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task</span><span class="params">(taskChannel <span class="keyword">chan</span> <span class="keyword">int</span>, resChannel <span class="keyword">chan</span> <span class="keyword">int</span>, closeChannel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> taskChannel {</span><br><span class="line">        resChannel &lt;- t</span><br><span class="line">    }</span><br><span class="line">    closeChannel &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">res: <span class="number">0</span></span><br><span class="line">res: <span class="number">1</span></span><br><span class="line">res: <span class="number">2</span></span><br><span class="line">res: <span class="number">3</span></span><br><span class="line">res: <span class="number">4</span></span><br><span class="line">res: <span class="number">5</span></span><br><span class="line">res: <span class="number">6</span></span><br><span class="line">res: <span class="number">7</span></span><br><span class="line">res: <span class="number">8</span></span><br><span class="line">res: <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/18/go-ce-shi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/go-ce-shi/" class="post-title-link" itemprop="url">go测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-17 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-17T16:21:41Z">2021-08-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-20 11:58:01" itemprop="dateModified" datetime="2021-09-20T11:58:01Z">2021-09-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>少DEBUG，多Testing</p>
<h2 id="传统测试"><a href="#传统测试" class="headerlink" title="传统测试"></a>传统测试</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>{</span><br><span class="line">    asserEquals(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    asserEquals(<span class="number">2</span>, add(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    asserEquals(<span class="number">0</span>, add(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    asserEquals(<span class="number">0</span>, add(-<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    asserEquals(Integer.MIN_VALUE, add(<span class="number">1</span>, Integer.MAX_VALUE));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>测试数据和测试逻辑混在一起</li>
<li>出错信息不明确</li>
<li>一旦一个数据出错测试全部结束</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>正常执行</li>
<li>异常例子</li>
<li>正常与异常的边界例子</li>
<li>追求分支覆盖</li>
<li>追求代码覆盖</li>
</ol>
<h2 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h2><ul>
<li>分离的测试数据和测试逻辑</li>
<li>明确的出错信息</li>
<li>可以部分失败</li>
<li>go语言的语法使得我们更容易实践表格驱动测试</li>
</ul>
<p>文件名必须命名为：xxx_test.go<br>如果要测试add函数，那么文件名就叫做add_test.go<br>测试方法 <code>TestXXXX(t *testing.T)</code><br>如果要测试add函数，那么方法就叫做 <code>TestAdd(t *testing.T)</code></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTriangle</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    tests := []<span class="keyword">struct</span>{ a, b, c <span class="keyword">int</span> }{</span><br><span class="line">        {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>},</span><br><span class="line">        {<span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>},</span><br><span class="line">        {<span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span>},</span><br><span class="line">        {<span class="number">12</span>, <span class="number">35</span>, <span class="number">37</span>},</span><br><span class="line">        {<span class="number">30000</span>, <span class="number">40000</span>, <span class="number">50000</span>},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests {</span><br><span class="line">        <span class="keyword">if</span> actual := calcTriangle(tt.a, tt.b); actual != tt.c {</span><br><span class="line">            t.Errorf(<span class="string">"calcTriangle(%d, %d); "</span>+<span class="string">"got %d; expected %d"</span>,</span><br><span class="line">                tt.a, tt.b, actual, tt.c)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// goland</span></span><br><span class="line">=== RUN   TestTriangle</span><br><span class="line">--- PASS: TestTriangle (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行 --- go test</span></span><br><span class="line">Running tool: C:\Program Files\Go\bin\<span class="keyword">go</span>.exe test -timeout <span class="number">30</span>s -run ^TestTriangle$ imooc.com/ccmouse/learngo/lang/basic/basic -v -count=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">=== RUN   TestTriangle</span><br><span class="line">--- PASS: TestTriangle (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/basic/basic    <span class="number">0.031</span>s</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line"></span><br><span class="line">    tests := []<span class="keyword">struct</span>{ a, b, c <span class="keyword">int</span> }{</span><br><span class="line">        {<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>},</span><br><span class="line">        {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},</span><br><span class="line">        {<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>}, <span class="comment">//模拟出错</span></span><br><span class="line">        {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>}, <span class="comment">// 模拟出错</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests {</span><br><span class="line">        <span class="keyword">if</span> actual := add(tt.a, tt.b); actual != tt.c {</span><br><span class="line">            t.Errorf(<span class="string">"%d + %d got %d ;expected %d "</span>, tt.a, tt.b, tt.c, actual)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="comment">// 命令行 在当前目录下使用`go test`命令</span></span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">    TestAdd: add_test.<span class="keyword">go</span>:<span class="number">19</span>: <span class="number">4</span> + <span class="number">5</span> got <span class="number">1</span> ;expected <span class="number">9</span></span><br><span class="line">    TestAdd: add_test.<span class="keyword">go</span>:<span class="number">19</span>: <span class="number">1</span> + <span class="number">1</span> got <span class="number">1</span> ;expected <span class="number">2</span></span><br><span class="line">--- FAIL: TestAdd (<span class="number">0.00</span>s)</span><br><span class="line">FAIL</span><br></pre></td></tr></tbody></table></figure>

<p>用命令行测试<br>在当前目录下使用<code>go test</code>命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> go tool cover</span></span><br><span class="line">Usage of 'go tool cover':</span><br><span class="line">Given a coverage profile produced by 'go test':</span><br><span class="line">        go test -coverprofile=c.out 生成文件</span><br><span class="line"></span><br><span class="line">Open a web browser displaying annotated source code:</span><br><span class="line">        go tool cover -html=c.out  页面观看覆盖率</span><br><span class="line"></span><br><span class="line">Write out an HTML file instead of launching a web browser:</span><br><span class="line">        go tool cover -html=c.out -o coverage.html</span><br><span class="line"></span><br><span class="line">Display coverage percentages to stdout for each function:</span><br><span class="line">        go tool cover -func=c.out</span><br><span class="line"></span><br><span class="line">Finally, to generate modified source code with coverage annotations</span><br><span class="line">(what go test -cover does):</span><br><span class="line">        go tool cover -mode=set -var=CoverageVariableName program.go</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -V    print version and exit</span><br><span class="line">  -func string</span><br><span class="line">        output coverage profile information for each function</span><br><span class="line">  -html string</span><br><span class="line">        generate HTML representation of coverage profile</span><br><span class="line">  -mode string</span><br><span class="line">        coverage mode: set, count, atomic</span><br><span class="line">  -o string</span><br><span class="line">        file for output; default: stdout</span><br><span class="line">  -var string</span><br><span class="line">        name of coverage variable to generate (default "GoCover")</span><br><span class="line"></span><br><span class="line">  Only one of -html, -func, or -mode may be set.</span><br></pre></td></tr></tbody></table></figure>

<p>goland <code>Run '' with Coverage</code> 检测代码覆盖率</p>
<p><code>go tool cover -html=c.out</code><br>注意： test文件要和逻辑代码在同一个包中 不然显示不出来</p>
<p><code>go test -bench . -cpuprofile=cpu.out</code> 生成二进制文件<br>用pprof查看这个二进制文件 <code>go tool pprof cpu.out</code>：<br>进入<code>pprof</code>交互式命令行环境<br>进入<code>pprof</code>环境之后，使用<code>web</code>命令生成图</p>
<figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  Failed to execute <span class="keyword">dot</span>. Is Graphviz installed? Error: <span class="keyword">exec</span>: <span class="string">"dot"</span>: executable <span class="keyword">file</span> not found <span class="keyword">in</span> $PATH</span><br></pre></td></tr></tbody></table></figure>

<p>要先安装graphviz工具</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>graphviz</span><br></pre></td></tr></tbody></table></figure>

<p>这张图会告诉你时间消耗在哪个地方，箭头越粗，方框越大越耗时<br>然后通过看这张图，看哪里可以优化，优化完再次运行，然后不断优化到满意为止</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/17/go-fan-xing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/go-fan-xing/" class="post-title-link" itemprop="url">go泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-16 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-16T16:21:41Z">2021-08-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-22 01:10:27" itemprop="dateModified" datetime="2021-09-22T01:10:27Z">2021-09-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>泛型有什么作用？<br>在使用Go没有泛型之前我们怎么实现针对多类型的逻辑实现的呢？有很多方法，比如说使用interface{}作为变量类型参数，在内部通过类型判断进入对应的处理逻辑；将类型转化为特定表现的鸭子类型，通过接口定义的方法实现逻辑整合；还有人专门编写了Go的函数代码生成工具，通过批量生成不同类型的相同实现函数代替手工实现等等。这些方法多多少少存在一些问题：使用了interface{}作为参数意味着放弃了编译时检查，作为强类型语言的一个优势就被抹掉了。同样，无论使用代码生成还是手工书写，一旦出现问题，意味着这些方法都需要重复生成或者进行批量修改，工作量反而变得更多了。</p>
<p>在Go中引入泛型会给程序开发带来很多好处：通过泛型，可以针对多种类型编写一次代码，大大节省了编码时间。你可以充分应用编译器的编译检查，保证程序变量类型的可靠性。借助泛型，你可以减少代码的重复度，也不会出现一处出现问题需要修改多处地方的尴尬问题。这也让很多测试工作变得更简单，借助类型安全，你甚至可以少考虑很多的边缘情况。</p>
<p>泛型方法：</p>
<ol>
<li>形式在方法名后面加类型参数，FuncName[T constraint]</li>
<li>类型参数可以有多个</li>
<li>constraint 是类型约束，必须是接口。可以是普通接口，也可以是如 Numeric 这种复合接口</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/07/leetocode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/leetocode/" class="post-title-link" itemprop="url">leetcode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-06 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-06T16:21:41Z">2021-08-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 08:31:33" itemprop="dateModified" datetime="2021-10-01T08:31:33Z">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="3">
<li>无重复字符的最长子串<br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</li>
</ol>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = ""</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></tbody></table></figure>

<p>提示：</p>
<ul>
<li>0 &lt;= s.length &lt;= 5 * 10^4</li>
<li>s 由英文字母、数字、符号和空格组成</li>
</ul>
<p>法一 滑动窗口<br>思路和算法</p>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。</p>
<p>找出<strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。</p>
<p>以示例一中的字符串 abcabcbb 为例，<br>先从第一个字符开始，只有一个字符肯定不会重复吧。“a”满足条件，更新最大长度为1；然后走到第二个字符，“ab”也满足，更新最大长度为2。<br>走到第三个字符，“abc” 也满足，更新最大长度为 3。<br>走到第四个字符，我们发现 “a” 已经出现过了，于是我们就必须要删除之前的一些字符来继续满足无重复字符的条件，但是我们不知道前面已经出现过一次的 “a” 的 index 在哪里呀，所以我们只能一个一个找了，从当前子串的“abca”的第一个字符开始找，删除第一个字符 “a”，发现这时候只剩下一个 “a”了，我们又满足条件了，更新最大长度为3，以此类推：</p>
<figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">  <span class="keyword">a</span>  b  c  <span class="keyword">a</span>  b  c  b  b</span><br></pre></td></tr></tbody></table></figure>

<p>end 指针不停往前走，只要当前子串 s[start:end+1] 不满足无重复字符条件的时候，我们就让 start 指针往前走直到满足条件为止，每次满足条件我们都要更新一下最大长度，即 res。<br>这就是滑动窗口的思想，也称为sliding window，</p>
<p>对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；<br>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；<br>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；<br>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；<br>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；<br>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；<br>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；<br>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。</p>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！<br>这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k，直到右侧出现了重复字符为止。</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k；</p>
</li>
<li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p>
</li>
<li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
</li>
</ul>
<p>判断重复字符<br>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，<br>但是我们不知道前面已经出现过一次的“a”的index在哪里呀，所以我们只能一个一个找了。<br>我们可以对这里做一个优化，就不需要一个个去找了。只需要用一个常用的数据结构为哈希集合、字典<br>（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set, golang 中的 map[byte]int{}）。<br>添加和移除的元素分别在右边指针和左边指针，set只充当一个记录当前左右指针之间不重复元素的功能。<br>对当前子串中的每一个字符，将其在input中的来源index记录下来即可。</p>
<p>我们先从第一个字符开始，只要碰到已经出现过的字符，我们就必须从之前出现该字符的index开始重新往后看。</p>
<p>例如‘xyzxlkjh’，当看到第二个‘x’时，我们就应该从第一个x后面的y开始重新往后看了。</p>
<p>我们将每一个已经阅读过的字符作为key，而它的值就是它在原字符串中的index。<br>如果我们现在的字符不在字典里面，我们就把它加进字典中去。<br>因此，只要end指针指向的这个字符c，在该字典中的值大于等于了当前子串首字符的index时，就说明c在当前子串中已经出现过了，<br>我们就将当前子串的首字符的index加1，即从后一位又重新开始读，此时当前子串已经满足条件了，然后我们更新res。</p>
<p>在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p>
<p>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度：O(|\Sigma|)O(∣Σ∣)，其中 \SigmaΣ 表示字符集（即字符串中可以出现的字符），|\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |\Sigma| = 128∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |\Sigma|∣Σ∣ 个，因此空间复杂度为 O(|\Sigma|)O(∣Σ∣)。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{} <span class="comment">// map[uint8]int</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> rk+<span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        <span class="comment">// rk-i+1 是当前字串从第 i 到 rk 个字符的长度</span></span><br><span class="line">        ans = max(ans, rk-i+<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> { <span class="comment">// go没有内置的max函数，但是有输入输出float的 math.Max</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y {</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>s = “abcabcbb”<br>len(s) = 8<br>rk, ans := -1, 0</p>
<p>i = 0<br>    rk + 1 = 0 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[0]] = m[“a”] == 0<br>    m[s[rk+1]] = m[s[rk+1]] + 1 = 1<br>    m[“a”] = m[“a”] + 1 = 1<br>    rk = rk + 1 = 0</p>
<pre><code>rk + 1 = 1 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[1]] = m["b"] == 0
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 1

rk + 1 = 2 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[2]] = m["c"] == 0
m["c"] = m["c"] + 1 = 1
rk = rk + 1 = 2

rk + 1 = 3 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[3]] = m["a"] = 1 != 0

ans = max(ans, rk-i+1) = max(0, 2-0+1) = 3
</code></pre>
<p>i = 1 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[0]) = delete(map[a:1 b:1 c:1], “a”)<br>    m = map[b:1 c:1]</p>
<pre><code>rk + 1 = 3 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[3]] = m["a"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["a"] = m["a"] + 1 = 1
rk = rk + 1 = 3

rk + 1 = 4 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[4]] = m["b"] == 1 != 0

ans = max(ans, rk-i+1) = max(3, 3-1+1) = 3
</code></pre>
<p>i = 2 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[1]) = delete(map[a:1 b:1 c:1], “b”)<br>    m = map[a:1 c:1]</p>
<pre><code>rk + 1 = 4 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[4]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 4

rk + 1 = 5 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[5]] = m["c"] == 1 != 0

ans = max(ans, rk-i+1) = max(3, 4-2+1) = 3
</code></pre>
<p>i = 3 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[2]) = delete(map[a:1 b:1 c:1], “c”)<br>    m = map[a:1 b:1]</p>
<pre><code>rk + 1 = 5 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[5]] = m["c"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["c"] = m["c"] + 1 = 1
rk = rk + 1 = 5

rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 5-3+1) = 3
</code></pre>
<p>i = 4 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[3]) = delete(map[a:1 b:1 c:1], “a”)<br>    m = map[b:1 c:1]</p>
<pre><code>rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 5-4+1) = 3
</code></pre>
<p>i = 5 != 0<br>    delete(m, s[i-1]) = delete(map[b:1 c:1], s[4]) = delete(map[b:1 c:1], “b”)<br>    m = map[c:1]</p>
<pre><code>rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 6

rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 6-5+1) = 3
</code></pre>
<p>i = 6 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[5]) = delete(map[a:1 b:1 c:1], “c”)<br>    m = map[b:1]</p>
<pre><code>rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 6-6+1) = 3
</code></pre>
<p>i = 7 != 0<br>    delete(m, s[i-1]) = delete(map[b:1], s[6]) = delete(map[b:1], “b”)<br>    m = map[]</p>
<pre><code>rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 7

rk + 1 = 8
ans = max(ans, rk-i+1) = max(3, 7-7+1) = 3
</code></pre>
<p>return ans = 3</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Max returns the larger of x or y.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Special cases are:</span></span><br><span class="line"><span class="comment">//    Max(x, +Inf) = Max(+Inf, x) = +Inf</span></span><br><span class="line"><span class="comment">//    Max(x, NaN) = Max(NaN, x) = NaN</span></span><br><span class="line"><span class="comment">//    Max(+0, ±0) = Max(±0, +0) = +0</span></span><br><span class="line"><span class="comment">//    Max(-0, -0) = -0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> {</span><br><span class="line">    <span class="keyword">if</span> haveArchMax {</span><br><span class="line">        <span class="keyword">return</span> archMax(x, y)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法二 滑动窗口 左边界一步一步移动</p>
<p>map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</p>
<p>1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,<br>此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</p>
<p>2、如果当前字符 ch 包含在 map中，此时有2类情况：<br> 1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，<br> 那么此时更新 left 为 map.get(a)+1=0+1=1索引，也就是left移动到b，当前有效子段更新为 bca；<br>i - left = 2-0 = 2 ，所以最后 max-left 要+1，s.cahrAt(i)+1 就是 让例如abca ，</p>
<p> 2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，<br> 当遍历到第二个b，再添加b，发现map中包含b，<br> 而且b包含在最长有效子段中，就是1）的情况，我们更新 left = map.get(‘b’) + 1 = 2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；<br> 随后，当遍历到第二个a时，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left= map.get(‘a’) + 1 = 1，实际上，left此时应该不变，left始终为2，left移动到第二个b，子段变成 ba才对，索引下标1的 a 不一定在滑动窗口内<br> 为了处理以上2类情况，我们每次更新left，left=Math.max(left, map.get(ch)+1)= Math.max(left, map.get(s.charAt(i)) + 1) = Math.max(2, 0+1) = 2</p>
<p> 另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，<br> 因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</p>
<p>如：abcbc，我们先添加a,b,c进map，此时left=0，<br> 当遍历到第二个b，再添加b，发现map中包含b，<br> 而且b包含在最长有效子段中，就是1）的情况，我们更新 left = map.get(‘b’) + 1 = 2，此时子段更新为 cb，而且map中仍然包含c，map.get(c)=2；<br> 随后，当遍历到第二个c时，发现c包含在map中，且map.get(c)=2，如果我们像1）一样处理，就会发现 left= map.get(‘c’) + 1 = 3，实际上，left此时应该不变，left始终为2，left移动到第二个b，子段变成 bc才对，索引下标3的 c 在滑动窗口内<br> 为了处理以上2类情况，我们每次更新left，left=Math.max(left, map.get(ch)+1)= Math.max(left, map.get(s.charAt(i)) + 1) = Math.max(3, 2+1) = 3</p>
<p>右窗口是靠 i++一步步右移的，但左窗口并不是，利用哈希表的下标可以一步到位。 以 abcbab 为例， 当滑动窗口框住的是 ab 【cba】 b时，left=2; 框中 b的下标已经更新为3，当下一步 框外的b 进入for循环，判断框中是否已经有它， 发现有，窗口就应该把 b 扔出去，所以left直接跳到b后边，也就是 b的下标+1=4，直接跳了两位，一步就把左窗口固定到位,此时框住的是abcb【ab】</p>
<p>遇到重复的元素，python会删除队列前面的元素，go和java并不会删除队列前面的元素，而是更新这个元素在HashMap中存储的数组下标 i，并同时更新左区间 left 的值，我们是通过 left 和 i 来计算当前无重复子串的长度，并与之前记录的最长子串进行比较。 按你下面说的，1~n-1的字符不重复，突然最后一个字符和第n-1个字符重复的话，并不需要删除n次，我们假设n-1的元素是a，他在HashMap中存储 ：(a,n-1)，随后遍历到第n个元素，假设其也是a，此时更新哈希表：(a,n)，同时更新left，然后计算当前无重复子串长度：n-left+1，随后与原先最长子串进行比较。对其他元素并没有进行操作。</p>
<p>最后，关于哈希表的操作，我们在设计哈希表的时候，假设有N个元素，我们如果开辟M长度的地址，那么每个数组位置的查找表（链表或红黑树）元素个数为：N/M，我们在查找/删除/插入 操作元素的时候，时间复杂度是：O(log(N/M)) 或者 O(log(N/M))，然而实际设计的时候，我们会对哈希表的数组进行动态扩容缩容，使得 N/M 在一定的范围内，可以看做常数，因此哈希表各个操作的时间复杂度可以看做：O(1)。另外，HashMap当某个位置元素个数超过8的时候，会从链表转换为红黑树。对于你说的删除操作，红黑树删除操作的时间复杂度是O(log k)，此处k为红黑树元素个数，即k=N/M，满足前面所说的情况。</p>
<p>这样做可以直接省略left++的中间步骤，直接将left的坐标设置为之前出现该重复字符的下一位，直接一步到位优化了一下官方题解上那个</p>
<p>移动的是下标，这里指的是 left 指针和 i 指针，他们之间的距离即使窗口的长度，也就是我们要求的最大子串的长度，如果有重复的，就把 left 指针更新为 重复的元素的位置。而 i 指针自始至终都是一直往右移动的。<br>比如’abcdefdc’，一开始头指针指向’a’，而当尾指针指向第二个’d’时，头指针就直接指向第一个’d’后的’e’，把中间的’bcd’给忽略了。注意，敲黑板，题目要求是“找出其中不含有重复字符的 最长子串 的长度”。从’a’开始的最长不重复字串长度为6，而从’b’开始的为5，从’c’开始的为4，从’d’开始的为3。由此可见，忽略了也没影响最终结果。<br>原因很简单，有重复元素在那里，搜索’bcd’的结果必然不会大于从’a’开始搜索的结果。因此，可以略过’bcd’，直接把窗口移动到’e’处继续搜索。</p>
<p>时间复杂度：O(2n) = O(n)，最坏的情况是 left 和 right 都遍历了一遍字符串<br>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 优化后的滑动窗口</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) {</span><br><span class="line">        <span class="keyword">char</span> rightChar = s.charAt(right);</span><br><span class="line">        <span class="keyword">int</span> rightCharIndex = window.getOrDefault(rightChar, <span class="number">0</span>);</span><br><span class="line">        left = Math.max(left, rightCharIndex);</span><br><span class="line">        maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        window.put(rightChar, right + <span class="number">1</span>);</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">// 最长不重复子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">// 滑动窗口左下标指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++){ <span class="comment">// i 相当于滑动窗口右下标 right</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))){<span class="comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span></span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);       <span class="comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span></span><br><span class="line">            }        <span class="comment">//map.get('a')=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span></span><br><span class="line">            <span class="comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span></span><br><span class="line">            map.put(s.charAt(i), i);      <span class="comment">//再更新map中a映射的下标</span></span><br><span class="line">            max = Math.max(max, i-left+<span class="number">1</span>);     <span class="comment">//比较两个参数的大小</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        lookup = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        cur_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># i 相当于滑动窗口右下标</span></span><br><span class="line">            cur_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lookup:</span><br><span class="line">                <span class="comment"># 不断从左缩小窗口，直到窗口中不存在与下一个字符重复的字符，才能加入新的元素</span></span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 一步一步移，效率不高</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<p>程序变量解释<br>start 是当前无重复字符的子串首字符的 index；<br>maps 放置每一个字符的 index，如果 maps.get(s[i], -1) 大于等于 start 的话，就说明字符重复了，此时就要重置 res 和 start 的值了。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># start 指针指向的是当前子串首字符在 input 中对应的index</span></span><br><span class="line">        res, start, n = <span class="number">0</span>, <span class="number">0</span>, len(s)</span><br><span class="line">        maps = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># i 相当于滑动窗口右下标</span></span><br><span class="line">            start = max(start, maps.get(s[i], <span class="number">-1</span>) + <span class="number">1</span>) <span class="comment"># 找到当前子串新的起点</span></span><br><span class="line">            res = max(res, i - start + <span class="number">1</span>) <span class="comment"># 当前子串满足条件了，更新结果</span></span><br><span class="line">            maps[s[i]] = i <span class="comment"># 将当前字符与其在 input 中的 index 记录下来</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    res, start := <span class="number">0</span>, <span class="number">0</span> <span class="comment">// start 指针指向的是当前子串首字符在 input 中对应的index</span></span><br><span class="line">    lookup := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> s { <span class="comment">// i 相当于滑动窗口右下标</span></span><br><span class="line">        idx, ok := lookup[s[i]]</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            start = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(start), <span class="keyword">float64</span>(<span class="number">-1</span>+<span class="number">1</span>))) <span class="comment">// 找到当前子串新的起点</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            start = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(start), <span class="keyword">float64</span>(idx+<span class="number">1</span>))) <span class="comment">// 从后一位作为当前子串新的起点又重新开始读</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 第 start 到 i 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        <span class="comment">// i-start+1 是当前字串从第 i 到 rk 个字符的长度</span></span><br><span class="line">        res = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(res), <span class="keyword">float64</span>(i-start+<span class="number">1</span>))) <span class="comment">// 当前子串满足条件了，更新结果</span></span><br><span class="line">        lookup[s[i]] = i                                      <span class="comment">// 将当前字符与其在 input 中的 index 记录下来</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>s = “abcabcbb”<br>len(s) = 8<br>start, res := 0, 0</p>
<p>i = 0<br>    lookup[s[i]] = lookup[“abcabcbb”[0]] = lookup[“a”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(0), float64(0-0+1))) = 1<br>    lookup[s[i]] = lookup[“a”] = i = 0</p>
<p>i = 1<br>    lookup[s[i]] = lookup[“abcabcbb”[2]] = lookup[“c”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(1), float64(1-0+1))) = 2<br>    lookup[s[i]] = lookup[“b”] = i = 1</p>
<p>i = 2<br>    lookup[s[i]] = lookup[“abcabcbb”[1]] = lookup[“b”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(2), float64(2-0+1))) = 3<br>    lookup[s[i]] = lookup[“c”] = i = 2</p>
<p>i = 3<br>    lookup[s[i]] = lookup[“abcabcbb”[3]] = lookup[“a”]<br>    idx = 0, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(0), float64(0+1))) = 1<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(3-1+1))) = 3<br>    lookup[s[i]] = lookup[“a”] = i = 3</p>
<p>i = 4<br>    lookup[s[i]] = lookup[“abcabcbb”[4]] = lookup[“b”]<br>    idx = 1, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(1+1))) = 2<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(4-2+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 4</p>
<p>i = 5<br>    lookup[s[i]] = lookup[“abcabcbb”[5]] = lookup[“c”]<br>    idx = 2, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(2+1))) = 3<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(5-3+1))) = 3<br>    lookup[s[i]] = lookup[“c”] = i = 5</p>
<p>i = 6<br>    lookup[s[i]] = lookup[“abcabcbb”[6]] = lookup[“b”]<br>    idx = 4, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(4+1))) = 5<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(6-5+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 6</p>
<p>i = 7<br>    lookup[s[i]] = lookup[“abcabcbb”[7]] = lookup[“b”]<br>    idx = 6, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(6+1))) = 7<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(7-7+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 7</p>
<p>return ans = 3</p>
<p>abc 再进来一个 b 或者c </p>
<p>s = “abcbc”<br>len(s) = 5<br>start, res := 0, 0</p>
<p>i = 0<br>    lookup[s[i]] = lookup[“abcbc”[0]] = lookup[“a”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(0), float64(0-0+1))) = 1<br>    lookup[s[i]] = lookup[“a”] = i = 0</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>法三：滑动窗口的万能模板</p>
<p>对于这种求”连续…”的题，我们首先想到，”连续“ 代表的是一个范围，我们只要找到这个最大范围即可，很显然先线性数据结构中找范围用 “滑动窗口” 思想。<br>对于窗口，那么必然有“左窗棱”和“右窗棱”。</p>
<p>初始，我们让左(left)右(right)窗棱都为 0 此是窗户(ans)最小。<br>每次 “右窗棱” 向右增大时我们都判断当前字符 s[right] 是否已经存在map中，如果没有，则把当前字符加入map。<br>用字符 s[right] 表示map的key，用字符所在的下标（right）表示 map 的 value （此处有妙用）</p>
<p>在“右窗棱” 向右增加时，如果当前字符已经存在map中，说明“左窗棱”-“右窗棱” 之间存在了重复元素，此时我们该改变我们 “左窗棱” 的位置</p>
<p>如何改变左窗棱的位置？</p>
<p>应该找到重复元素第一次（最近一次更新）添加到map中的value值，然后把该value值加1，既为最新的 “左窗棱” 的位置</p>
<p>更新后的“左窗棱”不能比之前的 “左窗棱” 小<br>更新map中重复元素最新的下标</p>
<p>不管每次”左窗棱“右移还是 “右窗棱”右移，都要计算一下此时窗口的大小，和原来窗口大小比较，记录历史窗口最大的值</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        lookup = defaultdict(int)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> lookup[s[end]] &gt; <span class="number">0</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            lookup[s[end]] += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> counter &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> lookup[s[start]] &gt; <span class="number">1</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                lookup[s[start]] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            max_len = max(max_len, end - start)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<p>滑动窗口优化<br>以上当在窗口中存在重复字符，是一个一个字符的缩小窗口<br>通过记住每个字符在字符串中的索引，当遇到重复字符的时候，就可以直接跳到重复字符的后面</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">    max_len, window = <span class="number">0</span>, {}</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; n:</span><br><span class="line">        right_char_index = window.get(s[right], <span class="number">-1</span>)</span><br><span class="line">        left = max(left, right_char_index)</span><br><span class="line">        max_len = max(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">        window[s[right]] = right + <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> {</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> left, right, window = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> right &lt; n {</span><br><span class="line">        <span class="keyword">var</span> rightChar = s[right]</span><br><span class="line">        <span class="keyword">var</span> rightCharIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := window[rightChar]; ok {</span><br><span class="line">            rightCharIndex = window[rightChar]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> rightCharIndex &gt; left {</span><br><span class="line">            left = rightCharIndex</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; maxLen {</span><br><span class="line">            maxLen = right - left + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        window[rightChar] = right + <span class="number">1</span></span><br><span class="line">        right++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    strLen := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> strLen == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    left,right,ans := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line">    <span class="keyword">for</span> right &lt; strLen{</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[s[right]]; !ok {</span><br><span class="line">            m[s[right]] = right</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> m[s[right]] + <span class="number">1</span> &gt;= left {</span><br><span class="line">                left = m[s[right]] + <span class="number">1</span></span><br><span class="line">            }</span><br><span class="line">            m[s[right]] = right</span><br><span class="line">        }</span><br><span class="line">        ans = max(right-left+<span class="number">1</span>,ans)</span><br><span class="line">        right ++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span> <span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> a &gt; b {</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>对于一个字母 x</p>
<p>start 当前找到的最长不含有重复字符的子串的开始</p>
<ul>
<li>lastOccurred[x]不存在，或者&lt;start → 无需操作</li>
<li>lastOccurred[x] &gt;= start → 更新 start = lastOccurred[x+1]</li>
<li>更新 lastOccurred[x]，更新 maxLength</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="comment">// lastOccurred := make(map[byte]int)</span></span><br><span class="line">    lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    maxLength := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for i, ch := range []byte(s) { // 不支持中文</span></span><br><span class="line">    <span class="comment">// for i, ch := range s { // 支持中文，一个中文字符算3个长度</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s) { <span class="comment">// 支持中文，一个中文字符算1个长度</span></span><br><span class="line">        <span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start {</span><br><span class="line">            start = lastI + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength {</span><br><span class="line">            maxLength = i - start + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        lastOccurred[ch] = i <span class="comment">// key唯一，如果有重复key会覆盖value</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"abcabcbb"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"bbbbb"</span>)) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"pwwkew"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">""</span>)) <span class="comment">// 0</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"b"</span>)) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"abcdef"</span>)) <span class="comment">// 6</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"这里是慕课网"</span>)) <span class="comment">// 6</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"一二三二一"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(</span><br><span class="line">            <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span>)) <span class="comment">// 8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSubstr</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    tests := []<span class="keyword">struct</span> {</span><br><span class="line">        s   <span class="keyword">string</span></span><br><span class="line">        ans <span class="keyword">int</span></span><br><span class="line">    }{</span><br><span class="line">        <span class="comment">// Normal cases</span></span><br><span class="line">        {<span class="string">"abcabcbb"</span>, <span class="number">3</span>},</span><br><span class="line">        {<span class="string">"pwwkew"</span>, <span class="number">3</span>},</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Edge cases</span></span><br><span class="line">        {<span class="string">""</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="string">"b"</span>, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"bbbbbbbbb"</span>, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"abcabcabcd"</span>, <span class="number">4</span>},</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Chinese support</span></span><br><span class="line">        {<span class="string">"这里是慕课网"</span>, <span class="number">6</span>},</span><br><span class="line">        {<span class="string">"一二三二一"</span>, <span class="number">3</span>},</span><br><span class="line">        {<span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span>, <span class="number">8</span>},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests {</span><br><span class="line">        actual := lengthOfLongestSubstring(tt.s)</span><br><span class="line">        <span class="keyword">if</span> actual != tt.ans {</span><br><span class="line">            t.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, tt.s, tt.ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">--- ide ---</span><br><span class="line">=== RUN   TestSubstr</span><br><span class="line">--- PASS: TestSubstr (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">--- 命令行 ---</span><br><span class="line">=== RUN   TestSubstr</span><br><span class="line">--- PASS: TestSubstr (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">coverage: <span class="number">52.6</span>% of statements in ../../../../learngo/...</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr    <span class="number">0.042</span>s</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BenchmarkXxx testing.B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSubstr</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">    s := <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span> <span class="comment">// 一般性能测试选择最复杂的那个用例</span></span><br><span class="line"></span><br><span class="line">    ans := <span class="number">8</span></span><br><span class="line">    <span class="comment">// 如果在这里做测试用的数据的生成，不想把这个时间加进去，可以在生成数据之后reset一下时间</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    <span class="comment">// 性能测试一般循环多次，具体不用我们定，用b.N系统自动帮我们确定多少次</span></span><br><span class="line">        actual := lengthOfLongestSubstring(s)</span><br><span class="line">        <span class="keyword">if</span> actual != ans {</span><br><span class="line">            b.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, s, ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">BenchmarkSubstr</span><br><span class="line"># <span class="number">100000000</span>次    每次操作  <span class="number">0.512</span> ns</span><br><span class="line">BenchmarkSubstr<span class="number">-8</span>            <span class="number">100000000</span>次      <span class="number">0.512</span> ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BenchmarkXxx testing.B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSubstr</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">    s := <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span> <span class="comment">// 一般性能测试选择最复杂的那个用例</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">13</span>; i++ {</span><br><span class="line">        s = s + s</span><br><span class="line">    }</span><br><span class="line">    b.Logf(<span class="string">"len(s) = %d"</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    ans := <span class="number">8</span></span><br><span class="line">    <span class="comment">// 如果在这里做测试用的数据的生成，不想把这个时间加进去，可以在生成数据之后reset一下时间</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    <span class="comment">// 性能测试一般循环多次，具体不用我们定，用b.N系统自动帮我们确定多少次</span></span><br><span class="line">        actual := lengthOfLongestSubstring(s)</span><br><span class="line">        <span class="keyword">if</span> actual != ans {</span><br><span class="line">            b.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, s, ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">BenchmarkSubstr</span><br><span class="line">nonrepeating_test.<span class="keyword">go</span>:<span class="number">40</span>: <span class="built_in">len</span>(s) = <span class="number">491520</span></span><br><span class="line">nonrepeating_test.<span class="keyword">go</span>:<span class="number">40</span>: <span class="built_in">len</span>(s) = <span class="number">491520</span></span><br><span class="line">BenchmarkSubstr<span class="number">-8</span>            <span class="number">100</span>      <span class="number">17965116</span> ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rose\go\src\learngo\lang\container\nonrepeatingsubstr&gt; go test -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr</span><br><span class="line">cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz</span><br><span class="line">BenchmarkSubstr-8            200           5943632 ns/op</span><br><span class="line">--- BENCH: BenchmarkSubstr-8</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">PASS</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr     1.837s</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rose\go\src\learngo\lang\container\nonrepeatingsubstr&gt; go test -bench . -cpuprofile cpu.out</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr</span><br><span class="line">cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz</span><br><span class="line">BenchmarkSubstr-8            171           7770656 ns/op</span><br><span class="line">--- BENCH: BenchmarkSubstr-8</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">PASS</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr     2.277s</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以设立两层循环，外层循环对字符串进行整体遍历—代表子串的起始点i，内层循环从当前起始点开始往后遍历，并且将每一个当前遇到的字符存入哈希集合当中，根据哈希表的特点我们可以很快地找出哈希表中是否存在某个字符，当不存在的时候内存循环结束，同时在内层循环中我们还是需要维护一个右边界的指针r，每循环一次内层循环就加一，当内层循环结束时，就代表从外层循环选择的左边界i到内层循环维护的右边界指针r这个区间的字符串为当前起始点的无重复字符的最长子串，这时与最大值max进行比较赋值，当整个循环完成，这个max就是最大的长度。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">//存储当前最长不重复子串，用来查询下个字符是否存在</span></span><br><span class="line">    maps := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line">    <span class="comment">//r是子串的右置针，这里还没有还是移动所以初始化为-1</span></span><br><span class="line">    <span class="comment">//max记录最大的子串的长度</span></span><br><span class="line">    r, max := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">//从头开始遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ {</span><br><span class="line">        <span class="comment">//当每一次外层循环结束就代表i++也就是待遍历子串的左边界加一，所以这个时候我们需要讲maps中</span></span><br><span class="line">        <span class="comment">//的最左字符删除</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">delete</span>(maps, s[i<span class="number">-1</span>])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> r &lt; <span class="built_in">len</span>(s)<span class="number">-1</span> &amp;&amp; maps[s[r+<span class="number">1</span>]] == <span class="number">0</span> {</span><br><span class="line">            maps[s[r+<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">            r++</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> max &lt; r-i+<span class="number">1</span> {</span><br><span class="line">            max = r - i + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] = [-2147483648~2147483647]，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>将一个有符号整数进行反转，也就是说 64 这个数字再反转后会变为 46 ，个位数反转到十位数，十位数反转到个位数。如果给出的整数是负数的话，整数的符号不能变。在这道题中我们要注意以下几点：</p>
<ul>
<li>整数会有负数的情况；</li>
<li>最后一位是 0 的情况下要舍弃，例如 120 反转后为 21 。</li>
</ul>
<p>解题方案<br>思路1：时间复杂度: O(lgx) 空间复杂度: O(1)<br>翻转数字问题需要注意的就是溢出问题，为什么会存在溢出问题呢？</p>
<p>int型的数值范围是 -2147483648～2147483647 (-2^31 ~ 2^31 - 1)，<br>那么如果我们要翻转 1000000009 这个在数值范围内的数，得到 9000000001，<br>但翻转后的数就超过了范围，这个情况就是溢出，这个时候程序返回 0 即可。</p>
<p>如果输入的是负数，就递归调用原函数，参数变成 -x 即可，代码大致执行流程如下：</p>
<ul>
<li>首先判断 x 是否为负数，如果是负数先取绝对值然后递归取反，最后再将结果转换为负数即可；</li>
<li>res 为最后结果，最开始等于 0 。x % 10(例如：123 % 10 = 3) 取出最后一位数。每次得到最后一位数字，并将其作为结果中的当前最高位；</li>
<li>判断结果 res 是否溢出，如果溢出则返回 0 </li>
</ul>
<p>时刻注意特殊情况——为负数怎么办；为0怎么办；为空怎么办。<br>合理运用写完的函数，机智一点，不要碰到负数又去实现一个负数的版本，直接递归调用原函数就可以了</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>: <span class="comment"># 判断是否为负数</span></span><br><span class="line">            <span class="keyword">return</span> -self.reverse(-x) <span class="comment"># 如果是负数则取绝对值调用自身，最后将结果转为负数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x: <span class="comment"># 每次得到最后一位数字，并将其作为结果中的当前最高位</span></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 如果溢出就返回0</span></span><br></pre></td></tr></tbody></table></figure>

<p>x = 123</p>
<p>res = 0 + 3 = 3<br>x = 123 // 10 = 12</p>
<p>res = 3 * 10 + 12 % 10 = 32<br>x = 12 // 10 = 1</p>
<p>res = 32 * 10 + 1 % 10 = 321<br>x = 1 // 10 = 0</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> { <span class="comment">// 如果是负数就取反递归再取反</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> { <span class="comment">// 每次得到最后一位数字，并将其作为结果中的当前最高位</span></span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> res &lt;= <span class="number">0x7fffffff</span> { <span class="comment">// 如果溢出就返回0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p>示例 1:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">9</span></span><br><span class="line">输出: <span class="string">"IX"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V</span> = <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></tbody></table></figure>

<p>详细的罗马数字计数规则如下：</p>
<ul>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3；</li>
<li>小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8；</li>
<li>小的数字，限于（I、X 和 C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4，这条规则好目前与本题无关；</li>
<li>正常使用时，连续的数字重复不得超过三次；</li>
<li>在一个数的上面画横线，表示这个数扩大 1000 倍（本题只考虑 3999 以内的数，所以用不到这条规则）；</li>
<li>从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数；反之，减去前一个数的两倍然后加上该数。</li>
</ul>
<p>我们可以将所有罗马数字的不同符号及对应整数放在字典中。但由于题目限制，正常使用时连续的数字重复不能超过三次，所以对于 400、40、4 或者是 900、90、9 这种情况我们直接单独列出来。</p>
<p>注：之所以将 900、90、9 这三种情况列出是因为罗马数字中并没有单独表示 400 的字符存在，而且不允许DCD这样的情况出现。</p>
<p>将罗马数字和对应整数以及各种特殊情况整合到字典中后，首先将字典按照对应罗马数字的对应整数值进行排序并遍历，每一项中的键 symbol 对应罗马数字符号 ，值 val 对应整数。</p>
<p>如果 num 大于 val 则进入 while 循环，并将当前的罗马数字字符 symbol 拼接到最后结果 roman 中，然后 num - val ，每执行一次 while 循环重新判断 num &gt;= val。如果不满足则跳出 while 循环，执行下一次 for 循环。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: int</span>) -&gt; str:</span></span><br><span class="line">        lookup = {</span><br><span class="line">            <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        roman = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 因为dict本身是无序的，这里做了一个排序的操作，否则可能会出现IIII这种状况。</span></span><br><span class="line">        <span class="keyword">for</span> symbol, val <span class="keyword">in</span> sorted(lookup.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>])[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= val:</span><br><span class="line">                roman += symbol</span><br><span class="line">                num -= val</span><br><span class="line">        <span class="keyword">return</span> roman</span><br></pre></td></tr></tbody></table></figure>

<p>以整数 3568 为例，3568 的对应罗马数字为：MMMDLXVIII</p>
<p>第一次 for 循环 ————&gt; symbol = ‘M’ val = 1000 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘M’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘M’,num 为 2568<br>    第二次 while 循环：<br>        将 ‘M’ 拼接到 roman 中，num 减去当前 val ，此时 roman 为 ‘MM’,num 为 1568<br>    第三次 while 循环：<br>        将 ‘M’ 拼接到 roman 中，num 减去当前 val ，此时 roman 为 ‘MMM’,num 为 568                     num &gt;= val 不成立，退出 while 循环。<br>第二次 for 循环 ————&gt; symbol = ‘CM’ val = 900 , num &gt;= val不成立，不能进入 while 循环：<br>第三次 for 循环 ————&gt; symbol = ‘D’ val = 500 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘D’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘MMMD’,num 为 68<br>        num &gt;= val 不成立，退出 while 循环。<br>第四次 for 循环 ————&gt; symbol = ‘CD’ val = 400 , num &gt;= val不成立，不能进入 while 循环：<br>…………<br>第七次 for 循环 ————&gt; symbol = ‘L’ val = 50 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘L’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘MMMDL’,num 为 18<br>        num &gt;= val 不成立，退出 while 循环。<br>…………依次执行后得出结果为 MMMDLXVIII 。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="comment">// 初始化了一个一一对应的map，方便后面取出符号。</span></span><br><span class="line">    lookupSymbol := []<span class="keyword">string</span>{<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>}</span><br><span class="line">    lookupNum := []<span class="keyword">int</span>{<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>}</span><br><span class="line">    roman := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i, symbol := <span class="keyword">range</span> lookupSymbol {</span><br><span class="line">        val := lookupNum[i]</span><br><span class="line">        <span class="keyword">for</span> num &gt;= val {</span><br><span class="line">            roman += symbol</span><br><span class="line">            num -= val</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> roman</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "III"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "IV"</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "IX"</span></span><br><span class="line"><span class="section">输出: 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></tbody></table></figure>

<p>提示：</p>
<p>1 &lt;= s.length &lt;= 15<br>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)<br>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内<br>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。<br>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。<br>通过次数467,201提交次数739,123</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```go</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/27/go-de-tcp-he-udp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/27/go-de-tcp-he-udp/" class="post-title-link" itemprop="url">go的tcp和udp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-26 16:21:41 / 修改时间：08:58:15" itemprop="dateCreated datePublished" datetime="2021-07-26T16:21:41Z">2021-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="如何获取完整应用数据报文"><a href="#如何获取完整应用数据报文" class="headerlink" title="如何获取完整应用数据报文?"></a>如何获取完整应用数据报文?</h4><ul>
<li>使用带消息头的协议，头部写入包长度，然后再读取包内容</li>
<li>设置定长消息，每次读取定长内容，长度不够时空位补齐固定字符</li>
<li>设置消息边界，服务端从网络流中按消息边界分离消息内容，一般使用‘\n’</li>
<li>更为复杂的协议，例如 json,protobuf</li>
</ul>
<h3 id="自定义消息格式实现装包与拆包"><a href="#自定义消息格式实现装包与拆包" class="headerlink" title="自定义消息格式实现装包与拆包"></a>自定义消息格式实现装包与拆包</h3><p>服务端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/e421083458/gateway_demo/demo/base/unpack/unpack"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//simple tcp server</span></span><br><span class="line">    <span class="comment">//1.监听端口</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"listen fail, err: %v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.接收请求</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"accept fail, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建协程</span></span><br><span class="line">        <span class="keyword">go</span> process(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">for</span> { <span class="comment">// 数据解码</span></span><br><span class="line">        bt, err := unpack.Decode(conn)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read from connect failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        str := <span class="keyword">string</span>(bt)</span><br><span class="line">        fmt.Printf(<span class="string">"receive from client, data: %v\n"</span>, str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>客户端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/e421083458/gateway_demo/demo/base/unpack/unpack"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"connect failed, err : %v\n"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 数据编码</span></span><br><span class="line">    unpack.Encode(conn, <span class="string">"hello world 0!!!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>unpack/unpack/codec.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unpack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Msg_Header = <span class="string">"12345678"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(bytesBuffer io.Writer, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">// 定义数据格式：msg_header+content_len+content</span></span><br><span class="line">    <span class="comment">// 对应的字节长度8+4+content_len</span></span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, []<span class="keyword">byte</span>(Msg_Header)); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    clen := <span class="keyword">int32</span>(<span class="built_in">len</span>([]<span class="keyword">byte</span>(content)))</span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, clen); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, []<span class="keyword">byte</span>(content)); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(bytesBuffer io.Reader)</span> <span class="params">(bodyBuf []<span class="keyword">byte</span>, err error)</span></span> {</span><br><span class="line">    MagicBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(Msg_Header))</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, MagicBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">string</span>(MagicBuf) != Msg_Header {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"msg_header error"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lengthBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, lengthBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    length := binary.BigEndian.Uint32(lengthBuf)</span><br><span class="line">    bodyBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, bodyBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bodyBuf, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>unpack/main.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Msg_Header = <span class="string">"12345678"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 类比接收缓冲区 net.Conn</span></span><br><span class="line">    bytesBuffer := bytes.NewBuffer([]<span class="keyword">byte</span>{})</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送</span></span><br><span class="line">    <span class="keyword">if</span> err := Encode(bytesBuffer, <span class="string">"hello world 0!!!"</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> err := Encode(bytesBuffer, <span class="string">"hello world 1!!!"</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">if</span> bt, err := Decode(bytesBuffer); err == <span class="literal">nil</span> {</span><br><span class="line">            fmt.Println(<span class="keyword">string</span>(bt))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(bytesBuffer io.Writer, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//msg_header+content_len+content</span></span><br><span class="line">    <span class="comment">//8            +4            +content</span></span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, []<span class="keyword">byte</span>(Msg_Header)); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    clen := <span class="keyword">int32</span>(<span class="built_in">len</span>([]<span class="keyword">byte</span>(content)))</span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, clen); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> err := binary.Write(bytesBuffer, binary.BigEndian, []<span class="keyword">byte</span>(content)); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(bytesBuffer io.Reader)</span> <span class="params">(bodyBuf []<span class="keyword">byte</span>, err error)</span></span> {</span><br><span class="line">    MagicBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(Msg_Header))</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, MagicBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">string</span>(MagicBuf) != Msg_Header {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"msg_header error"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lengthBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, lengthBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    length := binary.BigEndian.Uint32(lengthBuf)</span><br><span class="line">    bodyBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(bytesBuffer, bodyBuf); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bodyBuf, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world 0!!!</span><br><span class="line">hello world 1!!!</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">receive from client, data: hello world 0!!!</span><br><span class="line">read from connect failed, err: EOF</span><br></pre></td></tr></tbody></table></figure>

<h3 id="UDP实现"><a href="#UDP实现" class="headerlink" title="UDP实现"></a>UDP实现</h3><p>服务端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//step 1 监听服务器</span></span><br><span class="line">    listen, err := net.ListenUDP(<span class="string">"udp"</span>, &amp;net.UDPAddr{</span><br><span class="line">        IP:   net.IPv4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        Port: <span class="number">9090</span>,</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"listen failed, err:%v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 2 循环读取消息内容</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">var</span> data [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">        n, addr, err := listen.ReadFromUDP(data[:])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read failed from addr: %v, err: %v\n"</span>, addr, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="comment">//todo sth</span></span><br><span class="line">            <span class="comment">//step 3 回复数据</span></span><br><span class="line">            fmt.Printf(<span class="string">"addr: %v data: %v  count: %v\n"</span>, addr, <span class="keyword">string</span>(data[:n]), n)</span><br><span class="line">            _, err = listen.WriteToUDP([]<span class="keyword">byte</span>(<span class="string">"received success!"</span>), addr)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                fmt.Printf(<span class="string">"write failed, err: %v\n"</span>, err)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//step 1 连接服务器</span></span><br><span class="line">    conn, err := net.DialUDP(<span class="string">"udp"</span>, <span class="literal">nil</span>, &amp;net.UDPAddr{</span><br><span class="line">        IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        Port: <span class="number">9090</span>,</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"connect failed, err: %v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="comment">//step 2 发送数据</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello server!"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"send data failed, err : %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step 3 接收数据</span></span><br><span class="line">        result := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        n, remoteAddr, err := conn.ReadFromUDP(result)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"receive data failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Printf(<span class="string">"receive from addr: %v  data: %v\n"</span>, remoteAddr, <span class="keyword">string</span>(result[:n]))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先运行udp_serve.go，在运行udp_client.go</p>
<p>客户端udp_client.go 终端</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53974</span> data: hello server!  count: <span class="number">13</span></span><br><span class="line">addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53974</span> data: hello server!  count: <span class="number">13</span></span><br><span class="line">addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53974</span> data: hello server!  count: <span class="number">13</span></span><br><span class="line">addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53974</span> data: hello server!  count: <span class="number">13</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>客户端udp_client.go 终端</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">receive <span class="keyword">from</span> addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span>  data: received success!</span><br><span class="line">receive <span class="keyword">from</span> addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span>  data: received success!</span><br><span class="line">receive <span class="keyword">from</span> addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span>  data: received success!</span><br><span class="line">receive <span class="keyword">from</span> addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span>  data: received success!</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1、监听端口</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"listen fail, err: %v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.建立套接字连接</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"accept fail, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建处理协程</span></span><br><span class="line">        <span class="keyword">go</span> process(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> conn.Close() <span class="comment">//思考题：这里不填写会有啥问题？</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">var</span> buf [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">        n, err := conn.Read(buf[:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read from connect failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        str := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">        fmt.Printf(<span class="string">"receive from client, data: %v\n"</span>, str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {</span><br><span class="line">    doSend()</span><br><span class="line">    fmt.Print(<span class="string">"doSend over"</span>)</span><br><span class="line">    doSend()</span><br><span class="line">    fmt.Print(<span class="string">"doSend over"</span>)</span><br><span class="line">    <span class="comment">//select {}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSend</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 1、连接服务器</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()    <span class="comment">// 这里不填写会无法释放连接，一直是连接状态</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"connect failed, err : %v\n"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2、读取命令行输入</span></span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 3、一直读取直到读到\n</span></span><br><span class="line">        input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read from console failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4、读取Q时停止</span></span><br><span class="line">        trimmedInput := strings.TrimSpace(input)</span><br><span class="line">        <span class="keyword">if</span> trimmedInput == <span class="string">"Q"</span> {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 5、回复服务器信息</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(trimmedInput))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"write failed , err : %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先运行服务端 再运行客户端，</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 客户端终端输入</span></span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端终端输出</span></span><br><span class="line">receive from client, data: test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端终端输入</span></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端终端输出</span></span><br><span class="line">receive from client, data: q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端终端输入</span></span><br><span class="line">Q</span><br><span class="line">doSend over</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端终端输出</span></span><br><span class="line">read from connect failed, err: EOF</span><br></pre></td></tr></tbody></table></figure>


<h3 id="忘记关闭连接会怎么样？"><a href="#忘记关闭连接会怎么样？" class="headerlink" title="忘记关闭连接会怎么样？"></a>忘记关闭连接会怎么样？</h3><p>linux 检查端口状态</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -Aaln | grep 9090</span><br></pre></td></tr></tbody></table></figure>

<h4 id="客户端忘记关连接"><a href="#客户端忘记关连接" class="headerlink" title="客户端忘记关连接"></a>客户端忘记关连接</h4><p>如果进程不退出的话<br>客户端占用的端口会一直处于连接状态，资源不会被释放。</p>
<p>客户端程序是个独立的进程，进程关闭之后，进程里面所占用的资源都会同时释放</p>
<p>服务端和客户端的tcp连接都处于ESTABLISHED 状态，直到进程关闭或者服务端探测机制，探测两边是否存活，如果超过存活时间，它也会释放，tcp探活机制触发，才能释放资源<br>在没有自动探测之前，这个连接一直是ESTABLISHED 状态</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package client</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {</span><br><span class="line">    doSend()</span><br><span class="line">    fmt.Print(<span class="string">"doSend over"</span>)</span><br><span class="line">    doSend()</span><br><span class="line">    fmt.Print(<span class="string">"doSend over"</span>)</span><br><span class="line">    <span class="comment">//select {}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSend</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 1、连接服务器</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:9090"</span>)</span><br><span class="line">    <span class="comment">// defer conn.Close()    //思考题：这里不填写会有啥问题？</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"connect failed, err : %v\n"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2、读取命令行输入</span></span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 3、一直读取直到读到\n</span></span><br><span class="line">        input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read from console failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4、读取Q时停止</span></span><br><span class="line">        trimmedInput := strings.TrimSpace(input)</span><br><span class="line">        <span class="keyword">if</span> trimmedInput == <span class="string">"Q"</span> {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 5、回复服务器信息</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(trimmedInput))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"write failed , err : %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"client close"</span>)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="服务端忘记关连接"><a href="#服务端忘记关连接" class="headerlink" title="服务端忘记关连接"></a>服务端忘记关连接</h4><p>如果进程不退出的话<br>服务端会一直处于CLOSE_WAIT状态，由于没有给客户端发送FIN包，客户端会处于FIN_WAIT_2状态，直到tcp探活机制触发，才能释放资源。四次挥手里面的最后一个服务端被动关闭方，回置fin包的逻辑</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1、监听端口</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"listen fail, err: %v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.建立套接字连接</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"accept fail, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建处理协程</span></span><br><span class="line">        <span class="keyword">go</span> process(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> conn.Close() <span class="comment">//思考题：这里不填写会有啥问题？</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">var</span> buf [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">        n, err := conn.Read(buf[:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"read from connect failed, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        str := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">        fmt.Printf(<span class="string">"receive from client, data: %v\n"</span>, str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/osi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/osi/" class="post-title-link" itemprop="url">OSI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-27 11:41:04" itemprop="dateModified" datetime="2021-07-27T11:41:04Z">2021-07-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>网络协议分层</p>
<p>osi Open System Interconnection Reference Model<br>开放式系统互联通信参考模型</p>
<p>高层：负责主机之间的数据传输<br>底层：负责网络数据传输</p>
<h3 id="互联七层框架"><a href="#互联七层框架" class="headerlink" title="互联七层框架"></a>互联七层框架</h3><p>应用层 提供应用程序间通信  老张向老王提供了一份货物及价格清单<br>表示层 处理数据格式转化、数据加密 怕竞争对手公司看到给清单做了加密<br>会话层 建立、维护和管理会话 市场部整理后将报价清单放到收发室<br>传输层 建立、管理和维护主机端到端连接 收发室将报价清单送到快递公司<br>网络层 IP地址寻址和路由选择 快递公司分发到不同的集散中心<br>数据链路层 提供介质访问、链路管理 运输路线的规划及各集散中心访问方式<br>物理层 即物理设备 通过汽车,火车,飞机等设备进行运输</p>
<h3 id="OSI起源"><a href="#OSI起源" class="headerlink" title="OSI起源"></a>OSI起源</h3><p>为了是网络更加普及所以推出OSI参考模型，它的含义是推荐所有公司去使用这个规范去控制网络，这样所有公司都有相同的规范就可以相互互联。</p>
<h3 id="OSI七层和TCP-IP四层之间的关系："><a href="#OSI七层和TCP-IP四层之间的关系：" class="headerlink" title="OSI七层和TCP/IP四层之间的关系："></a>OSI七层和TCP/IP四层之间的关系：</h3><p>OSI引入服务、接口、协议的功能分层的概念，TCP/IP借鉴了OSI的概念然后建立了TCP/IP的参考模型。</p>
<p>OSI：先有OSI模型后有的协议，先有的标准后有的实战。</p>
<p>TCP/IP：先有协议后有模型，而且是参考OSI模型提出的。</p>
<p>OSI是理论性模型。而TCP/IP是更广泛使用的互联网标准。</p>
<p>OSI七层和TCP/IP五层协议及对应网络协议</p>
<ol>
<li>应用层(包括表示层,会话层):HTTP,HTTPS,FTP,SMTP</li>
<li>传输层:TCP/UDP</li>
<li>网络层: IP/ICMP</li>
<li>数据链路层 : ARP/RARP</li>
<li>物理层:MLT-3/PAM5</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/go-de-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/go-de-http/" class="post-title-link" itemprop="url">go的http</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-23 14:52:10" itemprop="dateModified" datetime="2021-09-23T14:52:10Z">2021-09-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Web是基于http协议的一个服务，<br>Go语言里面提供了一个完善的net/http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。<br>同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<p>阅读源代码原则：先整体再局部，先看脑图再逐一分析<br>注册路由:理解函数是一等公民以及注册原理开启服务处理连接</p>
<h4 id="web工作方式的几个概念"><a href="#web工作方式的几个概念" class="headerlink" title="web工作方式的几个概念"></a>web工作方式的几个概念</h4><p>Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息</p>
<p>Response：服务器需要反馈给客户端的信息</p>
<p>Conn：用户的每次请求链接</p>
<p>Handler：处理请求和生成返回信息的处理逻辑</p>
<h4 id="分析http包运行机制"><a href="#分析http包运行机制" class="headerlink" title="分析http包运行机制"></a>分析http包运行机制</h4><ol>
<li><p>创建Listen Socket, 监听指定的端口, 等待客户端请求到来。</p>
</li>
<li><p>Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。</p>
</li>
<li><p>处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。</p>
</li>
</ol>
<p><img src="./go%E7%9A%84http/0.png" alt="description"></p>
<p>• 从 http.Request 中读取数据并解析<br>• 往 http.ResponseWriter 中写入数据和响应</p>
<p>编写一个Web服务器很简单，只要调用http包的两个函数就可以了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// HandleFunc将一个普通的函数ServeHTTP包装成Handle</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 将处理请求逻辑的代码注册到路由分发器servermux 中</span></span><br><span class="line">    <span class="comment">// 将不同的url的请求交给对应的handler处理</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, ServeHTTP) <span class="comment">// 设置访问的路由</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\rose&gt;curl http://127.0.0.1:8080/</span><br><span class="line">通过HandleFunc启动一个http服务</span><br><span class="line">C:\Users\rose&gt;curl -v "http://127.0.0.1:8080/"</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET / HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: 127.0.0.1:8080</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.55.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Mon, 26 Jul 2021 09:20:45 GMT</span><br><span class="line">&lt; Content-Length: 27</span><br><span class="line">&lt; Content-Type: text/plain; charset=utf-8</span><br><span class="line">&lt;</span><br><span class="line">通过HandleFunc启动一个http服务* Connection #0 to host 127.0.0.1 left intact</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/1.png" alt="description"></p>
<p>Go的http有两个核心功能：Conn、ServeMux</p>
<p>HandlerFunc注册一个处理器事件和绑定路由</p>
<h4 id="Conn的goroutine"><a href="#Conn的goroutine" class="headerlink" title="Conn的goroutine"></a>Conn的goroutine</h4><p>与我们一般编写的http服务器不同, Go为了实现高并发和高性能, 使用了goroutines来处理Conn的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是Go高效的保证。</p>
<p>Go在等待客户端请求里面是这样写的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们可以看到客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，这样保证了每个请求的独立性。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> {</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="ServeMux的定义"><a href="#ServeMux的定义" class="headerlink" title="ServeMux的定义"></a>ServeMux的定义</h4><p>我们前面小节讲述conn.server的时候，其实内部是调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。那么这个路由器是怎么实现的呢？</p>
<p>ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。</p>
<p>它的结构如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux also takes care of sanitizing the URL request path and the Host</span></span><br><span class="line"><span class="comment">// header, stripping the port number and redirecting any request containing . or</span></span><br><span class="line"><span class="comment">// .. elements or repeated slashes to an equivalent, cleaner URL.</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> {</span><br><span class="line">    mu    sync.RWMutex <span class="comment">// 锁，由于请求涉及到并发处理</span></span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames 是否在任意的规则中带有host信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> {</span><br><span class="line">    h       Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">    pattern <span class="keyword">string</span> <span class="comment">// 匹配字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// Handle 注册HTTP处理器 handler 和对应的模式 pattern。</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="comment">// 如果该模式已经注册有一个处理器，Handle会panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> {</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> _, exist := mux.m[pattern]; exist {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> {</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    }</span><br><span class="line">    e := muxEntry{h: handler, pattern: pattern}</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> {</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> {</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Handler的定义"><a href="#Handler的定义" class="headerlink" title="Handler的定义"></a>Handler的定义</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn't log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> {</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Handler是一个接口，但是下面的sayhelloName函数并没有实现ServeHTTP这个接口，为什么能添加呢？<br>原来在http包里面还定义了一个类型HandlerFunc,我们定义的函数sayhelloName就是这个HandlerFunc调用之后的结果，<br>这个类型默认就实现了ServeHTTP这个接口，即我们调用了HandlerFunc(f)，<br>强制类型转换f成为HandlerFunc类型，这样f就拥有了ServeHTTP方法。</p>
<p>路由器里面存储好了相应的路由规则之后，那么具体的请求又是怎么分发的呢？请看下面的代码，默认的路由器实现了ServeHTTP</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="comment">// ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> {</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) {</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        }</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如上所示路由器接收到请求之后，如果是*那么关闭链接，不然调用mux.Handler(r)返回对应设置路由的处理Handler，然后执行h.ServeHTTP(w, r)<br>也就是调用对应路由的handler的ServerHTTP接口，<br>那么mux.Handler(r)怎么处理的呢？</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler returns the handler to use for the given request,</span></span><br><span class="line"><span class="comment">// consulting r.Method, r.Host, and r.URL.Path. It always returns</span></span><br><span class="line"><span class="comment">// a non-nil handler. If the path is not in its canonical form, the</span></span><br><span class="line"><span class="comment">// handler will be an internally-generated handler that redirects</span></span><br><span class="line"><span class="comment">// to the canonical path. If the host contains a port, it is ignored</span></span><br><span class="line"><span class="comment">// when matching handlers.</span></span><br><span class="line"><span class="comment">// Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The path and host are used unchanged for CONNECT requests.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handler also returns the registered pattern that matches the</span></span><br><span class="line"><span class="comment">// request or, in the case of internally-generated redirects,</span></span><br><span class="line"><span class="comment">// the pattern that will match after following the redirect.</span></span><br><span class="line"><span class="comment">// Handler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there is no registered handler that applies to the request,</span></span><br><span class="line"><span class="comment">// Handler returns a ``page not found'' handler and an empty pattern.</span></span><br><span class="line"><span class="comment">// 如果没有已注册模式可以应用于该请求，本方法将返回一个内建的"404 page not found"处理器和一个空字符串模式。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> {</span><br><span class="line">        <span class="comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line">        <span class="comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line">        <span class="comment">// but the path canonicalization does not.</span></span><br><span class="line">        <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All other requests have any port stripped and path cleaned</span></span><br><span class="line">    <span class="comment">// before passing to mux.handler.</span></span><br><span class="line">    host := stripHostPort(r.Host)</span><br><span class="line">    path := cleanPath(r.URL.Path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line">    <span class="comment">// redirect for /tree/.</span></span><br><span class="line">    <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path != r.URL.Path {</span><br><span class="line">        _, pattern = mux.handler(host, path)</span><br><span class="line">        url := *r.URL</span><br><span class="line">        url.Path = path</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler is the main implementation of Handler.</span></span><br><span class="line"><span class="comment">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts {</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> {</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> {</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    <span class="comment">// Check for exact match first.</span></span><br><span class="line">    v, ok := mux.m[path]</span><br><span class="line">    <span class="keyword">if</span> ok {</span><br><span class="line">        <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class="line">    <span class="comment">// that end in / sorted from longest to shortest.</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es {</span><br><span class="line">        <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) {</span><br><span class="line">            <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="comment">// HandleFunc注册一个处理器函数handler和对应的模式pattern。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    }</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers.</span></span><br><span class="line"><span class="comment">// HandlerFunc type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。</span></span><br><span class="line"><span class="comment">// If f is a function with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler that calls f.</span></span><br><span class="line"><span class="comment">// 如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span> // 基于现有的函数自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Go其实支持外部实现的路由器 ListenAndServe的第二个参数就是用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了Handler接口就可以，我们可以在自己实现的路由器的ServeHTTP里面实现自定义路由功能。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="comment">// addr ip+端口 不写ip默认本机地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> {</span><br><span class="line">    server := &amp;Server{Addr: addr, Handler: handler}</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Server defines parameters for running an HTTP server.</span></span><br><span class="line"><span class="comment">// The zero value for Server is a valid configuration.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Addr optionally specifies the TCP address for the server to listen on,</span></span><br><span class="line">    <span class="comment">// in the form "host:port". If empty, ":http" (port 80) is used.</span></span><br><span class="line">    <span class="comment">// The service names are defined in RFC 6335 and assigned by IANA.</span></span><br><span class="line">    <span class="comment">// See net.Dial for details of the address format.</span></span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLSConfig optionally provides a TLS configuration for use</span></span><br><span class="line">    <span class="comment">// by ServeTLS and ListenAndServeTLS. Note that this value is</span></span><br><span class="line">    <span class="comment">// cloned by ServeTLS and ListenAndServeTLS, so it's not</span></span><br><span class="line">    <span class="comment">// possible to modify the configuration with methods like</span></span><br><span class="line">    <span class="comment">// tls.Config.SetSessionTicketKeys. To use</span></span><br><span class="line">    <span class="comment">// SetSessionTicketKeys, use Server.Serve with a TLS Listener</span></span><br><span class="line">    <span class="comment">// instead.</span></span><br><span class="line">    TLSConfig *tls.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadTimeout is the maximum duration for reading the entire</span></span><br><span class="line">    <span class="comment">// request, including the body. A zero or negative value means</span></span><br><span class="line">    <span class="comment">// there will be no timeout.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Because ReadTimeout does not let Handlers make per-request</span></span><br><span class="line">    <span class="comment">// decisions on each request body's acceptable deadline or</span></span><br><span class="line">    <span class="comment">// upload rate, most users will prefer to use</span></span><br><span class="line">    <span class="comment">// ReadHeaderTimeout. It is valid to use them both.</span></span><br><span class="line">    ReadTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadHeaderTimeout is the amount of time allowed to read</span></span><br><span class="line">    <span class="comment">// request headers. The connection's read deadline is reset</span></span><br><span class="line">    <span class="comment">// after reading the headers and the Handler can decide what</span></span><br><span class="line">    <span class="comment">// is considered too slow for the body. If ReadHeaderTimeout</span></span><br><span class="line">    <span class="comment">// is zero, the value of ReadTimeout is used. If both are</span></span><br><span class="line">    <span class="comment">// zero, there is no timeout.</span></span><br><span class="line">    ReadHeaderTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteTimeout is the maximum duration before timing out</span></span><br><span class="line">    <span class="comment">// writes of the response. It is reset whenever a new</span></span><br><span class="line">    <span class="comment">// request's header is read. Like ReadTimeout, it does not</span></span><br><span class="line">    <span class="comment">// let Handlers make decisions on a per-request basis.</span></span><br><span class="line">    <span class="comment">// A zero or negative value means there will be no timeout.</span></span><br><span class="line">    WriteTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IdleTimeout is the maximum amount of time to wait for the</span></span><br><span class="line">    <span class="comment">// next request when keep-alives are enabled. If IdleTimeout</span></span><br><span class="line">    <span class="comment">// is zero, the value of ReadTimeout is used. If both are</span></span><br><span class="line">    <span class="comment">// zero, there is no timeout.</span></span><br><span class="line">    IdleTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxHeaderBytes controls the maximum number of bytes the</span></span><br><span class="line">    <span class="comment">// server will read parsing the request header's keys and</span></span><br><span class="line">    <span class="comment">// values, including the request line. It does not limit the</span></span><br><span class="line">    <span class="comment">// size of the request body.</span></span><br><span class="line">    <span class="comment">// If zero, DefaultMaxHeaderBytes is used.</span></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLSNextProto optionally specifies a function to take over</span></span><br><span class="line">    <span class="comment">// ownership of the provided TLS connection when an ALPN</span></span><br><span class="line">    <span class="comment">// protocol upgrade has occurred. The map key is the protocol</span></span><br><span class="line">    <span class="comment">// name negotiated. The Handler argument should be used to</span></span><br><span class="line">    <span class="comment">// handle HTTP requests and will initialize the Request's TLS</span></span><br><span class="line">    <span class="comment">// and RemoteAddr if not already set. The connection is</span></span><br><span class="line">    <span class="comment">// automatically closed when the function returns.</span></span><br><span class="line">    <span class="comment">// If TLSNextProto is not nil, HTTP/2 support is not enabled</span></span><br><span class="line">    <span class="comment">// automatically.</span></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConnState specifies an optional callback function that is</span></span><br><span class="line">    <span class="comment">// called when a client connection changes state. See the</span></span><br><span class="line">    <span class="comment">// ConnState type and associated constants for details.</span></span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ErrorLog specifies an optional logger for errors accepting</span></span><br><span class="line">    <span class="comment">// connections, unexpected behavior from handlers, and</span></span><br><span class="line">    <span class="comment">// underlying FileSystem errors.</span></span><br><span class="line">    <span class="comment">// If nil, logging is done via the log package's standard logger.</span></span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseContext optionally specifies a function that returns</span></span><br><span class="line">    <span class="comment">// the base context for incoming requests on this server.</span></span><br><span class="line">    <span class="comment">// The provided Listener is the specific Listener that's</span></span><br><span class="line">    <span class="comment">// about to start accepting requests.</span></span><br><span class="line">    <span class="comment">// If BaseContext is nil, the default is context.Background().</span></span><br><span class="line">    <span class="comment">// If non-nil, it must return a non-nil context.</span></span><br><span class="line">    BaseContext <span class="function"><span class="keyword">func</span><span class="params">(net.Listener)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConnContext optionally specifies a function that modifies</span></span><br><span class="line">    <span class="comment">// the context used for a new connection c. The provided ctx</span></span><br><span class="line">    <span class="comment">// is derived from the base context and has a ServerContextKey</span></span><br><span class="line">    <span class="comment">// value.</span></span><br><span class="line">    ConnContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, c net.Conn)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"></span><br><span class="line">    inShutdown atomicBool <span class="comment">// true when server is in shutdown</span></span><br><span class="line"></span><br><span class="line">    disableKeepAlives <span class="keyword">int32</span>     <span class="comment">// accessed atomically.</span></span><br><span class="line">    nextProtoOnce     sync.Once <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">    nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line"></span><br><span class="line">    mu         sync.Mutex</span><br><span class="line">    listeners  <span class="keyword">map</span>[*net.Listener]<span class="keyword">struct</span>{}</span><br><span class="line">    activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>{}</span><br><span class="line">    doneChan   <span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">    onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address srv.Addr and then</span></span><br><span class="line"><span class="comment">// calls Serve to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If srv.Addr is blank, ":http" is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error. After Shutdown or Close,</span></span><br><span class="line"><span class="comment">// the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> srv.shuttingDown() {</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    }</span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="string">""</span> {</span><br><span class="line">        addr = <span class="string">":http"</span></span><br><span class="line">    }</span><br><span class="line">    ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line"><span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line"><span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line"><span class="comment">// connections and they were configured with "h2" in the TLS</span></span><br><span class="line"><span class="comment">// Config.NextProtos.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line"><span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> {</span><br><span class="line">        fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    origListener := l</span><br><span class="line">    l = &amp;onceCloseListener{Listener: l}</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    baseCtx := context.Background()</span><br><span class="line">    <span class="keyword">if</span> srv.BaseContext != <span class="literal">nil</span> {</span><br><span class="line">        baseCtx = srv.BaseContext(origListener)</span><br><span class="line">        <span class="keyword">if</span> baseCtx == <span class="literal">nil</span> {</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"BaseContext returned a nil context"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        rw, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">                <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() {</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> {</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max {</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                }</span><br><span class="line">                srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, err, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        }</span><br><span class="line">        connCtx := ctx</span><br><span class="line">        <span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> {</span><br><span class="line">            connCtx = cc(connCtx, rw)</span><br><span class="line">            <span class="keyword">if</span> connCtx == <span class="literal">nil</span> {</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"ConnContext returned nil"</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw) <span class="comment">// 每一个请求都新生成一个connection，并且开启一个go的协程为这个请求进行服务，体现go的并发能力</span></span><br><span class="line">        c.setState(c.rwc, StateNew, runHooks) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serve a new connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> {</span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler {</span><br><span class="line">            <span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">            buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">            buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">            c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> !c.hijacked() {</span><br><span class="line">            c.<span class="built_in">close</span>()</span><br><span class="line">            c.setState(c.rwc, StateClosed, runHooks)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok {</span><br><span class="line">        <span class="keyword">if</span> d := c.server.ReadTimeout; d != <span class="number">0</span> {</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> d := c.server.WriteTimeout; d != <span class="number">0</span> {</span><br><span class="line">            c.rwc.SetWriteDeadline(time.Now().Add(d))</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> err := tlsConn.Handshake(); err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// If the handshake failed due to the client not speaking</span></span><br><span class="line">            <span class="comment">// TLS, assume they're speaking plaintext HTTP and write a</span></span><br><span class="line">            <span class="comment">// 400 response on the TLS conn's underlying net.Conn.</span></span><br><span class="line">            <span class="keyword">if</span> re, ok := err.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != <span class="literal">nil</span> &amp;&amp; tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {</span><br><span class="line">                io.WriteString(re.Conn, <span class="string">"HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n"</span>)</span><br><span class="line">                re.Conn.Close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        c.tlsState = <span class="built_in">new</span>(tls.ConnectionState)</span><br><span class="line">        *c.tlsState = tlsConn.ConnectionState()</span><br><span class="line">        <span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {</span><br><span class="line">            <span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != <span class="literal">nil</span> {</span><br><span class="line">                h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}</span><br><span class="line">                <span class="comment">// Mark freshly created HTTP/2 as active and prevent any server state hooks</span></span><br><span class="line">                <span class="comment">// from being run on these connections. This prevents closeIdleConns from</span></span><br><span class="line">                <span class="comment">// closing such connections. See issue https://golang.org/issue/39776.</span></span><br><span class="line">                c.setState(c.rwc, StateActive, skipHooks)</span><br><span class="line">                fn(c.server, tlsConn, h)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">    c.r = &amp;connReader{conn: c}</span><br><span class="line">    c.bufr = newBufioReader(c.r)</span><br><span class="line">    c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line">        <span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() {</span><br><span class="line">            <span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">            c.setState(c.rwc, StateActive, runHooks)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">const</span> errorHeaders = <span class="string">"\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> {</span><br><span class="line">            <span class="keyword">case</span> err == errTooLarge:</span><br><span class="line">                <span class="comment">// Their HTTP client may or may not be</span></span><br><span class="line">                <span class="comment">// able to read this if we're</span></span><br><span class="line">                <span class="comment">// responding to them and hanging up</span></span><br><span class="line">                <span class="comment">// while they're still writing their</span></span><br><span class="line">                <span class="comment">// request. Undefined behavior.</span></span><br><span class="line">                <span class="keyword">const</span> publicErr = <span class="string">"431 Request Header Fields Too Large"</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> isUnsupportedTEError(err):</span><br><span class="line">                <span class="comment">// Respond as per RFC 7230 Section 3.3.1 which says,</span></span><br><span class="line">                <span class="comment">//      A server that receives a request message with a</span></span><br><span class="line">                <span class="comment">//      transfer coding it does not understand SHOULD</span></span><br><span class="line">                <span class="comment">//      respond with 501 (Unimplemented).</span></span><br><span class="line">                code := StatusNotImplemented</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We purposefully aren't echoing back the transfer-encoding's value,</span></span><br><span class="line">                <span class="comment">// so as to mitigate the risk of cross side scripting by an attacker.</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 %d %s%sUnsupported transfer encoding"</span>, code, StatusText(code), errorHeaders)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> isCommonNetReadError(err):</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// don't reply</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> v, ok := err.(statusError); ok {</span><br><span class="line">                    fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 %d %s: %s%s%d %s: %s"</span>, v.code, StatusText(v.code), v.text, errorHeaders, v.code, StatusText(v.code), v.text)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                }</span><br><span class="line">                publicErr := <span class="string">"400 Bad Request"</span></span><br><span class="line">                fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expect 100 Continue support</span></span><br><span class="line">        req := w.req</span><br><span class="line">        <span class="keyword">if</span> req.expectsContinue() {</span><br><span class="line">            <span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> {</span><br><span class="line">                <span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">                req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}</span><br><span class="line">                w.canWriteContinue.setTrue()</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> {</span><br><span class="line">            w.sendExpectationFailed()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> requestBodyRemains(req.Body) {</span><br><span class="line">            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            w.conn.r.startBackgroundRead()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line">        <span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line">        <span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line">        <span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line">        <span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line">        <span class="comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line">        <span class="comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">        serverHandler{c.server}.ServeHTTP(w, w.req)</span><br><span class="line">        w.cancelCtx()</span><br><span class="line">        <span class="keyword">if</span> c.hijacked() {</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        w.finishRequest()</span><br><span class="line">        <span class="keyword">if</span> !w.shouldReuseConnection() {</span><br><span class="line">            <span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() {</span><br><span class="line">                c.closeWriteAndWait()</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        c.setState(c.rwc, StateIdle, runHooks)</span><br><span class="line">        c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !w.conn.server.doKeepAlives() {</span><br><span class="line">            <span class="comment">// We're in shutdown mode. We might've replied</span></span><br><span class="line">            <span class="comment">// to the user without "Connection: close" and</span></span><br><span class="line">            <span class="comment">// they might think they can send another</span></span><br><span class="line">            <span class="comment">// request, but such is life with HTTP/1.1.</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> {</span><br><span class="line">            c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">            <span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        c.rwc.SetReadDeadline(time.Time{})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }</span><br></pre></td></tr></tbody></table></figure>

<p>Go 提供了一系列用于创建 Web 服务器的标准库，而且通过 Go 创建一个服务器的 步骤非常简单，只要通过 net/http 包调用 ListenAndServe 函数并传入网络地址以及负责处理请求的处理器( handler )作为参数就可以了。</p>
<p>如果网络地址参数为空字符串，那么服务器默认使用 80 端口进行网络连接；<br>如果处理器参数为 nil，那么服务器将使用默认的多路复用器 DefaultServeMux，</p>
<p>我们也可以通过调用 NewServeMux 函数创建一个多路复用器。<br>多路复用器接收到用户的请求之后根据请求的 URL 来判断使用哪个处理器来处理请求，找到后就会重定向到对应的处理器来处理请求</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServeMux allocates and returns a new ServeMux.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span> { <span class="keyword">return</span> <span class="built_in">new</span>(ServeMux) }</span><br></pre></td></tr></tbody></table></figure>


<h4 id="使用默认的多路复用器（DefaultServeMux）"><a href="#使用默认的多路复用器（DefaultServeMux）" class="headerlink" title="使用默认的多路复用器（DefaultServeMux）"></a>使用默认的多路复用器（DefaultServeMux）</h4><p>使用实现ServerHTTP的类型来自定义的处理器处理请求</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// HandleFunc将一个普通的函数ServeHTTP包装成Handle</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefineServeMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsm *DefineServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 创建自定义的多路复用处理器defineServerMux</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过自定义类型启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//http.HandleFunc("/", ServeHTTP)</span></span><br><span class="line">    defineServeMux := DefineServeMux{}</span><br><span class="line">    http.Handle(<span class="string">"/defineServerMux"</span>, &amp;defineServeMux)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/2.png" alt="description"></p>
<p>使用自己创建的多路复用器</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefineServeMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsm *DefineServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 创建自定义的多路复用处理器defineServerMux</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过自定义类型启动一个http服务"</span>)</span><br><span class="line">    <span class="keyword">if</span> r.URL.Path == <span class="string">"/"</span> {</span><br><span class="line">        sayhelloName(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 hello myroute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello myroute!"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, ServeHTTP)</span><br><span class="line">    defineServeMux := DefineServeMux{}</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, &amp;defineServeMux)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/3.png" alt="description"></p>
<h2 id="web请求与响应解析"><a href="#web请求与响应解析" class="headerlink" title="web请求与响应解析"></a>web请求与响应解析</h2><p>Go 语言的 net/http 包提供了一系列用于表示 HTTP 报文的结构，我们可以使用它处理请求和发送相应，<br>其中 Request 结构代表了客户端发送的请求报文<br>Request结构体中的字段可以获取请求报文中的信息.</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Request represents an HTTP request received by a server</span></span><br><span class="line"><span class="comment">// or to be sent by a client.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The field semantics differ slightly between client and server</span></span><br><span class="line"><span class="comment">// usage. In addition to the notes on the fields below, see the</span></span><br><span class="line"><span class="comment">// documentation for Request.Write and RoundTripper.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Method specifies the HTTP method (GET, POST, PUT, etc.).</span></span><br><span class="line">    <span class="comment">// Method指定HTTP方法（GET、POST、PUT等）。</span></span><br><span class="line">    <span class="comment">// For client requests, an empty string means GET.</span></span><br><span class="line">    <span class="comment">// 对客户端，""代表GET。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Go's HTTP client does not support sending a request with</span></span><br><span class="line">    <span class="comment">// the CONNECT method. See the documentation on Transport for</span></span><br><span class="line">    <span class="comment">// details.</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL specifies either the URI being requested (for server</span></span><br><span class="line">    <span class="comment">// requests) or the URL to access (for client requests).</span></span><br><span class="line">    <span class="comment">// URL在服务端表示被请求的URI，在客户端表示要访问的URL。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the URL is parsed from the URI</span></span><br><span class="line">    <span class="comment">// supplied on the Request-Line as stored in RequestURI.  For</span></span><br><span class="line">    <span class="comment">// most requests, fields other than Path and RawQuery will be</span></span><br><span class="line">    <span class="comment">// empty. (See RFC 7230, Section 5.3)</span></span><br><span class="line">    <span class="comment">// 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，</span></span><br><span class="line">    <span class="comment">// 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。</span></span><br><span class="line">    <span class="comment">// （参见RFC 7230, Section 5.3）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, the URL's Host specifies the server to</span></span><br><span class="line">    <span class="comment">// connect to, while the Request's Host field optionally</span></span><br><span class="line">    <span class="comment">// specifies the Host header value to send in the HTTP</span></span><br><span class="line">    <span class="comment">// request.</span></span><br><span class="line">    <span class="comment">// 在客户端，URL的Host字段指定了要连接的服务器，</span></span><br><span class="line">    <span class="comment">// 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。</span></span><br><span class="line">    URL *url.URL</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The protocol version for incoming server requests.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, these fields are ignored. The HTTP</span></span><br><span class="line">    <span class="comment">// client code always uses either HTTP/1.1 or HTTP/2.</span></span><br><span class="line">    <span class="comment">// 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1</span></span><br><span class="line">    <span class="comment">// See the docs on Transport for details.</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Header contains the request header fields either received</span></span><br><span class="line">    <span class="comment">// by the server or to be sent by the client.</span></span><br><span class="line">    <span class="comment">// Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If a server received a request with header lines,</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    Host: example.com</span></span><br><span class="line">    <span class="comment">//    accept-encoding: gzip, deflate</span></span><br><span class="line">    <span class="comment">//    Accept-Language: en-us</span></span><br><span class="line">    <span class="comment">//    fOO: Bar</span></span><br><span class="line">    <span class="comment">//    foo: two</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// then // 则：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    Header = map[string][]string{</span></span><br><span class="line">    <span class="comment">//        "Accept-Encoding": {"gzip, deflate"},</span></span><br><span class="line">    <span class="comment">//        "Accept-Language": {"en-us"},</span></span><br><span class="line">    <span class="comment">//        "Foo": {"Bar", "two"},</span></span><br><span class="line">    <span class="comment">//    }</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For incoming requests, the Host header is promoted to the</span></span><br><span class="line">    <span class="comment">// Request.Host field and removed from the Header map.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// HTTP defines that header names are case-insensitive. The</span></span><br><span class="line">    <span class="comment">// request parser implements this by using CanonicalHeaderKey,</span></span><br><span class="line">    <span class="comment">// making the first character and any characters following a</span></span><br><span class="line">    <span class="comment">// hyphen uppercase and the rest lowercase.</span></span><br><span class="line">    <span class="comment">// HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, certain headers such as Content-Length</span></span><br><span class="line">    <span class="comment">// and Connection are automatically written when needed and</span></span><br><span class="line">    <span class="comment">// values in Header may be ignored. See the documentation</span></span><br><span class="line">    <span class="comment">// for the Request.Write method.</span></span><br><span class="line">    <span class="comment">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。</span></span><br><span class="line">    Header Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Body is the request's body.</span></span><br><span class="line">    <span class="comment">// Body是请求的主体。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, a nil body means the request has no</span></span><br><span class="line">    <span class="comment">// body, such as a GET request. The HTTP Client's Transport</span></span><br><span class="line">    <span class="comment">// is responsible for calling the Close method.</span></span><br><span class="line">    <span class="comment">// 在客户端，如果Body是nil表示该请求没有主体买入GET请求。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段会负责调用Body的Close方法。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the Request Body is always non-nil</span></span><br><span class="line">    <span class="comment">// but will return EOF immediately when no body is present.</span></span><br><span class="line">    <span class="comment">// The Server will close the request body. The ServeHTTP</span></span><br><span class="line">    <span class="comment">// Handler does not need to.</span></span><br><span class="line">    <span class="comment">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。</span></span><br><span class="line">    <span class="comment">// Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Body must allow Read to be called concurrently with Close.</span></span><br><span class="line">    <span class="comment">// In particular, calling Close should unblock a Read waiting</span></span><br><span class="line">    <span class="comment">// for input.</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetBody defines an optional func to return a new copy of</span></span><br><span class="line">    <span class="comment">// Body. It is used for client requests when a redirect requires</span></span><br><span class="line">    <span class="comment">// reading the body more than once. Use of GetBody still</span></span><br><span class="line">    <span class="comment">// requires setting Body.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, it is unused.</span></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContentLength records the length of the associated content.</span></span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度。</span></span><br><span class="line">    <span class="comment">// The value -1 indicates that the length is unknown.</span></span><br><span class="line">    <span class="comment">// 如果为-1，表示长度未知</span></span><br><span class="line">    <span class="comment">// Values &gt;= 0 indicate that the given number of bytes may</span></span><br><span class="line">    <span class="comment">// be read from Body.</span></span><br><span class="line">    <span class="comment">// 如果&gt;=0，表示可以从Body字段读取ContentLength字节数据。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, a value of 0 with a non-nil Body is</span></span><br><span class="line">    <span class="comment">// also treated as unknown.</span></span><br><span class="line">    <span class="comment">// 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TransferEncoding lists the transfer encodings from outermost to</span></span><br><span class="line">    <span class="comment">// innermost. An empty list denotes the "identity" encoding.</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    <span class="comment">// TransferEncoding can usually be ignored; chunked encoding is</span></span><br><span class="line">    <span class="comment">// automatically added and removed as necessary when sending and</span></span><br><span class="line">    <span class="comment">// receiving requests.</span></span><br><span class="line">    <span class="comment">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除"chunked"传输编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close indicates whether to close the connection after</span></span><br><span class="line">    <span class="comment">// replying to this request (for servers) or after sending this</span></span><br><span class="line">    <span class="comment">// request and reading its response (for clients).</span></span><br><span class="line">    <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求和读取响应后关闭连接。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the HTTP server handles this automatically</span></span><br><span class="line">    <span class="comment">// and this field is not needed by Handlers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, setting this field prevents re-use of</span></span><br><span class="line">    <span class="comment">// TCP connections between requests to the same hosts, as if</span></span><br><span class="line">    <span class="comment">// Transport.DisableKeepAlives were set.</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For server requests, Host specifies the host on which the</span></span><br><span class="line">    <span class="comment">// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this</span></span><br><span class="line">    <span class="comment">// is either the value of the "Host" header or the host name</span></span><br><span class="line">    <span class="comment">// given in the URL itself. For HTTP/2, it is the value of the</span></span><br><span class="line">    <span class="comment">// ":authority" pseudo-header field.</span></span><br><span class="line">    <span class="comment">// It may be of the form "host:port". For international domain</span></span><br><span class="line">    <span class="comment">// names, Host may be in Punycode or Unicode form. Use</span></span><br><span class="line">    <span class="comment">// golang.org/x/net/idna to convert it to either format if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="comment">// To prevent DNS rebinding attacks, server Handlers should</span></span><br><span class="line">    <span class="comment">// validate that the Host header has a value for which the</span></span><br><span class="line">    <span class="comment">// Handler considers itself authoritative. The included</span></span><br><span class="line">    <span class="comment">// ServeMux supports patterns registered to particular host</span></span><br><span class="line">    <span class="comment">// names and thus protects its registered Handlers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, Host optionally overrides the Host</span></span><br><span class="line">    <span class="comment">// header to send. If empty, the Request.Write method uses</span></span><br><span class="line">    <span class="comment">// the value of URL.Host. Host may contain an international</span></span><br><span class="line">    <span class="comment">// domain name.</span></span><br><span class="line">    <span class="comment">// 在服务端，Host指定URL会在其上寻找资源的主机。</span></span><br><span class="line">    <span class="comment">// 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。</span></span><br><span class="line">    <span class="comment">// Host的格式可以是"host:port"。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 在客户端，请求的Host字段（可选地）用来重写请求的Host头。</span></span><br><span class="line">    <span class="comment">// 如过该字段为""，Request.Write方法会使用URL字段的Host。</span></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form contains the parsed form data, including both the URL</span></span><br><span class="line">    <span class="comment">// field's query parameters and the PATCH, POST, or PUT form data.</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PostForm contains the parsed form data from PATCH, POST</span></span><br><span class="line">    <span class="comment">// or PUT body parameters.</span></span><br><span class="line">    <span class="comment">// PostForm是解析好的PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores PostForm and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    PostForm url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MultipartForm is the parsed multipart form, including file uploads.</span></span><br><span class="line">    <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseMultipartForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseMultipartForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores MultipartForm and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    MultipartForm *multipart.Form <span class="comment">// multipart 包下 Form 结构的指针类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trailer specifies additional headers that are sent after the request body.</span></span><br><span class="line">    <span class="comment">// Trailer指定了会在请求主体之后发送的额外的头域。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the Trailer map initially contains only the</span></span><br><span class="line">    <span class="comment">// trailer keys, with nil values. (The client declares which trailers it</span></span><br><span class="line">    <span class="comment">// will later send.)  While the handler is reading from Body, it must</span></span><br><span class="line">    <span class="comment">// not reference Trailer. After reading from Body returns EOF, Trailer</span></span><br><span class="line">    <span class="comment">// can be read again and will contain non-nil values, if they were sent</span></span><br><span class="line">    <span class="comment">// by the client.</span></span><br><span class="line">    <span class="comment">// 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。</span></span><br><span class="line">    <span class="comment">// （客户端会声明哪些trailer会发送）</span></span><br><span class="line">    <span class="comment">// 在处理器从Body读取时，不能使用本字段。</span></span><br><span class="line">    <span class="comment">// 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。</span></span><br><span class="line">    <span class="comment">// （如果客户端发送了这些键值对），此时才可以访问本字段。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, Trailer must be initialized to a map containing</span></span><br><span class="line">    <span class="comment">// the trailer keys to later send. The values may be nil or their final</span></span><br><span class="line">    <span class="comment">// values. The ContentLength must be 0 or -1, to send a chunked request.</span></span><br><span class="line">    <span class="comment">// After the HTTP request is sent the map values can be updated while</span></span><br><span class="line">    <span class="comment">// the request body is read. Once the body returns EOF, the caller must</span></span><br><span class="line">    <span class="comment">// not mutate Trailer.</span></span><br><span class="line">    <span class="comment">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）</span></span><br><span class="line">    <span class="comment">// ContentLength字段必须是0或-1，以启用"chunked"传输编码发送请求。</span></span><br><span class="line">    <span class="comment">// 在开始发送请求后，Trailer可以在读取请求主体期间被修改，</span></span><br><span class="line">    <span class="comment">// 一旦请求主体返回EOF，调用者就不可再修改Trailer。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Few HTTP clients, servers, or proxies support HTTP trailers.</span></span><br><span class="line">    <span class="comment">// 很少有HTTP客户端、服务端或代理支持HTTP trailer。</span></span><br><span class="line">    Trailer Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RemoteAddr allows HTTP servers and other software to record</span></span><br><span class="line">    <span class="comment">// the network address that sent the request, usually for</span></span><br><span class="line">    <span class="comment">// logging. This field is not filled in by ReadRequest and</span></span><br><span class="line">    <span class="comment">// has no defined format. The HTTP server in this package</span></span><br><span class="line">    <span class="comment">// sets RemoteAddr to an "IP:port" address before invoking a</span></span><br><span class="line">    <span class="comment">// handler.</span></span><br><span class="line">    <span class="comment">// This field is ignored by the HTTP client.</span></span><br><span class="line">    <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。</span></span><br><span class="line">    <span class="comment">// 本字段不是ReadRequest函数填写的，也没有定义格式。</span></span><br><span class="line">    <span class="comment">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为"IP:port"格式的地址。</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的RemoteAddr字段。</span></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestURI is the unmodified request-target of the</span></span><br><span class="line">    <span class="comment">// Request-Line (RFC 7230, Section 3.1.1) as sent by the client</span></span><br><span class="line">    <span class="comment">// to a server. Usually the URL field should be used instead.</span></span><br><span class="line">    <span class="comment">// It is an error to set this field in an HTTP client request.</span></span><br><span class="line">    <span class="comment">// RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI</span></span><br><span class="line">    <span class="comment">// （参见RFC 2616, Section 5.1）</span></span><br><span class="line">    <span class="comment">// 一般应使用URI字段，在客户端设置请求的本字段会导致错误。</span></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS allows HTTP servers and other software to record</span></span><br><span class="line">    <span class="comment">// information about the TLS connection on which the request</span></span><br><span class="line">    <span class="comment">// was received. This field is not filled in by ReadRequest.</span></span><br><span class="line">    <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息</span></span><br><span class="line">    <span class="comment">// 本字段不是ReadRequest函数填写的。</span></span><br><span class="line">    <span class="comment">// The HTTP server in this package sets the field for</span></span><br><span class="line">    <span class="comment">// TLS-enabled connections before invoking a handler;</span></span><br><span class="line">    <span class="comment">// otherwise it leaves the field nil.</span></span><br><span class="line">    <span class="comment">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。</span></span><br><span class="line">    <span class="comment">// This field is ignored by the HTTP client.</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的TLS字段。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cancel is an optional channel whose closure indicates that the client</span></span><br><span class="line">    <span class="comment">// request should be regarded as canceled. Not all implementations of</span></span><br><span class="line">    <span class="comment">// RoundTripper may support Cancel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, this field is not applicable.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Deprecated: Set the Request's context with NewRequestWithContext</span></span><br><span class="line">    <span class="comment">// instead. If a Request's Cancel field and context are both</span></span><br><span class="line">    <span class="comment">// set, it is undefined whether Cancel is respected.</span></span><br><span class="line">    Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Response is the redirect response which caused this request</span></span><br><span class="line">    <span class="comment">// to be created. This field is only populated during client</span></span><br><span class="line">    <span class="comment">// redirects.</span></span><br><span class="line">    Response *Response</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctx is either the client or server context. It should only</span></span><br><span class="line">    <span class="comment">// be modified via copying the whole Request using WithContext.</span></span><br><span class="line">    <span class="comment">// It is unexported to prevent people from using Context wrong</span></span><br><span class="line">    <span class="comment">// and mutating the contexts held by callers of the same request.</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获取请求 Request URL</p>
<ul>
<li>包含路径方面的所有信息和一些很有用的操作</li>
<li>URL 里面 Host 不一定有值</li>
<li>r.Host 一般都有值，是Host这个header的值</li>
<li>RawPath 也是不一定有</li>
<li>Path肯定有</li>
</ul>
<p>Request 结构中的 URL 字段用于表示请求行中包含的 URL，该字段是一个指向 <code>url.URL</code> 结构的指针</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A URL represents a parsed URL (technically, a URI reference).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The general form represented is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [scheme:][//[userinfo@]host][/]path[?query][#fragment]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// URLs that do not start with a slash after the scheme are interpreted as:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scheme:opaque[?query][#fragment]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.</span></span><br><span class="line"><span class="comment">// A consequence is that it is impossible to tell which slashes in the Path were</span></span><br><span class="line"><span class="comment">// slashes in the raw URL and which were %2f. This distinction is rarely important,</span></span><br><span class="line"><span class="comment">// but when it is, the code should use RawPath, an optional field which only gets</span></span><br><span class="line"><span class="comment">// set if the default encoding is different from Path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// URL's String method uses the EscapedPath method to obtain the path. See the</span></span><br><span class="line"><span class="comment">// EscapedPath method for more details.</span></span><br><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> {</span><br><span class="line">    Scheme      <span class="keyword">string</span></span><br><span class="line">    Opaque      <span class="keyword">string</span>    <span class="comment">// encoded opaque data 编码后的不透明数据</span></span><br><span class="line">    User        *Userinfo <span class="comment">// username and password information</span></span><br><span class="line">    Host        <span class="keyword">string</span>    <span class="comment">// host or host:port</span></span><br><span class="line">    Path        <span class="keyword">string</span>    <span class="comment">// path (relative paths may omit leading slash) 获取请求的 URL</span></span><br><span class="line">    RawPath     <span class="keyword">string</span>    <span class="comment">// encoded path hint (see EscapedPath method)</span></span><br><span class="line">    ForceQuery  <span class="keyword">bool</span>      <span class="comment">// append a query ('?') even if RawQuery is empty</span></span><br><span class="line">    RawQuery    <span class="keyword">string</span>    <span class="comment">// encoded query values, without '?' 编码后的查询字符串，获取请求的 URL 后面?后面的查询字符串，没有'?' </span></span><br><span class="line">    Fragment    <span class="keyword">string</span>    <span class="comment">// fragment for references, without '#'引用的片段（文档位置），没有'#'</span></span><br><span class="line">    RawFragment <span class="keyword">string</span>    <span class="comment">// encoded fragment hint (see EscapedFragment method)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wholeUrl</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  {</span><br><span class="line">    data, _ := json.Marshal(r.URL)</span><br><span class="line">    fmt.Fprintf(w, <span class="keyword">string</span>(data))</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/wholeUrl"</span>, wholeUrl)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/26.png" alt="description"><br><img src="./go%E7%9A%84http/27.png" alt="description"></p>
<p>Path 字段</p>
<p> 例如：<a target="_blank" rel="noopener" href="http://luboke.com/hello?username=%E5%85%A8%E6%A0%88%E7%BC%96%E7%A8%8B&amp;password=123456">http://luboke.com/hello?username=全栈编程&amp;password=123456</a><br> 通过 <code>r.URL.Path</code> 只能得到 /hello</p>
<p>RawQuery 字段</p>
<p> 例如：<a target="_blank" rel="noopener" href="http://luboke.com/hello?username=%E5%85%A8%E6%A0%88%E7%BC%96%E7%A8%8B&amp;password=123456">http://luboke.com/hello?username=全栈编程&amp;password=123456</a></p>
<p> 通过 <code>r.URL.RawQuery</code> 得到的是 username=全栈编程&amp;password=123456</p>
<p>获取请求头中的信息<br>通过 Request 结果中的 Header 字段用来获取请求头中的所有信息，Header 字段 的类型是 Header 类型，而 Header 类型是一个 string 类型的 key， string 切片类型的值。下面是 Header 类型及它的方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Header represents the key-value pairs in an HTTP header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The keys should be in canonical form, as returned by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key. If</span></span><br><span class="line"><span class="comment">// there are no values associated with the key, Get returns "".</span></span><br><span class="line"><span class="comment">// Get返回键对应的第一个值，如果键不存在会返回""。</span></span><br><span class="line"><span class="comment">// It is case insensitive; textproto.CanonicalMIMEHeaderKey is</span></span><br><span class="line"><span class="comment">// used to canonicalize the provided key. To use non-canonical keys,</span></span><br><span class="line"><span class="comment">// access the map directly.</span></span><br><span class="line"><span class="comment">// 如要获取该键对应的值切片，请直接用规范格式的键访问map。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> textproto.MIMEHeader(h).Get(key)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the header entries associated with key to the</span></span><br><span class="line"><span class="comment">// single element value. It replaces any existing values</span></span><br><span class="line"><span class="comment">// associated with key. The key is case insensitive; it is</span></span><br><span class="line"><span class="comment">// canonicalized by textproto.CanonicalMIMEHeaderKey.</span></span><br><span class="line"><span class="comment">// To use non-canonical keys, assign to the map directly.</span></span><br><span class="line"><span class="comment">// Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the key, value pair to the header.</span></span><br><span class="line"><span class="comment">// It appends to any existing values associated with key.</span></span><br><span class="line"><span class="comment">// The key is case insensitive; it is canonicalized by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="comment">// Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del deletes the values associated with key.Del删除键值对。</span></span><br><span class="line"><span class="comment">// The key is case insensitive; it is canonicalized by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Del(key)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write writes a header in wire format.Write以有线格式将头域写入w。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">return</span> h.write(w, <span class="literal">nil</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteSubset writes a header in wire format.</span></span><br><span class="line"><span class="comment">// If exclude is not nil, keys where exclude[key] == true are not written.</span></span><br><span class="line"><span class="comment">// Keys are not canonicalized before checking the exclude map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">WriteSubset</span><span class="params">(w io.Writer, exclude <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">return</span> h.writeSubset(w, exclude, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>header大体上是两类，一类是http 预定义的；一类是自己定义的<br>• Go 会自动将 header 名字转为标准名字——其实就是大小写调整<br>• 一般用 <code>X</code> 开头来表明是自己定义的，比如说 X-mycompany-your=header</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">header</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"header is %v\n"</span>, r.Header)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/header"</span>, header)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/28.png" alt="description"></p>
<h4 id="获取请求头中的某个具体属性的值"><a href="#获取请求头中的某个具体属性的值" class="headerlink" title="获取请求头中的某个具体属性的值"></a>获取请求头中的某个具体属性的值</h4><p>假如需要获取 Accept-Encoding 的值</p>
<p>方式一：r.Header[“Accept-Encoding”]<br>i. 得到的是一个字符串切片<br>ii. 结果<br>[gzip, deflate, br]</p>
<p>方式二：r.Header.Get(“Accept-Encoding”)<br>i. 得到的是字符串形式的值，多个值使用逗号分隔<br>ii. 结果<br>gzip, deflate, br</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// http:127.0.0.1:8080/?query=bobobo&amp;name=go#fragment</span></span><br><span class="line">    fmt.Fprintln(w, r.URL.RawQuery)</span><br><span class="line">    fmt.Fprintln(w, r.URL.Host)</span><br><span class="line">    fmt.Fprintln(w, r.URL.Path)</span><br><span class="line"></span><br><span class="line">    rawQuery := r.URL.RawQuery</span><br><span class="line">    val, _ := url.ParseQuery(rawQuery)</span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取url当中key为name的值"</span>, val)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取url当中key为name的值"</span>, val.Get(<span class="string">"name"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"######"</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中的所有信息有："</span>, r.Header)</span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> r.Header {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s:%s\n"</span>, key, r.Header[key])</span><br><span class="line">    }</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取Accept-Language的值"</span>, r.Header[<span class="string">"Accept-Language"</span>])</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中Accept-Encoding的信息是："</span>, r.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中Accept-Encoding的属性值是："</span>, r.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/geturl"</span>, ServeHTTP)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/4.png" alt="description"></p>
<p>把空格编码成%20，也就是%+2位十六进制数</p>
<p><img src="./go%E7%9A%84http/5.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseQuery parses the URL-encoded query string and returns</span></span><br><span class="line"><span class="comment">// a map listing the values specified for each key.</span></span><br><span class="line"><span class="comment">// ParseQuery always returns a non-nil map containing all the</span></span><br><span class="line"><span class="comment">// valid query parameters found; err describes the first decoding error</span></span><br><span class="line"><span class="comment">// encountered, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Query is expected to be a list of key=value settings separated by</span></span><br><span class="line"><span class="comment">// ampersands or semicolons. A setting without an equals sign is</span></span><br><span class="line"><span class="comment">// interpreted as a key set to an empty value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseQuery</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(Values, error)</span></span> {</span><br><span class="line">    m := <span class="built_in">make</span>(Values)</span><br><span class="line">    err := parseQuery(m, query)</span><br><span class="line">    <span class="keyword">return</span> m, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key.</span></span><br><span class="line"><span class="comment">// If there are no values associated with the key, Get returns</span></span><br><span class="line"><span class="comment">// the empty string. To access multiple values, use the map</span></span><br><span class="line"><span class="comment">// directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    vs := v[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vs) == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Query parses RawQuery and returns the corresponding values.</span></span><br><span class="line"><span class="comment">// It silently discards malformed value pairs.</span></span><br><span class="line"><span class="comment">// To check errors use ParseQuery.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *URL)</span> <span class="title">Query</span><span class="params">()</span> <span class="title">Values</span></span> {</span><br><span class="line">    v, _ := ParseQuery(u.RawQuery)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryParams</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    values := r.URL.Query()</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"query is %v\n"</span>, values)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/url/query"</span>, queryParams)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/25.png" alt="description"></p>
<p>http包建立Web服务器</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form {</span><br><span class="line">        fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">    }</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello 全栈编程@luboke.com !"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这个代码，我们build之后，然后执行web.exe,这个时候其实已经在9090端口监听http链接请求了。</p>
<p>在浏览器输入<a target="_blank" rel="noopener" href="http://localhost:9090/">http://localhost:9090</a></p>
<p><img src="./go%E7%9A%84http/6.png" alt="description"><br><img src="./go%E7%9A%84http/7.png" alt="description"></p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map<span class="comment">[]</span></span><br><span class="line">path /</span><br><span class="line">scheme </span><br><span class="line"><span class="comment">[]</span></span><br><span class="line">map<span class="comment">[]</span></span><br><span class="line">path /favicon.ico</span><br><span class="line">scheme </span><br><span class="line"><span class="comment">[]</span></span><br></pre></td></tr></tbody></table></figure>


<p>换一个地址试试：<a target="_blank" rel="noopener" href="http://localhost:9090/?url_long=111&amp;url_long=222">http://localhost:9090/?url_long=111&amp;url_long=222</a></p>
<p>在服务器端输出的信息如下：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">map[url_long</span>:<span class="string">[111 222]]</span></span><br><span class="line"><span class="attr">path</span> <span class="string">/</span></span><br><span class="line"><span class="attr">scheme</span> <span class="string"></span></span><br><span class="line"><span class="meta">[111</span> <span class="string">222]</span></span><br><span class="line"><span class="attr">key</span>: <span class="string">url_long</span></span><br><span class="line"><span class="attr">val</span>: <span class="string">111222</span></span><br><span class="line"><span class="attr">map[]</span></span><br><span class="line"><span class="attr">path</span> <span class="string">/favicon.ico</span></span><br><span class="line"><span class="attr">scheme</span> <span class="string"></span></span><br><span class="line"><span class="attr">[]</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="获取请求体中的信息"><a href="#获取请求体中的信息" class="headerlink" title="获取请求体中的信息"></a>获取请求体中的信息</h4><p>请求和响应的主体都是有 Request 结构中的 Body 字段表示，这个字段的类型是 io.ReadCloser 接口，该接口包含了 Reader 接口和 Closer 接口，<br>Reader 接口拥有 Read 方法，<br>Closer 接口拥有 Close 方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadCloser is the interface that groups the basic Read and Close methods.</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> {</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="comment">// Reader接口用于包装基本的读取方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read reads up to len(p) bytes into p.</span></span><br><span class="line"><span class="comment">// Read方法读取len(p)字节数据写入p。</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered.</span></span><br><span class="line"><span class="comment">// 它返回写入的字节数和遇到的任何错误。</span></span><br><span class="line"><span class="comment">// Even if Read returns n &lt; len(p), it may use all of p as scratch space during the call.</span></span><br><span class="line"><span class="comment">// 即使Read方法返回值 n &lt; len(p)，本方法在被调用时仍可能使用p的全部长度作为暂存空间。</span></span><br><span class="line"><span class="comment">// If some data is available but not len(p) bytes, Read conventionally</span></span><br><span class="line"><span class="comment">// returns what is available instead of waiting for more.</span></span><br><span class="line"><span class="comment">// 如果有部分可用数据，但不够len(p)字节，Read按惯例会返回可以读取到的数据，而不是等待更多数据。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When Read encounters an error or end-of-file condition after</span></span><br><span class="line"><span class="comment">// successfully reading n &gt; 0 bytes, it returns the number of</span></span><br><span class="line"><span class="comment">// bytes read. It may return the (non-nil) error from the same call</span></span><br><span class="line"><span class="comment">// or return the error (and n == 0) from a subsequent call.</span></span><br><span class="line"><span class="comment">// An instance of this general case is that a Reader returning</span></span><br><span class="line"><span class="comment">// a non-zero number of bytes at the end of the input stream may</span></span><br><span class="line"><span class="comment">// return either err == EOF or err == nil. The next Read should</span></span><br><span class="line"><span class="comment">// return 0, EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers should always process the n &gt; 0 bytes returned before</span></span><br><span class="line"><span class="comment">// considering the error err. Doing so correctly handles I/O errors</span></span><br><span class="line"><span class="comment">// that happen after reading some bytes and also both of the</span></span><br><span class="line"><span class="comment">// allowed EOF behaviors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations of Read are discouraged from returning a</span></span><br><span class="line"><span class="comment">// zero byte count with a nil error, except when len(p) == 0.</span></span><br><span class="line"><span class="comment">// Callers should treat a return of 0 and nil as indicating that</span></span><br><span class="line"><span class="comment">// nothing happened; in particular it does not indicate EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="comment">// Writer接口用于包装基本的写入方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line"><span class="comment">// Write方法len(p) 字节数据从p写入底层的数据流。</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line"><span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line"><span class="comment">// 它会返回写入的字节数(0 &lt;= n &lt;= len(p))和遇到的任何导致写入提取结束的错误。</span></span><br><span class="line"><span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line"><span class="comment">// Write必须返回非nil的错误，如果它返回的 n &lt; len(p)。</span></span><br><span class="line"><span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line"><span class="comment">// Write不能修改切片p中的数据，即使临时修改也不行。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> {</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closer is the interface that wraps the basic Close method.</span></span><br><span class="line"><span class="comment">// Closer接口用于包装基本的关闭方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The behavior of Close after the first call is undefined.</span></span><br><span class="line"><span class="comment">// 在第一次调用之后再次被调用时，Close方法的的行为是未定义的。</span></span><br><span class="line"><span class="comment">// Specific implementations may document their own behavior.</span></span><br><span class="line"><span class="comment">// 某些实现可能会说明他们自己的行为。</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHTTPBody</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="built_in">len</span> := r.ContentLength</span><br><span class="line">    body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>)</span><br><span class="line">    r.Body.Read(body)</span><br><span class="line">    fmt.Fprintln(w, body, <span class="keyword">string</span>(body))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/getbody"</span>, GetHTTPBody)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -id <span class="string">"action=search&amp;book=the way to go"</span> localhost:8080/getbody</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 22 Jul 2021 03:41:53 GMT</span><br><span class="line">Content-Length: 151</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">[97 99 116 105 111 110 61 115 101 97 114 99 104 38 98 111 111 107 61 116 104 101 32 119 97 121 32 116 111 32 103 111]</span><br><span class="line">action=search&amp;book=the way to go</span><br></pre></td></tr></tbody></table></figure>

<p>由于 GET 请求没有请求体，所以我们需要在 HTML 页面中创建一个 form 表单，通过指定 method=”post”来发送一个 POST 请求</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4?username=胡歌&amp;pwd=huge"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">"波哥"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密 码 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">value</span>=<span class="string">"666666"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/8.png" alt="description"><br><img src="./go%E7%9A%84http/9.png" alt="description"></p>
<p>通过 net/http 库中的 Request 结构的字段以及方法获取请求 URL 后面 的请求参数以及 form 表单中提交的请求参数</p>
<p>可以通过Request结构体的 Form 和 PostForm 字段获取请求参数</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Form contains the parsed form data, including both the URL</span></span><br><span class="line">    <span class="comment">// field's query parameters and the PATCH, POST, or PUT form data.</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// Values将建映射到值的列表。</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// 它一般用于查询的参数和表单的属性。</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="comment">// 不同于http.Header这个字典类型，Values的键是大小写敏感的。</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseForm populates r.Form and r.PostForm.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For all requests, ParseForm parses the raw query from the URL and updates r.Form.</span></span><br><span class="line"><span class="comment">// ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For POST, PUT, and PATCH requests, it also reads the request body, parses it</span></span><br><span class="line"><span class="comment">// as a form and puts the results into both r.PostForm and r.Form.</span></span><br><span class="line"><span class="comment">//对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。</span></span><br><span class="line"><span class="comment">// Request body parameters take precedence over URL query string values in r.Form.</span></span><br><span class="line"><span class="comment">//解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request Body's size has not already been limited by MaxBytesReader,</span></span><br><span class="line"><span class="comment">// the size is capped at 10MB.</span></span><br><span class="line"><span class="comment">// 如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For other HTTP methods, or when the Content-Type is not</span></span><br><span class="line"><span class="comment">// application/x-www-form-urlencoded, the request Body is not read, and</span></span><br><span class="line"><span class="comment">// r.PostForm is initialized to a non-nil, empty value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ParseMultipartForm calls ParseForm automatically.</span></span><br><span class="line"><span class="comment">// ParseMultipartForm会自动调用ParseForm。</span></span><br><span class="line"><span class="comment">// ParseForm is idempotent.</span></span><br><span class="line"><span class="comment">// 重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseForm</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">"POST"</span> || r.Method == <span class="string">"PUT"</span> || r.Method == <span class="string">"PATCH"</span> {</span><br><span class="line">            r.PostForm, err = parsePostForm(r)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">            r.PostForm = <span class="built_in">make</span>(url.Values)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.PostForm) &gt; <span class="number">0</span> {</span><br><span class="line">            r.Form = <span class="built_in">make</span>(url.Values)</span><br><span class="line">            copyValues(r.Form, r.PostForm)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">var</span> newValues url.Values</span><br><span class="line">        <span class="keyword">if</span> r.URL != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">var</span> e error</span><br><span class="line">            newValues, e = url.ParseQuery(r.URL.RawQuery)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">                err = e</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> newValues == <span class="literal">nil</span> {</span><br><span class="line">            newValues = <span class="built_in">make</span>(url.Values)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">            r.Form = newValues</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            copyValues(r.Form, newValues)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>除了 Body，我们还可能传递参数的地方是 Query<br>• 也就是<a target="_blank" rel="noopener" href="http://xxx.com/your/path?id=123&amp;b=456">http://xxx.com/your/path?id=123&amp;b=456</a><br>• 所有的值都被解释为字符串，所以需要自己解析为数字等</p>
<p>如果没有调用ParseForm方法，下面无法获取表单的数据<br>如果form表单的action属性的URL地址中也有与form表单参数名相同的请求参数，<br>那么参数值都可以得到，并且form表单中的参数值在URL的参数值的前面</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormAndPostForm</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"before parse r.Form --&gt; %v\n"</span>, r.Form)</span><br><span class="line">    <span class="comment">// 解析url传递的参数，对于POST则解析响应包的主体（request body）</span></span><br><span class="line">    err := r.ParseForm()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"parse form error %v\n"</span>, r.Form)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.PostForm --&gt;"</span>, r.PostForm)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.Form --&gt;"</span>, r.Form)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/getBody4"</span>, FormAndPostForm)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>点击提交跳转到指定url</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/10.png" alt="description"><br><img src="./go%E7%9A%84http/11.png" alt="description"></p>
<p>如果对 form 表单做一些修改</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">"波哥"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密 码 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">value</span>=<span class="string">"666666"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/12.png" alt="description"></p>
<p>在 action 属性的 URL 后面也添加相同的请求参数</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4?username=胡歌&amp;pwd=huge"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">"波哥"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密 码 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">value</span>=<span class="string">"666666"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/13.png" alt="description"></p>
<p>表单中的请求参数 username 和 URL 中的请求参数 username 都获取到了，而且表单中的请求参数的值排在 URL 请求参 数值的前面</p>
<p>如果此时我们只想获取表单中的请求参数该怎么办呢？那就需要使 用 Request 结构中的 PostForm 字段</p>
<p>Request本身也提供了FormValue()函数来获取用户提交的参数。如r.Form[“username”]也可写成r.FormValue(“username”)。</p>
<p>r.Form里面包含了所有请求的参数，比如URL中query-string、POST的数据、PUT的数据，所以当你在URL中的query-string字段和POST冲突时，会保存成一个slice，里面存储了多个值，Go官方文档中说在接下来的版本里面将会把POST、GET这些数据分离开来。</p>
<p>FormValue方法和PostFormValue方法直接获取请求参数，获取请求参数之前会自动调用ParseForm方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FormValue returns the first value for the named component of the query.</span></span><br><span class="line"><span class="comment">// FormValue返回key为键查询r.Form字段得到结果[]string切片的同名参数中第一个值。</span></span><br><span class="line"><span class="comment">// POST and PUT body parameters take precedence over URL query string values.</span></span><br><span class="line"><span class="comment">// POST和PUT主体中的同名参数优先于URL查询字符串。</span></span><br><span class="line"><span class="comment">// FormValue calls ParseMultipartForm and ParseForm if necessary and ignores</span></span><br><span class="line"><span class="comment">// any errors returned by these functions.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 该方法调用之前 会自动调用 ParseMultipartForm 和 ParseForm 方法对表单进行解析</span></span><br><span class="line"><span class="comment">// If key is not present, FormValue returns the empty string.</span></span><br><span class="line"><span class="comment">// 若参数不存在则返回空字符串。</span></span><br><span class="line"><span class="comment">// To access multiple values of the same key, call ParseForm and</span></span><br><span class="line"><span class="comment">// then inspect Request.Form directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> vs := r.Form[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostFormValue returns the first value for the named component of the POST,</span></span><br><span class="line"><span class="comment">// PATCH, or PUT request body. URL query parameters are ignored.</span></span><br><span class="line"><span class="comment">// PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。</span></span><br><span class="line"><span class="comment">// PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores</span></span><br><span class="line"><span class="comment">// any errors returned by these functions.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 该方法调用之前会自动调用 ParseMultipartForm 和 ParseForm 方法对表单进行解析</span></span><br><span class="line"><span class="comment">// If key is not present, PostFormValue returns the empty string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">PostFormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> vs := r.PostForm[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/formpostvalue"</span>, FormPostValue)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/formpostvalue"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/16.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/formpostvalue"</span>, FormPostValue)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/17.png" alt="description"></p>
<p>要使表单能够上传文件，首先第一步就是要添加form的enctype属性，enctype属性有如下三种情况:</p>
<p><code>application/x-www-form-urlencoded</code> 表示在发送前编码所有字符（默认）<br><code>multipart/form-data</code> 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。<br><code>text/plain</code> 空格转换为 “+” 加号，但不对特殊字符编码。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/formpostvalue"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As of Go 1.16, this function simply calls io.ReadAll.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> io.ReadAll(r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line">    f, _, err := r.FormFile(<span class="string">"photo"</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">        dataFromFile, err := ioutil.ReadAll(f)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">            fmt.Fprintf(w, <span class="string">"%s\n"</span>, <span class="keyword">string</span>(dataFromFile))</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Fprintf(w, <span class="string">"ioutil.ReadAll(f):%s\n"</span>, err.Error())</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/18.png" alt="description"><br><img src="./go%E7%9A%84http/19.png" alt="description"></p>
<p>PostForm 字段只支持 application/x-www-form-urlencoded 编码，如果 form 表单的 enctype 属性值为 <code>multipart/form-data</code>，那么使用 PostForm 字段 无法获取表单中的数据，<br>为了取得 <code>multipart/form-data</code> 编码的表单数据，我们需要用到 Request 结构的 <code>ParseMultipartForm</code> 方法和 <code>MultipartForm</code> 字段</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseMultipartForm parses a request body as multipart/form-data.</span></span><br><span class="line"><span class="comment">// ParseMultipartForm将请求的主体作为multipart/form-data解析。</span></span><br><span class="line"><span class="comment">// The whole request body is parsed and up to a total of maxMemory bytes of</span></span><br><span class="line"><span class="comment">// its file parts are stored in memory, with the remainder stored on</span></span><br><span class="line"><span class="comment">// disk in temporary files.</span></span><br><span class="line"><span class="comment">// 请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。</span></span><br><span class="line"><span class="comment">// ParseMultipartForm calls ParseForm if necessary.</span></span><br><span class="line"><span class="comment">// 如果必要，ParseMultipartForm会自行调用ParseForm。</span></span><br><span class="line"><span class="comment">// After one call to ParseMultipartForm, subsequent calls have no effect.</span></span><br><span class="line"><span class="comment">// 重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseMultipartForm</span><span class="params">(maxMemory <span class="keyword">int64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == multipartByReader {</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"http: multipart handled by MultipartReader"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        err := r.ParseForm()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mr, err := r.multipartReader(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    f, err := mr.ReadForm(maxMemory)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        r.PostForm = <span class="built_in">make</span>(url.Values)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> f.Value {</span><br><span class="line">        r.Form[k] = <span class="built_in">append</span>(r.Form[k], v...)</span><br><span class="line">        <span class="comment">// r.PostForm should also be populated. See Issue 9305.</span></span><br><span class="line">        r.PostForm[k] = <span class="built_in">append</span>(r.PostForm[k], v...)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r.MultipartForm = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileHeader describes a file part of a multipart request.</span></span><br><span class="line"><span class="comment">// FileHeader描述一个multipart请求的（一个）文件记录的信息。</span></span><br><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> {</span><br><span class="line">    Filename <span class="keyword">string</span></span><br><span class="line">    Header   textproto.MIMEHeader</span><br><span class="line">    Size     <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields 内含隐藏或非导出字段</span></span><br><span class="line">    content []<span class="keyword">byte</span></span><br><span class="line">    tmpfile <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open opens and returns the FileHeader's associated File.</span></span><br><span class="line"><span class="comment">// Open方法打开并返回其关联的文件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fh *FileHeader)</span> <span class="title">Open</span><span class="params">()</span> <span class="params">(File, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> b := fh.content; b != <span class="literal">nil</span> {</span><br><span class="line">        r := io.NewSectionReader(bytes.NewReader(b), <span class="number">0</span>, <span class="keyword">int64</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">        <span class="keyword">return</span> sectionReadCloser{r}, <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> os.Open(fh.tmpfile)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiPartForm</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 解析表单</span></span><br><span class="line">    r.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    fileHeader := r.MultipartForm.File[<span class="string">"photo"</span>][<span class="number">0</span>]</span><br><span class="line">    f, err := fileHeader.Open()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintln(w, <span class="string">"fileHeader.Open() --&gt;"</span>, err.Error())</span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//dataFromFile, err := ioutil.ReadAll(f)</span></span><br><span class="line">        <span class="comment">//if err != nil {</span></span><br><span class="line">        <span class="comment">//    fmt.Fprintf(w, "%s\n", dataFromFile)</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//// 获取请求参数</span></span><br><span class="line">        <span class="comment">//fmt.Fprintln(w, "r.MultipartForm --&gt;", r.MultipartForm)</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        dataFromFile, err := ioutil.ReadAll(f)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// 浏览器能打开的则直接显示，比如txt</span></span><br><span class="line">            <span class="comment">// 浏览器无法打开的则下载</span></span><br><span class="line">            fmt.Fprintf(w, <span class="string">"%s\n"</span>, <span class="keyword">string</span>(dataFromFile))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.MultipartForm --&gt;"</span>, r.MultipartForm)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/multipartform"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/15.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取被上传的文件，但是只能处理上传一个文件的情况。</span></span><br><span class="line"><span class="comment">// FormFile returns the first file for the provided form key.</span></span><br><span class="line"><span class="comment">// FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。</span></span><br><span class="line"><span class="comment">// FormFile calls ParseMultipartForm and ParseForm if necessary.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 查询失败会返回ErrMissingFile错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormFile</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(multipart.File, *multipart.FileHeader, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == multipartByReader {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"http: multipart handled by MultipartReader"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == <span class="literal">nil</span> {</span><br><span class="line">        err := r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm != <span class="literal">nil</span> &amp;&amp; r.MultipartForm.File != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> fhs := r.MultipartForm.File[key]; <span class="built_in">len</span>(fhs) &gt; <span class="number">0</span> {</span><br><span class="line">            f, err := fhs[<span class="number">0</span>].Open()</span><br><span class="line">            <span class="keyword">return</span> f, fhs[<span class="number">0</span>], err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ErrMissingFile</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenFile is the generalized open call; most users will use Open</span></span><br><span class="line"><span class="comment">// or Create instead. It opens the named file with specified flag</span></span><br><span class="line"><span class="comment">// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag</span></span><br><span class="line"><span class="comment">// is passed, it is created with mode perm (before umask). If successful,</span></span><br><span class="line"><span class="comment">// methods on the returned File can be used for I/O.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> {</span><br><span class="line">    testlog.Open(name)</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A FileMode represents a file's mode and permission bits.</span></span><br><span class="line"><span class="comment">// The bits have the same definition on all systems, so that</span></span><br><span class="line"><span class="comment">// information about files can be moved from one system</span></span><br><span class="line"><span class="comment">// to another portably. Not all bits apply to all systems.</span></span><br><span class="line"><span class="comment">// The only required bit is ModeDir for directories.</span></span><br><span class="line"><span class="keyword">type</span> FileMode = fs.FileMode</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line"></span><br><span class="line">    f, fh, err := r.FormFile(<span class="string">"photo"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将文件上传到某个文件夹下面，要有名称</span></span><br><span class="line">    <span class="comment">// 0666 当前文件的所属组有读写权限</span></span><br><span class="line">    _file, err := os.OpenFile(<span class="string">"./"</span>+fh.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"os.OpenFile:%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> _file.Close()</span><br><span class="line">    <span class="comment">// 将获取的文件拷贝到指定的文件夹下面</span></span><br><span class="line">    copybyte, err := io.Copy(_file, f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"io.Copy:%s\n"</span>, err.Error())</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Copy byte:%d\n"</span>, copybyte)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/20.png" alt="description"></p>
<p>上传文件主要三步处理：</p>
<p>表单中增加enctype=”multipart/form-data”<br>服务端处理文件上传我们需要调用r.ParseMultipartForm，把上传的文件存储在内存和临时文件中<br>里面的参数表示maxMemory最大字节，调用ParseMultipartForm之后，上传的文件存储在maxMemory大小的内存里面，如果文件大小超过了maxMemory，那么剩下的部分将存储在系统的临时文件中。</p>
<p>使用r.FormFile获取文件句柄，然后对文件进行存储等处理。实例中使用了io.Copy来存储文件。</p>
<p>获取其他非文件字段信息的时候就不需要调用r.ParseForm，因为在需要的时候Go自动会去调用。而且ParseMultipartForm调用一次之后，后面再次调用不会再有效果。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy copies from src to dst until either EOF is reached</span></span><br><span class="line"><span class="comment">// on src or an error occurs. It returns the number of bytes</span></span><br><span class="line"><span class="comment">// copied and the first error encountered while copying, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A successful Copy returns err == nil, not err == EOF.</span></span><br><span class="line"><span class="comment">// Because Copy is defined to read from src until EOF, it does</span></span><br><span class="line"><span class="comment">// not treat an EOF from Read as an error to be reported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If src implements the WriterTo interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling src.WriteTo(dst).</span></span><br><span class="line"><span class="comment">// Otherwise, if dst implements the ReaderFrom interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling dst.ReadFrom(src).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>通过 Server 结构对服务器进行更详细的配置<br>Server结构体也定义了实现http的相关方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDefinitionMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyDefinitionMux)</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello 我是波哥,go语言体系课@luboke.com!"</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyDefinitionMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"测试通过 Server 结构详细配置服务器"</span>)</span><br><span class="line">    <span class="comment">//h.sayhelloName(w,r)</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    myDefinitionMux := MyDefinitionMux{}</span><br><span class="line">    <span class="comment">//对net/http包中 Server 结构体设置</span></span><br><span class="line">    server := http.Server{</span><br><span class="line">        Addr: <span class="string">":8080"</span>,</span><br><span class="line">        <span class="comment">//自定义handle</span></span><br><span class="line">        Handler:     &amp;myDefinitionMux,</span><br><span class="line">        ReadTimeout: <span class="number">2</span> * time.Second,</span><br><span class="line">    }</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A ResponseWriter interface is used by an HTTP handler to</span></span><br><span class="line"><span class="comment">// construct an HTTP response.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A ResponseWriter may not be used after the Handler.ServeHTTP method</span></span><br><span class="line"><span class="comment">// has returned.</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">// Header returns the header map that will be sent by</span></span><br><span class="line">    <span class="comment">// WriteHeader. The Header map also is the mechanism with which</span></span><br><span class="line">    <span class="comment">// Handlers can set HTTP trailers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Changing the header map after a call to WriteHeader (or</span></span><br><span class="line">    <span class="comment">// Write) has no effect unless the modified headers are</span></span><br><span class="line">    <span class="comment">// trailers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// There are two ways to set Trailers. The preferred way is to</span></span><br><span class="line">    <span class="comment">// predeclare in the headers which trailers you will later</span></span><br><span class="line">    <span class="comment">// send by setting the "Trailer" header to the names of the</span></span><br><span class="line">    <span class="comment">// trailer keys which will come later. In this case, those</span></span><br><span class="line">    <span class="comment">// keys of the Header map are treated as if they were</span></span><br><span class="line">    <span class="comment">// trailers. See the example. The second way, for trailer</span></span><br><span class="line">    <span class="comment">// keys not known to the Handler until after the first Write,</span></span><br><span class="line">    <span class="comment">// is to prefix the Header map keys with the TrailerPrefix</span></span><br><span class="line">    <span class="comment">// constant value. See TrailerPrefix.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To suppress automatic response headers (such as "Date"), set</span></span><br><span class="line">    <span class="comment">// their value to nil.</span></span><br><span class="line">    Header() Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write writes the data to the connection as part of an HTTP reply.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If WriteHeader has not yet been called, Write calls</span></span><br><span class="line">    <span class="comment">// WriteHeader(http.StatusOK) before writing the data. If the Header</span></span><br><span class="line">    <span class="comment">// does not contain a Content-Type line, Write adds a Content-Type set</span></span><br><span class="line">    <span class="comment">// to the result of passing the initial 512 bytes of written data to</span></span><br><span class="line">    <span class="comment">// DetectContentType. Additionally, if the total size of all written</span></span><br><span class="line">    <span class="comment">// data is under a few KB and there are no Flush calls, the</span></span><br><span class="line">    <span class="comment">// Content-Length header is added automatically.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Depending on the HTTP protocol version and the client, calling</span></span><br><span class="line">    <span class="comment">// Write or WriteHeader may prevent future reads on the</span></span><br><span class="line">    <span class="comment">// Request.Body. For HTTP/1.x requests, handlers should read any</span></span><br><span class="line">    <span class="comment">// needed request body data before writing the response. Once the</span></span><br><span class="line">    <span class="comment">// headers have been flushed (due to either an explicit Flusher.Flush</span></span><br><span class="line">    <span class="comment">// call or writing enough data to trigger a flush), the request body</span></span><br><span class="line">    <span class="comment">// may be unavailable. For HTTP/2 requests, the Go HTTP server permits</span></span><br><span class="line">    <span class="comment">// handlers to continue to read the request body while concurrently</span></span><br><span class="line">    <span class="comment">// writing the response. However, such behavior may not be supported</span></span><br><span class="line">    <span class="comment">// by all HTTP/2 clients. Handlers should read before writing if</span></span><br><span class="line">    <span class="comment">// possible to maximize compatibility.</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteHeader sends an HTTP response header with the provided</span></span><br><span class="line">    <span class="comment">// status code.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If WriteHeader is not called explicitly, the first call to Write</span></span><br><span class="line">    <span class="comment">// will trigger an implicit WriteHeader(http.StatusOK).</span></span><br><span class="line">    <span class="comment">// Thus explicit calls to WriteHeader are mainly used to</span></span><br><span class="line">    <span class="comment">// send error codes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The provided code must be a valid HTTP 1xx-5xx status code.</span></span><br><span class="line">    <span class="comment">// Only one header may be written. Go does not currently</span></span><br><span class="line">    <span class="comment">// support sending user-defined 1xx informational headers,</span></span><br><span class="line">    <span class="comment">// with the exception of 100-continue response header that the</span></span><br><span class="line">    <span class="comment">// Server sends automatically when the Request.Body is read.</span></span><br><span class="line">    WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResponseData</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">//w.Write([]byte("向客户端响应字符串"))</span></span><br><span class="line">    <span class="comment">//    html := `</span></span><br><span class="line">    <span class="comment">//&lt;!DOCTYPE html&gt;</span></span><br><span class="line">    <span class="comment">//&lt;html lang="en"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;head&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;title&gt;Title&lt;/title&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/head&gt;</span></span><br><span class="line">    <span class="comment">//&lt;body&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/getBody4" method="POST"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/getBody4?username=胡歌&amp;pwd=huge" method="POST"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/multipartform" method="POST" enctype="multipart/form-data"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;form action="http://localhost:8080/formpostvalue" method="POST" enctype="multipart/form-data"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/formpostvalue" method="POST" enctype="application/x-www-form-urlencoded"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//    用户名： &lt;input type="text" name="username"</span></span><br><span class="line">    <span class="comment">//                value="波哥"&gt;&lt;br/&gt;</span></span><br><span class="line">    <span class="comment">//    密 码 ： &lt;input type="password" name="password"</span></span><br><span class="line">    <span class="comment">//                 value="666666"&gt;&lt;br/&gt;</span></span><br><span class="line">    <span class="comment">//    文件：&lt;input type="file" name="photo"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--    文件：&lt;input type="file" name="photo" /&gt;&lt;br/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;input type="submit"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/form&gt;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&lt;/body&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/html&gt;</span></span><br><span class="line">    <span class="comment">//`</span></span><br><span class="line">    <span class="comment">//w.Write([]byte(html))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">        ID       <span class="keyword">int</span></span><br><span class="line">        Username <span class="keyword">string</span></span><br><span class="line">        Password <span class="keyword">string</span></span><br><span class="line">    }</span><br><span class="line">    user := &amp;User{</span><br><span class="line">        ID:       <span class="number">1</span>,</span><br><span class="line">        Username: <span class="string">"boge"</span>,</span><br><span class="line">        Password: <span class="string">"123456"</span>,</span><br><span class="line">    }</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">    _json, _ := json.Marshal(user)</span><br><span class="line">    w.Write(_json)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/responsedata"</span>, ResponseData)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/21.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Addr = <span class="string">":1210"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建路由器</span></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    <span class="comment">// 设置路由规则</span></span><br><span class="line">    mux.HandleFunc(<span class="string">"/bye"</span>, sayBye)</span><br><span class="line">    <span class="comment">// 创建服务器</span></span><br><span class="line">    server := &amp;http.Server{</span><br><span class="line">        Addr:         Addr,</span><br><span class="line">        WriteTimeout: time.Second * <span class="number">3</span>,</span><br><span class="line">        Handler:      mux,</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 监听端口并提供服务</span></span><br><span class="line">    log.Println(<span class="string">"Starting httpserver at "</span> + Addr)</span><br><span class="line">    log.Fatal(server.ListenAndServe())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayBye</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="comment">// 将bye强制转换成字节数组</span></span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"bye bye ,this is httpServer"</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\rose&gt;curl http://127.0.0.1:1210/bye</span><br><span class="line">bye bye ,this is httpServer</span><br><span class="line">C:\Users\rose&gt;curl -v "http://127.0.0.1:1210/bye"</span><br><span class="line">*   Trying 127.0.0.1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 127.0.0.1 (127.0.0.1) port 1210 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET /<span class="built_in">bye</span> HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: 127.0.0.1:1210</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.55.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Mon, 26 Jul 2021 09:20:45 GMT</span><br><span class="line">&lt; Content-Length: 27</span><br><span class="line">&lt; Content-Type: text/plain; charset=utf-8</span><br><span class="line">&lt;</span><br><span class="line">bye bye ,this is httpServer* Connection #0 to host 127.0.0.1 left intact</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/22.png" alt="description"></p>
<p>为什么需要客户端代码?<br>一个服务调用它下属的一个基础服务，用代码的形式调用而不是浏览器形式访问一个地址</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建连接池</span></span><br><span class="line">    transport := &amp;http.Transport{</span><br><span class="line">        DialContext: (&amp;net.Dialer{</span><br><span class="line">            Timeout:   <span class="number">30</span> * time.Second, <span class="comment">//连接超时，每个细节的</span></span><br><span class="line">            KeepAlive: <span class="number">30</span> * time.Second, <span class="comment">//探活时间，连接进行建立了，tcp自动发送探测报文的时间间隔</span></span><br><span class="line">        }).DialContext,</span><br><span class="line">        MaxIdleConns:          <span class="number">100</span>,              <span class="comment">//最大空闲连接</span></span><br><span class="line">        IdleConnTimeout:       <span class="number">90</span> * time.Second, <span class="comment">//空闲超时时间，如果超过空闲超时时间，这个连接会失效</span></span><br><span class="line">        TLSHandshakeTimeout:   <span class="number">10</span> * time.Second, <span class="comment">//tls握手超时时间</span></span><br><span class="line">        ExpectContinueTimeout: <span class="number">1</span> * time.Second,  <span class="comment">//100-continue状态码超时时间</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    client := &amp;http.Client{</span><br><span class="line">        Timeout:   time.Second * <span class="number">30</span>, <span class="comment">//请求超时时间，一次请求全局</span></span><br><span class="line">        Transport: transport, <span class="comment">// 绑定连接池</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 请求数据</span></span><br><span class="line">    resp, err := client.Get(<span class="string">"http://127.0.0.1:1210/bye"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="comment">// 读取内容</span></span><br><span class="line">    bds, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bds))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 客户端输出</span></span><br><span class="line">bye bye ,this is httpServer</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httptest"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    hf := HandlerFunc(HelloHandler)</span><br><span class="line"></span><br><span class="line">    resp := httptest.NewRecorder()</span><br><span class="line">    req := httptest.NewRequest(<span class="string">"GET"</span>, <span class="string">"/"</span>, bytes.NewBuffer([]<span class="keyword">byte</span>(<span class="string">"test"</span>)))</span><br><span class="line"></span><br><span class="line">    hf.ServeHTTP(resp, req)</span><br><span class="line"></span><br><span class="line">    bts, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bts)) <span class="comment">// Hello world</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloHandler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> {</span><br><span class="line">    res.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="客户端源码"><a href="#客户端源码" class="headerlink" title="客户端源码"></a>客户端源码</h2><p>主要结构体</p>
<ul>
<li><p>type Client struct {…}</p>
<ul>
<li>Transport RoundTripper</li>
<li>Timeout time.Duration</li>
</ul>
</li>
<li><p>type RoundTripper interface {…}</p>
<ul>
<li>RoundTrip(*Request)(*Response, error)</li>
</ul>
</li>
</ul>
<p>请求流程<br>func (c *Client) Get(url string) -&gt; c.Do(req) -&gt; c.do(req) -&gt; c.send(req, deadline) -&gt; c.send(req, c.transport(), deadline) -&gt; resp, err = rt.RoundTrip(req)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Client is a client connection to a checksum database.</span></span><br><span class="line"><span class="comment">// All the methods are safe for simultaneous use by multiple goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> {</span><br><span class="line">    ops ClientOps <span class="comment">// access to operations in the external world</span></span><br><span class="line"></span><br><span class="line">    didLookup <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// one-time initialized data</span></span><br><span class="line">    initOnce   sync.Once</span><br><span class="line">    initErr    error          <span class="comment">// init error, if any</span></span><br><span class="line">    name       <span class="keyword">string</span>         <span class="comment">// name of accepted verifier</span></span><br><span class="line">    verifiers  note.Verifiers <span class="comment">// accepted verifiers (just one, but Verifiers for note.Open)</span></span><br><span class="line">    tileReader tileReader</span><br><span class="line">    tileHeight <span class="keyword">int</span></span><br><span class="line">    nosumdb    <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    record    parCache <span class="comment">// cache of record lookup, keyed by path@vers</span></span><br><span class="line">    tileCache parCache <span class="comment">// cache of c.readTile, keyed by tile</span></span><br><span class="line"></span><br><span class="line">    latestMu  sync.Mutex</span><br><span class="line">    latest    tlog.Tree <span class="comment">// latest known tree head</span></span><br><span class="line">    latestMsg []<span class="keyword">byte</span>    <span class="comment">// encoded signed note for latest</span></span><br><span class="line"></span><br><span class="line">    tileSavedMu sync.Mutex</span><br><span class="line">    tileSaved   <span class="keyword">map</span>[tlog.Tile]<span class="keyword">bool</span> <span class="comment">// which tiles have been saved using c.ops.WriteCache already</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> transport <span class="keyword">struct</span> {</span><br><span class="line">    cert       *<span class="keyword">string</span></span><br><span class="line">    key        *<span class="keyword">string</span></span><br><span class="line">    ca         *<span class="keyword">string</span></span><br><span class="line">    caCertPool *x509.CertPool</span><br><span class="line">    certs      []tls.Certificate</span><br><span class="line">    initOnce   sync.Once</span><br><span class="line">    initErr    error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RoundTrip executes a single HTTP transaction, returning</span></span><br><span class="line"><span class="comment">// a Response for the provided Request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *transport)</span> <span class="title">RoundTrip</span><span class="params">(req *http.Request)</span> <span class="params">(*http.Response, error)</span></span> {</span><br><span class="line">    tr.initOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        tr.initErr = tr.initialize()</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">if</span> tr.initErr != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, tr.initErr</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tlsConfig := &amp;tls.Config{</span><br><span class="line">        RootCAs:      tr.caCertPool,</span><br><span class="line">        Certificates: tr.certs,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> req.URL.Scheme == <span class="string">"https+insecure"</span> {</span><br><span class="line">        <span class="comment">// Make shallow copy of request, and req.URL, so the request's URL can be</span></span><br><span class="line">        <span class="comment">// modified.</span></span><br><span class="line">        r := *req</span><br><span class="line">        *r.URL = *req.URL</span><br><span class="line">        req = &amp;r</span><br><span class="line">        tlsConfig.InsecureSkipVerify = <span class="literal">true</span></span><br><span class="line">        req.URL.Scheme = <span class="string">"https"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    transport := http.Transport{</span><br><span class="line">        Proxy:           http.ProxyFromEnvironment,</span><br><span class="line">        TLSClientConfig: tlsConfig,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transport.RoundTrip(req)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get issues a GET to the specified URL. If the response is one of the</span></span><br><span class="line"><span class="comment">// following redirect codes, Get follows the redirect after calling the</span></span><br><span class="line"><span class="comment">// Client's CheckRedirect function:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    301 (Moved Permanently)</span></span><br><span class="line"><span class="comment">//    302 (Found)</span></span><br><span class="line"><span class="comment">//    303 (See Other)</span></span><br><span class="line"><span class="comment">//    307 (Temporary Redirect)</span></span><br><span class="line"><span class="comment">//    308 (Permanent Redirect)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An error is returned if the Client's CheckRedirect function fails</span></span><br><span class="line"><span class="comment">// or if there was an HTTP protocol error. A non-2xx response doesn't</span></span><br><span class="line"><span class="comment">// cause an error. Any returned error will be of type *url.Error. The</span></span><br><span class="line"><span class="comment">// url.Error value's Timeout method will report true if the request</span></span><br><span class="line"><span class="comment">// timed out.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When err is nil, resp always contains a non-nil resp.Body.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To make a request with custom headers, use NewRequest and Client.Do.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span> {</span><br><span class="line">    req, err := NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c.Do(req)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do sends an HTTP request and returns an HTTP response, following</span></span><br><span class="line"><span class="comment">// policy (such as redirects, cookies, auth) as configured on the</span></span><br><span class="line"><span class="comment">// client.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An error is returned if caused by client policy (such as</span></span><br><span class="line"><span class="comment">// CheckRedirect), or failure to speak HTTP (such as a network</span></span><br><span class="line"><span class="comment">// connectivity problem). A non-2xx status code doesn't cause an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the returned error is nil, the Response will contain a non-nil</span></span><br><span class="line"><span class="comment">// Body which the user is expected to close. If the Body is not both</span></span><br><span class="line"><span class="comment">// read to EOF and closed, the Client's underlying RoundTripper</span></span><br><span class="line"><span class="comment">// (typically Transport) may not be able to re-use a persistent TCP</span></span><br><span class="line"><span class="comment">// connection to the server for a subsequent "keep-alive" request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The request Body, if non-nil, will be closed by the underlying</span></span><br><span class="line"><span class="comment">// Transport, even on errors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// On error, any Response can be ignored. A non-nil Response with a</span></span><br><span class="line"><span class="comment">// non-nil error only occurs when CheckRedirect fails, and even then</span></span><br><span class="line"><span class="comment">// the returned Response.Body is already closed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Generally Get, Post, or PostForm will be used instead of Do.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the server replies with a redirect, the Client first uses the</span></span><br><span class="line"><span class="comment">// CheckRedirect function to determine whether the redirect should be</span></span><br><span class="line"><span class="comment">// followed. If permitted, a 301, 302, or 303 redirect causes</span></span><br><span class="line"><span class="comment">// subsequent requests to use HTTP method GET</span></span><br><span class="line"><span class="comment">// (or HEAD if the original request was HEAD), with no body.</span></span><br><span class="line"><span class="comment">// A 307 or 308 redirect preserves the original HTTP method and body,</span></span><br><span class="line"><span class="comment">// provided that the Request.GetBody function is defined.</span></span><br><span class="line"><span class="comment">// The NewRequest function automatically sets GetBody for common</span></span><br><span class="line"><span class="comment">// standard library body types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Any returned error will be of type *url.Error. The url.Error</span></span><br><span class="line"><span class="comment">// value's Timeout method will report true if request timed out or was</span></span><br><span class="line"><span class="comment">// canceled.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> c.do(req)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span> <span class="params">(retres *Response, reterr error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> testHookClientDoResult != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { testHookClientDoResult(retres, reterr) }()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> req.URL == <span class="literal">nil</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;url.Error{</span><br><span class="line">            Op:  urlErrorOp(req.Method),</span><br><span class="line">            Err: errors.New(<span class="string">"http: nil Request.URL"</span>),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        deadline      = c.deadline()</span><br><span class="line">        reqs          []*Request</span><br><span class="line">        resp          *Response</span><br><span class="line">        copyHeaders   = c.makeHeadersCopier(req)</span><br><span class="line">        reqBodyClosed = <span class="literal">false</span> <span class="comment">// have we closed the current req.Body?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Redirect behavior:</span></span><br><span class="line">        redirectMethod <span class="keyword">string</span></span><br><span class="line">        includeBody    <span class="keyword">bool</span></span><br><span class="line">    )</span><br><span class="line">    uerr := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> {</span><br><span class="line">        <span class="comment">// the body may have been closed already by c.send()</span></span><br><span class="line">        <span class="keyword">if</span> !reqBodyClosed {</span><br><span class="line">            req.closeBody()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">var</span> urlStr <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> resp != <span class="literal">nil</span> &amp;&amp; resp.Request != <span class="literal">nil</span> {</span><br><span class="line">            urlStr = stripPassword(resp.Request.URL)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            urlStr = stripPassword(req.URL)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> &amp;url.Error{</span><br><span class="line">            Op:  urlErrorOp(reqs[<span class="number">0</span>].Method),</span><br><span class="line">            URL: urlStr,</span><br><span class="line">            Err: err,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// For all but the first request, create the next</span></span><br><span class="line">        <span class="comment">// request hop and replace req.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(reqs) &gt; <span class="number">0</span> {</span><br><span class="line">            loc := resp.Header.Get(<span class="string">"Location"</span>)</span><br><span class="line">            <span class="keyword">if</span> loc == <span class="string">""</span> {</span><br><span class="line">                resp.closeBody()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, uerr(fmt.Errorf(<span class="string">"%d response missing Location header"</span>, resp.StatusCode))</span><br><span class="line">            }</span><br><span class="line">            u, err := req.URL.Parse(loc)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                resp.closeBody()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, uerr(fmt.Errorf(<span class="string">"failed to parse Location header %q: %v"</span>, loc, err))</span><br><span class="line">            }</span><br><span class="line">            host := <span class="string">""</span></span><br><span class="line">            <span class="keyword">if</span> req.Host != <span class="string">""</span> &amp;&amp; req.Host != req.URL.Host {</span><br><span class="line">                <span class="comment">// If the caller specified a custom Host header and the</span></span><br><span class="line">                <span class="comment">// redirect location is relative, preserve the Host header</span></span><br><span class="line">                <span class="comment">// through the redirect. See issue #22233.</span></span><br><span class="line">                <span class="keyword">if</span> u, _ := url.Parse(loc); u != <span class="literal">nil</span> &amp;&amp; !u.IsAbs() {</span><br><span class="line">                    host = req.Host</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ireq := reqs[<span class="number">0</span>]</span><br><span class="line">            req = &amp;Request{</span><br><span class="line">                Method:   redirectMethod,</span><br><span class="line">                Response: resp,</span><br><span class="line">                URL:      u,</span><br><span class="line">                Header:   <span class="built_in">make</span>(Header),</span><br><span class="line">                Host:     host,</span><br><span class="line">                Cancel:   ireq.Cancel,</span><br><span class="line">                ctx:      ireq.ctx,</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> includeBody &amp;&amp; ireq.GetBody != <span class="literal">nil</span> {</span><br><span class="line">                req.Body, err = ireq.GetBody()</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                    resp.closeBody()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">                }</span><br><span class="line">                req.ContentLength = ireq.ContentLength</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Copy original headers before setting the Referer,</span></span><br><span class="line">            <span class="comment">// in case the user set Referer on their first request.</span></span><br><span class="line">            <span class="comment">// If they really want to override, they can do it in</span></span><br><span class="line">            <span class="comment">// their CheckRedirect func.</span></span><br><span class="line">            copyHeaders(req)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the Referer header from the most recent</span></span><br><span class="line">            <span class="comment">// request URL to the new one, if it's not https-&gt;http:</span></span><br><span class="line">            <span class="keyword">if</span> ref := refererForURL(reqs[<span class="built_in">len</span>(reqs)<span class="number">-1</span>].URL, req.URL); ref != <span class="string">""</span> {</span><br><span class="line">                req.Header.Set(<span class="string">"Referer"</span>, ref)</span><br><span class="line">            }</span><br><span class="line">            err = c.checkRedirect(req, reqs)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sentinel error to let users select the</span></span><br><span class="line">            <span class="comment">// previous response, without closing its</span></span><br><span class="line">            <span class="comment">// body. See Issue 10069.</span></span><br><span class="line">            <span class="keyword">if</span> err == ErrUseLastResponse {</span><br><span class="line">                <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the previous response's body. But</span></span><br><span class="line">            <span class="comment">// read at least some of the body so if it's</span></span><br><span class="line">            <span class="comment">// small the underlying TCP connection will be</span></span><br><span class="line">            <span class="comment">// re-used. No need to check for errors: if it</span></span><br><span class="line">            <span class="comment">// fails, the Transport won't reuse it anyway.</span></span><br><span class="line">            <span class="keyword">const</span> maxBodySlurpSize = <span class="number">2</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> resp.ContentLength == <span class="number">-1</span> || resp.ContentLength &lt;= maxBodySlurpSize {</span><br><span class="line">                io.CopyN(io.Discard, resp.Body, maxBodySlurpSize)</span><br><span class="line">            }</span><br><span class="line">            resp.Body.Close()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="comment">// Special case for Go 1 compatibility: return both the response</span></span><br><span class="line">                <span class="comment">// and an error if the CheckRedirect function failed.</span></span><br><span class="line">                <span class="comment">// See https://golang.org/issue/3795</span></span><br><span class="line">                <span class="comment">// The resp.Body has already been closed.</span></span><br><span class="line">                ue := uerr(err)</span><br><span class="line">                ue.(*url.Error).URL = loc</span><br><span class="line">                <span class="keyword">return</span> resp, ue</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        reqs = <span class="built_in">append</span>(reqs, req)</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        <span class="keyword">var</span> didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">        <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">            reqBodyClosed = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() {</span><br><span class="line">                err = &amp;httpError{</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> early in cycle: s/Client.Timeout exceeded/timeout or context cancellation/</span></span><br><span class="line">                    err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">                    timeout: <span class="literal">true</span>,</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">        redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> !shouldRedirect {</span><br><span class="line">            <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        req.closeBody()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) {</span><br><span class="line">            req.AddCookie(cookie)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> c.Jar != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> {</span><br><span class="line">            c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// send issues an HTTP request.</span></span><br><span class="line"><span class="comment">// Caller should close resp.Body when done reading from it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> {</span><br><span class="line">    req := ireq <span class="comment">// req is either the original request, or a modified fork</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rt == <span class="literal">nil</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: no Client.Transport or DefaultTransport"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> req.URL == <span class="literal">nil</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: nil Request.URL"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> req.RequestURI != <span class="string">""</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: Request.RequestURI can't be set in client requests"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forkReq forks req into a shallow clone of ireq the first</span></span><br><span class="line">    <span class="comment">// time it's called.</span></span><br><span class="line">    forkReq := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">if</span> ireq == req {</span><br><span class="line">            req = <span class="built_in">new</span>(Request)</span><br><span class="line">            *req = *ireq <span class="comment">// shallow clone</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most the callers of send (Get, Post, et al) don't need</span></span><br><span class="line">    <span class="comment">// Headers, leaving it uninitialized. We guarantee to the</span></span><br><span class="line">    <span class="comment">// Transport that this has been initialized, though.</span></span><br><span class="line">    <span class="keyword">if</span> req.Header == <span class="literal">nil</span> {</span><br><span class="line">        forkReq()</span><br><span class="line">        req.Header = <span class="built_in">make</span>(Header)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u := req.URL.User; u != <span class="literal">nil</span> &amp;&amp; req.Header.Get(<span class="string">"Authorization"</span>) == <span class="string">""</span> {</span><br><span class="line">        username := u.Username()</span><br><span class="line">        password, _ := u.Password()</span><br><span class="line">        forkReq()</span><br><span class="line">        req.Header = cloneOrMakeHeader(ireq.Header)</span><br><span class="line">        req.Header.Set(<span class="string">"Authorization"</span>, <span class="string">"Basic "</span>+basicAuth(username, password))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !deadline.IsZero() {</span><br><span class="line">        forkReq()</span><br><span class="line">    }</span><br><span class="line">    stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line"></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        stopTimer()</span><br><span class="line">        <span class="keyword">if</span> resp != <span class="literal">nil</span> {</span><br><span class="line">            log.Printf(<span class="string">"RoundTripper returned a response &amp; error; ignoring response"</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> tlsErr, ok := err.(tls.RecordHeaderError); ok {</span><br><span class="line">            <span class="comment">// If we get a bad TLS record header, check to see if the</span></span><br><span class="line">            <span class="comment">// response looks like HTTP and give a more helpful error.</span></span><br><span class="line">            <span class="comment">// See golang.org/issue/11111.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">string</span>(tlsErr.RecordHeader[:]) == <span class="string">"HTTP/"</span> {</span><br><span class="line">                err = errors.New(<span class="string">"http: server gave HTTP response to HTTPS client"</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> resp == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">"http: RoundTripper implementation (%T) returned a nil *Response with a nil error"</span>, rt)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> resp.Body == <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// The documentation on the Body field says “The http Client and Transport</span></span><br><span class="line">        <span class="comment">// guarantee that Body is always non-nil, even on responses without a body</span></span><br><span class="line">        <span class="comment">// or responses with a zero-length body.” Unfortunately, we didn't document</span></span><br><span class="line">        <span class="comment">// that same constraint for arbitrary RoundTripper implementations, and</span></span><br><span class="line">        <span class="comment">// RoundTripper implementations in the wild (mostly in tests) assume that</span></span><br><span class="line">        <span class="comment">// they can use a nil Body to mean an empty one (similar to Request.Body).</span></span><br><span class="line">        <span class="comment">// (See https://golang.org/issue/38095.)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If the ContentLength allows the Body to be empty, fill in an empty one</span></span><br><span class="line">        <span class="comment">// here to ensure that it is non-nil.</span></span><br><span class="line">        <span class="keyword">if</span> resp.ContentLength &gt; <span class="number">0</span> &amp;&amp; req.Method != <span class="string">"HEAD"</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">"http: RoundTripper implementation (%T) returned a *Response with content length %d but a nil Body"</span>, rt, resp.ContentLength)</span><br><span class="line">        }</span><br><span class="line">        resp.Body = io.NopCloser(strings.NewReader(<span class="string">""</span>))</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> !deadline.IsZero() {</span><br><span class="line">        resp.Body = &amp;cancelTimerBody{</span><br><span class="line">            stop:          stopTimer,</span><br><span class="line">            rc:            resp.Body,</span><br><span class="line">            reqDidTimeout: didTimeout,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoundTripper is an interface representing the ability to execute a</span></span><br><span class="line"><span class="comment">// single HTTP transaction, obtaining the Response for a given Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A RoundTripper must be safe for concurrent use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="comment">// 请求下游接口</span></span><br><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">// RoundTrip executes a single HTTP transaction, returning</span></span><br><span class="line">    <span class="comment">// a Response for the provided Request.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// RoundTrip should not attempt to interpret the response. In</span></span><br><span class="line">    <span class="comment">// particular, RoundTrip must return err == nil if it obtained</span></span><br><span class="line">    <span class="comment">// a response, regardless of the response's HTTP status code.</span></span><br><span class="line">    <span class="comment">// A non-nil err should be reserved for failure to obtain a</span></span><br><span class="line">    <span class="comment">// response. Similarly, RoundTrip should not attempt to</span></span><br><span class="line">    <span class="comment">// handle higher-level protocol details such as redirects,</span></span><br><span class="line">    <span class="comment">// authentication, or cookies.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// RoundTrip should not modify the request, except for</span></span><br><span class="line">    <span class="comment">// consuming and closing the Request's Body. RoundTrip may</span></span><br><span class="line">    <span class="comment">// read fields of the request in a separate goroutine. Callers</span></span><br><span class="line">    <span class="comment">// should not mutate or reuse the request until the Response's</span></span><br><span class="line">    <span class="comment">// Body has been closed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// RoundTrip must always close the body, including on errors,</span></span><br><span class="line">    <span class="comment">// but depending on the implementation may do so in a separate</span></span><br><span class="line">    <span class="comment">// goroutine even after RoundTrip returns. This means that</span></span><br><span class="line">    <span class="comment">// callers wanting to reuse the body for subsequent requests</span></span><br><span class="line">    <span class="comment">// must arrange to wait for the Close call before doing so.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The Request's URL and Header fields must be initialized.</span></span><br><span class="line">    RoundTrip(*Request) (*Response, error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Like the RoundTripper interface, the error types returned</span></span><br><span class="line"><span class="comment">// by RoundTrip are unspecified.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// roundTrip implements a RoundTripper over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> {</span><br><span class="line">    t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">    ctx := req.Context()</span><br><span class="line">    trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> req.URL == <span class="literal">nil</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: nil Request.URL"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> req.Header == <span class="literal">nil</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: nil Request.Header"</span>)</span><br><span class="line">    }</span><br><span class="line">    scheme := req.URL.Scheme</span><br><span class="line">    isHTTP := scheme == <span class="string">"http"</span> || scheme == <span class="string">"https"</span></span><br><span class="line">    <span class="keyword">if</span> isHTTP {</span><br><span class="line">        <span class="keyword">for</span> k, vv := <span class="keyword">range</span> req.Header {</span><br><span class="line">            <span class="keyword">if</span> !httpguts.ValidHeaderFieldName(k) {</span><br><span class="line">                req.closeBody()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid header field name %q"</span>, k)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> _, v := <span class="keyword">range</span> vv {</span><br><span class="line">                <span class="keyword">if</span> !httpguts.ValidHeaderFieldValue(v) {</span><br><span class="line">                    req.closeBody()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid header field value %q for key %v"</span>, v, k)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    origReq := req</span><br><span class="line">    cancelKey := cancelKey{origReq}</span><br><span class="line">    req = setupRewindBody(req)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altRT := t.alternateRoundTripper(req); altRT != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {</span><br><span class="line">            <span class="keyword">return</span> resp, err</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        req, err = rewindBody(req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> !isHTTP {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, badStringError(<span class="string">"unsupported protocol scheme"</span>, scheme)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> req.Method != <span class="string">""</span> &amp;&amp; !validMethod(req.Method) {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid method %q"</span>, req.Method)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> req.URL.Host == <span class="string">""</span> {</span><br><span class="line">        req.closeBody()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: no Host in request URL"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            req.closeBody()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// treq gets modified by roundTrip, so we need to recreate for each retry.</span></span><br><span class="line">        treq := &amp;transportRequest{Request: req, trace: trace, cancelKey: cancelKey}</span><br><span class="line">        cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            req.closeBody()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the cached or newly-created connection to either the</span></span><br><span class="line">        <span class="comment">// host (for http or https), the http proxy, or the http proxy</span></span><br><span class="line">        <span class="comment">// pre-CONNECTed to https server. In any case, we'll be ready</span></span><br><span class="line">        <span class="comment">// to send it requests.</span></span><br><span class="line">        pconn, err := t.getConn(treq, cm)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            t.setReqCanceler(cancelKey, <span class="literal">nil</span>)</span><br><span class="line">            req.closeBody()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> resp *Response</span><br><span class="line">        <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// HTTP/2 path.</span></span><br><span class="line">            t.setReqCanceler(cancelKey, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">            resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            resp, err = pconn.roundTrip(treq)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">            resp.Request = origReq</span><br><span class="line">            <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Failed. Clean up and determine whether to retry.</span></span><br><span class="line">        <span class="keyword">if</span> http2isNoCachedConnError(err) {</span><br><span class="line">            <span class="keyword">if</span> t.removeIdleConn(pconn) {</span><br><span class="line">                t.decConnsPerHost(pconn.cacheKey)</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> !pconn.shouldRetryRequest(req, err) {</span><br><span class="line">            <span class="comment">// Issue 16465: return underlying net.Conn.Read error from peek,</span></span><br><span class="line">            <span class="comment">// as we've historically done.</span></span><br><span class="line">            <span class="keyword">if</span> e, ok := err.(transportReadFromServerError); ok {</span><br><span class="line">                err = e.err</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">        testHookRoundTripRetried()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rewind the body if we're able to.</span></span><br><span class="line">        req, err = rewindBody(req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getConn dials and creates a new persistConn to the target as</span></span><br><span class="line"><span class="comment">// specified in the connectMethod. This includes doing a proxy CONNECT</span></span><br><span class="line"><span class="comment">// and/or setting up TLS.  If this doesn't return an error, the persistConn</span></span><br><span class="line"><span class="comment">// is ready to write requests to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(pc *persistConn, err error)</span></span> {</span><br><span class="line">    req := treq.Request</span><br><span class="line">    trace := treq.trace</span><br><span class="line">    ctx := req.Context()</span><br><span class="line">    <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> {</span><br><span class="line">        trace.GetConn(cm.addr())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    w := &amp;wantConn{</span><br><span class="line">        cm:         cm,</span><br><span class="line">        key:        cm.key(),</span><br><span class="line">        ctx:        ctx,</span><br><span class="line">        ready:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>),</span><br><span class="line">        beforeDial: testHookPrePendingDial,</span><br><span class="line">        afterDial:  testHookPostPendingDial,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            w.cancel(t, err)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for idle connection.</span></span><br><span class="line">    <span class="keyword">if</span> delivered := t.queueForIdleConn(w); delivered {</span><br><span class="line">        pc := w.pc</span><br><span class="line">        <span class="comment">// Trace only for HTTP/1.</span></span><br><span class="line">        <span class="comment">// HTTP/2 calls trace.GotConn itself.</span></span><br><span class="line">        <span class="keyword">if</span> pc.alt == <span class="literal">nil</span> &amp;&amp; trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> {</span><br><span class="line">            trace.GotConn(pc.gotIdleConnTrace(pc.idleAt))</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line">        <span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line">        <span class="comment">// we enter roundTrip</span></span><br><span class="line">        t.setReqCanceler(treq.cancelKey, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> {})</span><br><span class="line">        <span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    t.setReqCanceler(treq.cancelKey, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> { cancelc &lt;- err })</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for permission to dial.</span></span><br><span class="line">    t.queueForDial(w)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for completion or cancellation.</span></span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-w.ready:</span><br><span class="line">        <span class="comment">// Trace success but only for HTTP/1.</span></span><br><span class="line">        <span class="comment">// HTTP/2 calls trace.GotConn itself.</span></span><br><span class="line">        <span class="keyword">if</span> w.pc != <span class="literal">nil</span> &amp;&amp; w.pc.alt == <span class="literal">nil</span> &amp;&amp; trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> {</span><br><span class="line">            trace.GotConn(httptrace.GotConnInfo{Conn: w.pc.conn, Reused: w.pc.isReused()})</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> w.err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// If the request has been cancelled, that's probably</span></span><br><span class="line">            <span class="comment">// what caused w.err; if so, prefer to return the</span></span><br><span class="line">            <span class="comment">// cancellation error (see golang.org/issue/16049).</span></span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">            <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">            <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">                <span class="keyword">if</span> err == errRequestCanceled {</span><br><span class="line">                    err = errRequestCanceledConn</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// return below</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> w.pc, w.err</span><br><span class="line">    <span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line">    <span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">        <span class="keyword">if</span> err == errRequestCanceled {</span><br><span class="line">            err = errRequestCanceledConn</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transport is an implementation of RoundTripper that supports HTTP,</span></span><br><span class="line"><span class="comment">// HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// By default, Transport caches connections for future re-use.</span></span><br><span class="line"><span class="comment">// This may leave many open connections when accessing many hosts.</span></span><br><span class="line"><span class="comment">// This behavior can be managed using Transport's CloseIdleConnections method</span></span><br><span class="line"><span class="comment">// and the MaxIdleConnsPerHost and DisableKeepAlives fields.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Transports should be reused instead of created as needed.</span></span><br><span class="line"><span class="comment">// Transports are safe for concurrent use by multiple goroutines.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Transport is a low-level primitive for making HTTP and HTTPS requests.</span></span><br><span class="line"><span class="comment">// For high-level functionality, such as cookies and redirects, see Client.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2</span></span><br><span class="line"><span class="comment">// for HTTPS URLs, depending on whether the server supports HTTP/2,</span></span><br><span class="line"><span class="comment">// and how the Transport is configured. The DefaultTransport supports HTTP/2.</span></span><br><span class="line"><span class="comment">// To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2</span></span><br><span class="line"><span class="comment">// and call ConfigureTransport. See the package docs for more about HTTP/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Responses with status codes in the 1xx range are either handled</span></span><br><span class="line"><span class="comment">// automatically (100 expect-continue) or ignored. The one</span></span><br><span class="line"><span class="comment">// exception is HTTP status code 101 (Switching Protocols), which is</span></span><br><span class="line"><span class="comment">// considered a terminal status and returned by RoundTrip. To see the</span></span><br><span class="line"><span class="comment">// ignored 1xx responses, use the httptrace trace package's</span></span><br><span class="line"><span class="comment">// ClientTrace.Got1xxResponse.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Transport only retries a request upon encountering a network error</span></span><br><span class="line"><span class="comment">// if the request is idempotent and either has no body or has its</span></span><br><span class="line"><span class="comment">// Request.GetBody defined. HTTP requests are considered idempotent if</span></span><br><span class="line"><span class="comment">// they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their</span></span><br><span class="line"><span class="comment">// Header map contains an "Idempotency-Key" or "X-Idempotency-Key"</span></span><br><span class="line"><span class="comment">// entry. If the idempotency key value is a zero-length slice, the</span></span><br><span class="line"><span class="comment">// request is treated as idempotent but the header is not sent on the</span></span><br><span class="line"><span class="comment">// wire.</span></span><br><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> {</span><br><span class="line">    idleMu       sync.Mutex</span><br><span class="line">    closeIdle    <span class="keyword">bool</span>                                <span class="comment">// user has requested to close all idle conns 用户是否已关闭所有的空闲连接</span></span><br><span class="line">    idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end 保存从connect到persistConn的映射</span></span><br><span class="line">    idleConnWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue  <span class="comment">// waiting getConns</span></span><br><span class="line">    idleLRU      connLRU</span><br><span class="line"></span><br><span class="line">    reqMu       sync.Mutex</span><br><span class="line">    reqCanceler <span class="keyword">map</span>[cancelKey]<span class="function"><span class="keyword">func</span><span class="params">(error)</span></span></span><br><span class="line"></span><br><span class="line">    altMu    sync.Mutex   <span class="comment">// guards changing altProto only</span></span><br><span class="line">    altProto atomic.Value <span class="comment">// of nil or map[string]RoundTripper, key is URI scheme</span></span><br><span class="line"></span><br><span class="line">    connsPerHostMu   sync.Mutex</span><br><span class="line">    connsPerHost     <span class="keyword">map</span>[connectMethodKey]<span class="keyword">int</span></span><br><span class="line">    connsPerHostWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue <span class="comment">// waiting getConns</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proxy specifies a function to return a proxy for a given</span></span><br><span class="line">    <span class="comment">// Request. If the function returns a non-nil error, the</span></span><br><span class="line">    <span class="comment">// request is aborted with the provided error.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The proxy type is determined by the URL scheme. "http",</span></span><br><span class="line">    <span class="comment">// "https", and "socks5" are supported. If the scheme is empty,</span></span><br><span class="line">    <span class="comment">// "http" is assumed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If Proxy is nil or returns a nil *URL, no proxy is used.</span></span><br><span class="line">    Proxy <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DialContext specifies the dial function for creating unencrypted TCP connections.</span></span><br><span class="line">    <span class="comment">// If DialContext is nil (and the deprecated Dial below is also nil),</span></span><br><span class="line">    <span class="comment">// then the transport dials using package net.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DialContext runs concurrently with calls to RoundTrip.</span></span><br><span class="line">    <span class="comment">// A RoundTrip call that initiates a dial may end up using</span></span><br><span class="line">    <span class="comment">// a connection dialed previously when the earlier connection</span></span><br><span class="line">    <span class="comment">// becomes idle before the later DialContext completes.</span></span><br><span class="line">    DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dial specifies the dial function for creating unencrypted TCP connections.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Dial runs concurrently with calls to RoundTrip.</span></span><br><span class="line">    <span class="comment">// A RoundTrip call that initiates a dial may end up using</span></span><br><span class="line">    <span class="comment">// a connection dialed previously when the earlier connection</span></span><br><span class="line">    <span class="comment">// becomes idle before the later Dial completes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Deprecated: Use DialContext instead, which allows the transport</span></span><br><span class="line">    <span class="comment">// to cancel dials as soon as they are no longer needed.</span></span><br><span class="line">    <span class="comment">// If both are set, DialContext takes priority.</span></span><br><span class="line">    Dial <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DialTLSContext specifies an optional dial function for creating</span></span><br><span class="line">    <span class="comment">// TLS connections for non-proxied HTTPS requests.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If DialTLSContext is nil (and the deprecated DialTLS below is also nil),</span></span><br><span class="line">    <span class="comment">// DialContext and TLSClientConfig are used.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If DialTLSContext is set, the Dial and DialContext hooks are not used for HTTPS</span></span><br><span class="line">    <span class="comment">// requests and the TLSClientConfig and TLSHandshakeTimeout</span></span><br><span class="line">    <span class="comment">// are ignored. The returned net.Conn is assumed to already be</span></span><br><span class="line">    <span class="comment">// past the TLS handshake.</span></span><br><span class="line">    DialTLSContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DialTLS specifies an optional dial function for creating</span></span><br><span class="line">    <span class="comment">// TLS connections for non-proxied HTTPS requests.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Deprecated: Use DialTLSContext instead, which allows the transport</span></span><br><span class="line">    <span class="comment">// to cancel dials as soon as they are no longer needed.</span></span><br><span class="line">    <span class="comment">// If both are set, DialTLSContext takes priority.</span></span><br><span class="line">    DialTLS <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLSClientConfig specifies the TLS configuration to use with</span></span><br><span class="line">    <span class="comment">// tls.Client.</span></span><br><span class="line">    <span class="comment">// If nil, the default configuration is used.</span></span><br><span class="line">    <span class="comment">// If non-nil, HTTP/2 support may not be enabled by default.</span></span><br><span class="line">    TLSClientConfig *tls.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLSHandshakeTimeout specifies the maximum amount of time waiting to</span></span><br><span class="line">    <span class="comment">// wait for a TLS handshake. Zero means no timeout.</span></span><br><span class="line">    TLSHandshakeTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DisableKeepAlives, if true, disables HTTP keep-alives and</span></span><br><span class="line">    <span class="comment">// will only use the connection to the server for a single</span></span><br><span class="line">    <span class="comment">// HTTP request.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is unrelated to the similarly named TCP keep-alives.</span></span><br><span class="line">    DisableKeepAlives <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DisableCompression, if true, prevents the Transport from</span></span><br><span class="line">    <span class="comment">// requesting compression with an "Accept-Encoding: gzip"</span></span><br><span class="line">    <span class="comment">// request header when the Request contains no existing</span></span><br><span class="line">    <span class="comment">// Accept-Encoding value. If the Transport requests gzip on</span></span><br><span class="line">    <span class="comment">// its own and gets a gzipped response, it's transparently</span></span><br><span class="line">    <span class="comment">// decoded in the Response.Body. However, if the user</span></span><br><span class="line">    <span class="comment">// explicitly requested gzip it is not automatically</span></span><br><span class="line">    <span class="comment">// uncompressed.</span></span><br><span class="line">    DisableCompression <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxIdleConns controls the maximum number of idle (keep-alive)</span></span><br><span class="line">    <span class="comment">// connections across all hosts. Zero means no limit.</span></span><br><span class="line">    MaxIdleConns <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle</span></span><br><span class="line">    <span class="comment">// (keep-alive) connections to keep per-host. If zero,</span></span><br><span class="line">    <span class="comment">// DefaultMaxIdleConnsPerHost is used.</span></span><br><span class="line">    MaxIdleConnsPerHost <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxConnsPerHost optionally limits the total number of</span></span><br><span class="line">    <span class="comment">// connections per host, including connections in the dialing,</span></span><br><span class="line">    <span class="comment">// active, and idle states. On limit violation, dials will block.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Zero means no limit.</span></span><br><span class="line">    MaxConnsPerHost <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IdleConnTimeout is the maximum amount of time an idle</span></span><br><span class="line">    <span class="comment">// (keep-alive) connection will remain idle before closing</span></span><br><span class="line">    <span class="comment">// itself.</span></span><br><span class="line">    <span class="comment">// Zero means no limit.</span></span><br><span class="line">    IdleConnTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ResponseHeaderTimeout, if non-zero, specifies the amount of</span></span><br><span class="line">    <span class="comment">// time to wait for a server's response headers after fully</span></span><br><span class="line">    <span class="comment">// writing the request (including its body, if any). This</span></span><br><span class="line">    <span class="comment">// time does not include the time to read the response body.</span></span><br><span class="line">    ResponseHeaderTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExpectContinueTimeout, if non-zero, specifies the amount of</span></span><br><span class="line">    <span class="comment">// time to wait for a server's first response headers after fully</span></span><br><span class="line">    <span class="comment">// writing the request headers if the request has an</span></span><br><span class="line">    <span class="comment">// "Expect: 100-continue" header. Zero means no timeout and</span></span><br><span class="line">    <span class="comment">// causes the body to be sent immediately, without</span></span><br><span class="line">    <span class="comment">// waiting for the server to approve.</span></span><br><span class="line">    <span class="comment">// This time does not include the time to send the request header.</span></span><br><span class="line">    ExpectContinueTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLSNextProto specifies how the Transport switches to an</span></span><br><span class="line">    <span class="comment">// alternate protocol (such as HTTP/2) after a TLS ALPN</span></span><br><span class="line">    <span class="comment">// protocol negotiation. If Transport dials an TLS connection</span></span><br><span class="line">    <span class="comment">// with a non-empty protocol name and TLSNextProto contains a</span></span><br><span class="line">    <span class="comment">// map entry for that key (such as "h2"), then the func is</span></span><br><span class="line">    <span class="comment">// called with the request's authority (such as "example.com"</span></span><br><span class="line">    <span class="comment">// or "example.com:1234") and the TLS connection. The function</span></span><br><span class="line">    <span class="comment">// must return a RoundTripper that then handles the request.</span></span><br><span class="line">    <span class="comment">// If TLSNextProto is not nil, HTTP/2 support is not enabled</span></span><br><span class="line">    <span class="comment">// automatically.</span></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(authority <span class="keyword">string</span>, c *tls.Conn)</span> <span class="title">RoundTripper</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyConnectHeader optionally specifies headers to send to</span></span><br><span class="line">    <span class="comment">// proxies during CONNECT requests.</span></span><br><span class="line">    <span class="comment">// To set the header dynamically, see GetProxyConnectHeader.</span></span><br><span class="line">    ProxyConnectHeader Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProxyConnectHeader optionally specifies a func to return</span></span><br><span class="line">    <span class="comment">// headers to send to proxyURL during a CONNECT request to the</span></span><br><span class="line">    <span class="comment">// ip:port target.</span></span><br><span class="line">    <span class="comment">// If it returns an error, the Transport's RoundTrip fails with</span></span><br><span class="line">    <span class="comment">// that error. It can return (nil, nil) to not add headers.</span></span><br><span class="line">    <span class="comment">// If GetProxyConnectHeader is non-nil, ProxyConnectHeader is</span></span><br><span class="line">    <span class="comment">// ignored.</span></span><br><span class="line">    GetProxyConnectHeader <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, proxyURL *url.URL, target <span class="keyword">string</span>)</span> <span class="params">(Header, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxResponseHeaderBytes specifies a limit on how many</span></span><br><span class="line">    <span class="comment">// response bytes are allowed in the server's response</span></span><br><span class="line">    <span class="comment">// header.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Zero means to use a default limit.</span></span><br><span class="line">    MaxResponseHeaderBytes <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteBufferSize specifies the size of the write buffer used</span></span><br><span class="line">    <span class="comment">// when writing to the transport.</span></span><br><span class="line">    <span class="comment">// If zero, a default (currently 4KB) is used.</span></span><br><span class="line">    WriteBufferSize <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadBufferSize specifies the size of the read buffer used</span></span><br><span class="line">    <span class="comment">// when reading from the transport.</span></span><br><span class="line">    <span class="comment">// If zero, a default (currently 4KB) is used.</span></span><br><span class="line">    ReadBufferSize <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextProtoOnce guards initialization of TLSNextProto and</span></span><br><span class="line">    <span class="comment">// h2transport (via onceSetNextProtoDefaults)</span></span><br><span class="line">    nextProtoOnce      sync.Once</span><br><span class="line">    h2transport        h2Transport <span class="comment">// non-nil if http2 wired up</span></span><br><span class="line">    tlsNextProtoWasNil <span class="keyword">bool</span>        <span class="comment">// whether TLSNextProto was nil when the Once fired</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero</span></span><br><span class="line">    <span class="comment">// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.</span></span><br><span class="line">    <span class="comment">// By default, use of any those fields conservatively disables HTTP/2.</span></span><br><span class="line">    <span class="comment">// To use a custom dialer or TLS config and still attempt HTTP/2</span></span><br><span class="line">    <span class="comment">// upgrades, set this to true.</span></span><br><span class="line">    ForceAttemptHTTP2 <span class="keyword">bool</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// connectMethodKey is the map key version of connectMethod, with a</span></span><br><span class="line"><span class="comment">// stringified proxy URL (or the empty string) instead of a pointer to</span></span><br><span class="line"><span class="comment">// a URL.</span></span><br><span class="line"><span class="keyword">type</span> connectMethodKey <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// 代理url,浏览器透明代理</span></span><br><span class="line">    <span class="comment">// scheme 协议 http https</span></span><br><span class="line">    <span class="comment">// addr 代理base的url,下游服务base地址</span></span><br><span class="line">    proxy, scheme, addr <span class="keyword">string</span></span><br><span class="line">    onlyH1              <span class="keyword">bool</span>     <span class="comment">// 是否http1.1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// persistConn wraps a connection, usually a persistent one</span></span><br><span class="line"><span class="comment">// (but may be used for non-keep-alive requests as well)</span></span><br><span class="line"><span class="keyword">type</span> persistConn <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// alt optionally specifies the TLS NextProto RoundTripper.</span></span><br><span class="line">    <span class="comment">// This is used for HTTP/2 today and future protocols later.</span></span><br><span class="line">    <span class="comment">// If it's non-nil, the rest of the fields are unused.</span></span><br><span class="line">    alt RoundTripper</span><br><span class="line"></span><br><span class="line">    t         *Transport</span><br><span class="line">    cacheKey  connectMethodKey</span><br><span class="line">    conn      net.Conn</span><br><span class="line">    tlsState  *tls.ConnectionState</span><br><span class="line">    br        *bufio.Reader       <span class="comment">// from conn从持久化的tcp套接字上读取内容</span></span><br><span class="line">    bw        *bufio.Writer       <span class="comment">// to conn从持久化的tcp套接字上写取内容</span></span><br><span class="line">    nwrite    <span class="keyword">int64</span>               <span class="comment">// bytes written</span></span><br><span class="line">    reqch     <span class="keyword">chan</span> requestAndChan <span class="comment">// written by roundTrip; read by readLoop 从roundTrip写内容，从readLoop读内容</span></span><br><span class="line">    writech   <span class="keyword">chan</span> writeRequest   <span class="comment">// written by roundTrip; read by writeLoop 从roundTrip写内容，从writeLoop读内容</span></span><br><span class="line">    closech   <span class="keyword">chan</span> <span class="keyword">struct</span>{}       <span class="comment">// closed when conn closed</span></span><br><span class="line">    isProxy   <span class="keyword">bool</span></span><br><span class="line">    sawEOF    <span class="keyword">bool</span>  <span class="comment">// whether we've seen EOF from conn; owned by readLoop</span></span><br><span class="line">    readLimit <span class="keyword">int64</span> <span class="comment">// bytes allowed to be read; owned by readLoop</span></span><br><span class="line">    <span class="comment">// writeErrCh passes the request write error (usually nil)</span></span><br><span class="line">    <span class="comment">// from the writeLoop goroutine to the readLoop which passes</span></span><br><span class="line">    <span class="comment">// it off to the res.Body reader, which then uses it to decide</span></span><br><span class="line">    <span class="comment">// whether or not a connection can be reused. Issue 7569.</span></span><br><span class="line">    writeErrCh <span class="keyword">chan</span> error</span><br><span class="line"></span><br><span class="line">    writeLoopDone <span class="keyword">chan</span> <span class="keyword">struct</span>{} <span class="comment">// closed when write loop ends</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Both guarded by Transport.idleMu:</span></span><br><span class="line">    idleAt    time.Time   <span class="comment">// time it last become idle</span></span><br><span class="line">    idleTimer *time.Timer <span class="comment">// holding an AfterFunc to close it</span></span><br><span class="line"></span><br><span class="line">    mu                   sync.Mutex <span class="comment">// guards following fields</span></span><br><span class="line">    numExpectedResponses <span class="keyword">int</span></span><br><span class="line">    closed               error <span class="comment">// set non-nil when conn is closed, before closech is closed</span></span><br><span class="line">    canceledErr          error <span class="comment">// set non-nil if conn is canceled</span></span><br><span class="line">    broken               <span class="keyword">bool</span>  <span class="comment">// an error has happened on this connection; marked broken so it's not reused.</span></span><br><span class="line">    reused               <span class="keyword">bool</span>  <span class="comment">// whether conn has had successful request/response and is being reused.</span></span><br><span class="line">    <span class="comment">// mutateHeaderFunc is an optional func to modify extra</span></span><br><span class="line">    <span class="comment">// headers on each outbound request before it's written. (the</span></span><br><span class="line">    <span class="comment">// original Request given to RoundTrip is not modified)</span></span><br><span class="line">    mutateHeaderFunc <span class="function"><span class="keyword">func</span><span class="params">(Header)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="golang-http客户端超时时间设置"><a href="#golang-http客户端超时时间设置" class="headerlink" title="golang http客户端超时时间设置"></a>golang http客户端超时时间设置</h4><p><img src="%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/httpclienttimeout.png"></p>
<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DumpResponse is like DumpRequest but dumps a response.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DumpResponse</span><span class="params">(resp *http.Response, body <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    save := resp.Body</span><br><span class="line">    savecl := resp.ContentLength</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !body {</span><br><span class="line">        <span class="comment">// For content length of zero. Make sure the body is an empty</span></span><br><span class="line">        <span class="comment">// reader, instead of returning error through failureToReadBody{}.</span></span><br><span class="line">        <span class="keyword">if</span> resp.ContentLength == <span class="number">0</span> {</span><br><span class="line">            resp.Body = emptyBody</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            resp.Body = failureToReadBody{}</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> resp.Body == <span class="literal">nil</span> {</span><br><span class="line">        resp.Body = emptyBody</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        save, resp.Body, err = drainBody(resp.Body)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    err = resp.Write(&amp;b)</span><br><span class="line">    <span class="keyword">if</span> err == errNoBody {</span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">    resp.Body = save</span><br><span class="line">    resp.ContentLength = savecl</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b.Bytes(), <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>http</code>客户端发送请求<br>使用<code>httputil</code>简化工作</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    resp, err := http.Get(<span class="string">"https://www.imooc.com"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 自己构造一个request</span></span><br><span class="line">    req, err := http.NewRequest(http.MethodGet, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 设置头部</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    req.Header.Add(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1"</span>)</span><br><span class="line">    <span class="comment">// 默认的client</span></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>http.Client</code>控制请求头部</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 自己构造一个request</span></span><br><span class="line">    request, _ := http.NewRequest(</span><br><span class="line">        http.MethodGet,</span><br><span class="line">        <span class="string">"https://www.imooc.com"</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 设置头部</span></span><br><span class="line">    request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1"</span>)</span><br><span class="line">    <span class="comment">// 自定义Client CheckRedirect 重定向会会从这里过</span></span><br><span class="line">    client := http.Client{</span><br><span class="line">        CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request,via []*http.Request)</span> <span class="title">error</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    resp, err := client.Do(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="http服务器性能分析"><a href="#http服务器性能分析" class="headerlink" title="http服务器性能分析"></a>http服务器性能分析</h3><p><code>import _ "net/http/pprof</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://localhost:8080/debug/pprof 不能用了，</span><br></pre></td></tr></tbody></table></figure>

<p>要在浏览器输入打开网页对应端口的页面看到一些性能的分析<code>http://localhost:8888/debug/pprof/</code></p>
<p>额外功能点开pprof的文件，里面有一些命令 可以获取对应的数据，然后生成图，可以直观的看到性能消耗在哪里 分析性能</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:8080/debug/pprof/profile</span><br><span class="line">30秒后输入web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存使用情况</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap</span><br><span class="line"><span class="comment"># 30秒 CPU使用情况</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>http 库 —— Request Body<br>• Body：<strong>只能读取一次</strong>，意味着你读了别人就不能读了；别人读了你就不能读了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">home</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  {</span><br><span class="line">    fmt.Fprint(w, <span class="string">"Hi, this is home page"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readBodyOnce</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  {</span><br><span class="line">    body, err := io.ReadAll(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"read body failed: %v"</span>, err)</span><br><span class="line">        <span class="comment">// 记住要返回，不然就还会执行后面的代码</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 类型转换，将 []byte 转换为 string</span></span><br><span class="line">    fmt.Fprintf(w, <span class="string">"read the data: %s \n"</span>, <span class="keyword">string</span>(body))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次读取，啥也读不到，但是也不会报错</span></span><br><span class="line">    body, err = io.ReadAll(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// 不会进来这里</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">"read the data one more time got error: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"read the data one more time: [%s] and read data length %d \n"</span>, <span class="keyword">string</span>(body), <span class="built_in">len</span>(body))</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, home)</span><br><span class="line">    http.HandleFunc(<span class="string">"/body/once"</span>, readBodyOnce)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/23.png" alt="description"></p>
<p>GetBody：原则上是可以多次读取，但是在原生的http.Request里面，这个是 nil<br>Body 是一次性的，而 GetBody 默认情况下是没有，一般中间件<br>会考虑帮你注入这个方<br>• 在读取到 body 之后，我们就可以用于反序列化，比如说将json格式的字符串转化为一个对象等</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBodyIsNil</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.GetBody == <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprint(w, <span class="string">"GetBody is nil \n"</span>)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"GetBody not nil \n"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/body/multi"</span>, getBodyIsNil)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/24.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, home)</span><br><span class="line">    http.HandleFunc(<span class="string">"/body/once"</span>, readBodyOnce)</span><br><span class="line">    http.HandleFunc(<span class="string">"/body/multi"</span>, getBodyIsNil)</span><br><span class="line">    http.HandleFunc(<span class="string">"/url/query"</span>, queryParams)</span><br><span class="line">    http.HandleFunc(<span class="string">"/header"</span>, header)</span><br><span class="line">    http.HandleFunc(<span class="string">"/wholeUrl"</span>, wholeUrl)</span><br><span class="line">    http.HandleFunc(<span class="string">"/form"</span>, form)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    serve := http.FileServer(http.Dir(<span class="string">"."</span>))</span><br><span class="line">    <span class="comment">//http.Handle("/", serve)</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, serve)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/go-bao-guan-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/go-bao-guan-li/" class="post-title-link" itemprop="url">go包管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-22 00:52:05" itemprop="dateModified" datetime="2021-09-22T00:52:05Z">2021-09-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>包管理 1.12之前 go的没有包管理 python java maven go modules</p>
<p>包package：工程项目当中根据不同工作模块建立的不同的文件夹</p>
<p>Go 语言的源码复用建立在包（package）基础之上。<br>Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。</p>
<p>所有与包相关的操作，必须依赖于工作目录（GOPATH）。</p>
<p>任何源代码文件必须属于某个包，<br>一个文件夹目录下的同级文件（不含子目录）只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</p>
<p>源码文件的第一行非注释有效代码必须是 <code>package pacakgeName</code> 语句，指明这个文件属于哪个包，包名是golang文件中package后面的字符，但包导入后使用的是包名非路径文件夹名称</p>
<p>包的习惯用法：</p>
<p>Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。<br>◆ 完整包名组成:引入路径+包名 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。</p>
<p>包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在<code>GOPATH/src/a/b/</code> 下定义一个包 c。在包 c 的源码中只需声明为<code>package c</code>，而不是声明为<code>package a/b/c</code>，但是在导入 c 包时，需要带上路径，例如<code>import "a/b/c"</code>。</p>
<p>文件名称在golang中仅仅是文件名称，没有编码含义</p>
<p>源代码中的包名称</p>
<ul>
<li>包名一般是小写的，使用一个简短且有意义的名称。</li>
<li>包名一般要和所在的目录文件夹同名，也可以不同，包名中不能包含- 等特殊符号。包与文件夹一一对应</li>
<li>同一个文件夹包下，所有源文件中的package包名是必须一致一样，不允许定义相同的变量和函数</li>
</ul>
<p>Go 语言的可执行入口 <code>main()</code> 函数只能在main包中使用才可以执行。main 包想要引用别的代码，必须同样以包的方式进行引用，编译不包含 main 包的源码文件时不会得到可执行文件。main() 无参数，无返回值</p>
<p>包AA-&gt;println()<br>包BB-&gt;println()<br>内置built-&gt;println()</p>
<p>.py文件要引用其他的函数或变量，通过文件名称就属于一个包了</p>
<h3 id="可见性-访问控制"><a href="#可见性-访问控制" class="headerlink" title="可见性 访问控制"></a>可见性 访问控制</h3><p>命名一般使用 CamelCase，不用 _</p>
<p>一个包中的变量或函数或者结构体结构体定义的 名称 以及内部变量属性的大小写：</p>
<ul>
<li>首字母大写是公开变量或函数，相当于类成员变量的 Public 类别。对于另一个包可见可引用 可以被导出，可以被其他包访问</li>
<li>首字母小写是内部变量或函数，相当于类成员变量的 Private 类别。内部变量只有属于同一个 package（目录）的代码才能直接访问，对于另一个包不可见，不可以被导出，不可以被其他包访问</li>
</ul>
<p>大小写是针对包来讲，仅对包管理有效</p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。<br>源代码导入 import 后面跟的的是相对文件夹路径 - 非包名 - 非文件路径<br>go引用不是通过文件名而是通过package声明的包名，</p>
<p>◆ 代码引用时使用包名，而非文件夹名称</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包目录的路径"</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<p>不要认为是包名，也不可以直接import一个包中的函数或变量</p>
<p>import 导入语句通常放在源码文件开头包声明语句的下面；<br>导入的包名需要使用双引号包裹起来；<br>包名是从 <code>GOPATH/src/</code> 后开始计算的，使用 <code>/</code> 进行路径分隔。</p>
<p>包的导入有两种写法，分别是单行导入和多行导入</p>
<h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包 1 的路径"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包 2 的路径"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"包 1 的路径"</span></span><br><span class="line">    <span class="string">"包 2 的路径"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包的导入路径"><a href="#包的导入路径" class="headerlink" title="包的导入路径"></a>包的导入路径</h2><p>包的引用路径有两种写法，分别是全路径导入和相对路径导入。</p>
<h3 id="全路径导入"><a href="#全路径导入" class="headerlink" title="全路径导入"></a>全路径导入</h3><p>包的绝对路径就是 <code>GOROOT/src/</code>或 <code>GOPATH/src/</code> 后面包的存放路径，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"lab/test"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql/driver"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面代码的含义如下：<br>test 包是自定义的包，其源码位于<code>GOPATH/src/lab/test</code> 目录下；<br>driver 包的源码位于<code>GOROOT/src/database/sql/driver</code> 目录下；<br>sql 包的源码位于<code>GOROOT/src/database/sql</code> 目录下。</p>
<h3 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h3><p>相对路径只能用于导入<code>GOPATH</code> 下的包，标准包的导入只能使用全路径导入。</p>
<p>例如包 a 的所在路径是GOPATH/src/lab/a，包 b 的所在路径为GOPATH/src/lab/b，<br>如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对路径导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../a"</span></span><br></pre></td></tr></tbody></table></figure>

<p>当然了，也可以使用上面的全路径导入，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全路径导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"lab/a"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="包的引用格式"><a href="#包的引用格式" class="headerlink" title="包的引用格式"></a>包的引用格式</h3><h4 id="标准引用格式"><a href="#标准引用格式" class="headerlink" title="标准引用格式"></a>标准引用格式</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="省略引用格式"><a href="#省略引用格式" class="headerlink" title="省略引用格式"></a>省略引用格式</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<p>包名前加点<code>.</code> 相当于把fmt包直接合并到当前程序中，在使用fmt包内的方法是可以不用加前缀<code>fmt.</code>，直接引用。</p>
<h4 id="自定义别名引用格式-给包取别名"><a href="#自定义别名引用格式-给包取别名" class="headerlink" title="自定义别名引用格式 给包取别名"></a>自定义别名引用格式 给包取别名</h4><p>在导入包的时候，我们还可以为导入的包设置别名，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中 F 就是 fmt 包的别名，使用时我们可以使用<code>F.</code>来代替标准引用格式的<code>fmt.</code>来作为前缀使用 fmt 包中的方法。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    F.Println(<span class="string">"C语言中文网"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当add1和add2都有同名的Add函数，给包取别名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    int_add <span class="string">"lang/add1"</span></span><br><span class="line">    float_add <span class="string">"lang/add2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   fmt.Println(int_add.Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">   fmt.Println(float_add.Add(<span class="number">1.0</span>, <span class="number">2.0</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="为结构体定义的方法必须在一个包内"><a href="#为结构体定义的方法必须在一个包内" class="headerlink" title="为结构体定义的方法必须在一个包内"></a>为结构体定义的方法必须在一个包内</h3><p>GO的面向对象使用结构体来做的，对一个结构体可以定义很多方法。</p>
<p>因为需要封装的原因，所以一个结构体中的方法必须在一个包内定义。也就是说，如果结构体定义在了包A中，那么它对应的方法也必须都定义在包A中，不可以在别的包中定义，这样就破坏了封装的概念。但是可以是不同的文件，即可以在同一个包中的不同源文件中定义结构体的方法。</p>
<h3 id="匿名引用格式"><a href="#匿名引用格式" class="headerlink" title="匿名引用格式"></a>匿名引用格式</h3><p>在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。</p>
<p>Go语言包的初始化有如下特点：<br>包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。<br>Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。</p>
<p>init 方法</p>
<ul>
<li>无参数</li>
<li>无返回值</li>
<li>包被引入的时候执行，只执行一次！</li>
<li>执行顺序不定（目前是按照所在文件名排序）</li>
<li>一个包，一个文件内都可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>-当前包引入其他包，优先调用其他包的全局变量，init()函数（如果其他包也调用 了init()函数，则继续向上调用），再调用本包的init()函数</p>
<p>单个包的初始化过程执行顺序:初始化常量–》全局变量-》init()-&gt;main()</p>
<p>导包<code>_</code>的作用是:当导入一个包的时候，该包的init和其他函数都会被导入，go语言编译器会自动调用，init函数自动执行，不需要显示调用</p>
<p>匿名引用导入包使用也不会报错<br>引用某个包时，如果只是希望执行包初始化的init函数，而不使用包内部的数据时，可以使用匿名引用格，也会和其他包一样编译到可执行文件中</p>
<ul>
<li><p>一般用于初始化工具，比如连接数据库</p>
</li>
<li><p>包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。</p>
</li>
<li><p>包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">   fmt.Println(<span class="string">"init初始化"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="本地包的使用"><a href="#本地包的使用" class="headerlink" title="本地包的使用"></a>本地包的使用</h3><p>action/productActino.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> action</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//public</span></span><br><span class="line"><span class="keyword">var</span> Product <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//private</span></span><br><span class="line"><span class="keyword">var</span> product <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductList</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"action-&gt;ProductList()"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productList</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"action-&gt;productList()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>practice_package/main.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="comment">//"function"</span></span><br><span class="line">    <span class="string">"learninggo/action"</span></span><br><span class="line">    <span class="string">"learninggo/model"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//function.Println("hello 波哥")</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(action.Product) <span class="comment">// 0</span></span><br><span class="line">    action.ProductList() <span class="comment">// action-&gt;ProductList()</span></span><br><span class="line">    <span class="comment">//action.productList()</span></span><br><span class="line"></span><br><span class="line">    bobo := model.UserInfo{</span><br><span class="line">        Name:      <span class="string">"波哥"</span>,</span><br><span class="line">        Age:       <span class="number">18</span>,</span><br><span class="line">        Height:    <span class="number">182.32</span>,</span><br><span class="line">        Eduschool: <span class="string">"北京邮电大学"</span>,</span><br><span class="line">        Hobby:     []<span class="keyword">string</span>{<span class="string">"coding"</span>, <span class="string">"旅行"</span>, <span class="string">"读书"</span>, <span class="string">"运动"</span>},</span><br><span class="line">        MoreInfo: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">            <span class="string">"work"</span>: <span class="string">"百度"</span>,</span><br><span class="line">            <span class="string">"duty"</span>: <span class="string">"产品狗"</span>,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(bobo.MoreInfo[<span class="string">"work"</span>]) <span class="comment">// 百度</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>添加依赖<br>命令行查看标准库</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br><span class="line">godoc -http :8080</span><br></pre></td></tr></tbody></table></figure>

<p>然后访问<a target="_blank" rel="noopener" href="http://localhost:8080/pkg/">http://localhost:8080/pkg/</a></p>
<p>浏览器访问<br><a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/kong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/kong/" class="post-title-link" itemprop="url">go的http</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-09 01:44:34" itemprop="dateModified" datetime="2021-09-09T01:44:34Z">2021-09-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
