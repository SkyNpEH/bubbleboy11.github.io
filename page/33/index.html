<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:type" content="website">
<meta property="og:title" content="外心人D的博客">
<meta property="og:url" content="https://bubbleboy11.github.io/page/33/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/page/33/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/33/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">339</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/liu-da-ji-ben-pai-xu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/liu-da-ji-ben-pai-xu/" class="post-title-link" itemprop="url">六大基本排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-10 01:55:30" itemprop="dateModified" datetime="2021-05-10T01:55:30Z">2021-05-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="排序算法-Sorting-algorithm"><a href="#排序算法-Sorting-algorithm" class="headerlink" title="排序算法 Sorting algorithm"></a>排序算法 Sorting algorithm</h1><p>是一种能将一串数据依照特定顺序进行排列的一种算法。<br>进行从小到大进行排序，内置排序函数<code>sort()</code></p>
<p>在平均情况下，快速排序最快；<br>在最好情况下，插入排序和起泡排序最快；<br>在最坏情况下，堆排序和归并排序最快。</p>
<p>排序算法的分析</p>
<ol>
<li>排序算法的稳定性：如果在对象序列中有两个对象 r[i]和r[j] ,它们的排序码 k[i]==k[j] 。如果排序前后,对象 r[i]和 r[j] 的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。</li>
<li>时间开销：排序的时间开销可用算法执行中的数据比较次数与数据移动次数来衡量。算法运行时间代价的大略估算一般都按平均情况进行估算。对于那些受对象排序码序列初始排列及对象个数影响较大的，需要按最好情况和最坏情况进行估算3. 空间开销：算法执行时所需的附加存储。</li>
</ol>
<h2 id="1-冒泡排序-Bubble-Sort-（了解）"><a href="#1-冒泡排序-Bubble-Sort-（了解）" class="headerlink" title="1.冒泡排序 Bubble Sort （了解）"></a>1.冒泡排序 Bubble Sort （了解）</h2><p>首先是每次比较两个相邻的元素，当左面的大于右面的时候，进行互换位置，当小于的时候，都不动。<br>它重复地遍历要排序的数列直到没有再需要交换，该数列已经排序完成。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端，大的向下沉。</p>
<p>外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。<br>一趟排序完成后，则无序区减少一个数，有序区增加一个数</p>
<p>冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换这两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>时间复杂度 O(n^2)<br>空间复杂度：O(1) 用到常数个临时变量。<br>稳定性：稳定</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="comment"># 遍历所有数组元素，每一个都要找到没排好序的最大值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):  <span class="comment"># 第i趟  </span></span><br><span class="line">    <span class="comment"># for i in range(len(array) - 1):  # 第i趟，减去1也不影响</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j 表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">            <span class="comment"># 将 没有排好序的数组 找最大值， 并一直将最大值换到最顶端</span></span><br><span class="line">            <span class="comment"># 判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。</span></span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j + <span class="number">1</span>]:</span><br><span class="line">                array[j], array[j + <span class="number">1</span>] = array[j + <span class="number">1</span>], array[j]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    array = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    print(bubbleSort(array))</span><br><span class="line">    <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len(<span class="built_in">array</span>) = <span class="number">4</span></span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line">len(<span class="built_in">array</span>) - i - <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">2</span> + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">i = <span class="number">1</span>     </span><br><span class="line">len(<span class="built_in">array</span>) - i - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">3</span> &gt; <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span> &gt; <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span> + <span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">i = <span class="number">2</span>     </span><br><span class="line">len(<span class="built_in">array</span>) - i - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span> &lt; <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[j]:</span><br><span class="line">                array[i], array[j] = array[j], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len(<span class="built_in">array</span>) = <span class="number">4</span></span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span> + <span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">3</span> &gt; <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span> &lt; <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">i = <span class="number">1</span>     </span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span> &gt; <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">i = <span class="number">2</span>     </span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>优化的冒泡<br>如果在某一趟过程中没有发生交换，说明已经结束排序。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array) - <span class="number">1</span>):  </span><br><span class="line">            flag = <span class="literal">False</span>  <span class="comment"># 优化后的冒泡，设置一个交换标志位</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array) - i - <span class="number">1</span>):  </span><br><span class="line">                <span class="keyword">if</span> array[j] &gt; array[j + <span class="number">1</span>]:</span><br><span class="line">                    array[j], array[j + <span class="number">1</span>] = array[j + <span class="number">1</span>], array[j]</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">return</span> array  <span class="comment"># 代表计算机偷懒成功</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 升序排序，从列表最前面开始进行判断，如果后面一个小于前面一个，则交换位置,依次比较</span></span><br><span class="line">    <span class="comment"># 第一次循环就会把最大的值放到列表的最后面</span></span><br><span class="line">    <span class="comment"># 第二次循环就会把第二大的值放到最大值的前面，以此类推</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> num_index <span class="keyword">in</span> range(index):</span><br><span class="line">            <span class="keyword">if</span> nums[num_index] &gt; nums[num_index + <span class="number">1</span>]:</span><br><span class="line">                nums[num_index], nums[num_index + <span class="number">1</span>] = nums[num_index +</span><br><span class="line">                                                            <span class="number">1</span>], nums[num_index]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="2-插入排序-Insertion-Sort-（熟悉）"><a href="#2-插入排序-Insertion-Sort-（熟悉）" class="headerlink" title="2.插入排序 Insertion Sort （熟悉）"></a>2.插入排序 Insertion Sort （熟悉）</h2><p>每次将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加1 的有序数据，<br>用于少量数据的排序，首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序。</p>
<p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>优化：「将一个数字插入一个有序的数组」这一步，可以不使用逐步交换，使用先赋值给「临时变量」，然后「适当的元素」后移，空出一个位置，最后把「临时变量」赋值给这个空位的策略（就是上面那张图的意思）。编码的时候如果不小心，可能会把数组的值修改，建议多调试；</p>
<p>特点：「插入排序」可以提前终止内层循环（体现在 nums[j - 1] &gt; temp 不满足时），在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 O(N)；</p>
<p>由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。</p>
<p>时间复杂度 O(n^2)<br>空间复杂度：O(1) 使用到常数个临时变量。<br>稳定性：稳定</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">ilist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ilist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> ilist[i] &lt; ilist[j]:</span><br><span class="line">                ilist.insert(j, ilist.pop(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ilist</span><br><span class="line"></span><br><span class="line">print(insert_sort([<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 6, 7, 8]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len(<span class="built_in">array</span>) = <span class="number">4</span></span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line">    j 为空</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span> &lt; <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">i = <span class="number">2</span>    </span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span> &lt; <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">i = <span class="number">3</span>     </span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span> &gt; <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span> &lt; <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(alist)):</span><br><span class="line">        <span class="comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[j<span class="number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="number">-1</span>] = alist[j<span class="number">-1</span>], alist[j]</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">print(insert_sort(alist))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        插入排序，将无序区的数据依次取出，与有序区数据比较，然后放在合理的位置</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):  <span class="comment"># 无序列表第一个数</span></span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; temp: <span class="comment">#如果有序区的数依次与无序列表第一个数比较，直到找到对应位置</span></span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">插入排序 Insertion Sort</span><br><span class="line">从左到右遍历每一个元素，每次将这个元素和前面的元素一一比较，如果比某个元素小，则跟其交换</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">arr, n</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序，每次选择未排序部分的最小值和未排序部分的第一位交换位置</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">        <span class="comment"># 寻找元素arr[i]合适的插入位置</span></span><br><span class="line"></span><br><span class="line">        e = arr[i]</span><br><span class="line">        j = i  <span class="comment"># j保存元素e应该插入的位置</span></span><br><span class="line">        <span class="keyword">while</span> arr[j<span class="number">-1</span>] &gt; e <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j] = e</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>选择排序一个特别重要的性质：当找到合适的位置以后（<code>arr[j-1] &gt; e</code>），可以提前终止内层循环<br>这使得在一个近乎有序的数组在进行插入排序的时候，效率要高的多，设置比o(logn)的算法效率还要高<br>当排序一个完全排序的数组时，插入排序的算法复杂度为o(n)级别</li>
</ul>
<p>（直白描述）<br>1.当只考虑第一个元素的时候，它已经排好序了，第一个元素不动。<br>2.寻找第二个元素合适的位置，把它和第一个元素比较，如果小于第一个元素，交换，否则，它的位置是合适的，继续下一次循环。<br>3.寻找第三个元素合适的位置，先和第二个元素比较，如果小于第二个元素，和第二个元素交换位置，然后和第一个元素比较，如果小于第一个元素，和第一个元素交换位置，继续下一次循环。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">arrList</span>):</span></span><br><span class="line">    <span class="comment"># 从1开始，第0个元素已经有序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arrList)):</span><br><span class="line">        <span class="comment"># 寻找arrList[i]合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 如果当前位置元素比前一个位置元素小，交换</span></span><br><span class="line">            <span class="keyword">if</span> arrList[j] &lt; arrList[j<span class="number">-1</span>]:</span><br><span class="line">                arrList[j<span class="number">-1</span>], arrList[j] = arrList[j], arrList[j<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 否则，当前元素位置合适，寻找下一个元素的合适位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">insertionSort(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [6, 7, 8, 9, 10]</span></span><br></pre></td></tr></tbody></table></figure>

<p>插入排序算法的改进<br>（形式化描述）<br>将第一个元素标记为已排序<br>遍历每个没有排序过的元素<br>    “提取” 元素 X<br>    i = 最后排序过元素的指数 到 0 的遍历<br>        如果现在排序过的元素 &gt; 提取的元素<br>            将排序过的元素向右移一格<br>        否则：插入提取的元素</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">arrList</span>):</span></span><br><span class="line">    <span class="comment"># 从1开始，第0个元素已经有序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arrList)):</span><br><span class="line">        <span class="comment"># 寻找arrList[i]合适的插入位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前元素提取出来</span></span><br><span class="line">        x = arrList[i]</span><br><span class="line">        <span class="comment"># j保存元素应该插入的位置，初始为i</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="comment"># -1取不到，可以取到0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arrList[j<span class="number">-1</span>] &gt; x:</span><br><span class="line">                <span class="comment"># 赋值而不做交换</span></span><br><span class="line">                arrList[j] = arrList[j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 位置合适</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        arrList[j] = x</span><br><span class="line"></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">insertionSort(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [6, 7, 8, 9, 10]</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="3-选择排序-Selection-sort-（了解）"><a href="#3-选择排序-Selection-sort-（了解）" class="headerlink" title="3.选择排序 Selection sort （了解）"></a>3.选择排序 Selection sort （了解）</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。<br>第一趟，在待排序记录r1 …r(n)中选出最小的记录，将它与r1 交换，<br>第二趟，在待排序记录r2 ~ r(n) 中选出最小的记录，将它与 r2 交换，<br>以此类推，第i趟在待排序记录 r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</p>
<p>算法思想 1：贪心算法：每一次决策只看当前，当前最优，则全局最优。<br>注意：这种思想不是任何时候都适用。</p>
<p>算法思想 2：减治思想：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。</p>
<p>优点：交换次数最少。</p>
<p>时间复杂度 O(n^2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="comment"># 外层循环控制循环次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):  <span class="comment"># 第i趟</span></span><br><span class="line">    <span class="comment"># for i in range(len(array) - 1):  # 第i趟</span></span><br><span class="line">        min_index = i  <span class="comment"># 假设找到的最小元素下标，无序区第一个数开始查找</span></span><br><span class="line">        <span class="comment"># 寻找最小元素的过程</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(array)):</span><br><span class="line">        <span class="comment"># for j in range(i + 1, len(array)):  </span></span><br><span class="line">        <span class="comment"># 加1也不影响 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">            <span class="comment"># 假设最小下标的值，大于循环中一个元素，那么就改变最小值的下标</span></span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="comment"># 循环一开始就假设把最小值的下标赋值给变量 min_index</span></span><br><span class="line">        <span class="comment"># 在不停的循环中，不停的交换两个不一样大小的值</span></span><br><span class="line">        array[i], array[min_index] = array[min_index], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len(<span class="built_in">array</span>) = <span class="number">4</span></span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line">min_index = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span> = <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span> &lt; <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    min_index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span> &lt; <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    min_index = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span> &gt; <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    min_index = <span class="number">2</span></span><br><span class="line">    slist[<span class="number">0</span>] = slist[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    slist[<span class="number">2</span>]  = slist[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    slist = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">min_index = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span>,  j 从i开始，不是从<span class="number">0</span>开始</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span> = <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span> &gt; <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">2</span> &lt; <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    min_index = <span class="number">3</span></span><br><span class="line">    slist[<span class="number">1</span>] = slist[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    slist[<span class="number">3</span>]  = slist[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">    slist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">i = <span class="number">2</span>  </span><br><span class="line">min_index = <span class="number">2</span>  </span><br><span class="line">    j = <span class="number">2</span>,  j 从i开始，不是从<span class="number">0</span>开始</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span> = <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">3</span> &lt; <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    min_index = <span class="number">3</span></span><br><span class="line">    slist[<span class="number">2</span>] = slist[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    slist[<span class="number">3</span>]  = slist[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    slist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">i = <span class="number">3</span>     </span><br><span class="line">min_index = <span class="number">3</span> </span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">3</span> = <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure>
<p>每次选择没有排序部分的最小值和第一位交换</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">org_arr, length</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序，每次选择未排序部分的最小值和未排序部分的第一位交换位置</span></span><br><span class="line"><span class="string">    :param org_arr: 待排序数组</span></span><br><span class="line"><span class="string">    :param length: 待数组长度</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        <span class="comment"># 寻找[i,n)区间里的最小值</span></span><br><span class="line">        main_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> org_arr[j] &lt; org_arr[main_index]:</span><br><span class="line">                main_index = j</span><br><span class="line">        org_arr[i], org_arr[main_index] = org_arr[main_index], org_arr[i]</span><br></pre></td></tr></tbody></table></figure>
<p>（直白描述）</p>
<ol>
<li>找出所有元素中的最小值，与第一个位置的元素互换。</li>
<li>找出剩下的元素中的最小值，与第二个位置的元素互换。</li>
<li>以此类推。</li>
</ol>
<p>（形式化描述）<br>重复（元素个数-1）次<br>    # 从0开始<br>    把第一个没有排序过的元素设置为最小值<br>    遍历每个没有排序过的元素<br>        如果元素 &lt; 现在的最小值<br>        将此元素设置成为新的最小值<br>    将最小值和第一个没有排序过的位置交换</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">arrList</span>):</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string">    :param arrList:可迭代对象</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(arrList)):</span><br><span class="line">        <span class="comment"># 寻找[i, len(arrlist))区间的最小值</span></span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arrList)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> arrList[j] &lt; arrList[i]:</span><br><span class="line">                minIndex = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交换i位置和最小值</span></span><br><span class="line">        <span class="comment"># 注意双向交换</span></span><br><span class="line">        arrList[i], arrList[minIndex] = arrList[minIndex], arrList[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">selectionSort(a)</span><br><span class="line"></span><br><span class="line">print(a)    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="4-希尔排序-Shell-Sort（不建议多花时间了解）"><a href="#4-希尔排序-Shell-Sort（不建议多花时间了解）" class="headerlink" title="4.希尔排序 Shell Sort（不建议多花时间了解）"></a>4.希尔排序 Shell Sort（不建议多花时间了解）</h2><p>是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。</p>
<p>是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好被分成一组，算法终止</p>
<p>将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>时间复杂度 O(n^2)<br>空间复杂度：O(nlogn)<br>稳定性：不稳定</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">slist</span>):</span></span><br><span class="line">    count = len(slist)</span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    group = count // step</span><br><span class="line">    <span class="keyword">while</span> group &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(group):</span><br><span class="line">            j = i + group</span><br><span class="line">            <span class="keyword">while</span> j &lt; count:</span><br><span class="line">                key = slist[j]</span><br><span class="line">                k = j - group</span><br><span class="line">                <span class="keyword">while</span> k &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> slist[k] &gt; key:</span><br><span class="line">                        slist[k+group] = slist[k]</span><br><span class="line">                        slist[k] = key</span><br><span class="line">                    k = k - group</span><br><span class="line">                j = j + group</span><br><span class="line">        group = group // step</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(shell_sort([4,5,7,3,2,6,9,8,0]))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShellSort</span>(<span class="params">arrList</span>):</span></span><br><span class="line">    arrayLen = len(arrList)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> h &lt; arrayLen//<span class="number">3</span>:</span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">        <span class="comment">#插入排序的方法，判断是不是后一个比前一个要小</span></span><br><span class="line">        <span class="comment">#如果是则交换</span></span><br><span class="line">    <span class="keyword">while</span> h &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(h,arrayLen):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= h <span class="keyword">and</span> arrList[j] &lt; arrList[j-h]:</span><br><span class="line">                arrList[j] ,arrList[j-h] = arrList[j-h],arrList[j]</span><br><span class="line">                j -= h</span><br><span class="line">        h  //= <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arrList = [<span class="number">14</span>,<span class="number">33</span>,<span class="number">27</span>,<span class="number">10</span>,<span class="number">35</span>,<span class="number">19</span>,<span class="number">42</span>,<span class="number">44</span>]</span><br><span class="line">    ShellSort(arrList)</span><br><span class="line">    print(arrList)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">shell_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h2><p><strong>给你一个整数数组 nums，请你将该数组升序排列。</strong></p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="5-归并排序-Merge-Sort-（重点）"><a href="#5-归并排序-Merge-Sort-（重点）" class="headerlink" title="5.归并排序  Merge_Sort （重点）"></a>5.归并排序  Merge_Sort （重点）</h2><p>算法思想：分而治之（分治思想）（Divide and Conquer）。<br>形象理解是「曹冲称象」、MapReduce，在一定情况下可以并行化。</p>
<p>算法描述：<br>把长度为n的输入序列中待排序数字分分成长度 n/2的子序列；<br>一直重复<br>直到每个子序列只包含一个数字，长度为一的数组是有序的<br>对两个子序列采用归并排序，合并为一个有序序列<br>反复归并，将若干个组两两合并，所有子序列。</p>
<p>直到只剩下一组，最后把另一个数组的剩余部分复制过来即可</p>
<p>让子序列有序，再将子序列间有序，</p>
<p>基本思路：是比较两个数组的最前面的数，<br>谁小就先取谁，取了后相应的指针就往后移一位。<br>然后再比较，直至一个数组为空，</p>
<p>例如：「力扣」第 88 题：合并两个有序数组。</p>
<p>「归并排序」是理解「递归思想」的非常好的学习材料，大家可以通过理解：<br>递归完成以后，合并两个有序数组的这一步骤，想清楚程序的执行流程。<br>即「递归函数执行完成以后，我们还可以做点事情」。</p>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(1)<br>稳定性：稳定</p>
<p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</p>
<p>思路<br>归并排序利用了分治的思想来对序列进行排序。对一个长为 n 的待排序的序列，我们将其分解成两个长度为 n/2 的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。</p>
<p>算法</p>
<p>定义 mergeSort(nums, l, r) 函数表示对 nums 数组里 [l,r] 的部分进行排序，整个函数流程如下：</p>
<ol>
<li><p>递归调用函数 mergeSort(nums, l, mid) 对 nums 数组里 [l,mid] 部分进行排序。</p>
</li>
<li><p>递归调用函数 mergeSort(nums, mid + 1, r) 对 nums 数组里 [mid+1,r] 部分进行排序。</p>
</li>
<li><p>此时 nums 数组里 [l,mid] 和 [mid+1,r] 两个区间已经有序，我们对两个有序区间线性归并即可使 nums 数组里 [l,r] 的部分有序。</p>
</li>
</ol>
<p>线性归并的过程，由于两个区间均有序，<br>所以我们维护两个指针 i 和 j 表示当前考虑到 [l,mid] 里的第 i 个位置和 [mid+1,r] 的第 j 个位置。</p>
<p>如果 nums[i] &lt; nums[j] ，那么我们就将 nums[i] 放入临时数组 tmp 中并让 i += 1 ，即指针往后移。否则我们就将 nums[j] 放入临时数组 tmp 中并让 j += 1 。<br>如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入 tmp 数组中即可。</p>
<p>这样能保证我们每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后 [l,r] 即为有序的。</p>
<p>函数递归调用的入口为 mergeSort(nums, 0, nums.length - 1)，递归结束当且仅当 l &gt;= r。</p>
<p>时间复杂度：O(nlogn)。由于归并排序每次都将当前待排序的序列折半成两个子序列递归调用，然后再合并两个有序的子序列，而每次合并两个有序的子序列需要 O(n) 的时间复杂度，所以我们可以列出归并排序运行时间 T(n) 的递归表达式：<br>T(n)=2T(n/2}) + O(n)<br>根据主定理我们可以得出归并排序的时间复杂度为 O(nlogn)。</p>
<p>空间复杂度：O(n)。我们需要额外 O(n) 空间的 tmp 数组，且归并排序递归调用的层数最深为 \log_2 ，所以我们还需要额外的 O(logn) 的栈空间，所需的空间复杂度即为 O(n+logn)=O(n)</p>
<p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/..%5C%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.gif"></p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        self.merge_sort(nums, l, mid)</span><br><span class="line">        self.merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        tmp = []</span><br><span class="line">        i, j = l, mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">or</span> j &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> i &gt; mid <span class="keyword">or</span> (j &lt;= r <span class="keyword">and</span> nums[j] &lt; nums[i]):</span><br><span class="line">                tmp.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        nums[l:r + <span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(solution.sortArray(array))</span><br><span class="line">    <span class="comment"># [1, 2, 2, 3, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">len(nums) - <span class="number">1</span> = <span class="number">6</span> - <span class="number">1</span> = <span class="number">5</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = <span class="number">5</span></span><br><span class="line">mid = (<span class="number">0</span> + <span class="number">5</span>) <span class="comment">// 2 = 2</span></span><br><span class="line"></span><br><span class="line">    merge_sort(nums, l, mid)</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="number">2</span></span><br><span class="line">    mid = (<span class="number">0</span> + <span class="number">2</span>) <span class="comment">// 2 = 1</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        merge_sort(nums, l, mid)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        mid = (<span class="number">0</span> + <span class="number">1</span>) <span class="comment">// 2 = 0</span></span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            merge_sort(nums, l, mid)</span><br><span class="line">            l = r = <span class="number">0</span></span><br><span class="line">            [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            递归到最深层</span><br><span class="line"></span><br><span class="line">        回到上一层的结果</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        mid = (<span class="number">0</span> + <span class="number">1</span>) <span class="comment">// 2 = 0</span></span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">            l = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span> = r</span><br><span class="line">            [<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            递归到最深层</span><br><span class="line"></span><br><span class="line">        回到上一层的结果</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        mid = (<span class="number">0</span> + <span class="number">1</span>) <span class="comment">// 2 = 0</span></span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        tmp = []</span><br><span class="line">        i = l = <span class="number">0</span> = mid </span><br><span class="line">        j = mid + <span class="number">1</span> = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span> = r </span><br><span class="line">        num[j] = nums[<span class="number">1</span>] = <span class="number">2</span> &gt; nums[i] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        tmp.append(nums[i])</span><br><span class="line">        tmp = [<span class="number">1</span>]</span><br><span class="line">        i = i + <span class="number">1</span> = <span class="number">1</span> &gt; mid = <span class="number">0</span></span><br><span class="line">        j = r</span><br><span class="line">        tmp.append(nums[j])</span><br><span class="line">        tmp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        j = j + <span class="number">1</span> = <span class="number">2</span> &gt; r = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums[l:r + <span class="number">1</span>] = tmp = [<span class="number">1</span>, <span class="number">2</span>]  # 切片左闭右开 </span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r + <span class="number">1</span> = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">        nums[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>]  # 切片左闭右开 </span><br><span class="line">        递归到最深层</span><br><span class="line"></span><br><span class="line">    回到上一层的结果</span><br><span class="line">    merge_sort(nums, l, mid)</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="number">2</span></span><br><span class="line">    mid = (<span class="number">0</span> + <span class="number">2</span>) <span class="comment">// 2 = 1</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        self.merge_sort(nums, l, mid)</span><br><span class="line">        已经执行过，不再执行</span><br><span class="line"></span><br><span class="line">        self.merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        l = mid + <span class="number">1</span> = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> = r</span><br><span class="line">        [<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">        递归到最深层</span><br><span class="line"></span><br><span class="line">    回到上一层的结果</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="number">2</span></span><br><span class="line">    mid = (<span class="number">0</span> + <span class="number">2</span>) <span class="comment">// 2 = 1</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    tmp = []</span><br><span class="line">    i = l = <span class="number">0</span> &lt; mid = <span class="number">1</span></span><br><span class="line">    j = mid + <span class="number">1</span> = <span class="number">2</span> = r</span><br><span class="line"></span><br><span class="line">    num[j] = nums[<span class="number">2</span>] = <span class="number">3</span> &gt; nums[i] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    tmp.append(nums[i])</span><br><span class="line">    tmp = [<span class="number">1</span>]</span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">1</span> = mid</span><br><span class="line">    tmp.append(nums[i])</span><br><span class="line">    tmp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">2</span> &gt; mid</span><br><span class="line">    tmp.append(nums[j])</span><br><span class="line">    tmp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    j = j + <span class="number">1</span> = <span class="number">3</span> &gt; r 退出循环</span><br><span class="line"></span><br><span class="line">    nums[l:r + <span class="number">1</span>] = tmp </span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    nums[<span class="number">0</span>:<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    递归到最深层</span><br><span class="line"></span><br><span class="line">回到上一层的结果</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = <span class="number">5</span></span><br><span class="line">mid = (<span class="number">0</span> + <span class="number">5</span>) <span class="comment">// 2 = 2</span></span><br><span class="line"></span><br><span class="line">    self.merge_sort(nums, l, mid)</span><br><span class="line">    不执行</span><br><span class="line"></span><br><span class="line">    self.merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">    l = mid + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> </span><br><span class="line">    r = <span class="number">5</span></span><br><span class="line">    mid = (<span class="number">3</span> + <span class="number">5</span>) <span class="comment">// 2 = 4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">        self.merge_sort(nums, l, mid)</span><br><span class="line">        l = <span class="number">3</span> </span><br><span class="line">        r = <span class="number">4</span></span><br><span class="line">        mid = (<span class="number">3</span> + <span class="number">4</span>) <span class="comment">// 2 = 3</span></span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">            self.merge_sort(nums, l, mid)</span><br><span class="line">            l = <span class="number">3</span> = r </span><br><span class="line">            [<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            递归到最深层</span><br><span class="line"></span><br><span class="line">        回到上一层的结果</span><br><span class="line">        l = <span class="number">3</span> </span><br><span class="line">        r = <span class="number">4</span></span><br><span class="line">        mid = (<span class="number">3</span> + <span class="number">4</span>) <span class="comment">// 2 = 3</span></span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">            self.merge_sort(nums, l, mid)</span><br><span class="line">            不执行</span><br><span class="line">            self.merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">            l = mid + <span class="number">1</span> = <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> = r </span><br><span class="line">            [<span class="number">5</span>]</span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">            递归到最深层</span><br><span class="line"></span><br><span class="line">        回到上一层的结果</span><br><span class="line">        l = <span class="number">3</span> </span><br><span class="line">        r = <span class="number">4</span></span><br><span class="line">        mid = (<span class="number">3</span> + <span class="number">4</span>) <span class="comment">// 2 = 3</span></span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        tmp = []</span><br><span class="line">        i = l = <span class="number">3</span> = mid </span><br><span class="line">        j = mid + <span class="number">1</span> = <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> = r </span><br><span class="line">        num[j] = nums[<span class="number">4</span>] = <span class="number">5</span> &gt; nums[i] = nums[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">        tmp.append(nums[i])</span><br><span class="line">        tmp = [<span class="number">2</span>]</span><br><span class="line">        i = i + <span class="number">1</span> = <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> &gt; mid = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        tmp.append(nums[j])</span><br><span class="line">        tmp = [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">        j = j + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span> &gt; r = <span class="number">4</span></span><br><span class="line">        跳出循环</span><br><span class="line"></span><br><span class="line">        nums[l:r + <span class="number">1</span>] = tmp  # 切片左闭右开 </span><br><span class="line">        l = <span class="number">3</span></span><br><span class="line">        r + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span></span><br><span class="line">        nums[<span class="number">3</span>:<span class="number">5</span>] = [<span class="number">2</span>, <span class="number">5</span>]  # 切片左闭右开</span><br><span class="line">        递归到最深层</span><br><span class="line"></span><br><span class="line">    回到上一层</span><br><span class="line">    l = mid + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> </span><br><span class="line">    r = <span class="number">5</span></span><br><span class="line">    mid = (<span class="number">3</span> + <span class="number">5</span>) <span class="comment">// 2 = 4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">        self.merge_sort(nums, l, mid)</span><br><span class="line">        不再执行</span><br><span class="line"></span><br><span class="line">        self.merge_sort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        l = mid + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span> = r </span><br><span class="line">        [<span class="number">6</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        递归到最深层</span><br><span class="line"></span><br><span class="line">    回到上一层</span><br><span class="line">    l = mid + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> </span><br><span class="line">    r = <span class="number">5</span></span><br><span class="line">    mid = (<span class="number">3</span> + <span class="number">5</span>) <span class="comment">// 2 = 4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    tmp = []</span><br><span class="line">    i = l = <span class="number">3</span> &lt; mid = <span class="number">4</span></span><br><span class="line">    j = mid + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span> = r </span><br><span class="line">    num[j] = nums[<span class="number">5</span>] = <span class="number">6</span> &gt; nums[i] = nums[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">    tmp.append(nums[i])</span><br><span class="line">    tmp = [<span class="number">2</span>]</span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> = mid = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    tmp.append(nums[i])</span><br><span class="line">    tmp = [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span> &gt; mid = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    tmp.append(nums[i])</span><br><span class="line">    tmp = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]    </span><br><span class="line">    j = j + <span class="number">1</span> = <span class="number">6</span> &gt; r</span><br><span class="line"></span><br><span class="line">    nums[l:r + <span class="number">1</span>] = tmp  # 切片左闭右开  </span><br><span class="line">    l = <span class="number">3</span></span><br><span class="line">    r + <span class="number">1</span> = <span class="number">5</span> + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">    nums[<span class="number">3</span>:<span class="number">6</span>] = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]  # 切片左闭右开</span><br><span class="line">    递归到最深层</span><br><span class="line"></span><br><span class="line">回到上一层的结果</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = <span class="number">5</span></span><br><span class="line">mid = (<span class="number">0</span> + <span class="number">5</span>) <span class="comment">// 2 = 2</span></span><br><span class="line"></span><br><span class="line">tmp = []</span><br><span class="line">i = l = <span class="number">0</span> &lt; mid = <span class="number">2</span></span><br><span class="line">j = mid + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> &lt; r = <span class="number">5</span></span><br><span class="line">num[j] = nums[<span class="number">3</span>] = <span class="number">2</span> &gt; nums[i] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">tmp.append(nums[i])</span><br><span class="line">tmp = [<span class="number">1</span>]</span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span> &lt; mid = <span class="number">2</span></span><br><span class="line">tmp.append(nums[i])</span><br><span class="line">tmp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> = mid = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tmp.append(nums[j])</span><br><span class="line">tmp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">j = j + <span class="number">1</span> = <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> &lt; r = <span class="number">5</span></span><br><span class="line">num[j] = nums[<span class="number">4</span>] = <span class="number">5</span> &gt; nums[i] = nums[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">tmp.append(nums[i])</span><br><span class="line">tmp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> &gt; mid = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tmp.append(nums[j])</span><br><span class="line">tmp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">j = j + <span class="number">1</span> = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span> = r = <span class="number">5</span></span><br><span class="line">num[j] = nums[<span class="number">5</span>] = <span class="number">6</span> &gt; nums[i] = nums[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tmp.append(nums[j])</span><br><span class="line">tmp = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">j = j + <span class="number">1</span> = <span class="number">5</span> + <span class="number">1</span> = <span class="number">6</span> &gt; r = <span class="number">5</span></span><br><span class="line">跳出循环</span><br><span class="line"></span><br><span class="line">nums[l:r + <span class="number">1</span>] = tmp  # 切片左闭右开 </span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r + <span class="number">1</span> = <span class="number">5</span> + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">nums[<span class="number">0</span>:<span class="number">6</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]  # 切片左闭右开</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span>(<span class="params">arrayList</span>):</span></span><br><span class="line">    arrayLen = len(arrayList)</span><br><span class="line">    <span class="comment">#判断输入参数的正确性,如果长度小于1，就说明为1</span></span><br><span class="line">    <span class="keyword">if</span> arrayLen &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arrayList</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    midIndex = arrayLen // <span class="number">2</span></span><br><span class="line">    <span class="comment">#左边的部分去做 MergeSort</span></span><br><span class="line">    leftArray = MergeSort(arrayList[:midIndex])</span><br><span class="line">    <span class="comment">#右边的去做 MergeSort</span></span><br><span class="line">    rightArray = MergeSort(arrayList[midIndex:])</span><br><span class="line">    <span class="comment">#将左右两边合并，称为一个新的数组，并已经排序成功</span></span><br><span class="line">    retArray = MergeCore(leftArray, rightArray)</span><br><span class="line">    <span class="keyword">return</span> retArray</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeCore</span>(<span class="params">leftArray, rightArray</span>):</span></span><br><span class="line">    <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="comment">#首先需要定义两个指针,这两个指针，分别指向这两个数组的第一个元素</span></span><br><span class="line">    leftIndex = <span class="number">0</span></span><br><span class="line">    rightIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">#获取两个数组的长度，用于指出上面两个指针的边界是什么</span></span><br><span class="line">    leftLen = len(leftArray)</span><br><span class="line">    rightLen = len(rightArray)</span><br><span class="line">    <span class="comment">#定义一个返回的列表,这一步就代表空间复杂度至少是 O(n)</span></span><br><span class="line">    retList = []</span><br><span class="line">    <span class="comment">#循环两个数组寻找最小值加入到返回值的数组中</span></span><br><span class="line">    <span class="keyword">while</span> leftIndex &lt; leftLen <span class="keyword">and</span> rightIndex &lt; rightLen:</span><br><span class="line">        <span class="keyword">if</span> leftArray[leftIndex] &lt; rightArray[rightIndex]:</span><br><span class="line">            retList.append(leftArray[leftIndex])</span><br><span class="line">            leftIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            retList.append(rightArray[rightIndex])</span><br><span class="line">            rightIndex += <span class="number">1</span></span><br><span class="line">    <span class="comment">#下面的代码是将剩余的数组中内容放置在返回的数组中</span></span><br><span class="line">    retList.extend(leftArray[leftIndex:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># while leftIndex &lt; leftLen:</span></span><br><span class="line">    <span class="comment">#     retList.append(leftArray[leftIndex])</span></span><br><span class="line">    <span class="comment">#     leftIndex += 1</span></span><br><span class="line"></span><br><span class="line">    retList.extend(rightArray[rightIndex:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># while rightIndex &lt; rightLen:</span></span><br><span class="line">    <span class="comment">#     retList.append(rightArray[rightIndex])</span></span><br><span class="line">    <span class="comment">#     rightIndex += 1</span></span><br><span class="line">    <span class="keyword">return</span> retList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    retList = MergeSort([<span class="number">14</span>, <span class="number">33</span>, <span class="number">27</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">19</span>, <span class="number">42</span>, <span class="number">44</span>])</span><br><span class="line">    print(retList)  <span class="comment"># [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__merge</span>(<span class="params">arrList, l, mid, r</span>):</span></span><br><span class="line">    <span class="comment"># 将arr[l...mid]和arr[mid + 1...r]两部分进行归并</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一段辅助的临时空间，大小为r-l+1</span></span><br><span class="line">    aux = [<span class="literal">None</span>]*(r-l+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 将当前要处理的arrList中的元素复制到aux中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># aux从0开始，要处理的元素从l开始，中间有个l的偏移量。</span></span><br><span class="line">        aux[i-l] = arrList[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 两个指针</span></span><br><span class="line">    i = l</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 寻找arrList[k]处的元素</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(l, r+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; mid:</span><br><span class="line">            arrList[k] = aux[j-l]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> j &gt; r:</span><br><span class="line">            arrList[k] = aux[i-l]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> aux[i-l] &lt;= aux[j-l]:</span><br><span class="line">            arrList[k] = aux[i-l]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arrList[k] = aux[j-l]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mergeSort</span>(<span class="params">arrList, l, r</span>):</span></span><br><span class="line">    <span class="comment"># 递归使用归并排序, 对arr[l...r]的范围进行排序</span></span><br><span class="line">    <span class="comment"># 处理递归到底的情况</span></span><br><span class="line">    <span class="comment"># 当l &lt; r时，至少有两个元素需要处理</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    当粒度小到一定程度时，使用插入排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if r-l &lt; 15:</span></span><br><span class="line"><span class="string">        insertinSort(arrList, l, r)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最小粒度拆分</span></span><br><span class="line">    <span class="comment"># 对分开的左右两部分进行归并排序</span></span><br><span class="line">    mid = int((l+r)/<span class="number">2</span>)</span><br><span class="line">    __mergeSort(arrList, l, mid)</span><br><span class="line">    __mergeSort(arrList, mid+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行归并排序之后，已经保证每个部分都是有序的</span></span><br><span class="line">    <span class="comment"># 仅当arrList[mid] &gt; arrList[mid+1]的时候，才需要进行merge操作</span></span><br><span class="line">    <span class="comment"># 对l-&gt;mid和mid+1-&gt;r进行merge操作</span></span><br><span class="line">    <span class="keyword">if</span> arrList[mid] &gt; arrList[mid+<span class="number">1</span>]:</span><br><span class="line">        __merge(arrList, l, mid, r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arrList</span>):</span></span><br><span class="line">    __mergeSort(arrList, <span class="number">0</span>, len(arrList)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">mergeSort(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [1, 1, 2, 3, 3, 4, 4, 5, 7, 8]</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="6-快速排序-Quick-sort"><a href="#6-快速排序-Quick-sort" class="headerlink" title="6.快速排序 Quick sort"></a>6.快速排序 Quick sort</h2><p>通过一趟排序划分将待排序的序列分成前后两部分，<br>其中前一部分的数据都比后一部分的数据要小，<br>然后再递归调用此方法对这两部分序列分别进行快速排序，以此使整个序列达到有序。</p>
<p>快速排序没有指定应如何具体实现第一步，不论是选择主元 pivot 的过程还是划分的过程，都有不止一种实现方法。</p>
<p>步骤为：</p>
<ol>
<li>在每一次 partition 之前，选一个元素作为切分元素 pivot，称为“基准”“主元”“分界点”，可以选择nums[left] 或随机<br>交换它与第 1 个或最后 1 个元素的位置，随机元素作为左端“标定点”元素的原因是为了避免极端测试用例，避免递归树加深、达不到减治的效果：</li>
</ol>
<ul>
<li><p>性能和「划分」出的子数组的长度密切相关。</p>
</li>
<li><p>最差的情况就是 pivot 被选在了数组的两侧。顺序数组与倒序数组就是这种最差的情况，<br>此时递归树画出来是链表，排序的“递归结构”就变成了“线性结构”，这个时候就很像选择排序，或者是冒泡排序了， 《算法4》这本书上有说，也可以取三个元素的中位数。<br>例如：例如“顺序数组” [1, 2, 3, 4, 5] 的 partition 过程，就是线性搜索，<br>如果找第 1 大元素，就得一个一个地看，看到末尾。<br>直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n - 1，<br>每次递归的时候又向 n−1 的集合中递归，<br>而导致时间复杂度退化为 O(N)，快速排序的最坏运行情况是 O(n ^ 2)<br>出现最坏情况的概率是： 1/1 * 1/2 * 1/3 * … 1/n，这个值非常小了。<br>讨论最坏情况意义不大，所以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，<br>证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。<br>快速排序的 平摊期望时间复杂度是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。<br>对绝大多数顺序性较弱的随机数列而言，是目前基于比较的内部排序中被认为是最好的方法，</p>
</li>
<li><p>最理想的情况是 快速排序每一次选择的 pivot 它最后会被交换到数组中间的部分，这样后面递归的部分，每一个小组的数据不用跟另外小组的数据比较，需要比较的元素就会减少，因此速度较快</p>
</li>
</ul>
<ol start="2">
<li>算法思想：分而治之（分治思想），不像「归并排序」无脑地一分为二，<br>把问题规模转化到一个更小的范围里，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。</li>
</ol>
<ul>
<li><p>partition 切分、分区：将数组 nums[left⋯right] 分成两个子数组 nums[left⋯j−1]、nums[j+1⋯right]，使得 </p>
<ul>
<li><p>nums[left⋯j−1] 中的每个元素小于等于 nums[j]，分割点左侧的数全部不大于基准值，所有元素比基准值小的摆放在基准前面，</p>
</li>
<li><p>nums[j] 小于等于 nums[j+1⋯right] 中的每个元素。右侧的数全部不小于分割点的数。所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。</p>
</li>
<li><p>计算下标 j 也是「划分」过程的一部分。</p>
</li>
<li><p>解决：通过递归调用快速排序，对子数组 nums[left⋯j−1] 和 nums[j+1⋯right] 进行排序。</p>
</li>
<li><p>因为子数组都是原址排序的，所以没有「合」的合并操作，nums[left⋯right] 已经完全有序。已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。</p>
</li>
</ul>
</li>
</ul>
<p>即基准元素 pivot = nums[j] 每次经过 partition 切分操作以后会放置在它 “最终应该放置的地方”索引为 j，</p>
<blockquote>
<p>至于 a[left⋯j−1] 和 a[j+1⋯right] 是否是有序的，我们不关心。</p>
</blockquote>
<p>切分过程可以不借助额外的数组空间，仅通过交换数组元素实现。</p>
<ol start="3">
<li>递归（recursive）地处理左右两段，把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归的最底部情形，是数列的大小是零或一，即直至排序区间为 0 时完成排序，也就是永远都已经被排序好了。<br>虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去，使数组中的每个数成为基准。</li>
</ol>
<p>快排一轮递归，再对分割点左右两侧的子数组成为独立两组数据，分别再像之前一样定一个pivot，比较，分组，如此类推。</p>
<p>保持「循环不变量」，<br>即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，<br>这个性质是人为根据问题特点定义的。<br>「循环不变量」是证明算法有效性的基础，更是写对代码的保证，<br>是不是该写等于号，先交换还是先 ++ ，就会特别清楚，绝对不会写错，<br>快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」</p>
<h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><ol>
<li><p>选中列表第一个元素nums[start] 为基准值 pivot，定义两个左右指针 left 指向左边表头和 right 指向右边表尾，</p>
</li>
<li><p>因为分界点选的第一个是最左边，所以不从左边开始而是从右向左找比这个值要大的数，找到就停止，否则指针继续向左移动一个位置，直到找到或者已经比左指针位置小。首先从 right 所指位置起向前 (表头方向)直到搜索出第一个小于关键字元素和pivot基准值相互交换；</p>
</li>
<li><p>从左向右找比这个值要小的数，找到就停止，否则指针继续向右移动一个位置，直到找到或者已经比右指针位置大。然后从 left 所指位置起向后 (表尾方向)直到搜索出第一个大于基准值元素和pivot基准值相互交换。重复这两步知道 left=right为止。</p>
</li>
<li><p>然后交换这两个数字的位置。<br>重复2 3 4 步骤，直到左指针位置已经不再小于右指针位置</p>
</li>
<li><p>然后将中值和现在的左指针或者右指针位置的数 交换位置<br>此时这个数组，就已经以中值为界限，中值左边的均小于中值，中值右边的均大于中值</p>
</li>
<li><p>最后递归重复以上的所有步骤 即可将一个无序数组完整的排序。<br>分别递归左侧列表，右侧列表<br>while里面套两个while循环，从左往右一个while，从右往左一个while<br>将所有大于 nums[start] 的数放到 nums[start] 右边，所有小于 nums[start] 的数放到 nums[start] 左边</p>
</li>
</ol>
<p>跟 start 还是 end 比取决于我们把哪个元素看作”哨兵“，跟 end 比也可以，<br>如果要用 end ，哨兵 i, j 的移动先后顺序也要对换<br>因为最后要把 nums[i], nums[start] 交换，因此要保证 ``nums[i] &gt; nums[start]` （和 end 的情况正好相反），这样交换后才符合快排定义。</p>
<p>维护一前一后两个指针 p 和 q ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针  遇到了一个比  小的数，那么可以交换  和  位置上的数，再把  向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。</p>
<p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/..%5C%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%BF%AB%E6%8E%92%E6%95%B0%E7%BB%84%E5%89%8D%E5%90%8E%E5%8F%8C%E6%8C%87%E9%92%88.jpg"></p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="comment"># 递归过程中发现start和end一致时，停止递归，直接返回列表</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 设定待排数组第一个元素为要寻找位置的基准元素</span></span><br><span class="line">            pivot = nums[start]</span><br><span class="line">            <span class="comment"># left为序列左边的由左向右移动的指针</span></span><br><span class="line">            left = start</span><br><span class="line">            <span class="comment"># right为序列右边的由右向左移动的指针</span></span><br><span class="line">            right = end</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当left = right，退出循环</span></span><br><span class="line">                <span class="comment"># 如果left与right未重合，right指向的元素不比基准元素小</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= pivot:</span><br><span class="line">                    <span class="comment"># right先往左移，直到找到一个比基准值小的元素</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上</span></span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果left与right未重合，left指向的元素比基准元素小，</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; pivot:</span><br><span class="line">                    <span class="comment"># 则left向右移动，直到找到一个比基准值大的元素</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上</span></span><br><span class="line">                nums[right] = nums[left]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 退出循环后，left与right重合，用哪个都一样，</span></span><br><span class="line">            nums[left] = pivot  <span class="comment"># 此时所指位置为基准元素的正确位置</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                pivot = partition(left, right)</span><br><span class="line">                <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">                quick_sort(left, pivot - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">                quick_sort(pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        quick_sort(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    array = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    print(solution.sortArray(array))</span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nums待排序列表，start第一个元素下标值为0，end最后一个元素下标值len(nums)-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, start, end</span>):</span></span><br><span class="line">    <span class="comment"># 递归过程中发现start和end一致时，停止递归，直接返回列表</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 设定待排数组第一个元素为要寻找位置的基准元素</span></span><br><span class="line">    pivot = nums[start]</span><br><span class="line">    <span class="comment"># left为序列左边的由左向右移动的指针</span></span><br><span class="line">    left = start</span><br><span class="line">    <span class="comment"># right为序列右边的由右向左移动的指针</span></span><br><span class="line">    right = end</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当left = right，退出循环</span></span><br><span class="line">        <span class="comment"># 如果left与right未重合，right指向的元素不比基准元素小</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= pivot:</span><br><span class="line">            <span class="comment"># right往左移,直到找到一个比基准值小的元素</span></span><br><span class="line">            right -= <span class="number">1</span>   <span class="comment"># 先移动 right</span></span><br><span class="line">        <span class="comment"># 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left与right未重合，left指向的元素比基准元素小，</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; pivot:</span><br><span class="line">            <span class="comment"># 则left向右移动，直到找到一个比基准值大的元素</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出循环后，left与right重合用哪个都一样，</span></span><br><span class="line">    nums[left] = pivot  <span class="comment"># 此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(nums, start, left - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(nums, left + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">quick_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">pivot = nums[start] = nums[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">left = start = <span class="number">0</span></span><br><span class="line">right = end = <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">进入外循环</span><br><span class="line">    nums[right] = nums[<span class="number">5</span>] = <span class="number">5</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        right = right - <span class="number">1</span> = <span class="number">1</span> = <span class="number">4</span></span><br><span class="line">        nums[right] = nums[<span class="number">4</span>] = <span class="number">2</span> &lt; pivot = <span class="number">3</span>:</span><br><span class="line">        不进入子循环</span><br><span class="line">    nums[left] = nums[right] = nums[<span class="number">0</span>] = nums[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    nums[left] = nums[<span class="number">0</span>] = <span class="number">2</span> &lt; pivot = <span class="number">3</span></span><br><span class="line">        left = left + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        nums[left] = nums[<span class="number">1</span>] = <span class="number">4</span> &gt; pivot = <span class="number">3</span></span><br><span class="line">        不进入子循环</span><br><span class="line">    nums[right] = nums[left] = nums[<span class="number">4</span>] = nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    nums[right] = nums[<span class="number">4</span>] = <span class="number">4</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        right = right - <span class="number">1</span> = <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">        nums[right] = nums[<span class="number">3</span>] = <span class="number">1</span> &lt; pivot = <span class="number">3</span>:</span><br><span class="line">        不进入子循环</span><br><span class="line">    nums[left] = nums[right] = nums[<span class="number">1</span>] = nums[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    nums[left] = nums[<span class="number">1</span>] = <span class="number">1</span> &lt; pivot = <span class="number">3</span></span><br><span class="line">        left = left + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">        nums[left] = nums[<span class="number">2</span>] = <span class="number">6</span> &gt; pivot = <span class="number">3</span></span><br><span class="line">        不进入子循环</span><br><span class="line">    nums[right] = nums[left] = nums[<span class="number">3</span>] = nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    nums[right] = nums[<span class="number">3</span>] = <span class="number">6</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        right = right - <span class="number">1</span> = <span class="number">1</span> = <span class="number">2</span> = left</span><br><span class="line">退出外循环</span><br><span class="line">nums[left] = pivot = nums[<span class="number">2</span>] = <span class="number">3</span>  </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">切分元素 pivot = <span class="number">3</span> 交换到它排序以后最终确定的位置上</span><br></pre></td></tr></tbody></table></figure>

<p>跟 l 还是 r 比取决于我们把哪个元素看作”哨兵“，<br>如果要用 r ，哨兵 i, j 的移动先后顺序也要对换<br>因为最后要把 strs[i], strs[r] 交换，因此要保证 ``strs[i] &gt; strs[r]` （和 l 的情况正好相反），这样交换后才符合快排定义。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="comment"># 递归过程中发现start和end一致时，停止递归，直接返回列表</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 设定待排数组第一个元素为要寻找位置的基准元素</span></span><br><span class="line">            pivot = nums[end]</span><br><span class="line">            <span class="comment"># left为序列左边的由左向右移动的指针</span></span><br><span class="line">            left = start</span><br><span class="line">            <span class="comment"># right为序列右边的由右向左移动的指针</span></span><br><span class="line">            right = end</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当left = right，退出循环</span></span><br><span class="line">                <span class="comment"># 如果left与right未重合，left指向的元素比基准元素小，</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; pivot:</span><br><span class="line">                    <span class="comment"># 则left向右移动，直到找到一个比基准值大的元素</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上</span></span><br><span class="line">                nums[right] = nums[left]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果left与right未重合，right指向的元素不比基准元素小</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= pivot:</span><br><span class="line">                    <span class="comment"># right先往左移，直到找到一个比基准值小的元素</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上</span></span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 退出循环后，left与right重合，用哪个都一样，</span></span><br><span class="line">            nums[left] = pivot  <span class="comment"># 此时所指位置为基准元素的正确位置</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                pivot = partition(left, right)</span><br><span class="line">                <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">                quick_sort(left, pivot - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">                quick_sort(pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        quick_sort(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    array = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    print(solution.sortArray(array))</span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, start, end</span>):</span></span><br><span class="line">    <span class="comment"># 递归过程中发现start和end一致时，停止递归，直接返回列表</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 设定待排数组倒数第一个元素为要寻找位置的基准元素</span></span><br><span class="line">    pivot = nums[end]</span><br><span class="line">    <span class="comment"># left为序列左边的由左向右移动的指针</span></span><br><span class="line">    left = start</span><br><span class="line">    <span class="comment"># right为序列右边的由右向左移动的指针</span></span><br><span class="line">    right = end</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 当left = right，退出循环</span></span><br><span class="line">        <span class="comment"># 如果left与right未重合，left指向的元素比基准元素小，</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; pivot:</span><br><span class="line">            <span class="comment"># 则left向右移动，直到找到一个比基准值大的元素</span></span><br><span class="line">            left += <span class="number">1</span>   <span class="comment"># 先移动 left</span></span><br><span class="line">        <span class="comment"># 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果left与right未重合，right指向的元素不比基准元素小</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= pivot:</span><br><span class="line">            <span class="comment"># right往左移,直到找到一个比基准值小的元素</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出循环后，left与right重合用哪个都一样，</span></span><br><span class="line">    nums[left] = pivot  <span class="comment"># 此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(nums, start, left - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(nums, left + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">quick_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            randidx = random.randint(left, right)</span><br><span class="line">            nums[left], nums[randidx] = nums[randidx], nums[left]</span><br><span class="line"></span><br><span class="line">            pivot = nums[left]</span><br><span class="line">            l = left + <span class="number">1</span></span><br><span class="line">            r = right</span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                <span class="keyword">while</span> l &lt;= r <span class="keyword">and</span> nums[l] &lt;= pivot:</span><br><span class="line">                    <span class="comment"># l 指向数字肯定比 pivot 大</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt;= r <span class="keyword">and</span> nums[r] &gt;= pivot:</span><br><span class="line">                    <span class="comment"># r 指向数字肯定比 pivot 小</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            <span class="comment"># r 和 left 互换, r为 pivot</span></span><br><span class="line">            nums[r], nums[left] = nums[left], nums[r]</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                pivot = partition(left, right)</span><br><span class="line">                quicksort(left, pivot - <span class="number">1</span>)</span><br><span class="line">                quicksort(pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        quicksort(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    array = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    print(solution.sortArray(array))</span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">quicksort(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">quicksort(<span class="number">0</span>, <span class="number">6</span> - <span class="number">1</span>)</span><br><span class="line">quicksort(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">left = <span class="number">0</span> &lt; right = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">partition(left, right)</span><br><span class="line">randidx = <span class="number">0</span>  随机取到最左边</span><br><span class="line">nums[left] = nums[randidx] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">nums[randidx] = nums[left] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">pivot = nums[left] = <span class="number">3</span></span><br><span class="line">l = left + <span class="number">1</span> = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">r = right = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">l = <span class="number">1</span> &lt; r = <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">1</span> &lt; r = <span class="number">5</span> <span class="keyword">and</span> nums[l] = nums[<span class="number">1</span>] = <span class="number">4</span> &gt; pivot = <span class="number">3</span></span><br><span class="line">        不进入循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">1</span> &lt; r = <span class="number">5</span> <span class="keyword">and</span> nums[r] = nums[<span class="number">5</span>] = <span class="number">5</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        r = r - <span class="number">1</span> = <span class="number">4</span></span><br><span class="line">        <span class="keyword">while</span> l = <span class="number">1</span> &lt; r = <span class="number">4</span> <span class="keyword">and</span> nums[r] = nums[<span class="number">4</span>] = <span class="number">2</span> &lt; pivot = <span class="number">3</span>:</span><br><span class="line">        退出子循环</span><br><span class="line"></span><br><span class="line">    nums[l] = nums[r] = nums[<span class="number">1</span>] = nums[<span class="number">4</span>] = <span class="number">2</span></span><br><span class="line">    nums[r] = nums[l] = nums[<span class="number">4</span>] = nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">1</span> &lt; r = <span class="number">4</span> <span class="keyword">and</span> nums[l] = nums[<span class="number">1</span>] = <span class="number">2</span> &lt; pivot = <span class="number">3</span></span><br><span class="line">    l = l + <span class="number">1</span> = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">2</span> &lt; r = <span class="number">4</span> <span class="keyword">and</span> nums[l] = nums[<span class="number">2</span>] = <span class="number">6</span> &gt; pivot = <span class="number">3</span></span><br><span class="line">        不进入循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">2</span> &lt; r = <span class="number">4</span> <span class="keyword">and</span> nums[r] = nums[<span class="number">4</span>] = <span class="number">4</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        r = r - <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> l = <span class="number">2</span> &lt; r = <span class="number">3</span> <span class="keyword">and</span> nums[r] = nums[<span class="number">3</span>] = <span class="number">1</span> &lt; pivot = <span class="number">3</span>:</span><br><span class="line">        退出子循环</span><br><span class="line"></span><br><span class="line">    nums[l] = nums[r] = nums[<span class="number">2</span>] = nums[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">    nums[r] = nums[l] = nums[<span class="number">3</span>] = nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">2</span> &lt; r = <span class="number">3</span> <span class="keyword">and</span> nums[l] = nums[<span class="number">2</span>] = <span class="number">1</span> &lt; pivot = <span class="number">3</span></span><br><span class="line">    l = l + <span class="number">1</span> = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">3</span> = r <span class="keyword">and</span> nums[l] = nums[<span class="number">3</span>] = <span class="number">6</span> &gt; pivot = <span class="number">3</span></span><br><span class="line">        不进入循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">3</span> = r <span class="keyword">and</span> nums[r] = nums[<span class="number">3</span>] = <span class="number">6</span> &gt; pivot = <span class="number">3</span>:</span><br><span class="line">        r = r - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> l = <span class="number">3</span> &gt; r = <span class="number">2</span> <span class="keyword">and</span> nums[r] = nums[<span class="number">2</span>] = <span class="number">1</span> &lt; pivot = <span class="number">3</span>:</span><br><span class="line">        退出子循环</span><br><span class="line"></span><br><span class="line">l = <span class="number">3</span> &gt; r = <span class="number">2</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">nums[r] = nums[left] = nums[<span class="number">2</span>] = nums[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">nums[left] = nums[r] = nums[<span class="number">0</span>] = nums[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">切分元素 pivot = <span class="number">3</span> 交换到它排序以后最终确定的位置上</span><br><span class="line"><span class="keyword">return</span> r = <span class="number">2</span></span><br><span class="line">pivot = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">quicksort(left, pivot - <span class="number">1</span>)</span><br><span class="line">    quicksort(<span class="number">0</span>, <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">    quicksort(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    partition(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    left = <span class="number">0</span> </span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    randidx = random.randint(left, right)</span><br><span class="line">    randidx = random.randint(<span class="number">0</span>, <span class="number">1</span>) 取不到后面的<span class="number">2</span>~<span class="number">5</span></span><br><span class="line">    randidx = <span class="number">0</span>  随机取到最左边</span><br><span class="line">    nums[left] = nums[randidx] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    nums[randidx] = nums[left] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    pivot = nums[left] = <span class="number">1</span></span><br><span class="line">    l = left + <span class="number">1</span> = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    r = right = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    l = <span class="number">1</span> = r:</span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">1</span> = r <span class="keyword">and</span> nums[l] = nums[<span class="number">1</span>] = <span class="number">2</span> &gt; pivot = <span class="number">1</span></span><br><span class="line">        不进入循环</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l = <span class="number">1</span> = r <span class="keyword">and</span> nums[r] = nums[<span class="number">1</span>] = <span class="number">2</span> &gt; pivot = <span class="number">1</span>:</span><br><span class="line">        r = r - <span class="number">1</span> = <span class="number">0</span> &lt; l = <span class="number">1</span></span><br><span class="line">    l = <span class="number">1</span> &gt; r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">break</span>    </span><br><span class="line">    nums[r] = nums[left] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    nums[left] = nums[r] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    切分元素 pivot = <span class="number">1</span> 交换到它排序以后最终确定的位置上</span><br><span class="line">    <span class="keyword">return</span> r = <span class="number">0</span></span><br><span class="line">    pivot = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    quicksort(left, pivot - <span class="number">1</span>)</span><br><span class="line">        quicksort(<span class="number">0</span>, <span class="number">0</span> - <span class="number">1</span>)</span><br><span class="line">        quicksort(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">        left = <span class="number">0</span> &gt; right = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    quicksort(pivot + <span class="number">1</span>, right)</span><br><span class="line">        quicksort(<span class="number">0</span> + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        left = <span class="number">1</span> = right</span><br><span class="line"></span><br><span class="line">quicksort(pivot + <span class="number">1</span>, right)</span><br><span class="line">    quicksort(<span class="number">2</span> + <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    quicksort(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    partition(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    randidx = random.randint(left, right)</span><br><span class="line">    randidx = random.randint(<span class="number">3</span>, <span class="number">5</span>)区间，取不到前面的<span class="number">0</span>~<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>方法三<br>我们定义函数 randomized_quicksort(nums, l, r) 为对 nums 数组里 [l,r] 的部分进行排序，每次先调用 randomized_partition 函数对 nums 数组里 [l,r] 的部分进行划分，并返回分界值的下标 pos，然后按上述将的递归调用 randomized_quicksort(nums, l, pos - 1) 和 randomized_quicksort(nums, pos + 1, r) 即可。</p>
<p>这里我们采用随机的方式，对当前划分区间 [l,r] 里的数等概率随机一个作为我们的主元，<br>再将主元放到区间末尾，进行划分。</p>
<p>整个划分函数 partition 主要涉及两个指针 i 和 j，<br>一开始 i = l - 1，j = l。<br>实时维护两个指针使得任意时候对于任意数组下标 k，我们有如下条件成立：</p>
<ol>
<li>l ≤ k ≤ i 时，nums[k] ≤ pivot。</li>
<li>i+1 ≤ k ≤ j−1 时，nums[k] &gt; pivot。</li>
<li>k == r 时，nums[k] = pivot。</li>
</ol>
<p>我们每次移动指针 j ，如果 nums[j] &gt; pivot，我们只需要继续移动指针 j ，即能使上述三个条件成立，否则我们需要将指针 i 加一，然后交换 nums[i] 和 nums[j]，再移动指针 j 才能使得三个条件成立。</p>
<p>当 j 移动到 r−1 时结束循环，此时我们可以由上述三个条件知道 [l,i] 的数都小于等于主元 pivot，[i+1,r−1] 的数都大于主元 pivot，那么我们只要交换 nums[i+1] 和 nums[r] ，即能使得 [l,i+1] 区间的数都小于 [i+2,r] 区间的数，完成一次划分，且分界值下标为 i+1，返回即可。</p>
<p>如下的动图展示了一次划分的过程，刚开始随机选了 4 作为主元，与末尾元素交换后开始划分：</p>
<p>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 n 为数组的长度。详细证明过程可以见《算法导论》第七章</p>
<p>空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 nlogn，空间复杂度为 O(logn)。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomized_partition</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        pivot = random.randint(l, r)</span><br><span class="line">        nums[pivot], nums[r] = nums[r], nums[pivot]</span><br><span class="line">        <span class="comment"># 设置一个 左边的指针位置 为 左侧的 前一个</span></span><br><span class="line">        i = l - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 双指针同时往后，一趟for循环，遍历 除 基准数之外的 数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):  <span class="comment"># range左闭右开</span></span><br><span class="line">            <span class="comment"># 比较 遍历的当前数 和 基准数 ，若是小于基准数 则 换到数组前面去</span></span><br><span class="line">            <span class="comment"># 交换位置，将遍历的比 基准数小的数 放到 我们指针 的 后一个上，然后 这个时候指针向后移一位。当遍历的数大于我们的基准数的时候，不移动，而且 指针也不发生变化，那么 当我们遍历完一圈以后，把 我们的基准数 放到 索引i 的后一个 位置，那么就形成了 一个 基准数 左边都是比它小的数，基准数右边 都是比它大的数 这样的模式。然后要把 索引 i 的后一个位置 作为基准数 与 原基准数 交换位置，进而可以第二次来 遍历比较。</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[r]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">        <span class="comment"># 遍历完后，将 ？数 和 right 上的数互换位置，就 重置 基准数了。</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">        <span class="comment"># 返回基准的下标</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomized_quicksort</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = self.randomized_partition(nums, l, r)</span><br><span class="line">        self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">        self.randomized_quicksort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数入口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.randomized_quicksort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    array = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">    print(solution.sortArray(array))</span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></tbody></table></figure>

<p>调试1</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">randomized_quicksort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">randomized_quicksort(nums, <span class="number">0</span>, <span class="number">6</span> - <span class="number">1</span>)</span><br><span class="line">randomized_quicksort(nums, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">l = <span class="number">0</span> &lt; r = <span class="number">5</span></span><br><span class="line">randomized_partition(nums, l, r)</span><br><span class="line">pivot = random.randint(l, r) = <span class="number">0</span></span><br><span class="line">nums[pivot] = nums[r] = nums[<span class="number">0</span>] = nums[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">nums[r] = nums[pivot] = nums[<span class="number">5</span>] = nums[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">i = l - <span class="number">1</span> = <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">5</span> &gt; num[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">4</span> &gt; num[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">6</span> &gt; num[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">1</span> &lt; num[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">3</span>] = nums[<span class="number">0</span>] = <span class="number">5</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">0</span>] = nums[<span class="number">3</span>] = <span class="number">1</span> </span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] = <span class="number">2</span> &lt; num[<span class="number">5</span>] = <span class="number">3</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">4</span>] = nums[<span class="number">1</span>] = <span class="number">4</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">1</span>] = nums[<span class="number">4</span>] = <span class="number">2</span> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>] </span><br><span class="line"></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">nums[i] = nums[r] = nums[<span class="number">2</span>] = nums[<span class="number">5</span>] = <span class="number">4</span> </span><br><span class="line">nums[r] = nums[i] = nums[<span class="number">5</span>] = nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>] </span><br><span class="line">切分元素 nums[pivot] = <span class="number">3</span> 交换到它排序以后最终确定的位置上</span><br><span class="line">mid = i = <span class="number">2</span> 返回原来下标为<span class="number">2</span>的元素<span class="number">3</span>的最终位置在下标<span class="number">2</span> </span><br><span class="line"></span><br><span class="line">self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    l = <span class="number">0</span> &lt; r = <span class="number">1</span></span><br><span class="line">    randomized_partition(nums, l, r)</span><br><span class="line">    pivot = random.randint(l, r) = <span class="number">0</span></span><br><span class="line">    nums[pivot] = nums[r] = nums[<span class="number">0</span>] = nums[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    nums[r] = nums[pivot] = nums[<span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>] </span><br><span class="line">    i = l - <span class="number">1</span> = <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">2</span> &gt; num[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">    nums[i] = nums[r] = nums[<span class="number">0</span>] = nums[<span class="number">1</span>] = <span class="number">1</span> </span><br><span class="line">    nums[r] = nums[i] = nums[<span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>] </span><br><span class="line">    切分元素 nums[pivot] = <span class="number">1</span> 交换到它排序以后最终确定的位置上</span><br><span class="line">    mid = i = <span class="number">0</span> 返回原来下标为<span class="number">0</span>的元素<span class="number">1</span>的最终位置在下标<span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">0</span> - <span class="number">1</span>)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">        l = <span class="number">0</span> &gt; r = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    self.randomized_quicksort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">0</span> + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        l = <span class="number">1</span> = r</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">self.randomized_quicksort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">2</span> + <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    l = <span class="number">3</span> &lt; r = <span class="number">5</span></span><br><span class="line">    randomized_partition(nums, l, r)</span><br><span class="line">    pivot = random.randint(l, r) = <span class="number">3</span></span><br><span class="line">    nums[pivot] = nums[r] = nums[<span class="number">3</span>] = nums[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line">    nums[r] = nums[pivot] = nums[<span class="number">5</span>] = nums[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>] </span><br><span class="line">    i = l - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">3</span></span><br><span class="line">    num[<span class="number">3</span>] = <span class="number">6</span> &gt; num[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">4</span></span><br><span class="line">    num[<span class="number">4</span>] = <span class="number">4</span> &lt; num[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    nums[j] = nums[i] = nums[<span class="number">4</span>] = nums[<span class="number">3</span>] = <span class="number">6</span> </span><br><span class="line">    nums[i] = nums[j] = nums[<span class="number">3</span>] = nums[<span class="number">4</span>] = <span class="number">4</span> </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>] </span><br><span class="line"></span><br><span class="line">    i = i + <span class="number">1</span> = <span class="number">4</span></span><br><span class="line">    nums[i] = nums[r] = nums[<span class="number">4</span>] = nums[<span class="number">5</span>] = <span class="number">6</span> </span><br><span class="line">    nums[r] = nums[i] = nums[<span class="number">5</span>] = nums[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    切分元素 nums[pivot] = <span class="number">5</span> 交换到它排序以后最终确定的位置上</span><br><span class="line">    mid = i = <span class="number">4</span> 返回原来下标为<span class="number">3</span>的元素<span class="number">5</span>的最终位置在下标<span class="number">4</span> </span><br><span class="line"></span><br><span class="line">    self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">3</span>, <span class="number">4</span> - <span class="number">1</span>)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        l = <span class="number">3</span> = r</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    self.randomized_quicksort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">    self.randomized_quicksort(nums, <span class="number">4</span> + <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">        l = <span class="number">5</span> = r</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>

<p>调试2</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] len(nums) - <span class="number">1</span> = <span class="number">7</span></span><br><span class="line">pivot = random.randint(l, r) = <span class="number">2</span></span><br><span class="line">nums[pivot] = <span class="number">4</span> </span><br><span class="line">nums[pivot] = nums[r] = nums[<span class="number">2</span>] = nums[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">nums[r] = nums[pivot] = nums[<span class="number">3</span>] = nums[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">i = l - <span class="number">1</span> = <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">2</span> &lt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">2</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">2</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">8</span> &gt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">7</span> &gt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">1</span> &lt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">3</span>] = nums[<span class="number">1</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">1</span>] = nums[<span class="number">3</span>] = <span class="number">1</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] = <span class="number">3</span> &lt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">4</span>] = nums[<span class="number">2</span>] = <span class="number">3</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">2</span>] = nums[<span class="number">4</span>] = <span class="number">7</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] = <span class="number">5</span> &gt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] = <span class="number">6</span> &gt; num[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">nums[i] = nums[r] = nums[<span class="number">3</span>] = nums[<span class="number">7</span>] = <span class="number">4</span> </span><br><span class="line">nums[r] = nums[i] = nums[<span class="number">7</span>] = nums[<span class="number">1</span>] = <span class="number">8</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">切分元素 pivot = <span class="number">4</span> 交换到它排序以后最终确定的位置上</span><br><span class="line">mid = i = <span class="number">3</span> 返回原来下标为<span class="number">2</span>的元素<span class="number">3</span>的最终位置在下标<span class="number">3</span> </span><br><span class="line"></span><br><span class="line">self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">1</span> - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">self.randomized_quicksort(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">3</span> + <span class="number">1</span>, <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] </span><br><span class="line">r = len(nums) - <span class="number">1</span> = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">pivot = random.randint(l, r) = <span class="number">7</span> 随机取到最右边</span><br><span class="line">nums[pivot] = <span class="number">7</span> </span><br><span class="line">nums[pivot] = nums[r] = nums[<span class="number">7</span>] = nums[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">nums[r] = nums[pivot] = nums[<span class="number">7</span>] = nums[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">i = l - <span class="number">1</span> = <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">2</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">2</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">2</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">8</span> &gt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">4</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">2</span>] = nums[<span class="number">1</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">1</span>] = nums[<span class="number">2</span>] = <span class="number">4</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">1</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">3</span>] = nums[<span class="number">2</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">2</span>] = nums[<span class="number">3</span>] = <span class="number">1</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] = <span class="number">3</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">4</span>] = nums[<span class="number">3</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">3</span>] = nums[<span class="number">4</span>] = <span class="number">3</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] = <span class="number">5</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">4</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">5</span>] = nums[<span class="number">4</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">4</span>] = nums[<span class="number">5</span>] = <span class="number">5</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] = <span class="number">6</span> &lt; num[<span class="number">7</span>] = <span class="number">7</span></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">5</span></span><br><span class="line">nums[j] = nums[i] = nums[<span class="number">6</span>] = nums[<span class="number">5</span>] = <span class="number">8</span> </span><br><span class="line">nums[i] = nums[j] = nums[<span class="number">5</span>] = nums[<span class="number">6</span>] = <span class="number">6</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">i = i + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">nums[i] = nums[r] = nums[<span class="number">6</span>] = nums[<span class="number">7</span>] = <span class="number">8</span> </span><br><span class="line">nums[r] = nums[i] = nums[<span class="number">7</span>] = nums[<span class="number">1</span>] = <span class="number">7</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">切分元素 nums[pivot] = <span class="number">7</span> 交换到它排序以后最终确定的位置上</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i = <span class="number">6</span></span><br><span class="line">mid = i = <span class="number">6</span> ，则原来下标为<span class="number">7</span>的元素<span class="number">7</span>的位置确定在下标<span class="number">6</span></span><br><span class="line"></span><br><span class="line">self.randomized_quicksort(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">6</span> - <span class="number">1</span>)</span><br><span class="line">self.randomized_quicksort(nums, <span class="number">0</span>, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pos</span>(<span class="params">lists, low, high</span>):</span></span><br><span class="line">    key = lists[low]</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> lists[high] &gt;= key:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        lists[low] = lists[high]</span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> lists[low] &lt;= key:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        lists[high] = lists[low]</span><br><span class="line">    lists[low] = key</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">alist, first, last</span>):</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        split_point = find_pos(alist, first, last)</span><br><span class="line">        quick_sort(alist, first, split_point<span class="number">-1</span>)</span><br><span class="line">        quick_sort(alist, split_point+<span class="number">1</span>, last)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">99</span>,<span class="number">88</span>,<span class="number">66</span>,<span class="number">23</span>,<span class="number">54</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">quick_sort(alist,<span class="number">0</span>,len(alist)<span class="number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">array: list</span>) -&gt; list:</span></span><br><span class="line">    lower = []  <span class="comment"># 存放小于基准值的数据</span></span><br><span class="line">    higher = []  <span class="comment"># 存放大于基准值的数据</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:  <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    pivot = array.pop()  <span class="comment"># 取列表最后一个数据为基准值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> i &gt;= pivot:</span><br><span class="line">            higher.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lower.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_sort(lower) + [pivot] + quick_sort(higher)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="使用递归-推导式写快速排序"><a href="#使用递归-推导式写快速排序" class="headerlink" title="使用递归+推导式写快速排序"></a>使用递归+推导式写快速排序</h5><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]  <span class="comment"># 找到一个基准值</span></span><br><span class="line">        <span class="comment"># 遍历整个列表，将小于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#遍历整个列表，将大于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="comment">#首先，明确我们对元素为0个/1个的列表无需要排序</span></span><br><span class="line">        <span class="comment">#使用函数递归</span></span><br><span class="line">        <span class="comment">#目标：让我们在一个基准值的一侧变为有序，然后依次返回，让我们的每个基准值的两侧都变得有序</span></span><br><span class="line">        <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(quick_sort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">11</span>]))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">quick_list</span>):</span></span><br><span class="line">    <span class="keyword">if</span> quick_list == []:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        first = quick_list[<span class="number">0</span>]</span><br><span class="line">        less = quick_sort([l <span class="keyword">for</span> l <span class="keyword">in</span> quick_list[<span class="number">1</span>:] <span class="keyword">if</span> l &lt; first])</span><br><span class="line">        more = quick_sort([m <span class="keyword">for</span> m <span class="keyword">in</span> quick_list[<span class="number">1</span>:] <span class="keyword">if</span> m &gt;= first])</span><br><span class="line">        <span class="keyword">return</span> less + [first] + more</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="各种排序的复杂度对比："><a href="#各种排序的复杂度对比：" class="headerlink" title="各种排序的复杂度对比："></a>各种排序的复杂度对比：</h2><p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83.jpg"></p>
<hr>
<h2 id="算法执行的时间："><a href="#算法执行的时间：" class="headerlink" title="算法执行的时间："></a>算法执行的时间：</h2><p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/%E6%8E%92%E5%BA%8F.png"></p>
<hr>
<h2 id="排序的内存使用："><a href="#排序的内存使用：" class="headerlink" title="排序的内存使用："></a>排序的内存使用：</h2><p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8.jpg"></p>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p><strong>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</strong></p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">0</span></span><br><span class="line">输出: <span class="number">-1</span>-&gt;<span class="number">0</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>解答一：归并排序 递归的向下递推过程实际上是在切分链表。<br><img src="/2020/08/21/liu-da-ji-ben-pai-xu/..%5C%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%92%E5%BD%92%E6%B3%95%EF%BC%89.png"></p>
<ul>
<li><p>题目要求时间空间复杂度分别为O(nlogn)和O(1)，根据时间复杂度我们自然想到二分法，从而联想到归并排序；</p>
</li>
<li><p>对数组做归并排序的空间复杂度为 O(n)，分别由新开辟数组O(n)和递归函数调用O(logn)组成，而根据链表特性：</p>
<ul>
<li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；</li>
<li>递归额外空间：递归调用函数将带来O(logn)的空间复杂度，因此若希望达到O(1)空间复杂度，则不能使用递归。<br>二分是二叉树状结构，深度为 log N ~<br>切分链表时向下“二分”，因此递归树的高度是 O(log n) ，<br>每层都需遍历整个链表，占用 O(n) ，因此总体为 O(n log n) ~</li>
</ul>
</li>
</ul>
<p>每次找到中间节点的时间复杂度度是n,排序也是n,但是他们是在一个函数前后执行的还是n,<br>复杂度线性累加 还是原复杂度，只有内外嵌套才会升级为 N^2 ~</p>
<ul>
<li>通过递归实现链表归并排序，有以下两个环节：<ul>
<li>分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；<ul>
<li>我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li>
<li>找到中点 slow 后，执行 slow.next = None 将链表切断。</li>
<li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 mid(因为链表是从 slow 切断的)。</li>
<li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li>
</ul>
</li>
<li>合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。<ul>
<li>双指针法合并，建立辅助ListNode h 作为头部。</li>
<li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助ListNode h 作为头部的下个节点 h.next。</li>
<li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li>
</ul>
</li>
<li>当题目输入的 head == None 时，直接返回None。</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="comment"># 当题目输入的 head == None 时，直接返回None。</span></span><br><span class="line">        <span class="comment"># 当head.next == None时，说明只有一个节点了，直接返回此节点。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: </span><br><span class="line">            <span class="keyword">return</span> head <span class="comment"># termination.</span></span><br><span class="line">        <span class="comment"># cut the LinkedList at the mid index.</span></span><br><span class="line">        <span class="comment"># 每次慢指针+1，快指针都相当于+2，</span></span><br><span class="line">        <span class="comment"># 所以当快指针到终点，慢指针到达中点</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:  <span class="comment"># 快</span></span><br><span class="line">            fast, slow = fast.next.next, slow.next</span><br><span class="line">        mid, slow.next = slow.next, <span class="literal">None</span> <span class="comment"># save and cut.</span></span><br><span class="line">        <span class="comment"># recursive for cutting.</span></span><br><span class="line">        <span class="comment"># left, right 分别指向两链表头部，比较两指针处节点值大小，</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="comment"># merge `left` and `right` linked list and return it.</span></span><br><span class="line">        <span class="comment"># res 是新建listNode，可以理解为新建一个头结点保留头指针，未创建新的链表，只是修改了原链表的节点指向，res指向的是h指针，这个h就是dummy亚指针，并不是合并后的头结点，而是它的前一个节点</span></span><br><span class="line">        <span class="comment"># 因为原头指针 h 在合并排序链表的时候会变化</span></span><br><span class="line">        h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                h.next, left = left, left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h.next, right = right, right.next</span><br><span class="line">            h = h.next</span><br><span class="line">        <span class="comment">#  前面while排序后, 如果左右子链表长度相同 ，</span></span><br><span class="line">        <span class="comment"># left和right都应该指向了左右子链表的最后一个node.next都是None</span></span><br><span class="line">        <span class="comment"># 但实际上长度可能不同，比如总长为 7 的链表，</span></span><br><span class="line">        <span class="comment"># 只能被分为7 = 3+4, 3 = 1+2……</span></span><br><span class="line">        <span class="comment"># 此时就需要把没走完的链表再加到尾部了。</span></span><br><span class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="comment"># h.next = left or right 更加 pythonic</span></span><br><span class="line">        <span class="keyword">return</span> res.next  <span class="comment"># 保存归并的结果的</span></span><br></pre></td></tr></tbody></table></figure>

<p>在 cut 到链表长度为 2 时，如果 fast, slow 都指向头部 head ，那么fast会走两步，slow走一步，cut点是不对的。 如果fast先走一步到 head.next ，就会避免长度为 2 时出现的特殊错误情况。<br>[3, 2]<br>slow = = head = 3<br>fast = = head.next = 2<br>fast.next = None不进入循环<br>mid = slow.next = 3<br>slow.next = None [3 | 2]</p>
<p>如果初始化时令fast=head，slow=head<br>slow = head = 3<br>fast.next != None进入循环</p>
<p>slow = slow.next = 2<br>fast = fast.next.next =None<br>mid = slow.next = None<br>slow.next = None </p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="string">slow</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">fast</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">slow</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">fast</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line">  </span><br><span class="line"><span class="string">mid</span> <span class="string">=</span> <span class="number">4</span> </span><br><span class="line"><span class="string">slow.next</span> <span class="string">=</span> <span class="string">None</span> <span class="string">切断</span>  [<span class="number">3</span>, <span class="number">2</span> <span class="string">|</span> <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">self.sortList(head)</span>  [<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="string">slow</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">fast</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">fast.next</span> <span class="string">=</span> <span class="string">None</span> <span class="string">不进入循环</span></span><br><span class="line"><span class="string">mid</span> <span class="string">=</span> <span class="string">slow.next</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">slow.next</span> <span class="string">=</span> <span class="string">None</span>    [<span class="number">3</span> <span class="string">|</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">self.sortList(head)</span></span><br><span class="line"><span class="string">head</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">head.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">return</span> <span class="string">head</span> </span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="string">self.sortList(mid)</span></span><br><span class="line"><span class="string">head</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">head.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">return</span> <span class="string">head</span> </span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">独立的</span> <span class="number">3</span> <span class="string">和</span> <span class="number">2</span> <span class="string">合并</span></span><br><span class="line"><span class="number">3</span> <span class="string">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">right</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="string">right.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">h</span> <span class="string">=</span> <span class="string">h.next</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">跳出循环</span></span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">left</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="string">self.sortList(mid)</span>  [<span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">slow</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">fast</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"><span class="string">fast.next</span> <span class="string">=</span> <span class="string">None</span> <span class="string">不进入循环</span></span><br><span class="line"><span class="string">mid</span> <span class="string">=</span> <span class="string">slow.next</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"><span class="string">slow.next</span> <span class="string">=</span> <span class="string">None</span>    [<span class="number">4</span> <span class="string">|</span> <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">self.sortList(head)</span> </span><br><span class="line"><span class="string">head</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">head.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">return</span> <span class="string">head</span> </span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="string">self.sortList(mid)</span></span><br><span class="line"><span class="string">head</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"><span class="string">head.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">return</span> <span class="string">head</span> </span><br><span class="line"><span class="string">right</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="string">独立的</span> <span class="number">4</span> <span class="string">和</span> <span class="number">6</span> <span class="string">合并</span></span><br><span class="line"><span class="number">4</span> <span class="string">&lt;</span> <span class="number">6</span>          </span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">left</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">left.next</span> <span class="string">=</span> <span class="string">None</span> </span><br><span class="line"><span class="string">h</span> <span class="string">=</span> <span class="string">h.next</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">跳出循环</span></span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">left</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">独立的</span> [<span class="number">2</span>, <span class="number">3</span>] <span class="string">和</span> [<span class="number">4</span>, <span class="number">6</span>] <span class="string">合并</span></span><br><span class="line"><span class="number">2</span> <span class="string">&lt;</span> <span class="number">4</span>         </span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">left</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">left.next</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">h</span> <span class="string">=</span> <span class="string">h.next</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">再循环</span></span><br><span class="line"><span class="number">3</span> <span class="string">&lt;</span> <span class="number">4</span></span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">left</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">left</span> <span class="string">=</span> <span class="string">left.next</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"><span class="string">h</span> <span class="string">=</span> <span class="string">h.next</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">h.next</span> <span class="string">=</span> <span class="string">right</span> <span class="string">=</span> <span class="number">4</span> <span class="string">right只是链表的头节点，会指向后面排序好的节点6</span></span><br><span class="line"><span class="string">h指向2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span><span class="string">，ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>一次方法的调用和返回代表着一个栈帧的入栈和出栈，栈帧出栈后，该栈帧中的临时变量所占用的空间都会得到释放。 对于数组的归并排序之所以空间复杂度是O(n)，是因为数组归并排序使用了一个创建了一个辅助数组。这里每个栈帧创建的只是辅助节点，出栈后就释放了。空间复杂度应该是O(1)<br>若算法执行所需要的辅助空间相对于输入数据n而言是一个常数，则称这个算法空间复杂度辅助空间为o（1）；<br>递归算法空间复杂度：递归深度n*每次递归所要的辅助空间，如果每次递归所需要的辅助空间为常数，则递归空间复杂度o（n）。</p>
<p>递归栈的空间复杂度和递归函数调用的 深度 有关<br>（即在某时刻有多少个递归函数 “尚未返回”）。<br>在返回后，系统会释放栈空间的。<br>递归调用次数多，空间复杂度不一定更高~</p>
<p>偶數個數的時候 mid 有偏左和偏右兩個。<br>如果直接從 fast 開始，slow 永遠會走到偏右的那個，會進入無窮迴圈。<br>所以我們要的是偏左那個 mid，一開始要先多走一步<br>如果不令fast初始化为head.next，则在链表长度n为偶数的情况下返回第n/2 + 1个数，题意需要的是第n/2个数<br>因为起点一样的话,拆分到只剩两个节点的时候,这两个节点永远拆分不开</p>
<hr>
<p>法二：归并排序（从底至顶直接合并）</p>
<p><img src="/2020/08/21/liu-da-ji-ben-pai-xu/..%5C%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BB%8E%E5%BA%95%E8%87%B3%E9%A1%B6%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%EF%BC%89.png"></p>
<ul>
<li><p>对于非递归的归并排序，需要使用迭代的方式替换cut环节：</p>
<ul>
<li>我们知道，cut环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</li>
<li>每一轮合并merge操作针对的单元都有固定长度intv，例如：<ul>
<li>第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li>
<li>第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li>
<li>以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。</li>
</ul>
</li>
<li>据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如:<ul>
<li><p>当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。</p>
</li>
<li><p>当intv = 2时，将链表第1-2和第3-4节点排序合并（第一组小片段），第5-6和第7-8节点排序合并（第二组小片段），……。，</p>
</li>
<li><p>当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>此方法时间复杂度O(nlogn)，空间复杂度O(1)。</p>
</li>
<li><p>模拟上述的多轮排序合并：</p>
<ul>
<li>统计链表长度length，用于通过判断intv &lt; length判定是否完成排序；</li>
<li>额外声明一个节点root，作为头部后面接整个链表，用于：<ul>
<li>intv *= 2即切换到下一轮合并时，可通过root.next找到链表头部cur；</li>
<li>执行排序合并时，需要一个辅助节点作为头部，而root则作为链表头部排序合并时的辅助头部merge_point；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。</li>
</ul>
</li>
<li>在每轮intv下的合并流程：<ol>
<li>根据intv找到合并单元1和单元2的头部h1, h2。<br>由于链表长度可能不是2^n，需要考虑边界条件：<ul>
<li>在找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并；</li>
<li>若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为len2 = intv - intv_residue_2。</li>
</ul>
</li>
<li>合并长度为len1, len2的h1, h2链表，其中：<ul>
<li>合并完后，需要修改新的合并单元的尾部merge_point指针指向下一个合并单元头部current。<br>（在寻找h1, h2环节中，current指针已经被移动到下一个单元头部）</li>
<li>合并单元尾部同时也作为下次合并的辅助头部merge_point。</li>
</ul>
</li>
<li>当current == None，代表此轮intv合并完成，跳出。</li>
</ol>
</li>
<li>每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur, length = head, <span class="number">0</span></span><br><span class="line">        <span class="comment">#  遍历链表求长度，时间复杂度就是On了,</span></span><br><span class="line">        <span class="comment">#  O(nlogn)复杂度高于线性低于平方,所以有个O(n)没关系</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur, length = cur.next, length + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        root = ListNode(<span class="number">0</span>)</span><br><span class="line">        root.next = head</span><br><span class="line">        intv = <span class="number">1</span>  <span class="comment"># 每次合并的规模</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据不同的链表切片规模，每一次都从头进行归并</span></span><br><span class="line">        <span class="keyword">while</span> intv &lt; length:</span><br><span class="line">            merge_point, current = root, root.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> current:  <span class="comment"># 根据当前的合并规模，将链表内的链表切片两两归并</span></span><br><span class="line">                <span class="comment"># 获取当前需要归并的子链表 h1</span></span><br><span class="line">                h1, intv_residue_1 = current, intv</span><br><span class="line">                <span class="keyword">while</span> intv_residue_1 <span class="keyword">and</span> current:</span><br><span class="line">                    current, intv_residue_1 = current.next, intv_residue_1 - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> intv_residue_1:</span><br><span class="line">                    <span class="comment"># h2 在这种情况下不存在，所以本轮不需要合并</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取当前需要归并的子链表 h2</span></span><br><span class="line">                h2, intv_residue_2 = current, intv</span><br><span class="line">                <span class="keyword">while</span> intv_residue_2 <span class="keyword">and</span> current:</span><br><span class="line">                    current, intv_residue_2 = current.next, intv_residue_2 - <span class="number">1</span></span><br><span class="line">                <span class="comment"># len2 的长度可能比 intv 小</span></span><br><span class="line">                len1, len2 = intv, intv - intv_residue_2</span><br><span class="line">                <span class="comment"># 归并排序</span></span><br><span class="line">                <span class="comment"># len1或len2一定有一个是等于0的，链接剩下的被切割剩下的一个链表</span></span><br><span class="line">                <span class="keyword">while</span> len1 <span class="keyword">and</span> len2:</span><br><span class="line">                    <span class="keyword">if</span> h1.val &lt; h2.val:</span><br><span class="line">                        merge_point.next, h1, len1 = h1, h1.next, len1 - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        merge_point.next, h2, len2 = h2, h2.next, len2 - <span class="number">1</span></span><br><span class="line">                    merge_point = merge_point.next</span><br><span class="line">                <span class="comment"># 归并排序处理一下没有被归并的剩余值</span></span><br><span class="line">                <span class="keyword">if</span> len1:</span><br><span class="line">                    merge_point.next = h1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    merge_point.next = h2</span><br><span class="line">                <span class="comment"># merge_point.next=h1 or h2 只是完成了第一组内部小片段最后一个节点的连接，例如此时 h1 = 2, h2 = 3，把2 和 3 连上 </span></span><br><span class="line">                <span class="comment"># merge_point指向的元素不一定是当前链表切片的末尾</span></span><br><span class="line">                <span class="comment"># merge_point还应该继续后移，直到指向当前链表切片末尾（即下一次链表切片的开头）</span></span><br><span class="line">                <span class="keyword">while</span> len1 &gt; <span class="number">0</span> <span class="keyword">or</span> len2 &gt; <span class="number">0</span>:</span><br><span class="line">                    merge_point, len1, len2 = merge_point.next, len1 - <span class="number">1</span>, len2 - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 把归并后的链表切片第一小组片段尾跟原链表h2之第二小组的头拼起来</span></span><br><span class="line">                <span class="comment"># 一次合并后有可能最后一个结点顺序被打乱而不是下一次合并的起点</span></span><br><span class="line">                <span class="comment"># [2 3] 要连上 还未排序的[4 6]</span></span><br><span class="line">                merge_point.next = current</span><br><span class="line"></span><br><span class="line">            intv *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">current = <span class="number">3</span></span><br><span class="line">length = <span class="number">0</span></span><br><span class="line">进入循环</span><br><span class="line">current = current.next = <span class="number">2</span></span><br><span class="line">length = <span class="number">1</span></span><br><span class="line">current = current.next = <span class="number">4</span></span><br><span class="line">length = <span class="number">2</span></span><br><span class="line">current = current.next = <span class="number">6</span></span><br><span class="line">length = <span class="number">3</span></span><br><span class="line">current = current.next = None</span><br><span class="line">length = <span class="number">4</span></span><br><span class="line">退出循环</span><br><span class="line"></span><br><span class="line">root.next = head</span><br><span class="line"><span class="built_in">int</span>v = <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>v = <span class="number">1</span> &lt; length = <span class="number">4</span></span><br><span class="line">merge_point = root </span><br><span class="line">current = root.next = head = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">进入循环</span><br><span class="line"></span><br><span class="line">h1 = current = <span class="number">3</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">进入子循环</span><br><span class="line">current = current.next = <span class="number">2</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v_residue_1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">退出子循环</span><br><span class="line"></span><br><span class="line">h2 = current = <span class="number">2</span></span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">进入子循环                    </span><br><span class="line">current = current.next = <span class="number">4</span></span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v_residue_2 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">退出子循环</span><br><span class="line"></span><br><span class="line">len1 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">len2 = <span class="built_in">int</span>v - <span class="built_in">int</span>v_residue_2 = <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">进入子循环</span><br><span class="line"><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">merge_point.next = h2 = <span class="number">2</span></span><br><span class="line">h2 = h2.next = <span class="number">4</span></span><br><span class="line">len2 = len2 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">merge_point = merge_point.next = <span class="number">2</span></span><br><span class="line">跳出子循环</span><br><span class="line"></span><br><span class="line">merge_point.next = h1 = <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">merge_point = merge_point.next = <span class="number">3</span></span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">len2 = len2 - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">merge_point.next = current = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">h1 = current = <span class="number">4</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">进入子循环</span><br><span class="line">current = current.next = <span class="number">6</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v_residue_1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">退出子循环</span><br><span class="line"></span><br><span class="line">h2 = current = <span class="number">6</span></span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">进入子循环                    </span><br><span class="line">current = current.next = None</span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v_residue_2 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">退出子循环</span><br><span class="line">len1 = <span class="built_in">int</span>v = <span class="number">1</span></span><br><span class="line">len2 = <span class="built_in">int</span>v - <span class="built_in">int</span>v_residue_2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">进入子循环</span><br><span class="line"><span class="number">4</span> &lt; <span class="number">6</span></span><br><span class="line">merge_point.next = h1 = <span class="number">4</span></span><br><span class="line">h1 = h1.next = <span class="number">6</span></span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">merge_point = merge_point.next = <span class="number">4</span></span><br><span class="line">跳出循环</span><br><span class="line"></span><br><span class="line">merge_point.next = h2 = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">merge_point = merge_point.next = <span class="number">6</span></span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line">len2 = len2 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">merge_point.next = current = None</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>v = <span class="built_in">int</span>v * <span class="number">2</span> =  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">merge_point = root</span><br><span class="line">current = root.next = head = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">进入循环</span><br><span class="line"></span><br><span class="line">h1 = current = <span class="number">2</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v = <span class="number">2</span></span><br><span class="line">进入子循环</span><br><span class="line">current = current.next = <span class="number">3</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v_residue_1 - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">再循环</span><br><span class="line">current = current.next = <span class="number">4</span></span><br><span class="line"><span class="built_in">int</span>v_residue_1 = <span class="built_in">int</span>v_residue_1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">退出子循环</span><br><span class="line"></span><br><span class="line">h2 = current = <span class="number">4</span></span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v = <span class="number">2</span></span><br><span class="line">进入子循环                    </span><br><span class="line">current = current.next = <span class="number">6</span></span><br><span class="line"><span class="built_in">int</span>v_residue_2 = <span class="built_in">int</span>v_residue_2 - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">退出子循环</span><br><span class="line">len1 = <span class="built_in">int</span>v = <span class="number">2</span></span><br><span class="line">len2 = <span class="built_in">int</span>v - <span class="built_in">int</span>v_residue_2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">进入子循环</span><br><span class="line"><span class="number">2</span> &lt; <span class="number">4</span></span><br><span class="line">merge_point.next = h1 = <span class="number">2</span></span><br><span class="line">h1 = h1.next = <span class="number">3</span> </span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">merge_point = merge_point.next = <span class="number">2</span></span><br><span class="line"><span class="number">3</span> &lt; <span class="number">4</span></span><br><span class="line">merge_point.next = h1 = <span class="number">3</span></span><br><span class="line">h1 = h1.next = <span class="number">4</span> </span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">merge_point = merge_point.next = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">merge_point.next = h2 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">merge_point = merge_point.next = <span class="number">4</span></span><br><span class="line">len1 = len1 - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line">len2 = len2 - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">merge_point.next = current = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>v = <span class="built_in">int</span>v * <span class="number">2</span> = <span class="number">4</span> = length 跳出循环</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>root.next = head不写成root = head<br>head指向的头节点在排序过程中是变化的顺序可能会被打乱，比如 4，3，2，1第一次完成后变为3，4，1，2，此时head指向了第二个节点，就不是头节点了，而dummy.next始终会指向每次归并完之后的新头节点，我觉得可以参照代码手推下更好理解了</p>
<hr>
<h3 id="堆-Heap-是计算机科学中一类特殊的数据结构的统称，一般讨论的堆都是二叉堆。"><a href="#堆-Heap-是计算机科学中一类特殊的数据结构的统称，一般讨论的堆都是二叉堆。" class="headerlink" title="堆(Heap)是计算机科学中一类特殊的数据结构的统称，一般讨论的堆都是二叉堆。"></a>堆(Heap)是计算机科学中一类特殊的数据结构的统称，一般讨论的堆都是二叉堆。</h3><p>堆满足下列性质：</p>
<ol>
<li>堆中某个节点的值或索引总是不大于或不小于其父节点的值或索引。</li>
<li>堆总是一棵完全二叉树，且该完全二叉树的深度为 k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边。</li>
</ol>
<p>把堆看作原生的Python list，数组的下标对应堆中节点的编号<br>我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，<br>heap[0] 表示访问最小的元素总是在根结点而不弹出它。，同时 heap.sort() 维护了堆的不变性！</p>
<h3 id="堆排序：利用堆的概念来排序的选择排序。先将待排序的序列建成分为两种："><a href="#堆排序：利用堆的概念来排序的选择排序。先将待排序的序列建成分为两种：" class="headerlink" title="堆排序：利用堆的概念来排序的选择排序。先将待排序的序列建成分为两种："></a>堆排序：利用堆的概念来排序的选择排序。先将待排序的序列建成分为两种：</h3><ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n−1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<h1 id="Python-里的-heapq-模块"><a href="#Python-里的-heapq-模块" class="headerlink" title="Python 里的 heapq 模块"></a>Python 里的 heapq 模块</h1><p>python3标准库中提供了heapq，使用原地算法得到对小顶堆进行操作<br>提供了堆队列算法的实现，也称为优先队列算法。<br>一般我们刷题或者写业务代码的时候，使用这个内置的 heapq 模块就够用了</p>
<p>实现 大顶堆 方法：小顶堆的插入和弹出操作均将元素 取反<br>小顶堆[1,2,3]堆顶是1，<br>如果想让3在堆顶的话，就只能是[-3,-2,-1]，堆顶是-3，<br>然后每次heappop取出时，-3加上负号就变成3了，变相实现大顶堆</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="number">-3</span></span><br><span class="line">  /  \       /  \</span><br><span class="line"> <span class="number">2</span>    <span class="number">3</span>     <span class="number">-2</span>  <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>shift up ：如何向一个最大堆中添加元素</li>
<li>shift down 如何从一个最大堆中取出一个元素，只能取出最大优先级的元素，也就是根节点，</li>
</ul>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">              <span class="number">62</span></span><br><span class="line">            /     \</span><br><span class="line">           <span class="number">52</span>      <span class="number">30</span></span><br><span class="line">         /   \     / \</span><br><span class="line">        <span class="number">28</span>    <span class="number">41</span>  <span class="number">22</span>  <span class="number">13</span></span><br><span class="line">       /  \      / \</span><br><span class="line">      <span class="number">19</span>  <span class="number">17</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">把原来的 <span class="number">62</span> 取出后，</span><br><span class="line"></span><br><span class="line">            /     \</span><br><span class="line">           <span class="number">52</span>      <span class="number">30</span></span><br><span class="line">         /   \     / \</span><br><span class="line">        <span class="number">28</span>    <span class="number">41</span>  <span class="number">22</span>  <span class="number">13</span></span><br><span class="line">       /  \      / \</span><br><span class="line">      <span class="number">19</span>  <span class="number">17</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">将数组最后一位数组放到根节点，此时不满足最大堆的定义。</span><br><span class="line">              <span class="number">16</span></span><br><span class="line">            /     \</span><br><span class="line">           <span class="number">52</span>      <span class="number">30</span></span><br><span class="line">         /   \     / \</span><br><span class="line">        <span class="number">28</span>    <span class="number">41</span>  <span class="number">22</span>  <span class="number">13</span></span><br><span class="line">       /  \      / \</span><br><span class="line">      <span class="number">19</span>  <span class="number">17</span> <span class="number">15</span> </span><br><span class="line">调整的过程是将这个根节点 <span class="number">16</span> 一步一步向下挪，<span class="number">16</span> 比子节点都小，</span><br><span class="line">先比较子节点 <span class="number">52</span> 和 <span class="number">30</span> 哪个大，和大的交换位置。</span><br><span class="line">              <span class="number">52</span></span><br><span class="line">            /     \</span><br><span class="line">           <span class="number">16</span>      <span class="number">30</span></span><br><span class="line">         /   \     / \</span><br><span class="line">        <span class="number">28</span>    <span class="number">41</span>  <span class="number">22</span>  <span class="number">13</span></span><br><span class="line">       /  \      / \</span><br><span class="line">      <span class="number">19</span>  <span class="number">17</span> <span class="number">15</span> </span><br><span class="line">继续比较 <span class="number">16</span> 的子节点 <span class="number">28</span> 和 <span class="number">41</span>，<span class="number">41</span> 大，所以 <span class="number">16</span> 和 <span class="number">41</span> 交换位置。</span><br><span class="line">              <span class="number">52</span></span><br><span class="line">            /     \</span><br><span class="line">           <span class="number">41</span>      <span class="number">30</span></span><br><span class="line">         /   \     / \</span><br><span class="line">        <span class="number">28</span>    <span class="number">16</span>  <span class="number">22</span>  <span class="number">13</span></span><br><span class="line">       /  \      / \</span><br><span class="line">      <span class="number">19</span>  <span class="number">17</span> <span class="number">15</span> </span><br><span class="line">继续 <span class="number">16</span> 和孩子节点 <span class="number">15</span> 进行比较，<span class="number">16</span> 大，所以现在不需要进行交换，最后我们的 shift down 操作完成，维持了一个最大堆的性质。</span><br></pre></td></tr></tbody></table></figure>


<p>要创建一个堆 </p>
<ol>
<li><p>或者 <code>heapq.heapify(list)</code> ，将列表list原地转换成为最小二叉堆列表，具备最小堆特征 线性时间内，算法时间复杂度为 O(n)。<br>Transform list x into a heap, in-place, in linear time.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">heap2 = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(heap2)</span><br><span class="line">print(heap2)</span><br><span class="line"><span class="comment"># [0, 1, 5, 3, 2, 7, 9, 8, 4, 6]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">            0</span></span><br><span class="line"><span class="string">          /   \</span></span><br><span class="line"><span class="string">         1     5</span></span><br><span class="line"><span class="string">        / \   / \</span></span><br><span class="line"><span class="string">       3   2  7  9</span></span><br><span class="line"><span class="string">      / \ / \</span></span><br><span class="line"><span class="string">     8  4 6</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>可以使用list来初始化为 []<br><code>heapq.heappush(heap, item)</code><br>将 item 的值加入 heap 中，保持堆的不变性。<br>push后堆也应该是一棵完全二叉树，所以必须将元素追加到数组末尾</p>
</li>
</ol>
<p><code>heapq.heappop(heap)</code><br>弹出并返回 heap 的最小的元素，保持堆的不变性。<br>如果堆为空，抛出 IndexError 。</p>
<p><code>heapq.heappushpop(heap, item)</code><br>将 item 放入堆中，然后弹出并返回 heap 的最小元素。<br>该组合操作比先调用  heappush() 再调用 heappop() 运行起来更有效率。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">从 iterable 所定义的数据集中返回前 n 个最小元素组成的列表。 </span><br><span class="line">如果提供了 key 则其应指定一个单参数的函数，</span><br><span class="line">用于从 iterable 的每个元素中提取比较键 (例如 key=str.lower)。 等价于: sorted(iterable, key=key)[:n]。。</span><br><span class="line"></span><br><span class="line">堆排序的原理是通过不断 交换元素 实现排序的：</span><br><span class="line">在数组中交换两个索引的元素时间复杂度为 O(1)，</span><br><span class="line">而链表 交换元素 本身是 O(N) 时间复杂度，若可以把此问题解决就可以用堆排。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)。初始化建堆的时间复杂度为 O(n)，建完堆以后需要进行 n-1 次调整，一次调整（即 maxHeapify） 的时间复杂度为 O(logn)，那么 n−1 次调整即需要 O(nlogn) 的时间复杂度。因此，总时间复杂度为 O(n+nlogn)=O(nlogn)。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(1)。给一个未排序的数组arr，堆排序就地排序，不借用额外空间，仅在arr上调整元素位置完成排序。如果把原数组arr算上就是O(N)，但一般只计算使用到的额外空间，只需要常数的空间存放若干变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">data = [3, 2, 6, 1]</span><br><span class="line">heap1 = []</span><br><span class="line"># 使用heapq库的heappush函数将数据堆入</span><br><span class="line">for i in data:</span><br><span class="line">    heapq.heappush(heap1, i)  # 数据堆入</span><br><span class="line">print(heap1)  # [1, 2, 6, 3]</span><br><span class="line">'''</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3</span><br><span class="line">'''</span><br><span class="line">heapq.heappush(heap1, 5)</span><br><span class="line">print(heap1)  # [1, 2, 6, 3, 5]</span><br><span class="line">'''</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5</span><br><span class="line">将元素追加到数组末尾，符合最小堆的规律        </span><br><span class="line">'''</span><br><span class="line">heapq.heappush(heap1, 0.5)</span><br><span class="line">print(heap1)</span><br><span class="line"># [0.5, 2, 1, 3, 5, 6]</span><br><span class="line">'''</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 0.5</span><br><span class="line">将元素追加到数组末尾，不符合最小堆的规律，需要调整</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    0.5</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 6</span><br><span class="line">            0.5</span><br><span class="line">           /  \</span><br><span class="line">          2    1</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 6</span><br><span class="line"></span><br><span class="line">'''</span><br><span class="line">print(heapq.heappop(heap1))  # 0.5 将数组堆中的最小元素弹出</span><br><span class="line">print(heap1)  # [1, 2, 6, 3, 5]</span><br><span class="line">'''</span><br><span class="line">            0.5</span><br><span class="line">           /  \</span><br><span class="line">          2    1</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 6</span><br><span class="line">第一步，先将根节点与编号最大节点的元素互换，并删除编号最大的节点。</span><br><span class="line">           /  \</span><br><span class="line">          2    1</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 6</span><br><span class="line">            6</span><br><span class="line">           /  \</span><br><span class="line">          2    1</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 </span><br><span class="line">此时堆仍然是一棵完全二叉树，但有可能不满足堆的性质一。</span><br><span class="line">所以我们需要对根节点的元素进行下沉操作，</span><br><span class="line">以大顶堆为例，设置一个游标 id, 初始指向根节点：</span><br><span class="line">如果id指向叶子节点，算法结束。</span><br><span class="line">如果id指向节点小于其左右子节点的值，算法结束。</span><br><span class="line">设id的左右子节点中，拥有较小值的编号为 p，交换 id 与 p 的值，并将 id 指向 p 节点。跳转步骤 1</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 </span><br><span class="line">'''</span><br><span class="line">print(heapq.heappop(heap1))  # 1 将数组堆中的最小元素弹出</span><br><span class="line">print(heap1)  # [2, 3, 6, 5]</span><br><span class="line">'''</span><br><span class="line">            1</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 </span><br><span class="line"></span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  5 </span><br><span class="line"></span><br><span class="line">            5</span><br><span class="line">           /  \</span><br><span class="line">          2    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3 </span><br><span class="line"></span><br><span class="line">            2</span><br><span class="line">           /  \</span><br><span class="line">          5    6</span><br><span class="line">         / \  / \</span><br><span class="line">        3  </span><br><span class="line"></span><br><span class="line">            2</span><br><span class="line">           /  \</span><br><span class="line">          3    6</span><br><span class="line">         / \  / \</span><br><span class="line">        5  </span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span>(<span class="params">self, heap, root, heap_len</span>):</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> p * <span class="number">2</span> + <span class="number">1</span> &lt; heap_len:</span><br><span class="line">            l, r = p * <span class="number">2</span> + <span class="number">1</span>, p * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> heap_len &lt;= r <span class="keyword">or</span> heap[r] &lt; heap[l]:</span><br><span class="line">                nex = l</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nex = r</span><br><span class="line">            <span class="keyword">if</span> heap[p] &lt; heap[nex]:</span><br><span class="line">                heap[p], heap[nex] = heap[nex], heap[p]</span><br><span class="line">                p = nex</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">self, heap</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.max_heapify(heap, i, len(heap))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        self.build_heap(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">            self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.heap_sort(nums)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">heap_sort(self, nums):</span><br><span class="line">self.build_heap(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span> - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">    i = <span class="number">4</span></span><br><span class="line">    self.max_heapify(heap, i, len(heap))</span><br><span class="line">    self.max_heapify(heap, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    p = root = <span class="number">4</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">9</span> &gt; heap_len = <span class="number">5</span></span><br><span class="line">        不进入循环</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">3</span></span><br><span class="line">    self.max_heapify(heap, i, len(heap))</span><br><span class="line">    self.max_heapify(heap, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    p = root = <span class="number">3</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> &gt; heap_len = <span class="number">5</span></span><br><span class="line">        不进入循环</span><br><span class="line"></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    self.max_heapify(heap, i, len(heap))</span><br><span class="line">    self.max_heapify(heap, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    p = root = <span class="number">2</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">5</span> = heap_len = <span class="number">5</span></span><br><span class="line">        不进入循环    </span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    self.max_heapify(heap, i, len(heap))</span><br><span class="line">    self.max_heapify(heap, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    p = root = <span class="number">1</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> &lt; heap_len = <span class="number">5</span></span><br><span class="line">        [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">        heap_len = <span class="number">5</span> &gt; r = <span class="number">4</span> </span><br><span class="line">        heap[r] = heap[<span class="number">4</span>] = <span class="number">9</span> &gt; heap[l] = heap[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">        nex = r = <span class="number">4</span></span><br><span class="line">        heap[p] = heap[<span class="number">1</span>] = <span class="number">6</span> &lt; heap[nex] = heap[<span class="number">4</span>] = <span class="number">9</span>:</span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">1</span>] = heap[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">4</span>] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        [<span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">        p = nex = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">9</span> &gt; heap_len = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    self.max_heapify(heap, i, len(heap))</span><br><span class="line">    self.max_heapify(heap, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> &lt; heap_len = <span class="number">5</span></span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">        heap_len = <span class="number">5</span> &gt; r = <span class="number">2</span> </span><br><span class="line">        heap[r] = heap[<span class="number">2</span>] = <span class="number">8</span> &lt; heap[l] = heap[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">        nex = l = <span class="number">1</span></span><br><span class="line">        heap[p] = heap[<span class="number">0</span>] = <span class="number">4</span> &lt; heap[nex] = heap[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">0</span>] = heap[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">1</span>] = heap[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">        [<span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">        p = nex = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> &lt; heap_len = <span class="number">5</span></span><br><span class="line">        再循环</span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">1</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">        heap_len = <span class="number">5</span> &gt; r = <span class="number">4</span> </span><br><span class="line">        heap[r] = heap[<span class="number">4</span>] = <span class="number">6</span> &gt; heap[l] = heap[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">        nex = r = <span class="number">4</span></span><br><span class="line">        heap[p] = heap[<span class="number">1</span>] = <span class="number">4</span> &lt; heap[nex] = heap[<span class="number">4</span>] = <span class="number">6</span>:</span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">1</span>] = heap[<span class="number">4</span>] = <span class="number">6</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">4</span>] = heap[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">        [<span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">        p = nex = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">9</span> &gt; heap_len = <span class="number">5</span></span><br><span class="line">        退出循环</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span> - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    i = <span class="number">4</span></span><br><span class="line">    nums[<span class="number">4</span>] = nums[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[i] = <span class="number">4</span></span><br><span class="line">    [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> &lt; heap_len = <span class="number">4</span></span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">        heap_len = <span class="number">4</span> &gt; r = <span class="number">2</span> </span><br><span class="line">        heap[r] = heap[<span class="number">2</span>] = <span class="number">8</span> &gt; heap[l] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        nex = r = <span class="number">2</span></span><br><span class="line">        heap[p] = heap[<span class="number">0</span>] = <span class="number">4</span> &lt; heap[nex] = heap[<span class="number">2</span>] = <span class="number">8</span></span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">0</span>] = heap[<span class="number">2</span>] = <span class="number">8</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">2</span>] = heap[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">        [<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">        p = nex = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">5</span> &gt; heap_len = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">3</span></span><br><span class="line">    nums[i] = nums[<span class="number">3</span>] = nums[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[i] = nums[<span class="number">3</span>] = <span class="number">5</span></span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> &lt; heap_len = <span class="number">3</span></span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">        heap_len = <span class="number">3</span> &gt; r = <span class="number">2</span> </span><br><span class="line">        heap[r] = heap[<span class="number">2</span>] = <span class="number">4</span> &lt; heap[l] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        nex = l = <span class="number">1</span> </span><br><span class="line">        heap[p] = heap[<span class="number">0</span>] = <span class="number">5</span> &lt; heap[nex] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">0</span>] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">1</span>] = heap[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">        [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">        p = nex = <span class="number">1</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> = heap_len = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    nums[i] = nums[<span class="number">2</span>] = nums[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[i] = nums[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> &lt; heap_len = <span class="number">2</span></span><br><span class="line">        l = p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        r = p * <span class="number">2</span> + <span class="number">2</span> = <span class="number">0</span> * <span class="number">2</span> + <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">        heap_len = <span class="number">2</span> = r = <span class="number">2</span> </span><br><span class="line">        heap[r] = heap[<span class="number">2</span>] = <span class="number">6</span> &gt; heap[l] = heap[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">        nex = l = <span class="number">1</span> </span><br><span class="line">        heap[p] = heap[<span class="number">0</span>] = <span class="number">4</span> &lt; heap[nex] = heap[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">        heap[p] = heap[nex] = heap[<span class="number">0</span>] = heap[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">        heap[nex] = heap[p] = heap[<span class="number">1</span>] = heap[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">        [<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">        p = nex = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> &gt; heap_len = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    nums[i] = nums[<span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[i] = nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> = heap_len = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    nums[i] = nums[<span class="number">0</span>] = nums[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[i] = nums[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">    self.max_heapify(nums, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    p = root = <span class="number">0</span></span><br><span class="line">        p * <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> &gt; heap_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>


<p>完全二叉树有个重要性质，对于第一个非叶子节点的索引是 n/2 取整数得到的索引值，<br>其中 n 是元素个数(前提是数组索引从 1 开始计算)。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">建立大顶堆</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">6</span>    <span class="number">8</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">9</span></span><br><span class="line"><span class="number">6</span> 是第一个非叶子节点，从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作</span><br><span class="line"><span class="number">6</span> 和 <span class="number">9</span> 交换位置。</span><br><span class="line">满足最大堆的性质。</span><br><span class="line"></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">9</span>    <span class="number">8</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">6</span></span><br><span class="line">对根节点<span class="number">4</span> 元素进行 shift down 操作</span><br><span class="line"></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">6</span></span><br><span class="line">对<span class="number">6</span> 元素进行 shift down 操作</span><br><span class="line"></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">6</span>    <span class="number">8</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">此时整个序列最大值即为堆顶元素，</span><br><span class="line">我们将其与末尾元素交换，使末尾元素为最大值，</span><br><span class="line">然后再调整堆顶元素使得剩下的 n<span class="number">-1</span> 个元素仍为大根堆，</span><br><span class="line">再重复执行以上操作我们即能得到一个有序的序列。</span><br><span class="line"></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">6</span>    <span class="number">8</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">8</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">6</span>    <span class="number">4</span></span><br><span class="line"> / \  </span><br><span class="line"><span class="number">5</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">6</span>   <span class="number">4</span> </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">8</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>   <span class="number">4</span> </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">8</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span> </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">8</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">6</span> </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">8</span>   <span class="number">9</span></span><br><span class="line">  </span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span> </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="comment"># 迭代写法</span></span><br><span class="line">    <span class="comment"># def adjust_heap(nums, startpos, endpos):</span></span><br><span class="line">    <span class="comment">#     newitem = nums[startpos]</span></span><br><span class="line">    <span class="comment">#     pos = startpos</span></span><br><span class="line">    <span class="comment">#     childpos = pos * 2 + 1</span></span><br><span class="line">    <span class="comment">#     while childpos &lt; endpos:</span></span><br><span class="line">    <span class="comment">#         rightpos = childpos + 1</span></span><br><span class="line">    <span class="comment">#         if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:</span></span><br><span class="line">    <span class="comment">#             childpos = rightpos</span></span><br><span class="line">    <span class="comment">#         if newitem &lt; nums[childpos]:</span></span><br><span class="line">    <span class="comment">#             nums[pos] = nums[childpos]</span></span><br><span class="line">    <span class="comment">#             pos = childpos</span></span><br><span class="line">    <span class="comment">#             childpos = pos * 2 + 1</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             break</span></span><br><span class="line">    <span class="comment">#     nums[pos] = newitem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归写法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span>(<span class="params">nums, startpos, endpos</span>):</span></span><br><span class="line">        pos = startpos</span><br><span class="line">        chilidpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> chilidpos &lt; endpos:</span><br><span class="line">            rightpos = chilidpos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightpos &lt; endpos <span class="keyword">and</span> nums[rightpos] &gt; nums[chilidpos]:</span><br><span class="line">                chilidpos = rightpos</span><br><span class="line">            <span class="keyword">if</span> nums[chilidpos] &gt; nums[pos]:</span><br><span class="line">                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]</span><br><span class="line">                adjust_heap(nums, pos, endpos)</span><br><span class="line"></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n // <span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i, n)</span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">heap_sort(alist)</span><br><span class="line">print(alist)</span><br><span class="line"><span class="comment"># [4, 5, 6, 8, 9]</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Top-K-问题"><a href="#Top-K-问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h1><p>面试题中有这样一类问题，让求出大量数据中的top k 个元素，比如一亿个数字中最大的100个数字。<br>对于这种问题有很多种解法，比如直接排序、mapreduce、trie 树、分治法等，当然如果内存够用直接排序是最简单的。<br>如果内存不够用呢？ 这里我们提一下使用固定大小的堆来解决这个问题的方式。</p>
<p>一开始的思路可能是，既然求最大的 k 个数，是不是应该维护一个包含 k 个元素的最大堆呢？<br>稍微尝试下你会发现走不通。我们先用数组的前面 k 个元素建立最大堆，然后对剩下的元素进行比对，但是最大堆只能每次获取堆顶<br>最大的一个元素，如果我们取下一个大于堆顶的值和堆顶替换，你会发现堆底部的小数一直不会被换掉。如果下一个元素小于堆顶<br>就替换也不对，这样可能最大的元素就被我们丢掉了。</p>
<p>相反我们用最小堆呢？<br>先迭代前 k 个元素建立一个最小堆，之后的元素如果小于堆顶最小值，跳过，否则替换堆顶元素并重新调整堆。你会发现最小堆里<br>慢慢就被替换成了最大的那些值，并且最后堆顶是最大的 topk 个值中的最小值。<br>（比如1000个数找10个，最后堆里剩余的是 [990, 991, 992, 996, 994, 993, 997, 998, 999, 995]，第一个 990 最小)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopK</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取大量元素 topk 大个元素，固定内存</span></span><br><span class="line"><span class="string">    思路：</span></span><br><span class="line"><span class="string">    1.先放入元素前 K 个建立最小堆</span></span><br><span class="line"><span class="string">    2.迭代剩余元素：</span></span><br><span class="line"><span class="string">        如果当前元素小于堆顶元素，跳过该元素(肯定不是前 K 大)</span></span><br><span class="line"><span class="string">        否则替换堆顶元素为当前元素，并重新调整堆</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterable, k</span>):</span></span><br><span class="line">        self.minheap = []         <span class="comment"># 定义最小堆</span></span><br><span class="line">        self.capacity = k         <span class="comment"># 最小堆容量为k个元素</span></span><br><span class="line">        self.iterable = iterable</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(self.minheap) &gt;= self.capacity:</span><br><span class="line">            min_val = self.minheap[<span class="number">0</span>]  </span><br><span class="line">            <span class="keyword">if</span> val &lt; min_val: </span><br><span class="line">                <span class="comment"># 当然你可以直接 if val &gt; min_val操作，这里我只是显示指出跳过这个元素</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 返回并且pop堆顶最小值，推入新的 val 值并调整堆</span></span><br><span class="line">                heapq.heapreplace(self.minheap, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 前面k个元素直接放入minheap</span></span><br><span class="line">            heapq.heappush(self.minheap, val)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_topk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> self.iterable:</span><br><span class="line">            self.push(val)</span><br><span class="line">        <span class="keyword">return</span> self.minheap</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    i = list(range(<span class="number">100</span>)) <span class="comment"># 这里可以是一个可迭代元素，节省内存</span></span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line">    random.shuffle(i)</span><br><span class="line">    _ = TopK(i, <span class="number">10</span>)</span><br><span class="line">    print(_.get_topk())</span><br><span class="line"> </span><br><span class="line">test()</span><br><span class="line"><span class="comment"># [90, 91, 93, 92, 97, 96, 94, 95, 98, 99]</span></span><br></pre></td></tr></tbody></table></figure>

<p>o(n^2)级别排序算法</p>
<p>为什么要学习O(n^2)的排序方法？<br>● 基础<br>● 编码简单，易于实现，是一些简单情景的首选<br>● 在一些特殊情况下，简单的排序算法更有效<br>● 简单的排序算法思想衍生出复杂的排序算法<br>● 作为子过程，改进更复杂的排序算法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/jian-zhi-offer25-30-ti/" class="post-title-link" itemprop="url">剑指offer25~30题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 04:58:43" itemprop="dateModified" datetime="2021-04-21T04:58:43Z">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="树的知识点："><a href="#树的知识点：" class="headerlink" title="树的知识点："></a>树的知识点：</h4><h5 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h5><p>树是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，<br>用来模拟具有树状结构性质的数据集合。<br>它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。<br>把它叫做“树”是因为它看起来像一棵倒挂的树，<br>是根朝上，而叶朝下的。<br>它具有以下的特点：</p>
<ul>
<li>每个结点至多只有两颗子树</li>
<li>二叉树的子树有左右之分，其次序不能任意颠倒</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
<p>树的术语</p>
<ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树的度：一棵树中，最大的节点的度称为树的度；</li>
<li>叶节点或终端节点：度为零的节点；没有子节点</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ul>
<p>树的种类</p>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li>二叉树：每个节点最多含有两个子树的树，子树被称作“左子树”（left subtree）和“右子树”（right subtree）二叉树常被用于实现二叉查找树和二叉堆。<br>二叉树的一些性质，这些性质可以很简单得到证明：<ol>
<li>: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）  </li>
<li>: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</li>
<li>: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</li>
<li>: 具有n个结点的完全二叉树的深度必为 log2(n+1)  (log2n)+1。（(log2n)表示不大于x的最大整数）。可以理解为性质2的倒推</li>
<li>:对完全二叉树，若从上至下、从左至右按照层序编号，则编号为i 的结点，<br>对任意一个节点（1&lt;=i&lt;=n）有：<br>如果i=1，则节点i是完全二叉树的根，无双亲；如果i&gt;1，其双亲节点是[i/2]<br>如果2i&gt;n，则节点i无左孩子（节点i为叶子节点）；否则左孩子是2i<br>如果2i+1&gt;n，则节点i无右孩子；否则其右孩子是节点2i+1<br>其左孩子编号必为2i，其右孩子编号必为2i＋1；<br>其双亲的编号必为i/2（i＝1 时为根,除外）</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>- 完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。
除了第d层外，其它各层（1~d-1）的节点数目均已达最大值，
且第d层有叶子结点所有节点从左向右连续地紧密排列，
并且最后一层或者是满的，或者是在右边缺少连续若干节点，

满二叉树的定义是所有叶节点都在最底层的完全二叉树;
除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树
一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。
特点是每一层上的节点数都是最大节点数。
</code></pre>
<p>深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点<br>    - 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<br>    - 二叉搜索树：Binary Search Tree<br>    左子树中所有节点的值 =&lt; 根节点的值 =&lt; 右子树中所有节点的值</p>
<ul>
<li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li>
</ul>
<p>树的存储与表示<br>顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，<br>但因所占空间比较大，是非主流二叉树。<br>二叉树通常以链式存储。</p>
<p>二叉树的节点表示以及树的创建<br>通过使用Node类中定义三个属性，分别为elem本身的值，<br>还有lchild左孩子和rchild右孩子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">""" 定义树的存储结构 Definition of a binary tree node."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>


<p>树的创建，创建一个树的类，并给一个root根节点，一开始为空，随后添加节点</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">"""树类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root=None</span>):</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""为树添加节点"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line">        <span class="comment">#如果树是空的，则对根节点赋值</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="comment">#弹出队列的第一个元素</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.lchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.lchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> cur.rchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.rchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果左右子树都不为空，加入队列继续判断</span></span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></tbody></table></figure>


<p>常见的一些树的应用场景<br>1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树<br>2.路由协议就是使用了树的算法<br>3.mysql数据库索引<br>4.文件系统的目录结构<br>5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构</p>
<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/Users\Administrator\Desktop\剑指offer\二叉树.png">)</p>
<h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，<br>使每一个结点都被访问一次且只仅访问一次。<br>由于二叉树是非线性结构，<br>因树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p>
<p>深度优先搜索(Depth First Search DFS)<br>沿着树的深度遍历树的节点，<br>尽可能深的搜索树的分支，<br>从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。<br>这三种方式常被用于访问树的节点，可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）</p>
<p>当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
<p>深度优先遍历、递归、栈，它们三者的关系背后统一的逻辑都是「后进先出」</p>
<p>解决可达性的问题。<br>两个要点：<br>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。<br>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</p>
<p>找到开始节点-&gt;访问节点并进行操作-&gt;递归调用dfs遍历下一个节点-&gt;遇到边界或已访问节点就return返回-&gt;全部遍历结束返回到开始节点，结束dfs</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">7</span>     <span class="number">8</span> <span class="number">9</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>层次遍历： 0 1 2 3 4 5 6 7 8 9<br>先序遍历： 0 1 3 7 8 4 9 2 5 6<br>中序遍历： 7 3 8 1 9 4 0 5 2 6<br>         738认作一个左子树，94认作一个右子树，该子树的根节点 1<br>         738认作一个左子树，94认作一个节点，该子树的根节点 1<br>         134认作一个左子树，256认作一个右子树<br>后序遍历： 7 8 3 9 4 1 5 6 2 0</p>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> /  <span class="tag">\</span></span><br><span class="line">B    F</span><br><span class="line"> <span class="tag">\<span class="name"> </span></span>   <span class="tag">\</span></span><br><span class="line">  C    G</span><br><span class="line">    / <span class="tag">\<span class="name"> </span></span> /</span><br><span class="line">   D   E H</span><br></pre></td></tr></tbody></table></figure>
<p>先序:a b c d e f g h<br>中序:b d c e a f h g<br>后序:d e c b h g f a</p>
<ul>
<li>先(前)序遍历 我们先访问根节点，然后递归使用先序遍历访问左子树，<br>再递归使用先序遍历访问右子树<br>根节点-&gt;左子树-&gt;右子树<br>Top-&gt;Bottom 和 Left-&gt;Right</li>
</ul>
<p>迭代<br>使用栈来完成，先将根节点放入栈中，<br>将根节点出栈，将根节点值放入结果数组中<br>然后遍历左子树、右子树，<br>因为栈是先进后出，<br>先压右节点右子树入栈，再压左节点左子树入栈，<br>出栈的时候才是先左后右的顺序，整体顺序才是中左右<br>每次迭代弹出当前栈顶元素，<br>继续出栈（左子树被出栈）……<br>依次循环出栈遍历入栈，直到栈为空，遍历完成</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">前序</span><br><span class="line">                               |<span class="string">3</span>|</span><br><span class="line">                     |<span class="string">1</span>|<span class="string">       </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">            </span>|<span class="string">5</span>|</span><br><span class="line">      |<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                             |<span class="string">6</span>|</span><br><span class="line">                                                        |<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                                              |<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">                                         |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                                    |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                          </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|</span><br><span class="line">res   |<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        <span class="comment"># [root, ]这个‘,’是什么意思呀?这个是方便多行定义的时候复制的,</span></span><br><span class="line">        <span class="comment">#否则容易在添加元素的过程中缺少逗号出现语法错误.</span></span><br><span class="line">        <span class="comment">#具体可以查python data structure trailing comma这个关键词. </span></span><br><span class="line">        <span class="comment">#对于tuple的定义就有差别了,因为(1)这个东西有二意性,</span></span><br><span class="line">        <span class="comment"># 所以tuple声明单元素的时候必须加逗号,也就是(1,)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 第一步的，先访问的是根节点，辅助栈的</span></span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                output.append(root.val)  <span class="comment"># 把根节点加入到结果集</span></span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    stack.append(root.right)  <span class="comment"># 加入到辅助栈</span></span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    stack.append(root.left)  <span class="comment"># 加入到辅助栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。<br>空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</p>
<p>先将根节点 cur 和遍历所有的左子树入栈并加入结果中，直至 cur 为空，<br>用一个 while 循环实现：<br>然后，每弹出一个栈顶元素 tmp，就到达它的右孩子，<br>再将这个节点当作 cur 重新按上面的步骤来一遍，直至栈为空。<br>这里又需要一个 while 循环。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">前序</span><br><span class="line">                |<span class="string">3</span>|<span class="string">       </span>|<span class="string">4</span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                             |<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                                                   |<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">    </span></span><br><span class="line"><span class="string">                                              </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>

<p>两个操作，一个是处理：将元素放进res数组中，一个是访问：遍历节点。<br>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，<br>因为要访问的元素和要处理的元素（也就是在把节点的数值放进result数组中）<br>顺序是一致的，都是中间节点。遇到节点直接把它的值存到输出数组里面，<br>所以刚刚才能写出相对简洁的代码</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        cur = root  <span class="comment"># 将树压入栈中</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack :  <span class="comment"># 循环栈</span></span><br><span class="line">            <span class="comment"># 根节点和左子树入栈</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left  <span class="comment"># 移至最左</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每弹出一个元素，就到达右子树</span></span><br><span class="line">            temp  = stack.pop()  <span class="comment"># 根节点等于出栈的节点</span></span><br><span class="line">            cur = temp.right</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>中序（根）遍历<br>左子树-&gt;根节点-&gt;右子树<br>先访问的是二叉树顶部的节点，<br>然后一层一层向下访问，直到到达树左面的最底部，<br>再开始处理节点（也就是在把节点的数值放进result数组中），<br>这就造成了处理顺序和访问顺序是不一致的。</li>
</ul>
<p>就需要借用指针的遍历来帮助访问节点，<br>栈则用来处理节点上的元素。<br>创建一个Stack，然后按 左 中 右的顺序输出节点。<br>尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，<br><u>其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，<br>并且在寻找的过程中记录了来源，才能返回上层</u>,<br>同时在返回上层的时候已经处理完毕左子树了。<br>当处理完最小单位的子树时，返回到上层处理了中间节点。<br>如果有右节点，其也要进行中序遍历。</p>
<p>和前序遍历的代码完全相同，<br>只是在出栈的时候才将节点 tmp 的值加入到结果中。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">中序</span><br><span class="line">                                         </span><br><span class="line">           |<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">                               </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|</span><br><span class="line">res   |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">            0</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          1    2</span></span><br><span class="line"><span class="string">         / \  / \</span></span><br><span class="line"><span class="string">        3  4 5   6</span></span><br><span class="line"><span class="string">中序</span></span><br><span class="line"><span class="string">                </span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string"> </span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                                  |<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                                                   |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">     </span></span><br><span class="line"><span class="string">                                              </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span></span><br><span class="line"><span class="string">                          </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span></span><br><span class="line"><span class="string">res   </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">   </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack :</span><br><span class="line">            <span class="comment"># cur 节点不为空一直压栈，并到达最左端的叶子节点</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 考虑左子树</span></span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 节点为空就出栈 </span></span><br><span class="line">            temp = stack.pop()</span><br><span class="line">            <span class="comment"># 出栈元素加入结果</span></span><br><span class="line">            res.append(temp.val)  </span><br><span class="line">            <span class="comment"># 考虑右子树</span></span><br><span class="line">            cur = temp.right</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>后序遍历 左子树-&gt;右子树-&gt;根节点 从下到上、从左至右</li>
</ul>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">1</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">4</span>  <span class="number">5</span>    </span><br><span class="line">```       </span><br><span class="line">当遍历完某个根节点的左子树，回到根节点的时候，</span><br><span class="line">对于中序遍历和先序遍历可以把当前根节点从栈里弹出，然后转到右子树</span><br><span class="line">当遍历完 <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span> 的时候，回到 <span class="number">1</span> 之后我们就可以把 <span class="number">1</span> 弹出，</span><br><span class="line">然后通过 <span class="number">1</span> 到达右子树继续遍历。</span><br><span class="line"></span><br><span class="line">而对于后序遍历，当我们到达 <span class="number">1</span> 的时候并不能立刻把 <span class="number">1</span> 弹出，</span><br><span class="line">因为遍历完右子树，我们还需要将这个根节点加入到 <span class="type">list</span> 中。</span><br><span class="line">所以我们就需要判断是从左子树到的根节点，还是右子树到的根节点。</span><br><span class="line">如果是从左子树到的根节点，此时应该转到右子树。</span><br><span class="line">如果是从右子树到的根节点，那么就可以把当前节点弹出，并且加入到 <span class="type">list</span> 中。</span><br><span class="line"></span><br><span class="line">当然，如果是从左子树到的根节点，此时如果根节点的右子树为 None， </span><br><span class="line">此时也可以把当前节点弹出，并且加入到 <span class="type">list</span> 中。</span><br><span class="line"></span><br><span class="line">基于上边的思想，可以写出一些不同的代码。</span><br><span class="line"></span><br><span class="line">法一：</span><br><span class="line">从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，</span><br><span class="line">然后依次压入它的所有孩子节点，</span><br><span class="line">而这里是先把左节点压入栈，再把右节点压入栈（根 - 右 - 左），</span><br><span class="line">按照从上到下、从左至右的顺序依次压入栈中。</span><br><span class="line">需要将输出列表逆序输出（左 - 右 -根），即后续遍历。</span><br><span class="line"></span><br><span class="line">只是能返回遍历的结果，并不是严格意义上树拓扑结构的遍历。</span><br><span class="line">虽然结果是正确，但是如果需要按照后续遍历的顺序对树节点进行访问（或操作），此解法就无法满足。</span><br><span class="line"></span><br><span class="line">时间复杂度为 O(N)：访问每个节点恰好一次，其中 N 是节点的个数，也就是树的大小。</span><br><span class="line">空间复杂度为 O(N)：取决于树的结构，最坏情况需要保存整棵树</span><br><span class="line"></span><br><span class="line">先序遍历：root-&gt;left-&gt;right </span><br><span class="line">后序遍历：left-&gt;right-root，两者反过来当然不相等了，</span><br><span class="line">但是如果把先序遍历改成root-&gt;right-left，再逆序一下就相等了</span><br></pre></td></tr></tbody></table></figure>
<pre><code>        0
       /  \
      1    2
</code></pre>
<p>后序</p>
<pre><code>       | |  | |  |2|  | |
</code></pre>
<p>stack |0|  | |  |1|  |1|  |1|  | | </p>
<pre><code>                           |1| 
            | |  | |  |2|  |2| 压入根左右
</code></pre>
<p>res   | |  |0|  |0|  |0|  |0|  |0| 弹出根右左————逆序：左右根</p>
<pre><code>        0
       /  \
      1    2
     / \  / \
    3  4 5   6
</code></pre>
<p>后序<br>                          |6|  | |<br>           | |  |2|  | |  |5|  |5|  | |  | |  | |  |4|  | |  | |<br>stack |0|  | |  |1|  |1|  |1|  |1|  |1|  | |  |3|  |3|  |3|  | |<br>      —  —  —  —  —  —  —  —  —  —  —  — </p>
<pre><code>                                                         |3|
                                               | |  |4|  |4|    
                                     |1|  |1|  |1|  |1|  |1|
                      | |  | |  |5|  |5|  |5|  |5|  |5|  |5|
            | |  | |  | |  |6|  |6|  |6|  |6|  |6|  |6|  |6| 
       | |  | |  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|
</code></pre>
<p>res   | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|<br>      —  —  —  —  —  —  —  —  —  —  —  —</p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```<span class="keyword">python</span></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, roo<span class="variable">t:</span> TreeNode) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line">        stack = [root,]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.<span class="keyword">pop</span>()</span><br><span class="line">            <span class="keyword">res</span>.<span class="keyword">append</span>(node.val)</span><br><span class="line">            # <span class="keyword">res</span>.<span class="keyword">insert</span>(<span class="number">0</span>, node.val)  # 直接插入头部，不用反转</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.<span class="keyword">left</span> :</span><br><span class="line">                stack.<span class="keyword">append</span>(node.<span class="keyword">left</span>)</span><br><span class="line">            <span class="keyword">if</span> node.righ<span class="variable">t:</span></span><br><span class="line">                stack.<span class="keyword">append</span>(node.<span class="keyword">right</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span>[::-<span class="number">1</span>]</span><br><span class="line">        # <span class="keyword">return</span> <span class="keyword">res</span>  # 直接插入头部，不用反转</span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>从「根-左-右」<br>节点插入结果数组尾部的逻辑，修改为将节点插入结果数组的头部，数组变成<br>—&gt; 「右-左-根」<br>遍历的顺序先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点<br>—&gt; 「左-右-根」这刚好是后序遍历的顺序</p>
<p>节点 cur 先到达最右端的叶子节点并将路径上的节点入栈；<br>然后每次从栈中弹出一个元素后，cur 到达它的左孩子，<br>并将左孩子看作 cur 继续执行上面的步骤。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">后序</span><br><span class="line">                                         </span><br><span class="line">           |<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">                          </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> 压入根左右</span></span><br><span class="line"><span class="string">res   </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> 弹出根右左————逆序：左右根</span></span><br><span class="line"></span><br><span class="line"><span class="string">            0</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          1    2</span></span><br><span class="line"><span class="string">         / \  / \</span></span><br><span class="line"><span class="string">        3  4 5   6</span></span><br><span class="line"><span class="string">后序</span></span><br><span class="line"><span class="string">                </span>|<span class="string">6</span>|<span class="string">       </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                                  |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|</span><br><span class="line">                                                   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">    </span></span><br><span class="line"><span class="string">                                         </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                          |<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, stack = [], []</span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:  </span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.insert(<span class="number">0</span>, cur.val)  <span class="comment"># 插入头部不用逆序</span></span><br><span class="line">                <span class="comment"># res.append(cur.val)  # 插入尾部要逆序</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 每次先遍历右节点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再遍历左节点</span></span><br><span class="line">            cur = stack.pop().left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 插入头部不用逆序，更快</span></span><br><span class="line">        <span class="comment"># return res[::-1]  # 插入尾部要逆序输出，要慢很多 </span></span><br></pre></td></tr></tbody></table></figure>


<p>因此掌握标准的栈操作解法是必要的。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">laterOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="keyword">while</span> tmpNode <span class="keyword">or</span> stack :</span><br><span class="line">        <span class="keyword">while</span> tmpNode:</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node = stack[<span class="number">-1</span>]</span><br><span class="line">        tmpNode = node.right</span><br><span class="line">        <span class="keyword">if</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> node == stack[<span class="number">-1</span>].right:</span><br><span class="line">                node =  stack.pop()</span><br><span class="line">                print(node.val)</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>递归算法的三个要素<br>1.确定递归函数的参数和返回值：<br>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，<br>并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
<p>2.确定终止条件：<br>写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，<br>就是没写终止条件或者终止条件写的不对，<br>操作系统也是用一个栈的结构来保存每一层递归的信息，<br>如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
<p>3.确定单层递归的逻辑：<br>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
<p>它们的模板相对比较固定，一般都会新增一个 dfs 函数：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">        dfs(root.right)</span><br></pre></td></tr></tbody></table></figure>

<p>对于前序、中序和后序遍历，<br>只需将递归函数里的 res.append(root.val) 放在不同位置即可，<br>然后调用这个递归函数就可以了，代码完全一样。</p>
<p>1.前序遍历</p>
<ol>
<li>确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，<br>所以参数里需要传入root在放节点的数值，<br>除了这一点就不需要在处理什么数据了也不需要有返回值，<br>所以递归函数返回类型就是</li>
<li>确定终止条件：在递归的过程中，如何算是递归结束了呢，<br>当然是当前遍历的节点是空了，那么本层递归就要要结束了，<br>所以如果当前遍历的这个节点是空，就直接return</li>
<li>确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>2.中序遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```                </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>后序遍历</span><br><span class="line">```python </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 右</span></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```                     </span><br><span class="line"></span><br><span class="line">- 广度优先遍历（Breath First Search）bfs</span><br><span class="line">返回其按 层序遍历 得到的节点值。</span><br><span class="line">从树的root开始，从上到下从从左到右遍历整个树的节点</span><br><span class="line">按照高度顺序逐层遍历的访问整棵树，</span><br><span class="line">示例：</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br></pre></td></tr></tbody></table></figure>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回其层次遍历结果：</span><br></pre></td></tr></tbody></table></figure>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</span><br><span class="line">每层遍历都以上一层遍历的结果作为起点，遍历一个长度，遍历一个距离能访问到的所有节点。</span><br><span class="line">要求我们区分每一层，同一层的节点应该放在一起，也就是返回一个二维数组，故使用模板二。</span><br><span class="line"></span><br><span class="line">使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，</span><br><span class="line">再把每个元素的非空左右子节点进入队列。</span><br><span class="line">因此即可得到每层的遍历。</span><br><span class="line">用到 deque 的结构用来模拟队列（先进先出），当前层的节点肯定会优先访问，</span><br><span class="line">先将根节点放到队列中，然后不断遍历队列</span><br><span class="line">然后每次处理从队列中出队一个元素</span><br><span class="line">要明确要从那些点开始扩张(具体如何扩张需要根据题目要求)</span><br><span class="line">对于扩张后满足某条件的点再进行处理，根据需要进入队列，</span><br><span class="line">进入队列的点就是扩到下一层的点(不同题目需要处理的方法不同，大家灵活运用)</span><br><span class="line">然后接着循环处理 deque 中的元素，直到 deque 为空，则代表所有点都已经完成扩张</span><br><span class="line">最后根据题目要求输出结果(当然这已经不属于 BFS 模板的范围了)</span><br><span class="line"></span><br><span class="line">BFS总共有两个模板：</span><br><span class="line">  1. 如果不需要确定当前遍历到了哪一层，BFS模板如下。</span><br><span class="line">```py</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 <span class="keyword">in</span> cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>如果要确定当前遍历到了哪一层，BFS模板如下。<br>这里增加了level表示当前遍历到二叉树中的哪一层了，<br>也可以理解为在一个图中，现在已经走了多少步了。<br>size表示在当前遍历层有多少个元素，<br>也就是队列中的元素数，<br>我们把这些元素一次性遍历完，<br>即把当前层的所有元素都向外走了一步。<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level = 0</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) {</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 <span class="keyword">in</span> cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    }</span><br><span class="line">    level ++;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点对象list1初始仅包含根节点，后续仅保存一层节点</span><br><span class="line">节点值list2初始为空，后续累积保存整棵树的所有节点值</span><br><span class="line"><span class="keyword">while</span> 节点对象list1不为空:</span><br><span class="line">    收集当前层节点对象list1的每一个值，添加保存至节点值list2</span><br><span class="line">    收集当前层节点对象list1的每一个子节点，覆盖保存至节点对象list1</span><br><span class="line">返回收集完全的节点值list2</span><br></pre></td></tr></tbody></table></figure>

<p>实现 BFS 时需要考虑以下问题：<br>队列：用来存储每一轮遍历的节点；<br>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</p>
<p>适用场景：求解目标：「层序遍历」、「最短路径」。<br>输入数据：没什么特征，不像深搜，需要有“递归”的性质。<br>如果是树或者状态转换图，概率更大。</p>
<p>算法流程：</p>
<ol>
<li>特例处理： 当根节点为空，则返回空列表 [] ；</li>
<li>初始化： 打印最终结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li>
<li>BFS 循环： 当队列 queue 为空时跳出；</li>
<li>新建一个临时列表 cur_layer ，用于存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）<br>避免定义了一个新队列存放下一层的节点，<ol>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 将 node.val 添加至 cur_layer 尾部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
</ol>
</li>
<li>将当前层结果 cur_layer 添加入 res 。</li>
<li>返回值： 返回打印结果列表 res 即可。</li>
</ol>
<p>时间复杂度 O(N)：每个点进队出队各一次，BFS 需循环 n 次。n 为二叉树的节点数量<br>空间复杂度 O(N)： 因为是按层打印，最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。<br>假定是满二叉树，也就是叶子节点那一层全满，那么每一层应该是2^(n-1)，<br>然后采用等比数列求和，就是2^n-1，<br>所以 (2^n-1) / (2^n-1) 约等于2，<br>所以可以看到几乎就是N/2<br>这个 N / 2 是一个数量级的表示，代表平衡情况下 最后一层节点数量是 所有节点数量的一半。<br>准确来说，最后一层节点的数量是 (N+1)/2 ~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span>  <span class="comment"># 返回含列表的列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># root为空遇到叶子节点返回[] </span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)  <span class="comment"># 根元素入队列</span></span><br><span class="line">        res = []  <span class="comment"># 层序遍历结果列表</span></span><br><span class="line">        <span class="keyword">while</span> queue:  <span class="comment"># 直到队列为空，无法再次向队列中推入节点，循环结束。</span></span><br><span class="line">            <span class="comment"># 当队列不为空的时候</span></span><br><span class="line">            cur_layer = []  <span class="comment"># 临时变量，记录当前层的节点</span></span><br><span class="line">            <span class="comment"># 第i次迭代得到二叉树的第i层的len(queue)个结点进行拓展</span></span><br><span class="line">            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                <span class="comment"># range() 的工作机制是在开启循环时建立一个列表，然后循环按照这个列表进行，因此“只会在进入循环前执行一次 len(queue) ” </span></span><br><span class="line">                cur = queue.popleft()  <span class="comment"># 从弹出队列的头部元素开始将队列中的元素都拿出来(也就是获取这一层的节点)</span></span><br><span class="line">                <span class="comment"># 不用判断 if cur: 因为不是序列化，None时不会append</span></span><br><span class="line">                cur_layer.append(cur.val)  <span class="comment"># 节点加入到当前层cur_layer</span></span><br><span class="line">                <span class="comment"># 如果当前节点有左右子节点，则先左后右压入队列，作为下一层的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)  <span class="comment"># 左子树，移动一层，不是最左</span></span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="comment">#  某一层的节点都处理完之后，将临时的当前层的结果压入最终返回结果中</span></span><br><span class="line">            res.append(cur_layer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line">                                    |<span class="string">6</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">               </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">queue |<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string"> </span></span><br><span class="line"><span class="string">cur_l </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span></span><br><span class="line"></span><br><span class="line"><span class="string">                                                        </span>|<span class="string">6</span>|</span><br><span class="line">                                                        |<span class="string">5</span>|</span><br><span class="line">                                                        |<span class="string">4</span>|</span><br><span class="line">                                                        |<span class="string">3</span>|<span class="string">     </span></span><br><span class="line"><span class="string">                                                        </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                                    </span>|<span class="string">2</span>|<span class="string">                 </span>|<span class="string">2</span>|</span><br><span class="line">                                    |<span class="string">1</span>|<span class="string">                 </span>|<span class="string">1</span>|<span class="string">   </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">res   </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  </span></span><br></pre></td></tr></tbody></table></figure>

<p>当访问根结点 3 的时候需要把它的左右孩子结点 [9, 20]先保存起来，访问[9, 20]把它两个结点的左右孩子结点保存起来[none, none, 15, 7], 访问[15, 7]的时候左右孩子结点为 [ ]。返访问为空结束层遍历。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># root为空时直接返回[]</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []  <span class="comment"># 返回的最终结果</span></span><br><span class="line">        cur_nodes = [root]  <span class="comment"># 当前访问层</span></span><br><span class="line">        next_nodes = []  <span class="comment"># 下一层需要访问的</span></span><br><span class="line">        res.append([i.val <span class="keyword">for</span> i <span class="keyword">in</span> cur_nodes])  <span class="comment"># 先把第一层的值放入res中</span></span><br><span class="line">        <span class="keyword">while</span> cur_nodes <span class="keyword">or</span> next_nodes:  <span class="comment"># 当前结点或下一层结点不为空</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur_nodes:  <span class="comment"># 当前结点的所有孩子都加入next_nodes</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_nodes.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_nodes.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> next_nodes:  <span class="comment"># 下一层结点不为空时加入res</span></span><br><span class="line">                res.append([i.val <span class="keyword">for</span> i <span class="keyword">in</span> next_nodes])</span><br><span class="line">            cur_nodes = next_nodes  <span class="comment"># 更新当前结点为next_nodes</span></span><br><span class="line">            next_nodes = []  <span class="comment"># 下一层结点置空</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line">                               |<span class="string">6</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">               </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">cur_n |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">next_ |<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                          </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                          |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">   </span></span><br><span class="line"><span class="string">           </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  </span></span><br></pre></td></tr></tbody></table></figure>


<p>递归<br>相同层的节点归于同一个数组<br>传入辅助的level参数决定层次</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">depth, r</span>):</span></span><br><span class="line">            <span class="comment"># 在第一次遍历到某一层是是没有"[]"的, 需要补一个"[]",用来存储该层节点值</span></span><br><span class="line">            <span class="comment"># 多维列表的长度</span></span><br><span class="line">            <span class="comment"># print(len([[1, 2], [3, 4], [5, 6]]))  # 3</span></span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            <span class="comment">#  将当前节点的值加入到res中，depth代表当前层，假设depth是3，节点值是99</span></span><br><span class="line">            <span class="comment"># res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]</span></span><br><span class="line">            res[depth - <span class="number">1</span>].append(r.val)</span><br><span class="line">            <span class="comment"># 递归的处理左子树，右子树，同时将层数depth+1</span></span><br><span class="line">            <span class="keyword">if</span> r.left:  <span class="comment"># 左节点存在，只在本次以左节点为根节点递归函数中深度加一</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right:  <span class="comment"># 右节点存在，只在本次以右节点为根节点递归函数中深度加一</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, r.right)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">1</span>, root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">0</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">3</span>  <span class="number">4</span> <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line"></span><br><span class="line">①root = <span class="number">0</span></span><br><span class="line">len(res) = <span class="number">0</span> &lt; depth = <span class="number">1</span></span><br><span class="line">res = [ [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">0</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>] ]</span><br><span class="line"></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">1</span> &lt; depth = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">0</span>], [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">1</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">2</span> = depth = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">1</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">②root = <span class="number">1</span></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">2</span> &lt; depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">3</span> = depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] ]</span><br><span class="line"></span><br><span class="line">②root = <span class="number">2</span></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">3</span> &lt; depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">3</span> = depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] ]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">"""递归法"""</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_to_result</span>(<span class="params">level, node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> level &gt; len(result) - <span class="number">1</span>:</span><br><span class="line">                result.append([])</span><br><span class="line">                </span><br><span class="line">            result[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                add_to_result(level+<span class="number">1</span>, node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                add_to_result(level+<span class="number">1</span>, node.right)</span><br><span class="line">        </span><br><span class="line">        add_to_result(<span class="number">0</span>, root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>本题使用 DFS 同样能做，DFS 不是按照层次遍历的。<br>为了让递归的过程中同一层的节点放到同一个列表中，<br>在递归时要记录每个节点的深度 level。<br>递归到新节点要把该节点放入 level 对应列表的末尾。</p>
<p>当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，<br>应该在 res 中新建一个列表用来保存该 level 的所有节点。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, depth</span>):</span></span><br><span class="line">            <span class="comment"># 相等于给当层返回值提供一个容器先，</span></span><br><span class="line">            <span class="comment"># 如果size的数量正好等于level，说明正好需要提供下一层的容器</span></span><br><span class="line">            <span class="comment"># 遍历到新的一个 level 时，需要新建一列表保存该层的所有节点</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left: helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> root.right: helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="28-从上往下打印二叉树"><a href="#28-从上往下打印二叉树" class="headerlink" title="28.从上往下打印二叉树"></a>28.从上往下打印二叉树</h2><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong><br>例如:<br>给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：</p>
<ul>
<li>二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。</li>
<li>BFS 通常借助 队列 的先入先出特性来实现。</li>
</ul>
<p>算法流程：</p>
<ol>
<li>特例处理：当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化：打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li>
<li>BFS 循环：当队列 queue 为空时跳出；</li>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 将 node.val 添加至列表 tmp 尾部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
<li>返回值： 返回打印结果列表 res ，一个一维数组，不用区分每一层。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，满二叉树的最下面那层 该层有N/2个节点，<br>即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</p>
<p>collections 中的双端队列 deque() 的 popleft() 方法 O(1) 时间复杂度；<br>列表 list 的 pop(0) 方法时间复杂度为 O(N) 。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span>  <span class="comment">#　返回含数字的列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []  <span class="comment"># 如果根结点为空，直接返回空列表</span></span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment"># 写成queue=[root]， pop(0) 方法时间复杂度为 O(N) </span></span><br><span class="line">        <span class="keyword">while</span> queue:  <span class="comment"># 当队列不为空时一直循环</span></span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span>          queue=[<span class="number">3</span>]</span><br><span class="line"> / \         res=[]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[]</span><br><span class="line"> / \         res=[<span class="number">3</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点  queue=[<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span>   </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[<span class="number">2</span>] # 队列默认删除第一个元素</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">9</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[<span class="number">2</span>]</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span>   </span><br><span class="line"> </span><br><span class="line">  <span class="number">3</span>          </span><br><span class="line"> / \         queue=[]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">  /  \       queue添加左右子节点 queue=[<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[<span class="number">7</span>]</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">1</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[<span class="number">7</span>] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[]</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">7</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[], queue为空</span><br><span class="line"> / \         跳出循环，返回res</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        </span><br><span class="line">  /  \        </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>        </span><br></pre></td></tr></tbody></table></figure>

<p><strong>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</strong></p>
<p>例如:<br>给定二叉树:&nbsp;[3,9,2,null,null,1,7],</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>奇数层正序打印顺序是从左边节点到右边节点，<br>偶数层倒序打印顺序是从右边节点到左边节点<br>双端队列的方法省了倒序的时间，</p>
<p>方法一：层序遍历 + 双端队列</p>
<ul>
<li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：<ul>
<li>奇数层 则添加至 tmp 尾部 ，</li>
<li>偶数层 则添加至 tmp 头部 。<br>算法流程：</li>
</ul>
</li>
</ul>
<ol>
<li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；</li>
<li>BFS 循环： 当 deque 为空时跳出；<ol>
<li>新建列表 tmp ，用于临时存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<ol>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；</li>
</ol>
</li>
<li>将当前层结果 tmp 转化为 list 并添加入 res ；</li>
</ol>
</li>
<li>返回值： 返回打印结果列表 res 即可；</li>
</ol>
<p>代码简短、容易实现；<br>但需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。</p>
<p>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；<br>双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                <span class="comment"># 每打印一层， res 长度就会加 1 ；</span></span><br><span class="line">                <span class="comment"># 因此，在遍历第 1 层时， res 长度为 0 ；</span></span><br><span class="line">                <span class="comment"># 在遍历第 2 层时， res 长度为 1；以此类推。 </span></span><br><span class="line">                <span class="comment"># 因此， res 的长度为 奇数 ，说明当前是偶数层。</span></span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span>:  <span class="comment"># if len(res) % 2 ，与位运算比除法更快</span></span><br><span class="line">                <span class="comment"># len(res)对2求余是1，代表是 1 3 5 7，此时在遍历 2 4 6 8 ……层，因此偶数层 -&gt; 队列头部</span></span><br><span class="line">                    tmp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># len(res)对2求余是0，即为奇数层 -&gt; 队列尾部</span></span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: deque.append(node.right)</span><br><span class="line">            res.append(list(tmp))  <span class="comment"># list() 这个函数时间复杂度是O（N）</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []  len(res)= <span class="number">0</span> <span class="number">0</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">deque = [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">tem = [] </span><br><span class="line">len(deque) = <span class="number">1</span> </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">tem = [<span class="number">3</span>] </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ] len(res)= <span class="number">1</span> <span class="number">1</span>%<span class="number">2</span>=<span class="number">1</span>!=<span class="number">0</span> 下一层插入队列头部</span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">2</span>]</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">tem = [<span class="number">9</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">tem = [<span class="number">2</span>，<span class="number">9</span>] </span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]  len(res)= <span class="number">2</span> <span class="number">2</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部 </span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">tem = [<span class="number">1</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">tem = [<span class="number">1</span>，<span class="number">7</span>] </span><br><span class="line">deque = []</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>，<span class="number">7</span>] ] </span><br><span class="line"></span><br><span class="line">deque = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>queue也可以直接用列表来存储，使用列表迭代来取节点，这样可以省略pop操作。<br>但是要注意不能直接给queue列表添加元素，这样会导致跳不出for循环，<br>要使用中间变量temp2来存储下一层节点。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = collections.deque()</span><br><span class="line">            temp2 = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span>:  <span class="comment"># 偶数层</span></span><br><span class="line">                    tmp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 奇数层</span></span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp2.append(node.right)</span><br><span class="line">            res.append(list(tmp))</span><br><span class="line">            queue = temp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []  len(res)= <span class="number">0</span> <span class="number">0</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">queue = [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">temp = [] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">temp = [<span class="number">3</span>] </span><br><span class="line">temp2 = [<span class="number">9</span>]</span><br><span class="line">temp2 = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ] len(res)= <span class="number">1</span> <span class="number">1</span>%<span class="number">2</span>=<span class="number">1</span>!=<span class="number">0</span> 下一层插入队列头部</span><br><span class="line">queue = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line">temp2 = []</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">temp = [<span class="number">9</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">temp = [<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line">temp2 = [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ] len(res)= <span class="number">2</span> <span class="number">2</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">queue = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line">temp2 = []</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">temp = [<span class="number">1</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">temp = [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>，<span class="number">7</span>] ] </span><br><span class="line">queue = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>方法三：层序遍历 + 双端队列（奇偶层逻辑分离）<br>通过将奇偶层逻辑拆分，可以消除冗余的判断。<br>算法流程：<br>与方法一对比，仅 BFS 循环不同。</p>
<ul>
<li>BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；<ol>
<li>打印奇数层： 从左向右 打印，先左后右 加入下层节点；</li>
<li>若 deque 为空，说明向下无偶数层，则跳出；</li>
<li>打印偶数层： 从右向左 打印，先右后左 加入下层节点；</li>
</ol>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># 打印奇数层</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="comment"># 从左向右打印</span></span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="comment"># 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span> node.left: </span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: </span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> deque: <span class="keyword">break</span> <span class="comment"># 若为空则提前跳出</span></span><br><span class="line">            <span class="comment"># 打印偶数层</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="comment"># 从右向左打印</span></span><br><span class="line">                node = deque.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="comment"># 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span> node.right: deque.appendleft(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: deque.appendleft(node.left)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">deque = [<span class="number">3</span>]</span><br><span class="line">tem = [] </span><br><span class="line">len(deque) = <span class="number">1</span></span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">tem = [<span class="number">3</span>] </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">tem = [<span class="number">2</span>] </span><br><span class="line">deque = [<span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">node = <span class="number">9</span> </span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]  </span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">tem = [<span class="number">1</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">tem = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>] ] </span><br><span class="line"></span><br><span class="line">deque = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>奇偶层的判断可以用标志符做判断，利用乘法“正负得负，负负得正”，<br>每层遍历完后做一次乘法，可以很简单的实现标志符的奇偶层转变。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># True False都可以只要反转就行</span></span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            flag = <span class="keyword">not</span> flag  <span class="comment"># 每次都进行反转</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="keyword">if</span> flag:  <span class="comment"># 从左向右打印</span></span><br><span class="line">                    node = deque.popleft()</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        deque.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        deque.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 从右向左，出队顺序为头进尾出，右节点早于左节点</span></span><br><span class="line">                    node = deque.pop()</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        deque.appendleft(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        deque.appendleft(node.left)</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">res</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">3</span>]</span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">3</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">2</span>] </span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">9</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">1</span>] </span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">7</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>] ]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        queue = deque([root])  <span class="comment">#储存每一层节点的队列</span></span><br><span class="line">        level = <span class="number">0</span>  <span class="comment">#表示节点的层级</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res.append([])</span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#偶数层</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        queue.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">#奇数层</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    node = queue.pop()</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        queue.appendleft(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        queue.appendleft(node.left)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">res</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">3</span>]</span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">3</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>] ]</span><br></pre></td></tr></tbody></table></figure>

<p>法五<br>双栈<br>如果当前层是偶数层(0,2,4),就访问queue1并依次读取左子树和右子树,<br>如果当前层是奇数层,就访问queue2并先读取右子树再读取左子树</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line">        level = <span class="number">0</span>  <span class="comment"># 表示节点的层级</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果当前是奇数层</span></span><br><span class="line">                <span class="comment"># 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(stack1)):</span><br><span class="line">                    node = stack1.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack2.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack2.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前是偶数层</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(stack2)):</span><br><span class="line">                    node = stack2.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack1.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack1.append(node.left)</span><br><span class="line">            res.append(temp)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">queue1 = [<span class="number">3</span>]</span><br><span class="line">queue2 = []</span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">res=[ [] ]</span><br><span class="line">len(queue1) = <span class="number">1</span></span><br><span class="line">queue1 = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">3</span>] ]</span><br><span class="line">queu2 = [<span class="number">9</span>]</span><br><span class="line">queue2 = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">level = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res = [ [<span class="number">3</span>], [] ]</span><br><span class="line">len(queue2) = <span class="number">2</span></span><br><span class="line">queue2 = [<span class="number">9</span>]</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>] ]</span><br><span class="line">queue1 = [<span class="number">7</span>]</span><br><span class="line">queue1 = [<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">queue2 = []</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]</span><br><span class="line">queue1 = [<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">level = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [] ]</span><br><span class="line">len(queue1) = <span class="number">2</span></span><br><span class="line">queue1 = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>] ]</span><br><span class="line">queue1 = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>] ]</span><br><span class="line">level = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">queue1 = queue2 = [] 都为空，跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>不需要level</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack2:  <span class="comment"># 如果当前是奇数层</span></span><br><span class="line">                <span class="comment"># 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2</span></span><br><span class="line">                <span class="keyword">while</span> stack1:</span><br><span class="line">                    node = stack1.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack2.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack2.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前是偶数层</span></span><br><span class="line">                <span class="keyword">while</span> stack2:</span><br><span class="line">                    node = stack2.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack1.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> stack1:</span><br><span class="line">                node = stack1.pop()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack2.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                res.append(temp)</span><br><span class="line">            temp2 = []</span><br><span class="line">            <span class="keyword">while</span> stack2:</span><br><span class="line">                node = stack2.pop()</span><br><span class="line">                temp2.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> temp2:</span><br><span class="line">                res.append(temp2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>



<p>层序遍历 + 倒序<br>此方法的优点是只用列表即可，无需其他数据结构。<br>偶数层倒序： 若 res 的长度为 奇数 ，说明当前是偶数层，则对 tmp 执行 倒序 操作。<br>复杂度分析：<br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        q = collections.deque()  <span class="comment"># BFS模板，需要用队列实现</span></span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)): <span class="comment"># 模板操作</span></span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果当前的res的长度是偶数，说明本次tmp中存储的是偶数层(设根为 0 层)</span></span><br><span class="line">                res.append(tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(tmp[::<span class="number">-1</span>])  <span class="comment"># 否则将tmp翻转再加入结果集</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="25-重建二叉树"><a href="#25-重建二叉树" class="headerlink" title="25.重建二叉树"></a>25.重建二叉树</h2><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">首先根据 preorder 找到根节点是 <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">然后根据根节点将 inorder 分成左子树和右子树</span><br><span class="line">左子树</span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">把相应的前序遍历的数组也加进来</span><br><span class="line">左子树</span><br><span class="line">preorder[<span class="number">9</span>] </span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">preorder[<span class="number">20</span> <span class="number">15</span> <span class="number">7</span>] </span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题</span><br><span class="line">然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 <span class="literal">null</span> 即可</span><br></pre></td></tr></tbody></table></figure>

<p>我们不需要真的把 preorder 和 inorder 切分了，只需要用分别用两个指针指向开头和结束位置即可。<br>注意下边的两个指针指向的数组范围是包括左边界，不包括右边界。</p>
<p>给出</p>
<figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前序遍历preorder = [<span class="keyword">E</span>,B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,F,H,G,<span class="keyword">I</span>,<span class="keyword">K</span>,J]</span><br><span class="line">中序遍历 inorder = [A,B,<span class="keyword">C</span>,<span class="keyword">D</span>,<span class="keyword">E</span>,F,G,H,<span class="keyword">I</span>,J,<span class="keyword">K</span>]</span><br><span class="line"></span><br><span class="line">根为第一个为 <span class="keyword">E</span>，则A,B,<span class="keyword">C</span>,<span class="keyword">D</span>为<span class="keyword">E</span>的左子树，F,G,H,<span class="keyword">I</span>,J,<span class="keyword">K</span>为<span class="keyword">E</span>的右子树</span><br><span class="line">A,B,<span class="keyword">C</span>,<span class="keyword">D</span>为左子树，B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,中的根为第一个为B,</span><br><span class="line">那么A 为根B的左子树，<span class="keyword">C</span>,<span class="keyword">D</span> 为根B的右子树</span><br><span class="line">B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,中的右子树的根为第一个<span class="keyword">D</span>，<span class="keyword">C</span>为根<span class="keyword">D</span>的左子树</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    E </span><br><span class="line">   / <span class="tag">\<span class="name"> </span></span></span><br><span class="line">  B   F</span><br><span class="line"> / <span class="tag">\<span class="name"> </span></span>  <span class="tag">\</span></span><br><span class="line">A   D   H</span><br><span class="line">    /  / <span class="tag">\<span class="name"> </span></span> </span><br><span class="line">   C  G   I</span><br><span class="line">           <span class="tag">\</span></span><br><span class="line">            K</span><br><span class="line">           /</span><br><span class="line">          J</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%89%8D%E4%B8%AD.png"></p>
<p>没有重复的元素：表明树中每个节点值都是唯一的，<br>保证节点的数值和它在中序遍历中的下标可以一一对应，<br>这样还原的二叉树才是可以唯一确定的</p>
<p>在中序遍历中搜索根节点 root 的索引 ，<br>可将此树的中序遍历划分为 [ 左子树 | 根节点 | 右子树 ] 。</p>
<p>根据中序遍历中的左（右）子树的节点数量，<br>可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ] 。</p>
<p>左子树区间 和 右子树区间 有对应的 左/右边界<br>这些边界分别用于递归左子树和右子树；</p>
<p>子树特点： 子树的前序和中序遍历仍符合以上特点，<br>通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。<br>此递推性质让我们联想到用 递归方法 处理。<br>知道inorder中，当前root的左侧的所有点就是其左子树，<br>root的右侧的所有点就是当前root的右子树，<br>就把这左右两堆数字想成当前root的左右2个节点就好，然后扔到函数里进行下一层的递归。</p>
<p>分治法的思想：把原问题分解（Divide）成若干个与原问题结构相同但规模更小的子问题，待子问题解决（Conquer）以后，再合并（Combine）它们，原问题就得以解决。</p>
<p>递归某子树解析：</p>
<ul>
<li><p>传入形参： </p>
<ol>
<li>当前递归到此子树根节点在先序遍历中的索引 pre_root 、</li>
<li>当前递归到此子树在中序遍历列表中的左 / 右边界的索引 in_left / in_right</li>
</ol>
</li>
<li><p>终止条件： 当 in_left &gt; in_right ，子树为空，已经越过叶子节点，此时返回空节点 。</p>
</li>
<li><p>递推工作：<br>recur(pre_root, in_left, in_right)自定义的递归函数，</p>
<ol>
<li><p>创建当前根节点root：当前节点在前序遍历中的索引为pre_root的节点<br>前序遍历的首个元素即为根节点 root 的值</p>
</li>
<li><p>搜索树的根节点root在中序遍历的索引i，从而将数组分为左子树和右子树<br> 就是代码中在HashMap中搜索到的 i ；<br> 每次搜索的时间复杂度为 O(1)。<br> 为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（中序遍历的元素，下标）键值对的哈希表。</p>
</li>
<li><p>实参<br>构建根节点root的左子树和右子树：通过调用 recur() 方法开启下一层递归。</p>
<ul>
<li>左子树：<br>根节点索引为 preL + 1 ，<br>左子树长度 x -(preL + 1) = i - 1 -inL<br>左子树右边界 x = i - 1 -inL + preL + 1 = i -inL + preL<br>左子树右边界不用传入递归函数，但是能方便算右子树的左边界<br>中序遍历的左右边界分别为 in_left 和 i - 1。</li>
<li>右子树： 根节点索引在前序遍历中为 i - in_left + preL + 1（即：根节点索引 + 左子树长度 + 1），<br>中序遍历的左右边界分别为 i + 1 和 in_right。</li>
</ul>
</li>
</ol>
</li>
<li><p>返回值： 返回 root 当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。<br>最后一层的结点p的话，他的左右子结点都返回一个空，下面会接着执行return root，也就是这个结点</p>
</li>
</ul>
<p>in_left：对当前节点递归时传入；<br>i - 1：中序遍历列表中当前节点的左边一定全部是左子树。</p>
<p>root.right = self.recur(pre_root + i - in_left + 1, i + 1, in_right)：<br>当前节点的序号做为0起点，加上中序遍历中左子树的长度，再右移1位得到右子树的根节点的序号；<br>i + 1：中序遍历列表中当前节点的右边一定全部是右子树；in_right：对当前节点递归时传入。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list2 = [<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>, <span class="string">'Google'</span>]</span><br><span class="line">dic = {}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list2)):</span><br><span class="line">    dic[list2[i]] = i</span><br><span class="line">    print(dic)</span><br><span class="line"><span class="comment"># {'Runoob': 0}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1, 'Google': 2}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1, 'Google': 2}</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；</span></span><br><span class="line">        <span class="comment"># 为什创建 po</span></span><br><span class="line">        <span class="comment"># 将self.po 指向 preorder 是为了在 recur() 中访问 preorder 。</span></span><br><span class="line">        <span class="comment"># 因为 recur() 中要用到前序遍历，所以要建立一个全局变量 po 。</span></span><br><span class="line">        <span class="comment"># 也可以把 preorder 作为参数传给 recur() 方法</span></span><br><span class="line">        <span class="comment"># 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例</span></span><br><span class="line">        self.dic, self.po = {}, preorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            <span class="comment"># 将中序遍历中序列的节点值及索引全部记录在哈希表中</span></span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">            <span class="comment"># 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，</span></span><br><span class="line">            <span class="comment"># 用字典搜索是 O(1) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根节点 root 的 pre_root, in_left 都是 0</span></span><br><span class="line">        <span class="comment"># 开启递归并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, pre_root, in_left, in_right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None</span></span><br><span class="line">        <span class="comment"># 前序遍历的首个元素即为当前子树的根节点 root 的TreeNode对象</span></span><br><span class="line">        root = TreeNode(self.po[pre_root])</span><br><span class="line">        <span class="comment"># 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树</span></span><br><span class="line">        idx = self.dic[self.po[pre_root]]    </span><br><span class="line">        <span class="comment"># idx = inorder.index(preorder[pre_root])</span></span><br><span class="line">        <span class="comment"># index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1) </span></span><br><span class="line">        <span class="comment"># 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。</span></span><br><span class="line">        <span class="comment"># 开启左子树的下层递归，找左子树的根：</span></span><br><span class="line">        root.left = self.recur(pre_root + <span class="number">1</span>, in_left, idx - <span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 开启右子树的下层递归，找右子树的根：</span></span><br><span class="line">        root.right = self.recur(idx - in_left + pre_root + <span class="number">1</span>, idx + <span class="number">1</span>, in_right) </span><br><span class="line">        <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">pre_root, in_left, in_right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span> <span class="comment"># 终止条件：中序遍历为空</span></span><br><span class="line">            <span class="comment"># 直接用 preorder </span></span><br><span class="line">            root = TreeNode(preorder[pre_root])  <span class="comment"># 建立当前子树的根节点</span></span><br><span class="line">            i = dic[preorder[pre_root]]  <span class="comment"># 搜索根节点在中序遍历中的索引，从而可对根节点、左子树、右子树完成划分。</span></span><br><span class="line">            root.left = recur(pre_root + <span class="number">1</span>, in_left, i - <span class="number">1</span>) <span class="comment"># 开启左子树的下层递归</span></span><br><span class="line">            root.right = recur(i - in_left + pre_root + <span class="number">1</span>, i + <span class="number">1</span>, in_right) <span class="comment"># 开启右子树的下层递归</span></span><br><span class="line">            <span class="keyword">return</span> root <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line"></span><br><span class="line">        dic = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="comment"># 如果分割到没有左子树或者右子树的时候，</span></span><br><span class="line">        <span class="comment"># 那么就意味着根节点的left或者right要指向None</span></span><br><span class="line">        <span class="comment"># 实际上inorder 和 preorder一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归条件：任一节点了若有左节点，那你必须先遍历它的左节点</span></span><br><span class="line">          </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])  <span class="comment"># 取出preorder 的第一个值就是根节点</span></span><br><span class="line"></span><br><span class="line">        idx = inorder.index(preorder[<span class="number">0</span>])  <span class="comment"># 获取在中序遍历中的根节点的索引值</span></span><br><span class="line">        <span class="comment"># idx还能当长度用，相当于 左+根 的长度，因为 左+根 和 根+左 是等长的</span></span><br><span class="line">        <span class="comment"># 索引值代表了左子树的长度，idx从0开始，</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 下面递归对root的左右子树求解即可</span></span><br><span class="line">        <span class="comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="comment"># 传入子数组参数比较耗时，相当于每次开启递归都要建立两个新的数组，其实是没有必要的</span></span><br><span class="line">        inLeft = inorder[<span class="number">0</span>:idx]</span><br><span class="line">        inRight = inorder[idx + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = preorder[<span class="number">1</span>:idx + <span class="number">1</span>]</span><br><span class="line">        preRight = preorder[idx + <span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        root.left = self.buildTree(preLeft, inLeft)</span><br><span class="line">        <span class="comment"># 右子树</span></span><br><span class="line">        root.right = self.buildTree(preRight, inRight)</span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 返回构造后树的根节点</span></span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度在最坏情况下(即左侧链，此时先序遍历与中序遍历相反，每一个根都需要在中序中查找一次)为O(n^2)</p>
<p>迭代法</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">"""思路为官方题解的迭代法思路，注意每次遍历比较的是什么，</span></span><br><span class="line"><span class="string">        一定要在纸上模拟一遍，不要光想"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        stack = []</span><br><span class="line">        L = len(preorder)</span><br><span class="line">        stack.append(root)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, L):</span><br><span class="line">            preorderval = preorder[i]</span><br><span class="line">            <span class="keyword">if</span> inorder[index] != stack[<span class="number">-1</span>].val: <span class="comment"># 比较栈顶元素和inorder</span></span><br><span class="line">                node = stack[<span class="number">-1</span>]</span><br><span class="line">                node.left = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == inorder[index]:</span><br><span class="line">                    node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                node.right = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        length = len(preorder)</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            preorderval = preorder[i]</span><br><span class="line">            node = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> node.val != inorder[index]: <span class="comment"># 每次比较栈顶元素和inorder[index]</span></span><br><span class="line">                node.left = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == inorder[index]:<span class="comment"># 栈顶元素等于inorder[index],弹出；并且index += 1</span></span><br><span class="line">                    node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                node.right = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p><strong>根据一棵树的中序遍历与后序遍历构造二叉树。</strong><br>你可以假设树中没有重复的元素。<br>例如，给出</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD.png"></p>
<p>根据中序遍历和后续遍历的特性我们进行树的还原过程分析<br>首先在后序遍历序列中找到最后一个元素为根节点<br>根据根节点在中序遍历序列中找到根节点的位置<br>根据根节点的位置将中序遍历序列分为左子树和右子树，和子树节点个数<br>根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置<br>递归构造左子树和右子树<br>返回根节点结束</p>
<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD%E4%BA%8C%E5%8F%89%E6%A0%91.png"><br><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png"></p>
<p>中序序列 表示中序遍历的输出序列；<br>后序序列 表示后序遍历的输出序列。</p>
<p>先定义变量：<br>in_left: 在中序序列中的左边界，初始化为 0；<br>in_right: 在中序序列中的右边界，初始化为序列末尾索引位置；<br>in_root: 在中序序列中根节点的位置；<br>post_left：在后序序列中的左边界，初始化为 0；<br>post_right：在后序序列中的右边界，初始化为序列末尾索引位置；<br>post_root：在后序序列中根节点的位置。</p>
<p>后序<br>左子树右边界x<br>①：都用左边<br>in_root -1 - in_left = x - post_left<br>x = in_root - 1 - in_left + post_left </p>
<p>②：都用in_right<br>post_right - x = in_right - (in_root - 1)<br>x = post_right - in_right + (in_root - 1)</p>
<p>右子树左边界y<br>①：都用左边<br>y - post_left = in_root - in_left<br>y = in_root - in_left + post_left<br>②：都用in_right<br>in_R - (in_root + 1) = post_right - 1 - y<br>y = post_right -1 - in_R + (in_root + 1)<br>y = post_right - in_R + in_root<br>先用法②</p>
<p>要先创建右子树，再创建左子树的依赖关系。<br>可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，<br>如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。<br>因为是根据后序建立的索引，是从后往前递减的</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3]<br>从后序里先拿了3，然后找到中序里3的位置，就能知道9是左子树，15 20 7是右子树 接下来再从后序里拿20，<br>这时候是应该先算中序里的右子树，等右子树三个点都算完了，<br>index才会到9这个点，也就是开始算左子树<br>返回根节点 root。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；</span></span><br><span class="line">        <span class="comment"># 为什创建 po</span></span><br><span class="line">        <span class="comment"># 将self.po 指向 postorder 是为了在 recur() 中访问 postorder 。</span></span><br><span class="line">        <span class="comment"># 因为 recur() 中要用到后序遍历，所以要建立一个全局变量 po 。</span></span><br><span class="line">        <span class="comment"># 也可以把 postorder 作为参数传给 recur() 方法</span></span><br><span class="line">        <span class="comment"># 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例</span></span><br><span class="line">        self.dic, self.po = {}, postorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            <span class="comment"># 将中序遍历中序列的节点值及索引全部记录在哈希表中</span></span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">            <span class="comment"># 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，</span></span><br><span class="line">            <span class="comment"># 用字典搜索是 O(1) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根节点 root 的 pre_root, in_right 都是 len(inorder) - 1</span></span><br><span class="line">        <span class="comment"># 开启递归并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(len(inorder) - <span class="number">1</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, post_right, in_left, in_right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None</span></span><br><span class="line">        <span class="comment"># 后序序列末尾元素就是根节点</span></span><br><span class="line">        post_root = post_right</span><br><span class="line">        <span class="comment"># 根节点 root 的TreeNode对象</span></span><br><span class="line">        root = TreeNode(self.po[post_root])</span><br><span class="line">        <span class="comment"># 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树</span></span><br><span class="line">        idx = self.dic[self.po[post_root]]    </span><br><span class="line">        <span class="comment"># idx = inorder.index(preorder[post_root])</span></span><br><span class="line">        <span class="comment"># index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1) </span></span><br><span class="line">        <span class="comment"># 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。</span></span><br><span class="line">        <span class="comment"># 开启右子树的下层递归，找右子树的根：</span></span><br><span class="line">        root.right = self.recur(post_right - <span class="number">1</span>, idx + <span class="number">1</span>, in_right) </span><br><span class="line">        <span class="comment"># 开启左子树的下层递归，找左子树的根：</span></span><br><span class="line">        root.left = self.recur(idx + post_right - in_right - <span class="number">1</span>, in_left, idx - <span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></tbody></table></figure>

<p>定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，<br>递归入口为helper(0, n - 1) ：<br>如果 in_left &gt; in_right，说明子树为空，返回空节点。<br>选择后序遍历的最后一个节点作为根节点。<br>利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。<br>从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。<br>根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">in_left, in_right</span>):</span></span><br><span class="line">            <span class="comment"># 如果这里没有节点构造二叉树了，就结束</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选择 post_idx 位置的元素作为当前子树根节点</span></span><br><span class="line">            val = postorder.pop()</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据 root 所在位置分成左右两棵子树</span></span><br><span class="line">            index = idx_map[val]</span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 构造右子树</span></span><br><span class="line">            root.right = helper(index + <span class="number">1</span>, in_right)</span><br><span class="line">            <span class="comment"># 构造左子树</span></span><br><span class="line">            root.left = helper(in_left, index - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建立（元素，下标）键值对的哈希表</span></span><br><span class="line">        idx_map = {val:idx <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(inorder)} </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。<br>空间复杂度：O(n)。我们需要使用 O(n) 的空间存储哈希表，<br>以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">in_left, in_right, post_left, post_right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后序序列末尾元素就是根节点</span></span><br><span class="line">            post_root = post_right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构造节点</span></span><br><span class="line">            root = TreeNode(postorder[post_root])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在中序序列定位根节点位置</span></span><br><span class="line">            in_root = inorder_map[root.val]    </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># size_of_right = in_right - in_root</span></span><br><span class="line">            <span class="comment"># 获取中序序列中左子树的节点数</span></span><br><span class="line">            size_of_left = in_root - in_left</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># root.left = build_tree(in_left, in_root-1, post_left, post_right-size_of_right-1)</span></span><br><span class="line">            <span class="comment"># 递归构建左子树</span></span><br><span class="line">            root.left = build_tree(in_left, in_root<span class="number">-1</span>, post_left, post_left+size_of_left<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># root.right = build_tree(in_root+1, in_right, post_right-size_of_right, post_right-1)</span></span><br><span class="line">            <span class="comment"># 递归构建右子树</span></span><br><span class="line">            root.right = build_tree(in_root+<span class="number">1</span>, in_right, post_left+size_of_left, post_root<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        size = len(inorder)</span><br><span class="line">        <span class="comment"># 先用字典存储中序序列，元素及其对应的索引位置</span></span><br><span class="line">        inorder_map = {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            inorder_map[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build_tree(<span class="number">0</span>, size<span class="number">-1</span>, <span class="number">0</span>, size<span class="number">-1</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">树A：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">树 B：</span><br><span class="line">①</span><br><span class="line">   <span class="number">3</span> </span><br><span class="line">  /</span><br><span class="line"> <span class="number">4</span></span><br><span class="line">②</span><br><span class="line">   <span class="number">5</span> </span><br><span class="line">    \</span><br><span class="line">     </span><br><span class="line">③</span><br><span class="line">   <span class="number">4</span> </span><br><span class="line">  / </span><br><span class="line"> <span class="number">1</span>  </span><br></pre></td></tr></tbody></table></figure>

<p>名词规定：树 A 的根节点记作 节点 A ，树 B 的根节点称为 节点 B 。</p>
<p>解题思路：<br>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。<br>因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 n_A；（对应函数 isSubStructure(A, B)）</li>
<li>判断树 A 中 以 n_A 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>
</ol>
<p>如果a树和b树的当前节点的值相同，那么比较a的左右节点和b的左右子树是否相同<br>如果a树和b树的当前节点的值不同，那么比较a的左子树和B是否相同，或者比较a的右子树和B是否相同</p>
<p>recur判断A,B的根结点是否相同，相同的话继续递归左右子节点判断是否相同，一直相同的话就返回true，若不相同就调用A的左节点或者右几点为根结点与B比较，都要重新匹配整个树 B </p>
<p>算法流程：<br>isSubStructure(A, B) 函数：</p>
<ol>
<li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</li>
<li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol>
<li>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；</li>
<li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；<br>以上 2. 3. 实质上是在对树 A 做 先序遍历 。</li>
</ol>
</li>
</ol>
<p>recur(A, B) 函数：在匹配子结构，因此要 左子树相同 “且”右子树相同才是子结构。</p>
<ol>
<li>终止条件：<ol>
<li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li>
<li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li>
<li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
</ol>
</li>
<li>返回值：</li>
<li>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
<p>复杂度分析：<br>时间复杂度 O(MN)： 其中 M,N 分别为树 A 和 树 B 的节点数量；<br>先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。</p>
<p>空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。<br>当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；<br>当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。<br>当达到 M 时， 树 B 只遍历一层就会返回 因为 树 A 已经到底了~ </p>
<p>空间复杂度要看在同一时刻，有多少递归函数未返回，而不是总共执行了多少函数。<br>因为递归过程中是会回溯的，返回了的函数就不计入空间复杂度计算啦</p>
<p>这类题目与字符串匹配有些神似，求解过程大致分为两步：<br>先将根节点匹配；<br>根节点匹配后，对子树进行匹配。<br>而参与匹配的二叉树可以是一棵，与自身匹配；也可以是两棵，即互相匹配。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 定义一个标志位res用来做判断</span></span><br><span class="line">        res = <span class="literal">False</span>  <span class="comment"># 如果没这句 local variable 'res' referenced befored assignment</span></span><br><span class="line">        <span class="comment"># 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> B <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> A.val == B.val:</span><br><span class="line">                res = self.helper(A, B)</span><br><span class="line">            <span class="comment"># 如果根结点开始的没有找到，那么就再去TreeA的左子节点当作起点，去判断是否包含TreeB</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.isSubStructure(A.left, B)</span><br><span class="line">            <span class="comment"># 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.isSubStructure(A.right, B)</span><br><span class="line">        <span class="comment"># 最后返回help()里面的res即得到结果</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">        <span class="comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">        <span class="comment"># 如果颠倒顺序，会先判断A是否为None，当A为空B为空时，B的结点已经遍历完成确定相等了，但是返回了False，判断错误先</span></span><br><span class="line">        <span class="comment"># 如果TreeB已经遍历完了，还没发现不一样的，</span></span><br><span class="line">        <span class="comment"># B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构</span></span><br><span class="line">        <span class="keyword">if</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果TreeB还没有遍历完，TreeA却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果以上情况都不是，说明A.val == B.val，根节点对应的上，</span></span><br><span class="line">        <span class="comment"># 那么继续向下递归判断子节点里是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A.left, B.left) <span class="keyword">and</span> self.helper(A.right, B.right)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 若两个结点有一个为空，不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> B == <span class="literal">None</span> <span class="keyword">or</span> A == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> B <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果找到了对应TreeB的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span> A.val == B.val <span class="keyword">and</span> self.helper(A,B):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br><span class="line">            <span class="comment"># 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">        <span class="comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">        <span class="comment"># 如果颠倒顺序，会先判断A是否为None，其实这个时候B的结点已经遍历完成确定相等了，但是返回了False，判断错误</span></span><br><span class="line">        <span class="comment"># 如果TreeB已经遍历完了，还没发现不一样的，</span></span><br><span class="line">        <span class="comment"># B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构</span></span><br><span class="line">        <span class="keyword">if</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果TreeB还没有遍历完，TreeA却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果以上情况都不是，说明A.val == B.val，根节点对应的上，</span></span><br><span class="line">        <span class="comment"># 那么继续向下递归判断子节点里是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A.left, B.left) <span class="keyword">and</span> self.helper(A.right, B.right)</span><br></pre></td></tr></tbody></table></figure>


<hr>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><code>输入描述:</code></h5><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">            <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">        镜像二叉树</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>二叉树镜像定义：<br>对于二叉树中任意节点 root ，设其左 / 右子节点分别为 left, right ；<br>则在二叉树的镜像中的对应 root 节点，其左 / 右子节点分别为 right, left 。</p>
<p>方法一：递归 （dfs）二叉树</p>
<h4 id="交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换"><a href="#交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换" class="headerlink" title="交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换"></a><code>交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换</code></h4><h4 id="和现实中的树是一样的，是根-—-枝-—-叶-的结构。"><a href="#和现实中的树是一样的，是根-—-枝-—-叶-的结构。" class="headerlink" title="和现实中的树是一样的，是根 — 枝 — 叶 的结构。"></a><code>和现实中的树是一样的，是根 — 枝 — 叶 的结构。</code></h4><h4 id="当我们剪下两个树枝（上面分别有树枝分叉、直到叶），"><a href="#当我们剪下两个树枝（上面分别有树枝分叉、直到叶），" class="headerlink" title="当我们剪下两个树枝（上面分别有树枝分叉、直到叶），"></a><code>当我们剪下两个树枝（上面分别有树枝分叉、直到叶），</code></h4><h4 id="并将此二树枝交换位置-嫁接回树上。"><a href="#并将此二树枝交换位置-嫁接回树上。" class="headerlink" title="并将此二树枝交换位置 嫁接回树上。 "></a><code>并将此二树枝交换位置 嫁接回树上。 </code></h4><h4 id="此时，你会发现，此两树枝的根和其树枝分叉-叶-都交换了。"><a href="#此时，你会发现，此两树枝的根和其树枝分叉-叶-都交换了。" class="headerlink" title="此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。"></a><code>此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。</code></h4><p>仔细看下题目的输入和输出，输出的左右子树的位置跟输入正好是相反的，<br>于是我们可以递归的交换左右子树来完成这道题。</p>
<p>①前序遍历，是基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。<br>递归解析：</p>
<ol>
<li>终止条件： 当节点 root 为空时（即越过叶节点），则返回 None ；</li>
<li>递推工作：<ol>
<li>初始化节点 tmp ，用于暂存 root 的左子节点；</li>
<li>交换当前节点的左右节点，整个子树交换但它们内部的子树还没翻转，并将返回值作为 root 的节点</li>
<li>再递归的交换当前节点的左节点，递归的交换当前节点的右节点，并将返回值作为 root 的 子节点 。</li>
</ol>
</li>
<li>返回值： 返回当前节点 root ；  </li>
</ol>
<p>时间复杂度：每个元素都必须访问一次，所以是O(n)<br>空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)</p>
<p>Q： 为何需要暂存 root 的左子节点？<br>A： 在递归右子节点 “root.left = mirrorTree(root.right);” 执行完毕后，<br>root.left 的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。</p>
<p>这个节点不存在，比如叶子节点返回左子树，就是返回空<br>相当于 root = None ，交换只是把 None 赋给了一个变量，不会报错，<br>只要不执行 None.left 这种就好</p>
<p>在交换左右孩子的时候，temp指针在函数体结束返回后，temp 会被销毁，temp所指向的数据不会销毁，销毁指针数据的方法是delete temp;</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.left = root.right = <span class="number">7</span></span><br><span class="line">root.right = tmp = <span class="number">2</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">tmp = root.left = <span class="number">6</span></span><br><span class="line">root.left = root.right = <span class="number">9</span></span><br><span class="line">root.right = tmp = <span class="number">6</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">第一个递归函数的函数root不断改变不影响第二个递归函数的函数root的初始值</span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">tmp = root.left = <span class="number">1</span></span><br><span class="line">root.left = root.right = <span class="number">3</span></span><br><span class="line">root.right = tmp = <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将当前节点的左右子树交换</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        <span class="comment"># 递归交换当前节点的 左子树和右子树</span></span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="comment"># 返回时就表示当前这个节点，以及它的左右子树都已经交换完了    </span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p>②后序遍历，基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。<br>递归解析：</p>
<ol>
<li>终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；</li>
<li>递推工作：<ol>
<li>从根节点开始，递归地对树进行遍历，直到遇到 null 节点，结束递归调用。</li>
<li>并从叶子结点先开始翻转。</li>
<li>如果当前遍历到的节点 root 的左右两棵子树都已经翻转，<br>那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</li>
</ol>
</li>
<li>返回值： 返回当前节点 root ；  </li>
</ol>
<p>时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。<br>空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归压栈压到底</span></span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        tmp = root.left</span><br><span class="line">        <span class="comment"># 执行交换</span></span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">9</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">3</span>   <span class="number">1</span> <span class="number">9</span>   <span class="number">6</span>            </span><br><span class="line"><span class="string">```</span> </span><br><span class="line"></span><br><span class="line"><span class="string">③</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">终止条件：</span> <span class="string">当节点</span> <span class="string">root</span> <span class="string">为空时（即越过叶节点），则返回</span> <span class="literal">null</span> <span class="string">；</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">递推工作：</span></span><br><span class="line">   <span class="number">1</span><span class="string">.</span> <span class="string">初始化节点</span> <span class="string">tmp</span> <span class="string">，用于暂存</span> <span class="string">root</span> <span class="string">的左子节点；</span></span><br><span class="line">   <span class="number">2</span><span class="string">.</span> <span class="string">开启递归</span> <span class="string">右子节点</span> <span class="string">mirrorTree(root.right)</span> <span class="string">，并将返回值作为</span> <span class="string">root</span> <span class="string">的</span> <span class="string">左子节点</span> <span class="string">。</span></span><br><span class="line">   <span class="number">3</span><span class="string">.</span> <span class="string">开启递归</span> <span class="string">左子节点</span> <span class="string">mirrorTree(tmp)</span> <span class="string">，并将返回值作为</span> <span class="string">root</span> <span class="string">的</span> <span class="string">右子节点</span> <span class="string">。</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">返回值：</span> <span class="string">返回当前节点</span> <span class="string">root</span> <span class="string">；</span>  </span><br><span class="line"><span class="string">```py</span></span><br><span class="line"><span class="attr">class Solution:</span></span><br><span class="line">    <span class="string">def</span> <span class="string">mirrorTree(self,</span> <span class="attr">root:</span> <span class="string">TreeNode)</span> <span class="string">-&gt;</span> <span class="attr">TreeNode:</span></span><br><span class="line">        <span class="attr">if not root:</span> <span class="string">return</span></span><br><span class="line">        <span class="string">tmp</span> <span class="string">=</span> <span class="string">root.left</span></span><br><span class="line">        <span class="comment"># 开始递归，重头开始执行原来右边的完成，终止时root为最右下角的节点</span></span><br><span class="line">        <span class="string">root.left</span> <span class="string">=</span> <span class="string">self.mirrorTree(root.right)</span></span><br><span class="line">        <span class="comment"># 执行原来左边的</span></span><br><span class="line">        <span class="string">root.right</span> <span class="string">=</span> <span class="string">self.mirrorTree(tmp)</span></span><br><span class="line">        <span class="string">return</span> <span class="string">root</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.right = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">7</span></span><br><span class="line">tmp = root.left = <span class="number">6</span> 暂存 <span class="number">7</span> 的左子节点 <span class="number">6</span></span><br><span class="line">root.right = <span class="number">9</span></span><br><span class="line">开启递归 <span class="number">7</span> 的右子节点为 <span class="number">9</span></span><br><span class="line">root = root.right = <span class="number">9</span></span><br><span class="line">tmp = root.left = None  # 暂存 <span class="number">9</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">9</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line">开启递归 <span class="number">9</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">9</span> 赋值给 <span class="number">7</span> 的左子节点为 <span class="number">9</span></span><br><span class="line">root = <span class="number">7</span></span><br><span class="line">root.left  = <span class="number">9</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /   \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">9</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">tmp = <span class="number">6</span></span><br><span class="line">开启递归 <span class="number">7</span> 的左子节点为 <span class="number">6</span></span><br><span class="line">root = tmp = <span class="number">6</span></span><br><span class="line">tmp = root.left = None  # 暂存 <span class="number">6</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">6</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line"><span class="keyword">return</span> 空</span><br><span class="line">开启递归 <span class="number">6</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">6</span> 赋值 <span class="number">7</span> 的右子节点</span><br><span class="line">root = <span class="number">7</span> </span><br><span class="line">root.right = <span class="number">6</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">9</span>   <span class="number">6</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回节点 <span class="number">7</span>，<span class="number">7</span>的子节点都用过，跳到上一层节点<span class="number">4</span>  </span><br><span class="line">root = <span class="number">4</span> </span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.right = <span class="number">7</span> </span><br><span class="line">开启递归 <span class="number">4</span> 的右子节点 <span class="number">7</span></span><br><span class="line">root = root.right = <span class="number">7</span> </span><br><span class="line">tmp = root.left = None  # 已经用过了 暂存 <span class="number">6</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">7</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line"><span class="keyword">return</span> 空</span><br><span class="line">开启递归 <span class="number">7</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">7</span> 赋值 <span class="number">4</span> 的左子节点</span><br><span class="line">root.left = <span class="number">7</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">tmp = <span class="number">2</span> 开启递归<span class="number">4</span>的左子节点<span class="number">2</span></span><br><span class="line">root = tmp = <span class="number">2</span></span><br><span class="line">tmp = root.left = <span class="number">1</span></span><br><span class="line">root.right = tmp = <span class="number">3</span></span><br><span class="line">开启递归<span class="number">2</span>的右子节点<span class="number">3</span></span><br><span class="line">root = root.right = <span class="number">3</span></span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">3</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">3</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">函数返回 <span class="number">3</span> 赋值给 <span class="number">2</span> 的左子节点</span><br><span class="line">root.left = <span class="number">3</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">3</span>   <span class="number">3</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">开启递归<span class="number">2</span>的左子节点<span class="number">1</span> tmp</span><br><span class="line">root = tmp = <span class="number">1</span></span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">1</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">1</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">3</span>   <span class="number">1</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">返回节点<span class="number">1</span>，<span class="number">2</span>的子节点都用过，跳到上一层返回节点<span class="number">4</span>  </span><br><span class="line">开启递归节点<span class="number">4</span> </span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">开启递归 <span class="number">4</span> 的左子节点 <span class="number">2</span></span><br><span class="line">root = tmp = <span class="number">2</span>  </span><br><span class="line">root.right = None</span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">1</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">1</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">函数返回 <span class="number">2</span> 赋值给 <span class="number">4</span> 的右子节点</span><br><span class="line">root.right = <span class="number">2</span></span><br><span class="line">其子树一起移动</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>迭代<br>①<br>辅助栈（或队列）<br>利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。<br>算法流程：<br>特例处理： 当 root 为空时，直接返回 null ；<br>初始化： 栈（或队列），本文用栈，并加入根节点 root 。<br>循环交换： 当栈 stack 为空时跳出；<br>出栈： 记为 node ；<br>添加子节点： 将 node 左和右子节点入栈；<br>交换： 交换 node 的左 / 右子节点。<br>返回值： 返回根节点 root 。</p>
<p>入栈的时候 顺序是 2 7 ，所以出栈顺序是 7 2 鸭~ 和 节点是否交换没有关系的</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">4</span>         stack=[<span class="number">4</span>]</span><br><span class="line">   /  \       node = <span class="number">4</span></span><br><span class="line">  <span class="number">2</span>    <span class="number">7</span></span><br><span class="line"> / \  / \</span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack=[]</span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">  <span class="number">2</span>    <span class="number">7</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>  <span class="number">9</span>                                                              </span><br><span class="line">             </span><br><span class="line">    <span class="number">4</span>         交换 <span class="number">2</span>, <span class="number">7</span></span><br><span class="line">   /  \       所以出栈顺序是 <span class="number">7</span> <span class="number">2</span> 鸭~ 和 节点是否交换没有关系的</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      stack=[<span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>  <span class="number">3</span>                                                      | |</span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack=[<span class="number">2</span>]</span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>  <span class="number">3</span>   </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         交换<span class="number">6</span>, <span class="number">9</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>   </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">9</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">6</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">2</span></span><br><span class="line">   /  \       stack=[]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      stack=[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         交换 None 和 None</span><br><span class="line">   /  \       stack=[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      </span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">3</span></span><br><span class="line">   /  \       stack=[<span class="number">1</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">1</span></span><br><span class="line">   /  \       stack=[]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack 为空</span><br><span class="line">   /  \       跳出循环，返回<span class="number">4</span></span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      </span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure>

<p>②<br>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。<br>深度优先遍历的特点是一竿子插到底，不行了再退回来继续；<br>而广度优先遍历的特点是层层扫荡。<br>所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：</p>
<ul>
<li>判断其左子树是否为空，不为空就放入队列中</li>
<li>判断其右子树是否为空，不为空就放入队列中</li>
</ul>
<p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是n/2个，所以时间复杂度是0(n)</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 每次都从队列中拿一个节点，并交换这个节点的左右子树</span></span><br><span class="line">            tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            tmp.left, tmp.right = tmp.right, tmp.left</span><br><span class="line">            <span class="comment"># 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> tmp.left:</span><br><span class="line">                queue.append(tmp.left)</span><br><span class="line">            <span class="comment"># 如果当前节点的右子树不为空，则放入队列等待后续处理    </span></span><br><span class="line">            <span class="keyword">if</span> tmp.right:</span><br><span class="line">                queue.append(tmp.right)</span><br><span class="line">        <span class="comment"># 返回处理完的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             4</span><br><span class="line">           /  \</span><br><span class="line">          2     7</span><br><span class="line">         / \   / \</span><br><span class="line">        1   3 6   9</span><br><span class="line">                                                                   </span><br><span class="line">                                                   |<span class="string">1</span>|</span><br><span class="line">                                    |<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|</span><br><span class="line">           |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">queue |<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">             4</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          2     7</span></span><br><span class="line"><span class="string">         / \   / \</span></span><br><span class="line"><span class="string">        1   3 6   9</span></span><br><span class="line"><span class="string">                                         </span>|<span class="string">7</span>|</span><br><span class="line">                     |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">tmp   |<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="35-对称的二叉树-本题考点-树"><a href="#35-对称的二叉树-本题考点-树" class="headerlink" title="35.对称的二叉树 [^本题考点 树]"></a>35.对称的二叉树 [^本题考点 <em>树</em>]</h4><p>​    <strong>题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</strong><br>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>
<p>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp;/ \ / <br>3 &nbsp;4 4 &nbsp;3<br>但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp; &nbsp;\ &nbsp; <br>&nbsp; &nbsp; 3 &nbsp; 3</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
<p>解题思路：</p>
<ul>
<li>对称二叉树定义：对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val = R.val ：即此两对称节点值相等。</li>
<li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<p>算法流程：<br>isSymmetric(root) ：</p>
<ul>
<li>特例处理： 若根节点 root 为空，则直接返回 true 。</li>
<li>返回值： 即 recur(root.left, root.right) ;</li>
</ul>
<p>recur(L, R) ：<br>先“递（推）”至底，再“归”。两个参数的递归，<br>通过「同步移动」两个指针的方法来遍历这棵树，L 指针和 R 指针一开始都指向这棵树的根，随后 R 右移时，L 左移，R 左移时，L 右移。每次检查当前 L 和 R 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p>终止条件：</p>
<ul>
<li>当 L 和 R 同时越过叶节点： 左右都为空，也就是判断到了最后，还没返回false，那么此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点 但另一个还没有，此树不对称，因此返回 false ；</li>
<li>当节点 L 值 \ne= 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
<p>当 L.val = R.val且不为空，递推工作：</p>
<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；<br>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp; 连接。</li>
</ul>
<p>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法，事实上这个递归方法就是在做树的遍历，每个结点访问一次；</p>
<p>空间复杂度 O(N) ： 最差情况下，根节点的左子节点 有 N/2 长度的链表，右子节点有 N/2 长度的链表，那么递归深度会达到 N/2。因为一直先执行 recur(L.left, R.right) 。<br>只需要保证每个左节点的左边和右节点的右边相同(其余的我可以都为空)，就可以一直走走到最底端，如果是这样的话，应该是O(n/2)，约等于O(n)这样就是线性级别了</p>
<p>递归复杂度要看递归的深度，因为剪枝or回溯后，内存会被释放。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">    <span class="comment"># 如果此二叉树为空，则其也是对称的</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">L, R</span>):</span></span><br><span class="line">            <span class="comment"># 如果两侧都为空，则是镜像的了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 若有一侧不为空，则不是镜像的 或者 如果左侧的值不等于右侧额值，就不是镜像的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">or</span> <span class="keyword">not</span> R <span class="keyword">or</span> L.val != R.val:</span><br><span class="line">            <span class="comment"># if L.val!=R.val or not L or not R 会报错，当 L == None 时，直接访问 L.val 会报错的 </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># if L.val = R.val: </span></span><br><span class="line">            <span class="keyword">return</span> recur(L.left, R.right) <span class="keyword">and</span> recur(L.right, R.left)</span><br><span class="line">        <span class="comment"># 返回判断此二叉树的左侧和右侧</span></span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; <span class="number">1</span></span><br><span class="line">&nbsp; &nbsp;/ \</span><br><span class="line">&nbsp; <span class="number">2</span> &nbsp; <span class="number">2</span></span><br><span class="line">&nbsp;/ \ / \</span><br><span class="line"><span class="number">3</span> &nbsp;<span class="number">4</span> <span class="number">4</span> &nbsp;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">root = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(root.left, root.right)</span></span> </span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">1</span>.left, <span class="number">1</span>.right)</span></span> </span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span></span><br><span class="line">L<span class="selector-class">.val</span> = R.val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>.left, R=<span class="number">2</span>.right)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span> recur(L<span class="selector-class">.right</span>, R.<span class="attribute">left</span>)</span><br><span class="line"><span class="number">3</span><span class="selector-class">.left</span> = <span class="number">3</span><span class="selector-class">.right</span> = <span class="number">3</span><span class="selector-class">.right</span> = <span class="number">3</span><span class="selector-class">.left</span> = None</span><br><span class="line">L和R同时越过叶子节点，访问了叶节点的 <span class="attribute">left</span> 和 right， 其 left 和 right 都是 None</span><br><span class="line">返回true</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.right, R.left)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>.right, <span class="number">2</span>.left)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span> recur(L<span class="selector-class">.right</span>, R.<span class="attribute">left</span>)</span><br><span class="line"><span class="number">4</span><span class="selector-class">.left</span> = <span class="number">4</span><span class="selector-class">.right</span> = <span class="number">4</span><span class="selector-class">.right</span> = <span class="number">4</span><span class="selector-class">.left</span> = None</span><br><span class="line">L和R同时越过叶子节点</span><br><span class="line">返回true</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 现在获取的 mir = node 就是新建的树的根节点了</span></span><br><span class="line">        mir = self.mirror(root) </span><br><span class="line">        <span class="keyword">return</span> self.recur(root,mir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self,root,mir</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">and</span> <span class="keyword">not</span> mir: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mir <span class="keyword">or</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (root.val == mir.val) <span class="keyword">and</span> self.recur(root.left,mir.left) <span class="keyword">and</span> self.recur(root.right,mir.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        node = TreeNode(root.val) <span class="comment"># 建立节点 node</span></span><br><span class="line">        node.left, node.right = self.mirror(root.right), self.mirror(root.left) </span><br><span class="line">        <span class="comment"># 即镜像之 node.left = root.right , node.right = root.left</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：非递归写法（层序遍历）<br>这个方法有点像层序遍历，故使用队列，<br>但是根据对称性，队首和队尾其实都需要能够执行入队和出队操作，因此使用双端队列（Deque）；</p>
<p>时间复杂度：O(N)，这里 N 为树的结点个数，事实上这个递归方法就是在做树的遍历，每个结点访问一次；<br>空间复杂度：O(L)，这里 L 表示树的相邻两层结点个数之和的最大值。</p>
<p>首先从队列中拿出两个节点(left和right)比较<br>将left的left节点和right的right节点放入队列<br>将left的right节点和right的left节点放入队列</p>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; 2</span><br><span class="line">&nbsp; &nbsp;/ <span class="tag">\</span></span><br><span class="line">&nbsp; ３ &nbsp; ３</span><br><span class="line">&nbsp;/ <span class="tag">\<span class="name"> </span></span>  / <span class="tag">\</span></span><br><span class="line">４ &nbsp;５ N   4&nbsp;</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        queue = deque()  <span class="comment"># 辅助双端队列</span></span><br><span class="line">        queue.appendleft(root.left)  <span class="comment"># 初始节点依次入队</span></span><br><span class="line">        queue.append(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 从队列中取出两个节点，再比较这两个节点</span></span><br><span class="line">            left_node = queue.popleft()</span><br><span class="line">            right_node = queue.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 深度优先，如果两个节点都为空就继续循环，只是越过了某一对叶子节点，而不是检查完了所有的叶子节点，所以不能return true。</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 代码走到这里一定有 left_node 和 right_node 非空</span></span><br><span class="line">            <span class="comment"># 因此可以取出 val 进行判断了</span></span><br><span class="line">            <span class="keyword">if</span> left_node.val != right_node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 将左节点的右孩子，右节点的左孩子入队（以便两节点一起出队，进行比较）</span></span><br><span class="line">            queue.appendleft(left_node.right)</span><br><span class="line">            queue.appendleft(left_node.left)</span><br><span class="line">            <span class="comment"># 将左节点的左孩子， 右节点的右孩子入队（以便两节点一起出队，进行比较）</span></span><br><span class="line">            queue.append(right_node.left)</span><br><span class="line">            queue.append(right_node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; 1</span><br><span class="line">&nbsp; &nbsp;/ \</span><br><span class="line">&nbsp; 2 &nbsp; 2</span><br><span class="line">&nbsp;/ \ / \</span><br><span class="line">3 &nbsp;4 4 &nbsp;3</span><br><span class="line"></span><br><span class="line">root = 1</span><br><span class="line"></span><br><span class="line">queue = [2, 2]</span><br><span class="line">left_node = 2</span><br><span class="line">right_node = 2</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(2.right)</span><br><span class="line">queue = [4]</span><br><span class="line">queue.appendleft(2.left)</span><br><span class="line">queue = [3, 4]</span><br><span class="line">            # 将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(2.left)</span><br><span class="line">queue = [3, 4, 4]</span><br><span class="line">queue.append(2.right)</span><br><span class="line">queue = [3, 4, 4, 3]</span><br><span class="line"></span><br><span class="line">left_node = queue.popleft() = 3</span><br><span class="line">queue = [4, 4, 3]</span><br><span class="line">right_node = queue.pop() = 3</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(3.right)</span><br><span class="line">queue = [4, 4]</span><br><span class="line">queue.appendleft(left_node.left)</span><br><span class="line">queue.appendleft(3.left)</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(3.left)</span><br><span class="line">queue = [4, 4]</span><br><span class="line">queue.append(right_node.right)</span><br><span class="line">queue.append(4.right)</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">left_node = queue.popleft() = 4</span><br><span class="line">queue = [4]</span><br><span class="line">right_node = queue.pop() = 4</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(4.right)</span><br><span class="line">queue = []</span><br><span class="line">queue.appendleft(left_node.left)</span><br><span class="line">queue.appendleft(3.left)</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(4.left)</span><br><span class="line">queue = []</span><br><span class="line">queue.append(right_node.right)</span><br><span class="line">queue.append(4.right)</span><br><span class="line">queue = [] 退出循环</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h2><p><strong>给定一棵二叉搜索树，请找出其中第k大的节点。</strong><br>示例 1:</p>
<p>输入: root = [3,1,4,null,2], k = 1</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：<br>1、看到这题首先想到的是递归遍历每一个节点，然后存在一个数组中，遍历结束后把数组 sort 排序一下就可以取得第 K 大的值了。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.right, res)</span><br><span class="line">        dfs(root, res)</span><br><span class="line">        <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></tbody></table></figure>

<p>2、继续看题会发现是二叉搜索树，发现中序遍历的数组结果刚好是排好序的，这样就可以想到反中序遍历,遍历结束后直接获取数组第 K-1 位的数值就是结果了（当然上面说的都可以不用倒序，直接用中序遍历获取 array.lenth-k 大的值也是所需结果）<br>3、在第二种解法上利用反中序遍历，优化就是直接遍历到第 k 大的值就停止遍历，直接返回需要的值，即第三种解法。<br>本文解法基于此性质：二叉搜索树的中序遍历为 递增序列 。</p>
<p>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。<br>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。从右节点遍历可以早点退出</p>
<p>中序遍历 为 “左、根、右” 顺序，递归法代码模板如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure>

<p>中序遍历的倒序 为 “右、根、左” 顺序，递归法代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历倒序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br></pre></td></tr></tbody></table></figure>

<p>为求第 k 个节点，需要实现以下 三项工作 ：</p>
<ol>
<li>递归遍历时计数，统计当前节点的序号；</li>
<li>递归到第 k 个节点时，应记录结果 res ；</li>
<li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
</ol>
<p>递归解析：</p>
<ol>
<li><p>终止条件： 当节点 root 为空（越过叶节点），则直接返回；</p>
</li>
<li><p>递归右子树： 即 dfs(root.right) ；</p>
</li>
<li><p>三项工作：</p>
<ol>
<li><p>提前返回： 若 k = 0 ，代表已找到目标节点，无需继续遍历，提前终止中序遍历，因此直接返回提升效率，在某些特例下尤其明显，例如：树有 10000 个节点，求第 1 大的节点。<br>不加 if(k == 0) return 是做不到提前返回的，会降低效率</p>
</li>
<li><p>统计序号： 执行 k = k - 1 （即从 k 减至 0 ），每遍历一个节点 k 的值就减一；</p>
</li>
<li><p>记录结果： 若 k = 0 ，代表当前节点为第 k 大的节点，因此记录 res = root.val ；</p>
</li>
</ol>
</li>
<li><p>递归左子树： 即 dfs(root.left) ；</p>
</li>
</ol>
<p>时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。<br>空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</p>
<p>题目指出：1≤k≤N （二叉搜索树节点个数）；因此无需考虑 k &gt; N 的情况。<br>若考虑，可以在中序遍历完成后判断 k &gt; 0 是否成立，若成立则说明 k &gt; N 。</p>
<p>如果修改了函数外部变量的引用，比方说 k -= 1，相当于 k = k - 1，<br>就是给k重新赋值了，那它就变成了内部函数的局部变量，局部变量 k 不能在 dfs() 函数内访问，<br>此时可以声明 self.k = k 则建立了类成员变量 self.k<br>或者在函数内部声明 nonlocal k 说明 k 不会因为引用修改而成为局部变量。<br>需要对于函数 $dfs()$ 的全局变量，因此在 dfs() 内就可以正常访问 k</p>
<p>不能把两个k==0写在一起，因为此方法在访问每个节点时，需要将 “k -= 1” 前 和 “k -= 1” 后的逻辑分开~<br>如果直接在第一次遇到 k = 0 时，就返回 self.res，下面还会遇到 k -= 1， k 会被减到 -1 , -2 , … ，因此 K 就不 == 0 了，因此就会继续中序遍历，而不会终止。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  <span class="comment"># 第一次遇到 k == 0 时 ，记录结果</span></span><br><span class="line">                self.res = root.val</span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">dfs(root.right)</span><br><span class="line">    root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">    dfs(<span class="number">6</span>)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">6.</span>right = None</span><br><span class="line">        dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">6</span></span><br><span class="line">    k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    dfs(root.left)</span><br><span class="line">        root = root.left = <span class="number">6.</span>left = None</span><br><span class="line">        dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">6</span></span><br><span class="line">返回上一层 root = <span class="number">5</span></span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">dfs(<span class="number">5.</span>left)</span><br><span class="line">    root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">    dfs(<span class="number">3</span>)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">        dfs(<span class="number">4</span>)</span><br><span class="line">        dfs(root.right)</span><br><span class="line">            root = root.right = <span class="number">4.</span>right = None</span><br><span class="line">            dfs(None)</span><br><span class="line">        返回上一层 root = <span class="number">4</span></span><br><span class="line">        k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">        res = root.val = <span class="number">4</span></span><br><span class="line">        dfs(root.leftt)</span><br><span class="line">        root = root.right = <span class="number">4.</span>left = None</span><br><span class="line">            dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">    <span class="keyword">return</span> res = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果不想要上面的 if ，并且想保留提前返回，<br>实际上也执行了dfs(root.left)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.k == <span class="number">0</span>: </span><br><span class="line">                    self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<p>右根左的顺序，非递归遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 右根左 非递归遍历</span></span><br><span class="line">        stack,count = [],<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == k:</span><br><span class="line">                    <span class="keyword">return</span> curr.val</span><br><span class="line">                root = cur.left</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>]</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">root = root.right = <span class="number">6.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">1</span> &lt; k = <span class="number">3</span></span><br><span class="line">root = cur.left = <span class="number">6.</span>left = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">5</span></span><br><span class="line">stack = []</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">2</span> &lt; k = <span class="number">3</span></span><br><span class="line">root = cur.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">root = root.right = <span class="number">4.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">3</span> = k</span><br><span class="line"><span class="keyword">return</span> cur.val = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>


<p>迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> len(res)==k: </span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">root = root.right = <span class="number">6.</span>right = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">res = [<span class="number">6</span>]</span><br><span class="line">len(res) = <span class="number">1</span></span><br><span class="line">root = root.left = <span class="number">6.</span>left = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">5</span></span><br><span class="line">stack = []</span><br><span class="line">res = [<span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">len(res) = <span class="number">2</span></span><br><span class="line">root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">root = root.right = <span class="number">4.</span>right = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">res = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>] </span><br><span class="line">len(res) = <span class="number">3</span> = k</span><br><span class="line"><span class="keyword">return</span> res[<span class="number">-1</span>] = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="38-二叉搜索树的第k个结点-本题考点-树"><a href="#38-二叉搜索树的第k个结点-本题考点-树" class="headerlink" title="38.二叉搜索树的第k个结点 [^本题考点 树]"></a>38.二叉搜索树的第k个结点 [^本题考点 <em>树</em>]</h4><p>​    <strong>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。<br>例如,（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</strong></p>
<p>示例 1:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">root</span> <span class="string">=</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  <span class="string">/</span> <span class="string">\</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">\</span></span><br><span class="line">&nbsp;  <span class="number">2</span></span><br><span class="line"><span class="string">输入:</span> <span class="string">k</span> <span class="string">=</span> <span class="number">1</span> </span><br><span class="line"><span class="string">输出:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">输入:</span> <span class="string">k</span> <span class="string">=</span> <span class="number">0</span> </span><br><span class="line"><span class="string">输出:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">root</span> <span class="string">=</span> [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>]<span class="string">,</span> <span class="string">k</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      <span class="string">/</span> <span class="string">\</span></span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    <span class="string">/</span> <span class="string">\</span></span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">/</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"><span class="string">输出:</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化&nbsp;kthSmallest&nbsp;函数？</p>
<p>方法一：<br>算法：通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">r</span>):</span></span><br><span class="line">            <span class="keyword">return</span> inorder(r.left) + [r.val] + inorder(r.right) <span class="keyword">if</span> r <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> inorder(root)[k - <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：O(N)，遍历了整个树。<br>空间复杂度：O(N)，用了一个数组存储中序序列。</p>
<p>方法二：迭代<br>算法：<br>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p>
<p>时间复杂度：O(H+k)，其中 H 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(logN+k)。<br>当树是一个不平衡树时：复杂度为 O(N+k)，此时所有的节点都在左子树。<br>空间复杂度：O(H+k)<br>当树是一个平衡树时：O(logN+k)。<br>当树是一个非平衡树时：O(N+k)。<br>当迭代到最小的那个数时需要O(H)的复杂度，然后O(K)的复杂度就找第k小的元素的迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">root = root.left = <span class="number">3.</span>left = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">root = root.left = <span class="number">2.</span>left = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">root = root.left = <span class="number">1.</span>left = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">root = cur.right = <span class="number">1.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">root = cur.right = <span class="number">2.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">3</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> cur.val = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>


<p>递归</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)  <span class="comment"># BFS，不断左侧下探到叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span>  <span class="comment"># 左侧下探返回后，节点数+1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  <span class="comment"># 判断当前节点是否是目标节点，即第k小</span></span><br><span class="line">                self.res = root.val</span><br><span class="line">            dfs(root.right)  <span class="comment"># 右侧递归</span></span><br><span class="line"></span><br><span class="line">        self.k = k  <span class="comment"># 全局变量，self不能少</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">dfs(root.left)</span><br><span class="line">    root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">    dfs(<span class="number">3</span>)</span><br><span class="line">    dfs(root.left)</span><br><span class="line">        root = root.left = <span class="number">3.</span>left = <span class="number">2</span></span><br><span class="line">        dfs(<span class="number">2</span>)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">            root = root.left = <span class="number">2.</span>left = <span class="number">1</span></span><br><span class="line">            dfs(<span class="number">1</span>)</span><br><span class="line">            dfs(root.left)</span><br><span class="line">                root = root.left = <span class="number">1.</span>left = None</span><br><span class="line">                dfs(None)</span><br><span class="line">            返回上一层 root = <span class="number">1</span></span><br><span class="line">            k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">                root = root.right = <span class="number">2.</span>right = None</span><br><span class="line">                dfs(None)</span><br><span class="line">            返回上一层 root = <span class="number">1</span></span><br><span class="line">        返回上一层 root = <span class="number">2</span></span><br><span class="line">        k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">            root = root.right = <span class="number">2.</span>right = None</span><br><span class="line">            dfs(None)</span><br><span class="line">        返回上一层 root = <span class="number">2</span></span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">    res = root.val = <span class="number">3</span></span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">        dfs(<span class="number">4</span>)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">            root = root.left = <span class="number">4.</span>left = None</span><br><span class="line">        返回上一层 root = <span class="number">4</span>   </span><br><span class="line">        k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">返回上一层 root = <span class="number">5</span></span><br><span class="line">k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.res = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="29-二叉搜索树的后序遍历序列"><a href="#29-二叉搜索树的后序遍历序列" class="headerlink" title="29.二叉搜索树的后序遍历序列"></a>29.二叉搜索树的后序遍历序列</h2><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 1：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>题目只是说能不能是，而不是所有后序是这样的都是。<br>解题思路：</p>
<p>题目：假设输入的数组的任意两个数字都互不相同<br>左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值<br>其左、右子树也分别为二叉搜索树。</p>
<p>后序遍历定义： 遍历顺序为 “左、右、根” 。<br>后序遍历 的序列中，最后一个数字是树的根节点</p>
<p>左右子树分界点 与根节点作比较<br>数组中前面的数字可以分为两部分：<br>第一部分是左子树节点 的值，都比根节点的值小；<br>第二部分 是右子树 节点的值，都比 根 节点 的值大，</p>
<p>方法一：递归分治</p>
<ul>
<li>根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性<br>（即其后序遍历是否满足二叉搜索树的定义） ，<br>若所有子树都正确，则此序列为二叉搜索树的后序遍历。</li>
</ul>
<p>递归解析：<br>i, j 是递归过程中 后序遍历的左右边界， i, j 命名规范用left, right吧<br>i, j 之间的节点是当前子树包含的节点。 </p>
<p>当 i &gt; j 时，没有节点。</p>
<ul>
<li>终止条件： 当 i \geq j i≥j ，说明此子树节点数量 \leq 1 ≤ 1 ，无需判别正确性，直接返回 true ，递归到“空”则说明所有子树满足</li>
</ul>
<p>当 i = m = j - 1 时，<br>向下递归 recur(i, m - 1) 时 i &gt; j ，<br>本质上就是左子树为空的情况</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<p>[6, 5]<br>第一个大于 root = 5 的后面都是5的右子节点[6]。<br>这个数组只有一个根节点，没有子节点<br>m = 0 = i = 0, recur(i, m - 1) = recur(0, 0 - 1), 0 &gt; -1</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">6</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>[7, 6, 5]<br>第一个大于 root = 5 的后面都是5的右子树[7，6]。<br>然后再递归这个数组，6是根节点，第一个比6大的后面都是6的右子节点[7]，<br>只有一个根节点，没有子节点</p>
<p>所以我们能确定这棵树是二叉搜索树。<br>本来left= 0,right = 2, 通过第一个while循环m= cur = 7,<br>那么return中的第二个recur(i, m - 1)就是recur(0, 0 - 1)，这是只有右子树的情况，<br>i &gt; j，返回True</p>
<p>[1, 2, 3] 可能不是二叉搜索树的后序遍历，但也可能是。<br>根据题意，只要能构成二叉搜索树的后序遍历，就应返回 true 。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   /  </span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /     </span><br><span class="line"><span class="number">1</span>       </span><br></pre></td></tr></tbody></table></figure>
<p>本来left= 0,right = 2, 通过第一个while循环 m = cur = 2,<br>那么return中的第二个recur(m, j - 1)就是recur(2, 2 - 1)，这是只有左子树的情况，<br>i &gt; j，返回True</p>
<ul>
<li><p>递推工作：</p>
<ol>
<li><p>划分左右子树： 遍历后序遍历的 [i, j] 区间元素，<br>从头、左往右找出第一个大于或等于根节点的节点，索引记为 m ，数组的任意两个数字都互不相同，<br>如果没有大于第一个大于根节点 的节点，则根节点索引也记为 m，<br>此时，可划分出左子树区间 [i, m-1] 、右子树区间 [m, j - 1] 、根节点索引 j 。</p>
</li>
<li><p>判断是否为二叉搜索树：</p>
</li>
</ol>
<ul>
<li><p>左子树区间 [i, m - 1] 内的所有节点都应 &lt;&lt; postorder[j] 。<br>而第 1. 划分左右子树 步骤已经保证左子树区间的正确性，<br>因此只需要判断右子树区间即可。</p>
</li>
<li><p>右子树区间 [m, j-1] 内的所有节点都应 &gt;&gt; postorder[j] 。<br>实现方式为遍历，当遇到 \leq ≤postorder[j] 的节点则跳出；<br>则可通过 cur = j 判断是否为二叉搜索树。</p>
</li>
</ul>
</li>
<li><p>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符and 连接。</p>
<ol>
<li>cur = j ： 判断 “当前树”的后序遍历满足二叉搜索树的性质，<br>若未将postoerder[i, j)遍历完，则非后序遍历序列 返回false</li>
<li>recur(i, m - 1) ： 判断 此树的左子树 是否正确。</li>
<li>recur(m, j - 1) ： 判断 此树的右子树 是否正确。</li>
</ol>
</li>
</ul>
<p>时间复杂度 O(N^2) ： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；<br>最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。<br>空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: [int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="comment"># 如果left==right，就一个节点不需要判断了，</span></span><br><span class="line">            <span class="comment"># 如果left&gt;right说明只有左子树的情况，如果只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = i</span><br><span class="line">            <span class="keyword">while</span> postorder[cur] &lt; postorder[j]: cur += <span class="number">1</span></span><br><span class="line">            <span class="comment"># cur继续保留已经循环了的次数的数值</span></span><br><span class="line">            m = cur  <span class="comment"># 第一个大于根节点 的节点的索引记为 m</span></span><br><span class="line">            <span class="keyword">while</span> postorder[cur] &gt; postorder[j]: cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cur == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>步骤：</p>
<ol>
<li>确定根节点root；</li>
<li>遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；</li>
<li>遍历右子树，若发现有小于root的值，则直接返回false；</li>
<li>分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。<br>时间复杂度(n) 击败90%</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> postorder <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        length = len(postorder)</span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 在二叉搜索树中左子树节点都小于根节点，找到左子树的区间，</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 二叉搜索树中右子树的节点都大于根节点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length):</span><br><span class="line">            <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断左子树是否为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            left = self.verifyPostorder(postorder[<span class="number">0</span>:i])  <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="comment"># 判断右子树是否为二叉搜索树</span></span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; length - <span class="number">1</span>:</span><br><span class="line">            right = self.verifyPostorder(postorder[i:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isTree</span>(<span class="params">postorder</span>):</span></span><br><span class="line">            root = postorder[<span class="number">-1</span>]</span><br><span class="line">            length = len(postorder)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length): </span><br><span class="line">                <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            left = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                left = isTree(postorder[:i])</span><br><span class="line">            right = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; length <span class="number">-1</span> :</span><br><span class="line">                right = isTree(postorder[i:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br><span class="line">        <span class="keyword">return</span> isTree(postorder)</span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>出发点不是检索子树的正确性。 而是“所有递减节点的父节点 root 性质” 得到满足即可</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>后序遍历    [1, 3, 2, 6, 5]<br>后序遍历倒序 [5, 6, 2, 3, 1]<br>后序遍历倒序： [ 根节点 | 右子树 | 左子树 ] 。<br>类似 先序遍历的镜像，即先序遍历为 “根、左、右” 的顺序，</p>
<ul>
<li><p>设后序遍历倒序列表为 [r_{n}, r_{n-1},…,r_1]，<br>遍历此列表，设索引为 i ，若为 二叉搜索树 ，则有规律：</p>
<ul>
<li><p>当节点值 r_i &gt; r_{i+1} 时： 节点 r_i 一定是节点 r_{i+1} 的右子节点。<br>例如5和6是挨着的并且5 &lt; 6，所以6是5的右子节点。<br>证明：比arr[i+1]大的肯定都是他的右子节点，如果还是挨着他的，<br>肯定是在后续遍历中所有的右子节点最后一个遍历的，<br>所以他一定是arr[i]的右子节点</p>
</li>
<li><p>当节点值 r_i &lt; r_{i+1} 时： 节点 r_i 一定是某节点 root 的左子节点，且 root 为节点 r_{i+1}, r_{i+2},…, r_{n}r 中值大于且最接近 r_i 的节点（∵ root 直接连接 左子节点 r_i ）。<br>比如6，2是降序的，那么2肯定是他前面某一个节点的左子节点，并且这个值是大于2中最小的，我们看到5和6都是大于2的，但5最小，所以2就是5的左子节点。<br>同理我们可以观察到3和1是降序，1前面大于1中最小的是2，所以1就是12的左子节点。</p>
</li>
</ul>
</li>
<li><p>当遍历时遇到递减节点 r_i &lt; r_{i+1}，若为二叉搜索树，则对于后序遍历中节点 r_i 右边的任意节点 r_x \in [r_{i-1}, r_{i-2}, …, r_1]，必有节点值 r_x &lt; root 。<br>序列中节点2右边的所有节点(即节点3，1)都应小于节点5。</p>
</li>
</ul>
<p>节点 r_x 只可能为以下两种情况：<br>① r_x 为 r_i 的左、右子树的各节点；<br>② r_x 为 root 的父节点或更高层父节点的左子树的各节点。<br>在二叉搜索树中，以上节点都应小于 root 。</p>
<ul>
<li>遍历 “后序遍历的倒序” 会多次遇到递减节点 r_i ，若所有的递减节点 r_i 对应的父节点 root 都满足以上条件，则可判定为二叉搜索树。</li>
<li>根据以上特点，考虑借助 单调栈 实现：<ol>
<li>借助一个单调栈 stack 存储值递增的节点；</li>
<li>每当遇到值递减的节点 r_i，则通过出栈来更新节点 r_i 的父节点 root ；</li>
<li>每轮判断 r_i 和 root 的值关系：<ol>
<li>若 r_i &gt; root 则说明不满足二叉搜索树定义，直接返回 false 。</li>
<li>若 r_i &lt; root 则说明满足二叉搜索树定义，则继续遍历。</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>算法流程：</p>
<ol>
<li>初始化： 单调栈 stack ，父节点值 root = +\inf root=+∞<br>（初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；</li>
<li>倒序遍历 postorder ：记每个节点为 r_i；</li>
<li>判断： 若 r_i&gt;root ，说明此后序遍历序列不满足二叉搜索树定义，直接返回 false ；</li>
<li>更新父节点 root ： 当栈不为空 且 r_i &lt; stack[-1] 时，循环执行出栈，并将出栈节点赋给 root 。</li>
<li>入栈： 将当前节点 r_i入栈；</li>
<li>若遍历完成，则说明后序遍历满足二叉搜索树定义，返回 true 。</li>
</ol>
<p>时间复杂度 O(N) ： 遍历 postorder 所有节点，各节点均入栈 / 出栈一次，使用 O(N) 时间。递归判断需要重复遍历节点，而单调栈不用。<br>空间复杂度 O(N) ： 最差情况下，单调栈 stack 存储所有节点，使用 O(N) 额外空间。</p>
<p>把先序遍历的功能通过单调栈实现了12356 13265 56231 inf根5(右)-inf左 562 231 ，<br>并且通过局部性使得左中右的顺序在每个节点处都进行判断，太妙了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: [int]</span>) -&gt; bool:</span></span><br><span class="line">        stack, root = [], float(<span class="string">"+inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># root是在什么情况下赋的值，root并不一定都是根节点的值，</span></span><br><span class="line">            <span class="comment"># 相对于遇到了左子节点的时候他是左子节点的根节点。</span></span><br><span class="line">            <span class="comment"># 如果是右子节点，parent就是他的某一个祖先节点，</span></span><br><span class="line">            <span class="comment"># 并且这个右子节点是这个祖先节点的一个左子树的一部分，所以不能超过他，</span></span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，</span></span><br><span class="line">            <span class="comment"># 说明当前节点是前面某个节点的左子节点，我们要找到他的根节点</span></span><br><span class="line">            <span class="keyword">while</span>(stack <span class="keyword">and</span> postorder[i] &lt; stack[<span class="number">-1</span>]):</span><br><span class="line">                root = stack.pop()</span><br><span class="line">            <span class="comment"># 只要遇到了某一个左子节点，才会执行上面的代码，</span></span><br><span class="line">            <span class="comment"># 才会更新root的值，否则root就是一个非常大的值，</span></span><br><span class="line">            <span class="comment"># 也就是说如果一直没有遇到左子节点，那么右子节点可以非常大</span></span><br><span class="line">            stack.append(postorder[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">self, sequence</span>):</span></span><br><span class="line">        <span class="keyword">if</span> sequence == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rootNum = sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">del</span> sequence[<span class="number">-1</span>]</span><br><span class="line">        index = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sequence)):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="literal">None</span> <span class="keyword">and</span> sequence[i] &gt; rootNum:</span><br><span class="line">                index = i</span><br><span class="line">            <span class="keyword">if</span> index != <span class="literal">None</span> <span class="keyword">and</span> sequence[i] &lt; rootNum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> sequence[:index] == []:</span><br><span class="line">            leftRet = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            leftRet = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        <span class="keyword">if</span> sequence[index:] == []:</span><br><span class="line">            rightRet = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rightRet = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRet <span class="keyword">and</span> rightRet</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先找到根节点的右子节点，然后判断右子树的值是否全大于root；</span></span><br><span class="line"><span class="comment"># 然后再递归根节点的左右子树即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        cur_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt;= root:</span><br><span class="line">                cur_index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        left = postorder[:cur_index]</span><br><span class="line">        right = postorder[cur_index : <span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 检查左右子树是否有不符合要求的节点</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> right:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 检查左、右子树是否分别是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> self.verifyPostorder(left) <span class="keyword">and</span> self.verifyPostorder(right)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="30-二叉树中和为某一值的路径"><a href="#30-二叉树中和为某一值的路径" class="headerlink" title="30.二叉树中和为某一值的路径"></a>30.二叉树中和为某一值的路径</h2><p><strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定如下二叉树，以及目标和&nbsp;sum = <span class="number">22</span>，</span><br><span class="line"></span><br><span class="line">              <span class="number">5</span></span><br><span class="line">             / \</span><br><span class="line">            <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">           /   / \</span><br><span class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line">         /  \    / \</span><br><span class="line">        <span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：<br>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。</p>
<ul>
<li>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。</li>
<li>路径记录： 在先序遍历中，记录从根节点到当前节点的路径。<br>当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</li>
</ul>
<p>算法流程：<br>pathSum(root, sum) 函数：</p>
<ul>
<li>初始化： 结果列表 res ，路径列表 path 。</li>
<li>返回值： 返回 res 即可。</li>
</ul>
<p>recur(root, tar) 函数：</p>
<ul>
<li>递推参数： 当前节点 root ，当前目标值 tar 。</li>
<li>终止条件： 若节点 root 为空，则直接返回。</li>
<li>递推工作：<ol>
<li>路径更新： 将当前节点值 root.val 加入路径 path ；</li>
<li>目标值更新： tar = tar - root.val（即目标值 tar 从 sum 减至 0 ）；</li>
<li>路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 只有当前函数终止才会向上回溯前，所有变量恢复到原来的状态，需要将当前节点从路径 path 中弹出删除，即执行 path.pop()</li>
</ol>
</li>
</ul>
<p>状态是指完成一件事情进行到哪一个阶段，在上面的代码中：path 、tar 都是状态变量</p>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，先序遍历需要遍历所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。<br>res 作为返回值，是必须要使用的空间，因此不计入计算范围内~ 这里的空间复杂度只计算“额外空间”</p>
<p>击败50%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment">#  res 保存最终的所有路径结果， path 保存每条路径。</span></span><br><span class="line">        res, path = [], []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, tar</span>):</span></span><br><span class="line">            <span class="comment"># 递归终止条件 1：解决子问题，如果输入结点为空结点，返回空列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:   </span><br><span class="line">                <span class="comment"># recur() 函数实际上是 void 函数，最后return 的是 res ,写成return [] 都可以</span></span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="comment"># 有节点</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="comment"># 递归终止条件 2：tar == 0，并且节点为叶子节点 </span></span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="comment"># 对引用类型参数（Reference Data Type Arguments）动态变量，</span></span><br><span class="line">                <span class="comment"># 在调用函数时，将实际参数的 内存地址（引用，而不是真正的变量） 复制传递到函数中。</span></span><br><span class="line">                <span class="comment"># 可变对象如列表，字典等，原本就可以改变，如果在函数中对参数修改，将会影响到实际参数。</span></span><br><span class="line">                <span class="comment"># 记录路径时若执行 res.append(path) ，</span></span><br><span class="line">                <span class="comment"># 把 path 列表对象在“方法传参”中传递所在的内存地址（引用）加到 res 中 ；</span></span><br><span class="line">                <span class="comment"># 所有递归函数始终对唯一的内存地址的同一个 path 对象做处理，因此回溯时，也应将 path 还原至此递归函数执行前的形式 </span></span><br><span class="line">                <span class="comment"># 不断地变长变短、变长变短的 path 变量所指向的列表在深度优先遍历的过程中只有一份，</span></span><br><span class="line">                <span class="comment"># 后续 path 对象改变时，后面又进栈 append 又出栈 pop 的，</span></span><br><span class="line">                <span class="comment"># res 中的 path 对象 也会随之改变</span></span><br><span class="line">                <span class="comment"># 深度优先遍历完成以后，最终回溯回根节点root，path回到空列表。</span></span><br><span class="line">                <span class="comment"># 实际上指向的是同一块内存地址，指向的那块内存区域没有变，因此会看到 6 个空的列表对象。</span></span><br><span class="line">                <span class="comment"># res 里面是这样的：[path 在内存中的地址, path 在内存中的地址,</span></span><br><span class="line">                <span class="comment"># path 在内存中的地址, path 在内存中的地址, path 在内存中的地址]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 深拷贝 copy.deepcopy，没有拷贝对象的地址(引用)，只是拷贝对象的值，</span></span><br><span class="line">                <span class="comment"># 当一条path找到的时候，我想要完整的保存它，</span></span><br><span class="line">                <span class="comment"># 每次都要新复制了一个 path 列表，把新复制的列表的地址复制到 res 中，因此不会受到 path 变化的影响。</span></span><br><span class="line">                <span class="comment"># 在它遍历到符合条件的状态时候，把其中的在某个特定时期的状态的变量的地址复制下来</span></span><br><span class="line">                <span class="comment"># 解决的方法，list(path)或path[:]或path.copy()</span></span><br><span class="line">                <span class="comment"># 本文中的 path 列表对象对于 dfs() 函数来说仍是 ”全局的“ </span></span><br><span class="line">                res.append(list(path))</span><br><span class="line">            recur(root.left, tar)  <span class="comment"># 递归处理左边或函数已返回（左子树已递归完成）</span></span><br><span class="line">            recur(root.right, tar)  <span class="comment"># 递归处理右边或函数已返回（右子树已递归完成）</span></span><br><span class="line">            path.pop()  <span class="comment"># 递归完成以后，必须重置变量</span></span><br><span class="line">            <span class="comment"># 为什么仅path.pop() 而不tar += root.val呢？</span></span><br><span class="line">            <span class="comment"># 而且加上了tar += root.val也能通过？</span></span><br><span class="line">            <span class="comment"># tar 是数值不可变对象值传递，因此每轮递归函数里的修改的 tar 都是独立的数字，</span></span><br><span class="line">            <span class="comment"># 上层递归的 tar 还保存在系统调用dfs的栈中，是没有变的，相当于tar没有减去那个数，因此tar不用回溯 不用重置</span></span><br><span class="line">            <span class="comment"># 在记录路径时，一旦涉及本节点的路径都检查并记录完毕，就要去掉本节点，但未完毕前不能去掉，所以放在最后。</span></span><br><span class="line">            <span class="comment"># 另外，递归思考过程中需要且仅需要着眼当下，如果实在纠结递归的进行过程，要从函数调用栈的角度思考。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 函数执行完就会自己结束的～因为本题 recur() 不需要有返回值，因此就不用 return</span></span><br><span class="line"></span><br><span class="line">        recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">tar = <span class="number">22</span></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">11</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">tar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">7</span>]</span><br><span class="line">tar = <span class="number">-5</span></span><br><span class="line"></span><br><span class="line">不满足回到上一层</span><br><span class="line">root = <span class="number">11</span></span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">8</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">13</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line">tar = <span class="number">-4</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">8</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>],  ]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">root = root.right = <span class="number">1</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">tar = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>



<p>递归先序遍历树，把结点加入路径。<br>若该结点是叶子结点则比较当前路径和是否等于期待和。<br>弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</p>
<p>方法二，击败95%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, tar</span>):</span></span><br><span class="line">            <span class="comment"># print(path)</span></span><br><span class="line">            <span class="comment"># 递归终止条件 1：如果遍历到的结点为空结点，返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 递归终止条件 2：如果遍历到的叶子结点，且 tar 恰好等于叶子结点的值</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.val == tar <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                path.pop()</span><br><span class="line">                <span class="comment"># 在叶子结点处，并且找到了一个解以后，就可以返回，所以要加上 return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 缩进错了，下面 3 行都是 dfs 函数里的内容</span></span><br><span class="line">            dfs(root.left, tar - root.val)</span><br><span class="line">            dfs(root.right, tar - root.val)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在这里要调用一下 dfs 方法</span></span><br><span class="line">        dfs(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">path = []</span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">tar = <span class="number">22</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">4</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">11</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">tar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">7</span>]</span><br><span class="line">tar = <span class="number">-5</span></span><br><span class="line"></span><br><span class="line">不满足回到上一层</span><br><span class="line">root = <span class="number">11</span></span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>] ]</span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">tar = <span class="number">22</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">8</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">13</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">8</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">4</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">5</span></span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">1</span></span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">tar = <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum_: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, path, sum_</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> sum_ - root.val == <span class="number">0</span>:</span><br><span class="line">                path += [root.val]</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="comment"># path + [root.left.val] 返回一个新的列表，所有递归函数里的 path 操作不会互相干扰。 </span></span><br><span class="line">            <span class="comment"># path.append(root.left.val)是对path进行修改，无返回值</span></span><br><span class="line">            <span class="comment"># 记录到达每个节点时的sum - 「路径和」</span></span><br><span class="line">            <span class="comment"># 如果遍历到叶子节点的时候，sum - 「路径和」恰好等于叶子节点的值，</span></span><br><span class="line">            <span class="comment"># 那么这条从根节点到叶子节点的路径即为一条满足题目的路径。</span></span><br><span class="line">            helper(root.left, path + [root.val], sum_ - root.val)</span><br><span class="line">            helper(root.right, path + [root.val], sum_ - root.val)</span><br><span class="line">        helper(root, [], sum_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="31-二叉搜索树与双向链表"><a href="#31-二叉搜索树与双向链表" class="headerlink" title="31.二叉搜索树与双向链表"></a>31.二叉搜索树与双向链表</h2><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">4</span></span><br><span class="line">   / \ </span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。<br>对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，<br>树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>解题思路：<br>本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。<br>因此把标准中序遍历中 改变每个父节点的左右指向即可<br>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p>
<ol>
<li>排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点；</li>
<li>双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right = cur ，也应 cur.left = pre 。</li>
<li>循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right = head 。</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure>
<p>根据以上分析，考虑使用中序遍历访问树的各节点 cur ；<br>并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；<br>中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p>
<p>算法流程：<br>dfs(cur): 递归法中序遍历；</p>
<ol>
<li>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 dfs(cur.left) ；</li>
<li>构建链表：<ol>
<li>当 pre 为空时：代表正在访问链表头节点，记为 head 。</li>
<li>当 pre 不为空时：修改双向节点引用，<br>即 pre.right = cur ， cur.left = pre ；</li>
<li>保存 cur ：更新 pre = cur ，即节点 cur 是后继节点的 pre ；</li>
</ol>
</li>
<li>递归右子树，即 dfs(cur.right) ；<br>并没有创建新节点，pre 、 head 只是两个引用，指向现有节点的地址。</li>
</ol>
<p>treeToDoublyList(root)：</p>
<ol>
<li>特例处理： 若节点 root 为空，则直接返回；</li>
<li>初始化： 空节点 pre ；</li>
<li>转化为双向链表： 调用 dfs(root) ；</li>
<li>构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可。</li>
<li>返回值： 返回链表的头节点 head 即可。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</p>
<p>pre = ListNode() ，如果不加self的话，pre和head是dfs函数内部的变量，那么就是类中方法的私有变量，是无法被类所访问的，外函数和内函数不能共享<br>由于中序遍历完还需要用到 pre 去实现循环链表，<br>此时可以声明 self.pre = pre 则建立了类成员变量 self.pre<br>或者在函数内部声明 nonlocal pre 说明 pre 不会因为引用修改而成为局部变量。<br>这样此变量就能在所属类的任何方法中访问。类里面的全局变量<br>使其在两个函数 dfs()中都可以正常访问 head 和 pre，</p>
<p>list 类型是外部变量全局变量，函数中的函数也可以访问。<br>内部调用 list.append() 等方法，<br>不会改变引用，也就不需要做 self 和 nonlocal 等操作。</p>
<p>head是个指针变量，（这里你就当成个普通int型变量来理解就行了），指针变量作为函数参数传入时和普通变量一样，也就是，如你在dfs函数中怎么修改它，当函数结束返回的时候，指针变量或者普通变量还是传入之前的值。但是加上引用就不一样了，此时你在dfs中修改head指针，函数返回时，head指针是被修改过的。</p>
<p>值传递与引用传递的区别，因为函数是void的，想要把函数内部对指针的修改传出来就得用引用（或者指针的指针也可以），别去管head和pre是不是指针（指针本质上也是一个对象），最后修改一下函数的返回值也是可以的。<br>因为你修改的对象是Node<em>本身，而不是指向的那个东西，所以要对Node</em>再加个引用。（指针参数本质上也是一种值传递，传递的就是地址）</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="comment"># 递归出口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left)  <span class="comment"># # 中序遍历，先递归左子树</span></span><br><span class="line">            <span class="comment"># pre 用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur</span></span><br><span class="line">            <span class="comment"># pre!=None时，cur左侧存在节点pre，需要进行 pre.right=cur 的操作</span></span><br><span class="line">            <span class="comment"># pre 相对于递归函数是全局变量，因此需要加 self</span></span><br><span class="line">            <span class="comment"># 中序遍历，然后父节点</span></span><br><span class="line">            <span class="keyword">if</span> self.pre:  <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="comment"># 当pre==None时，cur左侧没有节点，即此时cur为双向链表中的头节点</span></span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                self.head = cur  <span class="comment"># 记录初始头节点</span></span><br><span class="line">            self.pre = cur  <span class="comment"># 保存 cur, pre指向当前的cur</span></span><br><span class="line">            dfs(cur.right)  <span class="comment"># 中序遍历，最后 递归右子树 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 中序遍历全部迭代完后，head 指向头节点，pre 指向尾节点，</span></span><br><span class="line">        <span class="comment"># 构建循环链表：因此修改 head 和 pre 的双向节点引用即可。</span></span><br><span class="line">        <span class="comment"># 进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的</span></span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></tbody></table></figure>

<p>不是把二叉树的根节点当作链表的头，应该是将最左下的叶节点作为链表的头结点。<br>排序：树的中序遍历 1 2 3 4 5<br>双向：2.right = 3 ,  3.left = 2<br>循环：5.right = 1， 1.left = 5</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pre</span> = None</span><br><span class="line"><span class="attr">root</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">cur</span> = root</span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = None</span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">head</span> = <span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">right</span> = <span class="number">3</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">3</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">2</span> </span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">right</span> = <span class="number">5</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">5</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">self.head.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">5</span></span><br><span class="line">self.pre.<span class="attr">right</span> = self.<span class="attr">head</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>


<p>法二：不用递归，利用栈中序遍历，顺便更改节点左右指向，头结点和尾结点的指针。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        head = node = stack.pop()</span><br><span class="line">        pre = node</span><br><span class="line">        node = node.right</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pre.right = node</span><br><span class="line">            node.left = pre</span><br><span class="line">            pre = node</span><br><span class="line">            node = node.right</span><br><span class="line">        pre.right = head</span><br><span class="line">        head.left = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= root</span> = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">head = <span class="keyword">node</span> <span class="title">= 1</span></span><br><span class="line">pre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line">node.left = pre = <span class="number">1</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line">node.left = pre = <span class="number">2</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line">node.left = pre = <span class="number">3</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line">node.left = pre = <span class="number">4</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line">stack 和 <span class="keyword">node</span> <span class="title">同时为空</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">pre</span>.right = head = <span class="number">1</span></span><br><span class="line">head.left = pre = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三：分治 递归遍历<br>第一步：需要把 left 指针指向上一个比该元素小的值，<br>right 指针指向下一个比当前元素大的值。但是这个值不一定是该节点的父亲或者儿子。<br>所以递归的时候需要传递当前元素已知的界限给儿子。</p>
<p>而且传给左孩子的右界限是自己，左界限是当前元素的父亲传下来的界限。<br>给右孩子的则正好相反。</p>
<p>递归的起始根节点的左右界限都设为 None</p>
<p>第二步：把最小值和最大值连接起来</p>
<p>如何找到最小值和最大值，最小值和最大值不一定是叶子节点。我刚开始犯了这个错误。</p>
<p>最小值一定是某个节点的左儿子，而且他没有左儿子。是整个树最左边的左儿子。</p>
<p>所以我定义的找最小节点的条件是：没有左儿子 + 父亲传来的左界限为 None<br>最大节点：没有右儿子 + 父亲传来的右界限为 None</p>
<p>这个方法将dfs()的输出改为头和尾，然后左节点尾连根节点再连右节点头，接着递归即可<br>时间复杂度：O(N)，所有节点遍历一次。<br>空间复杂度：O(N)，当二叉搜索树退化为链表时，树的深度为 N.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root: <span class="string">'Node'</span></span>) -&gt; ('Node', 'Node'):</span></span><br><span class="line">            <span class="comment"># 根为空，那么 对应的双向链表的 头节点 和 尾节点 也为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 左子树 对应的 双向链表的头节点和尾节点</span></span><br><span class="line">            left_head, left_tail = dfs(root.left)</span><br><span class="line">            <span class="comment"># 右子树 对应的 双向链表的头节点和尾节点</span></span><br><span class="line">            right_head, right_tail = dfs(root.right)</span><br><span class="line">            <span class="comment"># 根的 左节点 与 左子树的尾节点 互相连接</span></span><br><span class="line">            <span class="comment"># 根的 右节点 与 右子树的头节点 互相连接</span></span><br><span class="line">            root.left, root.right = left_tail, right_head</span><br><span class="line">            <span class="keyword">if</span> left_tail: </span><br><span class="line">                left_tail.right = root</span><br><span class="line">            <span class="keyword">if</span> right_head: </span><br><span class="line">                right_head.left = root</span><br><span class="line">            <span class="comment"># 左子树的头节点 如果存在则作为当前 双向链表的头节点，否则使用 根节点。尾节点同理。</span></span><br><span class="line">            <span class="keyword">return</span> left_head <span class="keyword">if</span> left_head <span class="keyword">else</span> root, right_tail <span class="keyword">if</span> right_tail <span class="keyword">else</span> root</span><br><span class="line">        head, tail = dfs(root)</span><br><span class="line">        <span class="comment"># 改造成循环双向链表</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> tail:</span><br><span class="line">            head.left, tail.right = tail, head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            lh, lt = merge(root.left)</span><br><span class="line">            rh, rt = merge(root.right)</span><br><span class="line">            res = [lh, rt]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lh:</span><br><span class="line">                res[<span class="number">0</span>] = root                </span><br><span class="line">            root.left = lt</span><br><span class="line">            <span class="keyword">if</span> lt:</span><br><span class="line">                lt.right = root</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rt:</span><br><span class="line">                res[<span class="number">1</span>] = root</span><br><span class="line">            root.right = rh</span><br><span class="line">            <span class="keyword">if</span> rh:</span><br><span class="line">                rh.left = root</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        head, tail = merge(root)</span><br><span class="line">        head.left, tail.right = tail, head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>回溯法<br>一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p>
<p>采用试错的思想，它尝试分步的去解决一个问题。<br>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。<br>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案；</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案。</li>
</ol>
<p>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。<br>「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。<br>而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。<br>至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。</p>
<p>搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。</p>
<p>与动态规划的区别<br>共同点<br>用于求解多阶段决策问题。多阶段决策问题即：</p>
<ol>
<li>求解一个问题分为很多步骤（阶段）；</li>
<li>每一个步骤（阶段）可以有多种选择。<br>不同点</li>
<li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li>
<li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li>
</ol>
<p>怎么前进（进入下一个状态）；<br>怎么回退（回到上一个状态）；<br>什么时候停止。 其中比较重要的是：采取何种方式处理好状态的前进和回退。</p>
<p>回溯问题本身是在树形问题上的遍历，且是深度优先遍历。所以有回退的过程，需要撤销选择。<br>单从代码上看可能看不出来，<br>一定要先理解「深度优先遍历」这个思想，然后再去理解为什么可以用「一个变量」去在「所有可能的状态集合」里搜索要求的状态。</p>
<p>我在标题和题解的一开始都在强调这件事情。怎样构建一个「树」的模型，去执行深度优先遍历，是解决这一类问题的关键思想</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<p>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。<br>以数组 [1, 2, 3] 的全排列为例。</p>
<p>按顺序枚举每一个位置可能出现的数字，之前已经出现的数字在接下来要选择的数字中不能出现</p>
<p>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p>
<p>说明：</p>
<ul>
<li>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；</li>
<li>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。<br>例如：从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。<br>不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；</li>
</ul>
<p>正是因为修改的都是同一个对象，在回到来过的地方的时候，这个对象的值要和之前来到的时候是一样的。</p>
<ul>
<li>深度优先遍历，借助系统栈空间，已经选了哪些树的 path，保存每一个结点的所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；</li>
<li>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。</li>
</ul>
<p>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p>
<p>设计状态变量：表示了在求解一个问题的时候所处的阶段。</p>
<ul>
<li>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；</li>
<li>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；</li>
<li>布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应下标设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</li>
</ul>
<p>需要根据问题的场景设计合适的状态变量。</p>
<p>剪枝<br>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p>
<p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。<br>总结<br>做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：<br>分支如何产生；递归到叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？<br>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p>
<p>在前进时，需要查看当前数字是否已经在组合的路径中，也就是要回避非法状态；<br>在回退时，要将当前数字从组合的路径中删除，以达到回溯、不影响进入到下一个状态的目的。 </p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, length, depth, path, used, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> depth == length:  <span class="comment"># 递归结束条件：当前递归的层数=输入数组的长度</span></span><br><span class="line">                res.append(list(path))</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment"># 在满足条件return之后，depth-1=2，i =2顺次执行状态重置的代码。path = [1, 2], used = [True, True, False]</span></span><br><span class="line">                <span class="comment"># 至于它为什么可以继续执行上一步的状态重置，而不需要再次进入if语句是因为！！！在我们把第三个True置为False，并把3 pop之后，本层调用已经结束了,因为所有的可能已经都调用完了，该函数的子孙们都被解决掉了，[1, 2]后面不会在加上除了3以外的数字</span></span><br><span class="line">                <span class="comment"># 回到上一层，depth = 1, i = 1 </span></span><br><span class="line">                <span class="comment"># dfs(nums, length, depth + 1, path, used, res)就是个单纯的语句了，就继续往下执行代码啦，</span></span><br><span class="line">                <span class="comment"># 然后又来到了状态重置这里，改变第二个位置的状态[True, False, False]，pop(), path = [1],</span></span><br><span class="line">                <span class="comment"># 进入for</span></span><br><span class="line">                <span class="comment"># depth = 1, i = 2, used = [True, False, True], path = [1, 3]</span></span><br><span class="line">                <span class="comment"># dfs(nums, length, depth + 1, path, used, res)进入下一层</span></span><br><span class="line">                <span class="comment"># depth = 2, i = 0, used[0] = True, path = [1, 3], </span></span><br><span class="line">                <span class="comment"># depth = 2, i = 1, used[1] = False, used = [True, True, True], path = [1, 3, 2], </span></span><br><span class="line">                <span class="comment"># return i =1,</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在非叶子结点处，产生不同的分支，</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:  <span class="comment"># 当前未选择的数中依次选择一个元素作为下一个位置的元素，flase才能</span></span><br><span class="line">                    used[i] = <span class="literal">True</span>  <span class="comment"># 标记为已经选择的元素</span></span><br><span class="line">                    path.append(nums[i])  <span class="comment"># 把选择的元素添加到栈的末尾</span></span><br><span class="line">                    print(<span class="string">'递归前 used ='</span>, used, <span class="string">', path ='</span>, path)</span><br><span class="line"></span><br><span class="line">                    dfs(nums, length, depth + <span class="number">1</span>, path, used, res)</span><br><span class="line">                    <span class="comment"># 下一层结点的递归执行结束以后，</span></span><br><span class="line">                    <span class="comment"># 它后面的语句是表示程序要回退到上一个结点进行相关操作</span></span><br><span class="line">                    <span class="comment"># （这里要结合图形来理解）。</span></span><br><span class="line">                    <span class="comment"># 不是因为写了 used[i] = False 和 path.pop() 才有回退</span></span><br><span class="line">                    print(<span class="string">'递归后 used ='</span>, used, <span class="string">', path ='</span>, path)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 下面这两行代码发生 「回溯」，为了保证在回退的时候，相关数据也正确，最终结果才会正确。</span></span><br><span class="line">                    <span class="comment"># 回溯发生在从 深层结点 回到 浅层结点 的过程，</span></span><br><span class="line">                    <span class="comment"># 代码在形式上和递归之前是对称的</span></span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        length = len(nums)  <span class="comment"># 输入数组的长度</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:  <span class="comment"># 如果输入数组是一个空数组</span></span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment"># 返回一个空列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化每个元素都为 false，表示这些数还没有被选择，空间换时间</span></span><br><span class="line">        used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]</span><br><span class="line">        <span class="comment"># print([False for _ in range(3)])  # [False, False, False]</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(nums, length, <span class="number">0</span>, [], used, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.permute(nums)</span><br><span class="line">    print(res)</span><br></pre></td></tr></tbody></table></figure>

<p>因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。</p>
<p>它们的区别仅在于</p>
<p>1、二进制右边是低位，数组左边是索引为 0 的位置；</p>
<p>2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。</p>
<p>因此，完全可以用一个整数表示一个布尔型数组。</p>
<p>我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。</p>
<p>异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。</p>
<p>具体说来：</p>
<p>把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。</p>
<p>因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。</p>
<p>它们的区别仅在于</p>
<p>1、二进制右边是低位，数组左边是索引为 0 的位置；</p>
<p>2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。</p>
<p>因此，完全可以用一个整数表示一个布尔型数组。</p>
<p>我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。</p>
<p>异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。</p>
<p>具体说来：</p>
<p>把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = k = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_func</span>(<span class="params">first=<span class="number">0</span></span>):</span></span><br><span class="line">            <span class="comment"># first等于k时返回，代表着是计算A(n,k)的全排列问题，应题目要求此时k==n</span></span><br><span class="line">            <span class="keyword">if</span> first == k:</span><br><span class="line">                res.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">                <span class="comment"># 用first选定nums中每个位置，取值是[0, n-1]</span></span><br><span class="line">                <span class="comment"># 用交换来选定first位置上所有可能的元素</span></span><br><span class="line">                <span class="comment"># 当first=0时有n个元素可以放到first位置</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">                <span class="comment"># first位置放好元素之后，用递归去放first+1位置的元素，它有n-1种取值</span></span><br><span class="line">                back_func(first+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 当将k个位置都放好元素之后函数会return，但别忘了撤销交换操作，</span></span><br><span class="line">                <span class="comment"># 因为此时的first位置还要继续for循环和其它的i位置交换元素</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">        back_func()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">first = <span class="number">0</span></span>):</span></span><br><span class="line">            <span class="comment"># 所有数都填完了</span></span><br><span class="line">            <span class="keyword">if</span> first == n:  </span><br><span class="line">                res.append(nums[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">                <span class="comment"># 动态维护数组</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">                <span class="comment"># 继续递归填下一个数</span></span><br><span class="line">                backtrack(first + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销操作</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, tmp</span>):</span>  <span class="comment"># temp为临时列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 已经选完所有的元素了，可以结束</span></span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="comment"># backtrack函数，确定好递归的终点和当前一步转移到下一步的递归的写法，然后从起点开始调用这个递归函数就行了。</span></span><br><span class="line">                <span class="comment"># nums[:i] + nums[i+1:] 对nums当中除了第i个数之外的数进行遍历</span></span><br><span class="line">                backtrack(nums[:i] + nums[i+<span class="number">1</span>:], tmp + [nums[i]])</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]  <span class="comment"># 记录那些元素已经访问</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">numbers, result, cur, visit</span>):</span></span><br><span class="line">            <span class="keyword">if</span> len(cur) == len(numbers):</span><br><span class="line">                result.append(cur[:])  <span class="comment"># 这里记得用cur[:]或拷贝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">                <span class="keyword">if</span> visit[i]:  <span class="comment"># 如果已经访问过某元素，直接跳过进下一个元素</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(numbers[i])</span><br><span class="line">                visit[i] = <span class="literal">True</span>  <span class="comment"># 将访问过的元素标记</span></span><br><span class="line">                dfs(numbers, result, cur, visit)</span><br><span class="line">                cur.pop()  <span class="comment"># 恢复到之前状态</span></span><br><span class="line">                visit[i] = <span class="literal">False</span>  <span class="comment"># 恢复到之前状态</span></span><br><span class="line"></span><br><span class="line">        dfs(nums, res, [], visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<p>递归</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:  <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            res_nums = nums[:idx] + nums[idx + <span class="number">1</span>:]  <span class="comment"># 确定剩余元素</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.permute(res_nums):  </span><br><span class="line">                res.append([num] + j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<h2 id="组数总和"><a href="#组数总和" class="headerlink" title="组数总和"></a>组数总和</h2><p><strong>给定一个无重复元素的数组&nbsp;candidates&nbsp;和一个目标数&nbsp;target&nbsp;，找出&nbsp;candidates&nbsp;中所有可以使数字和为&nbsp;target&nbsp;的组合。candidates&nbsp;中的数字可以无限制重复被选取。</strong></p>
<p>说明：</p>
<ul>
<li>所有数字（包括&nbsp;target）都是正整数。</li>
<li>解集不能包含重复的组合。&nbsp;<br>示例&nbsp;1：<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
示例&nbsp;2：<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">&nbsp; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">&nbsp; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">&nbsp; [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>思路分析：根据示例 1：输入: candidates = [2, 3, 6, 7]，target = 7。</p>
<p>候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；<br>同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。</p>
<p>先画出树形图，然后编码实现。</p>
<h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h2><p>**序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。**</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。<br>不能有任何辅助信息帮助完成序列化和反序列化。<br>LeetCode的测试方式是事先提供一个二叉树，然后跑一下你的序列化代码，然后将你序列化的返回的字符串作为反序列化的输入，比较还原的二叉树和原始二叉树的序列化结果是否一致，说明你的方法就对了。你事先把结果保存了，比如你在序列化的时候如果保存了 root 为类的成员，<br>然后在反序列化中直接返回存储的 root，<br>这样题目就没有意义了，防止你使用作弊方式来通过测试，</p>
<p>DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。<br>根据根节点、左节点和右节点之间的相对顺序，<br>可以进一步将DFS策略区分为：先序遍历、中序遍历、后序遍历</p>
<p>示例: </p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">你可以将以下二叉树：</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     <span class="string">/</span> <span class="string">\</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      <span class="string">/</span>   <span class="string">\</span></span><br><span class="line">     <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">    <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="string">X</span>   <span class="string">X</span>  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">        <span class="string">/</span> <span class="string">\</span>  <span class="string">/</span> <span class="string">\</span></span><br><span class="line">       <span class="string">X</span>   <span class="string">X</span> <span class="string">X</span>  <span class="string">X</span>       </span><br><span class="line"><span class="string">序列化为</span> <span class="string">"[1,2,None,None,3,4,None,None,5,None,None]"</span></span><br><span class="line"><span class="string">None,None,</span> <span class="string">是用来标记缺少左、右子节点</span></span><br><span class="line"><span class="string">遇到</span> <span class="string">None</span> <span class="string">节点也要翻译成一个符号，反序列化时才知道这里对应</span> <span class="string">None。</span></span><br><span class="line"><span class="string">为使反序列化可行，考虑将越过叶节点后的</span> <span class="literal">null</span> <span class="string">也看作是节点。</span></span><br><span class="line"></span><br><span class="line"><span class="string">在此基础上，对于列表中任意某节点</span> <span class="string">node</span> <span class="string">，</span></span><br><span class="line"><span class="string">其左子节点</span> <span class="string">node.left</span> <span class="string">和右子节点</span> <span class="string">node.right</span> <span class="string">在序列中的位置都是</span> <span class="string">唯一确定</span> <span class="string">的。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>递归遍历一棵树，只需关注当前的根节点就好，它的子树的遍历交给递归完成：</p>
<ul>
<li>“serialize函数，请帮我序列化我的左右子树，我等你的返回结果，再追加到我身上。”</li>
</ul>
</li>
<li><p>选择前序遍历是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。<br>先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。</p>
</li>
</ul>
<p>何反序列化呢？<br>前序遍历的序列化后的字符串呈现这样的排列：<br>“根|(根|(根|左|右)|(根|左|右))|(根|(根|左|右)|(根|左|右))”<br>序列化得到的字符串序列，通过指定分隔符逗号，对字符串进行切片，返回分割后的字符串列表，转化为数组，先序遍历的元素列表<br>然后从左向右遍历dataList列表，依次弹出 dataList 数组的首项，用它构建当前子树的根节点，</p>
<ul>
<li>如果当前的元素(字符)为 ‘X’ ，返回 None，</li>
<li>如果它不为 ‘X’，则为它创建节点，并递归调用 buildTree 构建左右子树，当前子树构建完毕，返回当前子树 </li>
</ul>
<p>时间复杂度O(n)：在序列化和反序列化函数中，我们只访问每个节点一次，其中 n 是节点数，即树的大小。<br>空间复杂度O(n)：在序列化和反序列化函数中，我们递归会使用栈空间</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span> <span class="comment"># 要求转化成字符串格式</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="comment"># 遇到None节点，“翻译”成X                </span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'null,'</span>  <span class="comment"># 字符串类型</span></span><br><span class="line">            <span class="comment"># if root:</span></span><br><span class="line">            <span class="comment"># 左子树的序列化的字符串</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            <span class="comment"># 右子树的序列化的字符串</span></span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            <span class="comment"># 按 根|左|右 顺序拼接</span></span><br><span class="line">            <span class="keyword">return</span> str(root.val) + <span class="string">','</span> + left + right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># 由前序遍历的list，由序列化字符串转成，返回这棵树</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">data</span>):</span></span><br><span class="line">            <span class="comment"># 输入为序列化字符串转成的 list 数组</span></span><br><span class="line">            val = data.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'null'</span>:</span><br><span class="line">                <span class="comment"># 是X，就返回None节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 不是X，则创建节点</span></span><br><span class="line">            node = TreeNode(val)  <span class="comment"># 实例化一个节点</span></span><br><span class="line">            node.left = dfs(data)  <span class="comment"># 构建左子树</span></span><br><span class="line">            node.right = dfs(data)  <span class="comment"># 构建右子树</span></span><br><span class="line">            <span class="keyword">return</span> node  <span class="comment"># 返回当前构建好的子树</span></span><br><span class="line"></span><br><span class="line">        dataList = data.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(dataList)  <span class="comment"># 构建的入口</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然序列化的时候结尾会多出一个逗号，然后反序列化split列表会处理这个逗号，然后正确地建树。最后会多出一个空字符串，但是并没有影响，反序列化的时候就是序列化方式并不唯一，是自己制定的，只要你能按照你序列化的规则再反序列化把树正确地建出来就行。</p>
<p>序列化</p>
<figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = <span class="number">2</span></span><br><span class="line">left = dfs(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"></span><br><span class="line">root = <span class="number">1</span></span><br><span class="line">root =<span class="built_in"> root</span>.right = <span class="number">3</span></span><br><span class="line">right = dfs(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = <span class="number">4</span></span><br><span class="line">left = dfs(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">3</span></span><br><span class="line">root =<span class="built_in"> root</span>.right = <span class="number">5</span></span><br><span class="line">right = dfs(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">'X,'</span></span><br><span class="line">        leftserilized = self.serialize(root.left)</span><br><span class="line">        rightserilized = self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> str(root.val) + <span class="string">','</span> + leftserilized + rightserilized</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        dataList = data.split(<span class="string">','</span>)</span><br><span class="line">        root = self.buildTree(dataList)</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        val = data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">'X'</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        node.left = self.buildTree(data)</span><br><span class="line">        node.right = self.buildTree(data)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></tbody></table></figure>

<p>法三，最快，击败99%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(str(node.val))</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(<span class="string">"#"</span>)</span><br><span class="line"></span><br><span class="line">        vals = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(vals)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            v = next(vals)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="string">"#"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(int(v))</span><br><span class="line">            node.left = dfs()</span><br><span class="line">            node.right = dfs()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        vals = iter(data.split(<span class="string">","</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs()</span><br></pre></td></tr></tbody></table></figure>

<p>BFS 可以按照层次的顺序从上到下遍历所有的节点 利用队列<br>示例: </p>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      /   \</span><br><span class="line">     <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">    / \   /  \</span><br><span class="line">   X   X  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">        / \  / \</span><br><span class="line">       X   X X  X       </span><br><span class="line">序列化为字符串 <span class="string">"[1,2,3,X,X,4,5,X,X,X,X]"</span></span><br><span class="line">X,X, 是用来标记缺少左、右子节点</span><br><span class="line">遇到越过叶节点的 None 节点也要翻译成一个符号，反序列化时才知道这里对应 None。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>算法流程：</p>
<ol>
<li>特例处理： 若 root 为空，则直接返回空列表 “[]” ；</li>
<li>初始化： 队列 queue （包含根节点 root ）；序列化列表 res ；</li>
<li>层序遍历： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>若 node 不为空：<ol>
<li>将它的值推入一个数组 res ，打印字符串 node.val 让子节点 None 也入列，，</li>
<li>将左、右子节点入列 queue ；</li>
</ol>
</li>
<li>否则（若 node 为空）：将 ‘null’ 推入 res 数组，打印字符串 “null” ；</li>
</ol>
</li>
<li>返回值： 拼接列表（用 ‘,’ 隔开，首尾添加中括号）。将它转成字符串，就是序列化字符串。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N + 1 个 null ，总体复杂度为 O(2N + 1) = O(N) 。<br>空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储 (N + 1)/2 个节点（或 N+1 个 null），使用 O(N) ；列表 res 使用 O(N) 。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>除了第一个是根节点的值，其他节点值都是成对的，对应左右子节点。<br>我们用一个指针从第二项开始扫描，每次考察两个节点值。</p>
<p>起初用根节点值构建根节点，并让它入列。<br>让节点出列，考察出列的节点，指针指向的字符是它的左子节点，指针右边的字符是它的右子节点。<br>如果子节点值不为 ‘X’，则为它创建节点，并认父亲，并作为未来的父亲入列。<br>如果子节点值为 ‘X’，什么都不用做。<br>所有的父节点（真实节点）都会在队列里走一遍。</p>
<p>基于本文一开始分析的 “ node, node.left, node.right ” 在序列化列表中的位置关系，可实现反序列化。</p>
<p>利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</p>
<p>算法流程：</p>
<ol>
<li>特例处理： 若 data 为空，直接返回 null ；</li>
<li>初始化： 序列化列表 vals （先去掉首尾中括号，再用逗号隔开），<br>指针 i = 1 ，根节点 root （值为 vals[0] ），队列 queue（包含 root ）；</li>
<li>按层构建： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>构建 node 的左子节点：node.left 的值为 vals[i] ，并将 node.left 入队；</li>
<li>执行 i+=1 ；</li>
<li>构建 node 的右子节点：node.right 的值为 vals[i] ，并将 node.right 入队；</li>
<li>执行 i+=1 ；</li>
</ol>
</li>
<li>返回值： 返回根节点 root 即可。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，按层构建二叉树需要遍历整个 vals ，其长度最大为 2N+1 。<br>空间复杂度 O(N) ： 最差情况下，假如是一颗满二叉树，最后一排空节点个数为2N+1/2，队列 queue 同时存储 (N + 1)/2 个节点，因此使用 O(N) 额外空间。</p>
<p>如果想在去掉多余的null上实现可逆，可以尝试在序列化的最后加一个while loop去掉 null，然后反序列化的时候把输入的‘data’作为queue 来做后续操作（可以节省因为子节点过多而多花费的判断null的时间）</p>
<p>序列化</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">queue = [1]</span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">res = [1]</span><br><span class="line">queue = [2, 3]</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2 </span><br><span class="line">res = [1, 2]</span><br><span class="line">queue = [3, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = 3 </span><br><span class="line">res = [1, 2, 3]</span><br><span class="line">queue = [None, None, 4, 5]</span><br><span class="line"></span><br><span class="line">queue = [None, 4, 5]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, None] </span><br><span class="line"></span><br><span class="line">queue = [4, 5]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, None, None] </span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4] </span><br><span class="line">queue = [5, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = 5</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5] </span><br><span class="line">queue = [None, None, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None, None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = [None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>] </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">','</span>.join(res) + <span class="string">']'</span></span><br><span class="line">        <span class="comment"># res.append(node.val + ","); </span></span><br><span class="line">        <span class="comment"># 可以优化成 res.append(node.val).append(",")。因为拼接字符串可能增大消耗。</span></span><br><span class="line">        <span class="comment"># +号就是把字符串拼接起来的意思，因为中括号是字符串类型，所以要加一个' ', </span></span><br><span class="line">        <span class="comment"># 就和你输出'hello world'一样，输出结果其实并没有' '，你跑一下结果就知道了，就是[1,2,3,null,null,4,5]，那个题目里的引号只是告诉你结果是引号里的东西(是字符串类型，而不是数组类型)，结果就是那串字符 [1,2,3,null,null,4,5] 并不是结果要带引号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> data==<span class="string">'[]'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 去除第一个和最后一个字符串，也就是去掉两个单括号</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        <span class="comment"># TreeNode 的 val 变量是 int 类型</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>]))  <span class="comment"># 实例化一个节点</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                <span class="comment"># 构建左子树</span></span><br><span class="line">                node.left = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                <span class="comment"># 构建右子树</span></span><br><span class="line">                node.right = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p>反序列化</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">'[1, 2, 3, null, null, 4, 5, null, null, null, null]'</span> </span><br><span class="line">print(data, type(data))</span><br><span class="line"><span class="comment"># [1, 2, 3, null, null, 4, 5, null, null, null, null] &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>], type(data[<span class="number">1</span>:<span class="number">-1</span>]))</span><br><span class="line"><span class="comment"># 1, 2, 3, null, null, 4, 5, null, null, null, null &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), type(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>)))</span><br><span class="line"><span class="comment"># ['1', ' 2', ' 3', ' null', ' null', ' 4', ' 5', ' null', ' null', ' null', ' null'] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">'[1,2,3,null,null,4,5,null,null,null,null]'</span> </span><br><span class="line">print(data, type(data))</span><br><span class="line"><span class="comment"># [1,2,3,null,null,4,5,null,null,null,null] &lt;class 'str'&gt; </span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>], type(data[<span class="number">1</span>:<span class="number">-1</span>]))</span><br><span class="line"><span class="comment"># 1,2,3,null,null,4,5,null,null,null,null &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), type(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>)))</span><br><span class="line"><span class="comment"># ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null'] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">a = [<span class="string">'1'</span>, <span class="string">' 2'</span>, <span class="string">' 3'</span>]</span><br><span class="line">b = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">print(type(a[<span class="number">2</span>]), type(b[<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># &lt;class 'str'&gt; &lt;class 'str'&gt;</span></span><br><span class="line">print(a[<span class="number">2</span>], b[<span class="number">2</span>], a[<span class="number">2</span>] == b[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 3 3 False</span></span><br><span class="line">print(a[<span class="number">0</span>], b[<span class="number">0</span>], a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 1 1 True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vals = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>]</span><br><span class="line">type(vals) = &lt;class <span class="string">'list'</span>&gt;</span><br><span class="line"></span><br><span class="line">root = = TreeNode(int(vals[0])) = 1</span><br><span class="line">queue = [1]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">vals[i] 都是 str 类型 i初始值为1</span><br><span class="line">vals[i] = vals[1] = <span class="string">'2'</span></span><br><span class="line">node.left = 2 </span><br><span class="line">queue = [2]</span><br><span class="line">i = 2</span><br><span class="line">vals[i] = vals[2] = <span class="string">'3'</span></span><br><span class="line">node.right = 3</span><br><span class="line">queue = [2, 3]</span><br><span class="line">i = 3</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2</span><br><span class="line">vals[i] = vals[3] = <span class="string">'null'</span></span><br><span class="line">i = 4</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 5</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 3</span><br><span class="line">vals[i] = vals[5] = <span class="string">'4'</span></span><br><span class="line">node.left = 4</span><br><span class="line">queue = [4]</span><br><span class="line">i = 6</span><br><span class="line">vals[i] = vals[6] = <span class="string">'5'</span></span><br><span class="line">node.right = 5</span><br><span class="line">queue = [4，5]</span><br><span class="line">i = 7</span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">vals[i] = vals[7] = <span class="string">'null'</span></span><br><span class="line">i = 8</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 9</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 5</span><br><span class="line">vals[i] = vals[9] = <span class="string">'null'</span></span><br><span class="line">i = 10</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 11</span><br><span class="line"></span><br><span class="line">queue = [] queue为空，结束循环</span><br><span class="line">空子树不用赋值</span><br></pre></td></tr></tbody></table></figure>


<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res += str(node.val) + <span class="string">','</span></span><br><span class="line">                queue.append(node.left)  <span class="comment"># 不管是不是None节点都入列</span></span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 是None节点</span></span><br><span class="line">                res += <span class="string">'X,'</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        data = data.split(<span class="string">','</span>)</span><br><span class="line">        root = TreeNode(data.pop(<span class="number">0</span>))</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                val = data.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'X'</span>:</span><br><span class="line">                    node.left = TreeNode(val)</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                val = data.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'X'</span>:</span><br><span class="line">                    node.right = TreeNode(val)</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>


<p>反序列化</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">data = [1,2,3,None,None,4,5,None,None,None,None]</span><br><span class="line"></span><br><span class="line">data = [2,3,None,None,4,5,None,None,None,None]</span><br><span class="line">root = 1</span><br><span class="line">queue = [1]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">data = [3,None,None,4,5,None,None,None,None]</span><br><span class="line">val = 2</span><br><span class="line">queue = [2]</span><br><span class="line"></span><br><span class="line">data = [None,None,4,5,None,None,None,None]</span><br><span class="line">val = 3</span><br><span class="line">queue = [2, 3]</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2</span><br><span class="line">data = [None,4,5,None,None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [3]</span><br><span class="line"></span><br><span class="line">data = [4,5,None,None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [3]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 3</span><br><span class="line">data = [5,None,None,None,None]</span><br><span class="line">val = 4</span><br><span class="line">queue = [4]</span><br><span class="line"></span><br><span class="line">data = [None,None,None,None]</span><br><span class="line">val = 5</span><br><span class="line">queue = [4, 5]</span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">data = [None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [5]</span><br><span class="line"></span><br><span class="line">data = [None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [5]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 5</span><br><span class="line">data = [None]</span><br><span class="line">val = None</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">val = None</span><br><span class="line">queue = [] queue为空，结束循环</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：</p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-attr">[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span></span><br><span class="line">输出：<span class="selector-attr">[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：</p>
<figure class="highlight smalltalk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="comment">"H"</span>,<span class="comment">"a"</span>,<span class="comment">"n"</span>,<span class="comment">"n"</span>,<span class="comment">"a"</span>,<span class="comment">"h"</span>]</span><br><span class="line">输出：[<span class="comment">"h"</span>,<span class="comment">"a"</span>,<span class="comment">"n"</span>,<span class="comment">"n"</span>,<span class="comment">"a"</span>,<span class="comment">"H"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>（1）使用 list 本身的reverse() 方法</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reversed(s)        <span class="comment"># Python内置reverse()函数可以反转一个可迭代序列</span></span><br><span class="line">&lt;list_reverseiterator object at <span class="number">0x0000014C63AF5CF8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed(s))  <span class="comment"># 强转成list</span></span><br><span class="line">[<span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s                  <span class="comment"># s本身并没有修改</span></span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.reverse()        <span class="comment"># 使用list本身的reverse方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s                  <span class="comment"># s被改为倒序</span></span><br><span class="line">[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]    </span><br></pre></td></tr></tbody></table></figure>

<p>（2）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```s[:]```浅拷贝 表示数组中所有子模块，</span><br><span class="line">```s[:]=s[::-1]```表示将原数组反转后赋值给s中每一个对应的位置</span><br><span class="line">```s=s[::-1]```表示将s反转后赋值给新的对象s（可以通过id函数查看内存地址），与题意原地修改不符。</span><br><span class="line">```py</span><br><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        """</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        """</span><br><span class="line">        s[:]=s[::-1]</span><br></pre></td></tr></tbody></table></figure>

<p>（3）双指针<br>思路与算法<br>对于长度为 N 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 s[0] s[1] s[2] … s[N - 1]，那么反转后字符数组为 s[N - 1] s[N - 2] … s[0]。比较反转前后下标变化很容易得出 s[i] 的字符与 s[N - 1 - i] 的字符发生了交换的规律</p>
<ul>
<li>初始化：left 指向数组第一个元素，right 指向数组最后一个元素，</li>
<li>步骤：<ul>
<li>当 left &lt; right：<ul>
<li>把 left 和 right 指向的元素交换一下，交换s[left]和s[right]对应元素，</li>
<li>left 指针后移，right 指针前移，left+=1,right-=1，</li>
<li>再把它两个交换，以此类推，</li>
</ul>
</li>
<li>当 left &gt;= right<br>直到 left 和 right 相遇指向同一个元素，这样就得到了一个倒序的序列。</li>
</ul>
</li>
<li>时间复杂度：O(N)，其中 N 为字符数组的长度。一共执行了 N/2 次的交换。</li>
<li>空间复杂度：O(1)。只使用了常数空间来存放若干变量。</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[str]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        right = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:   </span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><p><strong>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</strong></p>
<p>示例 1:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">-121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从左向右读,</span> <span class="string">为</span> <span class="number">-121</span> <span class="string">。</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">121</span><span class="bullet">-</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">10</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">01</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></tbody></table></figure>
<p>法一：将整数转为字符串，需要额外的非常量空间来创建问题描述中所不允许的字符串。<br>思路：<br>首先，我们应该处理一些临界情况。负数都不可能是回文，直接返回False，<br>如：’-1 ‘ 的回文是 ‘1-‘只需要，因为 - 不等于 1。所以我们可以对所有负数返回 false。</p>
<p>考虑大于等于 0 的时候，首先把数字转换成一个字符串，这样就非常方便判断。</p>
<p>定义两个指针一个指向第一个元素的首指针和一个指向末尾的尾指针，然后首指针后移，尾指针前移作对比，如果中间有不相等的就返回False，如果没有直到首尾指针相遇说明是一个回文数。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 负数肯定不是回文数</span></span><br><span class="line">        s = str(x)        <span class="comment"># 把x转换成str</span></span><br><span class="line">        beg, end = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> beg &lt; end:          <span class="comment"># s是个位数的时候,end = 0不会执行到 while里</span></span><br><span class="line">            <span class="keyword">if</span> s[beg] == s[end]:</span><br><span class="line">                beg += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isPalindrome(<span class="number">121</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">    print(s.isPalindrome(<span class="number">-1</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">    print(s.isPalindrome(<span class="number">1</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">test()</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (str(x) == str(x)[::<span class="number">-1</span>])</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (x &gt;= <span class="number">0</span>) <span class="keyword">and</span> (x == int(str(x)[::<span class="number">-1</span>]))</span><br></pre></td></tr></tbody></table></figure>


<p>考虑只反转 int 数字的一半</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        s = str(x)</span><br><span class="line">        l = len(s)</span><br><span class="line">        h = l//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[:h] == str(x)[<span class="number">-1</span>:-h<span class="number">-1</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># s = '12321'</span></span><br><span class="line"><span class="comment"># l = 5</span></span><br><span class="line"><span class="comment"># h = 2</span></span><br><span class="line"><span class="comment"># s[:h] = s[:2] = '12'</span></span><br><span class="line"><span class="comment"># str(x)[-1:-h-1:-1] = str(x)[-1:-3:-1] = '12' </span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：不将整数转为字符串，将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。如果真是回文，是不可能溢出的；若非回文，溢出就会成为负数，自然也就跟原数不相等了</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的后一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p>除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p>
<p>步骤</p>
<ul>
<li>每次进行取余操作 （ %10），取出最低的数字：y = x % 10</li>
<li>将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y</li>
<li>每取一个最低位数字，x 都要自除以 10</li>
<li>判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了</li>
<li>最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将revertNum除以 10 以后应该和 x 相等。</li>
</ul>
<p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p>
<p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p>
<p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p>
<p>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。<br>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 特殊情况：</span></span><br><span class="line">        <span class="comment"># 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment"># 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment"># 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment"># 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        revertedNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; revertedNumber:</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment"># 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment"># 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber <span class="keyword">or</span> x == revertedNumber // <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(12321))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(123321))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(-1))  # False</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(0))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(6))  # True</span></span><br><span class="line">    print(obj.isPalindrome(<span class="number">10</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x = 12321 &gt; 0 数字长度为奇数</span></span><br><span class="line"><span class="comment"># revertedNumber = 0 &lt; x </span></span><br><span class="line"><span class="comment"># revertedNumber = revertedNumber * 10 + x % 10</span></span><br><span class="line"><span class="comment"># revertedNumber = 0 * 10 + 12321 % 10 = 1 </span></span><br><span class="line"><span class="comment"># x = x // 10 = 1232 &gt; revertedNumber</span></span><br><span class="line"><span class="comment"># revertedNumber = 1 * 10 + 1232 % 10 = 12</span></span><br><span class="line"><span class="comment"># x = x // 10 = 123 &gt; revertedNumber</span></span><br><span class="line"><span class="comment"># revertedNumber = 12 * 10 + 123 % 10 = 123</span></span><br><span class="line"><span class="comment"># x = x // 10 = 12 &lt; revertedNumber</span></span><br><span class="line"><span class="comment"># x = 12 = revertedNumber // 10 = 123 // 10</span></span><br><span class="line"><span class="comment"># return True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x = 123321 &gt; 0 数字长度为偶数</span></span><br><span class="line"><span class="comment"># revertedNumber = 0 &lt; x </span></span><br><span class="line"><span class="comment"># revertedNumber = revertedNumber * 10 + x % 10</span></span><br><span class="line"><span class="comment"># revertedNumber = 0 * 10 + 123321 % 10 = 1 </span></span><br><span class="line"><span class="comment"># x = x // 10 = 12332 &gt; revertedNumber</span></span><br><span class="line"><span class="comment"># revertedNumber = 1 * 10 + 12332 % 10 = 12</span></span><br><span class="line"><span class="comment"># x = x // 10 = 1233 &gt; revertedNumber</span></span><br><span class="line"><span class="comment"># revertedNumber = 12 * 10 + 1233 % 10 = 123</span></span><br><span class="line"><span class="comment"># x = x // 10 = 123 = revertedNumber</span></span><br><span class="line"><span class="comment"># return True</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/jian-zhi-offer1-24-ti/" class="post-title-link" itemprop="url">剑指offer1~24题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-31 11:35:55" itemprop="dateModified" datetime="2021-05-31T11:35:55Z">2021-05-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>熟练度，一个题目默写5遍</p>
<p>任何逻辑都先写特殊情况，然后再一般<br>程序=算法+数据结构<br>系统=服务+存储。</p>
<p>脚本类语言的特殊性:如JS, Python等可以用来学习算法原理，但是不适于用来考察性能。<br>因为具体的执行是在解释器上执行的，所以代码的执行效率在很多时候是依靠解释器的实现方式，<br>解释器可能会对语言的内部的某一些函数做一些底层的优化，导致如果添加一些逻辑上的优化反而使得底层的优化失效了，最终整个代码的执行效率变低了</p>
<p>单独的return要怎么理解呢，无返回值 void 类型函数， 需要 return 提前终止~ 由于是无返回值函数，因此无需返回任何变量~</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span>(not [])  <span class="meta"># 返回一个布尔值</span></span><br><span class="line"><span class="keyword">print</span>([] == None)  <span class="meta"># False</span></span><br></pre></td></tr></tbody></table></figure>
<p>力扣后台已经帮你定义好 TreeNode 这个类啦，就是默认代码那个被注释掉的部分，在本地你需要把那个树节点的类写上<br>每个节点是 O(1)，总节点数是 O(n) </p>
<p>ListNode这个是类，ListNode(i)实际上是类的实例化，它创建了一个对象，调用了initialization这个初始化函数<br>int(i)倒是直接将i的类型进行改变。</p>
<p>root 是 节点，是一个类的实例；root.val 是此节点的值；<br>[root] 是向当前列表添加一个子列表，子列表包含 root 节点</p>
<p>动态规划与分治的区别：前者自底向上，后者自顶向下</p>
<p>log n 一般和二叉树的高度相关，<br>例如：二叉搜索树的平均查找时间复杂度为 O(log n) 。<br>而树的遍历，一般都是 O(N) 复杂度，<br>例如先序遍历，每开启一个递归函数 遍历到一个节点，而树节点为 N ， 因此复杂度为 O(N)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ListNode(0) 建立一个值为 0 ListNode 类型的变量的节点实例，开辟结点的内存空间，</span></span><br><span class="line"><span class="comment"># 变量 node 引用指向 “节点实例”地址 </span></span><br><span class="line">node = ListNode(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判断时间复杂度判断占用时间"><a href="#判断时间复杂度判断占用时间" class="headerlink" title="判断时间复杂度判断占用时间"></a>判断时间复杂度判断占用时间</h3><ul>
<li>确定问题规模n</li>
<li>循环减半过程 –&gt; logn</li>
<li>K层关于n的循环 —&gt;nk<br>复杂情况：根据算法执行过程判断</li>
</ul>
<h3 id="判断空间复杂度"><a href="#判断空间复杂度" class="headerlink" title="判断空间复杂度"></a>判断空间复杂度</h3><p>评估算法内存占用大小的式子，表达方式与时间复杂度完全一样</p>
<ul>
<li>使用了几个变量：O(1)</li>
<li>使用了长度为n的一维列表：O(n)</li>
<li>使用了m行n列的二维列表：O(mn)</li>
</ul>
<p>算法（Algorithm）：是指解题方案的准确而完整的描述，<br>是一系列解决问题的清明确指令步骤，<br>算法代表着用系统的方法描述解决问题的策略机制。<br>能够对一定规范的输入，在有限时间内获得所要求的输出。<br>算法的实现是指将指令步骤序列转化成计算机能够执行的计算机程序。<br>而这个转化过程就叫计算机编程。</p>
<p>数据结构（Data Structures）：是计算机存储和组织数据的一种方式，可以用来高效地处理数据。<br>举个例子：二分查找就是一个非常经典的算法，而二分查找经常需要作用在一个有序数组上。<br>这里二分就是一种折半的算法思想，<br>很多算法需要特定的数据结构来实现，所以经常把它们放到一块讲。</p>
<p>抽象数据类型(Abstract Data Type)<br>ADT<br>指一个数学模型以及定义在此数学模型上的一组操作。<br>即把数据类型和数据类型上的运算捆在一起，进行封装。<br>引入抽象数据类型的目的是<br>把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。<br>我们自定义的 ADT 必须要有一个实现，<br>而实现 ADT 时我们所做出的选择会影响实现的功能和效率。<br>数据结构可以通过以下两方面来描述：<br>它们如何存储和组织单个数据元素<br>提供哪些操作来存取和处理其上的数据</p>
<p>有很多常用的数据结构，如链表、堆、栈，队列，树等。<br>所有的数据结构都会存储一组数据值，<br>但对于如何组织单个数据项和提供哪些操作来处理数据集上有区别。<br>实现 ADT 时，需要根据具体问题来选择具体的数据结构。<br>例如，实现打印队列最好选择 queue 数据结构，而 B-Tree 适合数据库索引。</p>
<p>实际上，在真正的项目开发中，大部分时间都是<br>从数据库取数据 -&gt; 数据操作和结构化 -&gt; 返回给前端，<br>在数据操作过程中需要合理地抽象， 组织、处理数据，<br>如果选用了错误的数据结构，就会造成代码运行低效。<br>这也是我们需要学习算法和数据结构的原因。</p>
<p>实现新的数据类型时，我们将使用 python 的 class 实现，它包含属性和方法。<br>属性一般是使用某种特定的数据类型，<br>而方法一般是对属性的操作。 </p>
<p>ADT: Abstract Data Type，抽象数据类型，<br>我们在组合已有的数据结构来实现一种新的数据类型，<br>定义的数据类型，它指定了一组数据值的集合及可作用在这些数据值上的一组操作。<br>ADT 的定义与它的具体实现无关，因此我们可以只关注如何使用它，而无需关注它的具体实现。</p>
<p>ADT 可被看作为一个黑盒子。用户程序与 ADT 实例的交互是通过调用定义在 ADT 接口上的操作进行的。这些操作集可分为 4 类：</p>
<p>Constructors: 创建和初始化 ADT 的实例<br>Accessors: 返回实例中的数据，而不进行修改<br>Mutators: 修改 ADT 实例的内容<br>Iterators: 逐个处理单个数据组件</p>
<p>我们以抽象一个背包(Bag) 数据类型来说明，<br>背包是一种容器类型，我们可以给它添加东西，也可以移除东西，<br>并且我们想知道背包里 有多少东西。<br>于是我们可以定义一个新的数据类型叫做 Bag.</p>
<hr>
<h2 id="1-两个栈实现一个队列：-本题考点-队列-栈"><a href="#1-两个栈实现一个队列：-本题考点-队列-栈" class="headerlink" title="1. 两个栈实现一个队列：[^本题考点 队列 栈]"></a>1. 两个栈实现一个队列：[^本题考点 队列 栈]</h2><p><strong>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )。队列中的元素为int类型。</strong></p>
<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ul>
<li>栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。</li>
<li>双栈可实现列表倒序： 设有含三个元素的栈 A = [1,2,3] 和空栈 B = []。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A = [] , B = [3,2,1] ，即 栈 B 元素实现栈 A 元素倒序 。</li>
<li>利用栈 B 删除队首元素： 倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。</li>
</ul>
<h4 id="函数设计："><a href="#函数设计：" class="headerlink" title="函数设计："></a>函数设计：</h4><p>题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p>
<ul>
<li><p>加入队尾 appendTail()函数： 将数字 val 只需要向栈a加入。</p>
</li>
<li><p>删除队首deleteHead()函数： B里面的肯定是先进到A的，所以即便添加删除轮着来，也是先删完B，才会把A的放入B。如果队列（即双栈）中有元素，那么一定是在 栈 B 中。因此要先判断栈 B 是否为空~有以下三种情况。</p>
<ol>
<li>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</li>
<li>否则，当 A 也为空： 即两个栈都为空，无元素，因此返回 −1 。</li>
<li>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</li>
</ol>
</li>
</ul>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>由于问题特殊，以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况。</p>
<ul>
<li><p>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。 ；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 B 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
</li>
<li><p>空间复杂度 O(N) ： 最差情况下，栈 A 和 B 共存储已有的 N 个元素。</p>
</li>
</ul>
<p>一个 [] 既可以当栈、也可以当队列，当然自己写一个栈类也是可以的~<br>题目的本意应该是让我们使用 先进后出 实现 先进先出 ，而不是考察对某一集合框架的具体使用。无论用什么集合框架，都只能当作“栈”来看待，把 [] 看作栈来使用~</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># 本地测试代码</span></span><br><span class="line">    q = CQueue()</span><br><span class="line">    q.appendTail(<span class="number">1</span>)</span><br><span class="line">    q.appendTail(<span class="number">2</span>)</span><br><span class="line">    q.appendTail(<span class="number">3</span>)</span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 1</span></span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 2</span></span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="string">'''自己实现栈结构，先进后出'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.items = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span>  <span class="comment"># 返回栈顶值，双端队列右边作为栈顶</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="string">'''使用栈实现队列操作'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1 = Stack()</span><br><span class="line">        self.s2 = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1.push(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2.empty():  <span class="comment"># 只要栈s2不为空直接返回栈s2中元素</span></span><br><span class="line">            <span class="keyword">return</span> self.s2.pop()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():  <span class="comment"># 只要栈s1不为空，将栈s1的元素转到s2中</span></span><br><span class="line">            val = self.s1.pop()</span><br><span class="line">            self.s2.push(val)</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2.empty():  <span class="comment"># 只要栈s2不为空直接返回栈s2中栈顶元素</span></span><br><span class="line">            <span class="keyword">return</span> self.s2.top()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">            val = self.s1.pop()</span><br><span class="line">            self.s2.push(val)</span><br><span class="line">        <span class="keyword">return</span> self.s2.top()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.s1.empty() <span class="keyword">and</span> self.s2.empty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># 我自己写的本地测试代码，可以不要</span></span><br><span class="line">    q = MyQueue()</span><br><span class="line">    q.push(<span class="number">1</span>)</span><br><span class="line">    q.push(<span class="number">2</span>)</span><br><span class="line">    q.push(<span class="number">3</span>)</span><br><span class="line">    print(q.pop())  <span class="comment"># 1</span></span><br><span class="line">    print(q.pop())  <span class="comment"># 2</span></span><br><span class="line">    print(q.pop())  <span class="comment"># 3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p><strong>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</strong><br>返回删除后的链表的头节点。<br>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<p>面试题13：在O（1）时间删除链表结点<br>题目：给定单向链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该结点。<br>链表结点与函数的定义如下：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, next=None</span>):</span></span><br><span class="line">        self.val, self.next = val, next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, headnode, target_node</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        传统方法是从头遍历到要删除的节点，然后让前一个节点指向下一个节点。</span></span><br><span class="line"><span class="string">        思路：把下一个节点节点复制到当前节点就好了。但是要注意只有一个节点的情况</span></span><br><span class="line"><span class="string">        - 链表只有一个节点</span></span><br><span class="line"><span class="string">        - 链表有多个节点并且不是尾节点</span></span><br><span class="line"><span class="string">        - 链表有多个节点并且是尾节点（此时不存在下一个节点了，需要从头遍历）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headnode <span class="keyword">or</span> <span class="keyword">not</span> target_node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target_node.next:</span><br><span class="line">            next_node = target_node.next</span><br><span class="line">            target_node.next = next_node.next</span><br><span class="line">            target_node.val = next_node.val</span><br><span class="line">            <span class="keyword">del</span> next_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> target_node == headnode:</span><br><span class="line">            headnode.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">del</span> target_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># O(n) 删除</span></span><br><span class="line">            cur_node = headnode</span><br><span class="line">            <span class="keyword">while</span> cur_node:</span><br><span class="line">                <span class="keyword">if</span> cur_node.next == target_node:</span><br><span class="line">                    cur_node.next = target_node.next</span><br><span class="line">                    <span class="keyword">del</span> target_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur_node = cur_node.next</span><br></pre></td></tr></tbody></table></figure>

<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可表示为：4 -&gt; 5 -&gt;1 -&gt;9</p>
<p>输入: head = [4,5,1,9], node = 5</p>
<p>输出: [4,1,9]</p>
<p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>说明:<br>链表至少包含两个节点。</p>
<p>链表中所有节点的值都是唯一的。</p>
<p>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</p>
<p>不要从你的函数中返回任何结果。</p>
<p>思路：<br>输入只有一个要删除的节点，无法知道前一个节点。</p>
<p>4 -&gt; 5 -&gt;1 -&gt;9，当我们知道 5 这个节点时，下一个节点 5.next 就知道是 1，下下个节点 9 就是 5.next.next。既然不能直接删除5这个节点，可以让 5 这个值替换成 下一个节点1值，然后可以让 5.next直接指向 9。这样就实现类似删除功能。</p>
<p>由此的可知 5（node），1（node.next），9（node.next.next）</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        也可以类似这样理解node.next在等号右边就是个节点，左边就是个指针。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nextnode = node.next            <span class="comment"># 获取下一个结点</span></span><br><span class="line">        after_nextnode = node.next.next  <span class="comment"># 获取下下个结点</span></span><br><span class="line">        node.val = nextnode.val       <span class="comment"># 当前结点值覆盖为下一个结点的值</span></span><br><span class="line">        node.next = after_nextnode    <span class="comment"># 当前的节点next指向下下个结点</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分查找法-分为整数和浮点数"><a href="#二分查找法-分为整数和浮点数" class="headerlink" title="二分查找法 分为整数和浮点数"></a>二分查找法 分为整数和浮点数</h3><p>适用于<br>1.数据量较大时，但是数据需要先排好顺序<br>2.顺序存储。<br>原因：1.通过下标即可得到关键字<br>2.任取一个关键字的值即可确定所寻找关键字是在它前面还是后面<br>主要思想是：（设查找的数组区间为array[low, high]）<br>（1）确定该区间的中间位置mid<br>（2）将查找的值T与array[mid]比较。若相等，查找成功返回此位置；<br>否则确定新的查找区域，继续二分查找。<br>区域确定如下：</p>
<ul>
<li>a.array[mid]&gt;T 由数组的有序性可知array[mid,mid+1,……,right]&gt;T，故新的区间为array[left,……，mid-1]</li>
<li>b.array[mid]&lt;T 类似上面查找区间为array[mid+1,……，right]。<br>每一次查找与中间值比较，可以确定是否查找成功，不成功当前收缩左边界或右边界，查找区间将缩小一半，递归查找即可。</li>
</ul>
<p>一般二分查找：left=mid+1 right=mid-1<br>原因：确定mid所指元素并非査找元素</p>
<p>把数组内的数据一分为二，然后计算出中间数据的 索引值。</p>
<p>先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，<br>如果相等那么就返回，如果不相等，那么就继续判断。<br>如果说我们找到的 array[mid] 小于  target 这个数;<br>那么 就说明 我们要查找的数在右侧的一半数据中，<br>那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，<br>而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。<br>如果说我们找到的 array[mid]  大于 target 这个数 ，<br>那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，<br>为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。</p>
<p>二分查找中的小技巧<br><code>mid = (left + right) &gt;&gt; 1</code><br><code>mid = left + (right - left) // 2</code> 而不是 <code>(high + low) // 2</code><br>如果left和right很大的话可能会造成溢出越界，使用减法避免了溢出发生<br>除法没有移位的快<br>向右 移一位， 它就相当于 除以2<br>101 = 5 =&gt; 10 = 2<br>1100 = 12 =&gt; 110 = 6</p>
<p>时间复杂度为:<code>O(logn)</code><br>1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)<br>所以T(n)=O(log2n) =O(logn)<br>2.最好情况查找中间元素O(1)查找的元素即为中间元素<br>（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）<br>空间复杂度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">array, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(array) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果中间的数等于我们要找的数，那么就返回。</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># 如果说中间的数 &lt; 目标的数</span></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">            <span class="comment"># 目标的数在右侧，所以左侧取值的索引需要改变为中间的索引+1</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果说中间的数 &gt; 目标的数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 目标的数在左侧，所以左侧取值的索引需要改变为中间的索引-1</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元素索引值</span></span><br><span class="line">    <span class="comment"># 正常值，包含有和无两种结果</span></span><br><span class="line">    print(binary_search([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">5</span>))  <span class="comment"># 2</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>))  <span class="comment"># None</span></span><br><span class="line">    <span class="comment"># 边界值</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>))  <span class="comment"># 0</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>], <span class="number">0</span>))  <span class="comment"># 0</span></span><br><span class="line">    <span class="comment"># 异常值</span></span><br><span class="line">    print(binary_search([], <span class="number">1</span>))  <span class="comment"># None</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="2-旋转数组的最小数字-本题考点-查找"><a href="#2-旋转数组的最小数字-本题考点-查找" class="headerlink" title="2. 旋转数组的最小数字 [^本题考点 查找]"></a>2. 旋转数组的最小数字 [^本题考点 查找]</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p>
<p>输入一个递增排序的数组的一个旋转 ，即输入的是旋转，不是递增数组。<br>旋转后的数组局部有序的，实际上可以划分为两个排序的子数组，<br>{3,4,5,1,2}其中前半部分{3,4,5}和后半部分{1,2}都为非减数组，</p>
<p>前面子数组的任一元素都大于或者等于后面子数组的任一元素。</p>
<p>最小的元素是既小于左边的数又小于右边的数，右排序数组 的首个元素 </p>
<p>由于给定的数组是有序的，我们就可以使用二分搜索。<br>然而，数组被旋转了，所以简单的使用二分搜索并不可行。<br>在这个问题中，我们使用一种改进的二分搜索，判断条件与标准的二分搜索有些不同。<br>我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？<br>如果数组没有被旋转，是升序排列，就满足 last element &gt; first element</p>
<p>思考： 是否可以用 numbers[m] 和 numbers[left] 比较做代替？<br>解析： 不可以。因为做比较的目的是判断 mid 在哪个排序数组中。<br>但在 numbers[mid] &gt; numbers[left]情况下，<br>无法判断 m 在哪个排序数组中。<br>本质是因为 right 初始值肯定在右排序数组中；<br>left 初始值无法确定在哪个排序数组中，也就不能确定最小值的位置范围。<br>示例： 当 left = 0, right = 4, mid = 2时，<br>有 numbers[mid] &gt; numbers[left] ，以下两示例得出不同结果。<br>numbers = [1, 2, 3, 4 ,5]   3 4 5 1 2<br>旋转点 min = 0，则 mid 在右排序数组（此示例只有右排序数组）；<br>numbers = [3, 4, 5, 1 ,2]   1 2 3 4 5<br>旋转点 min = 3，则 mid 在左排序数组。</p>
<p>mid = left + (right - left) / 2整数除法是向下取整的```除，mid更靠近left，<br>再结合while循环的条件left &lt; right，索引号<br>mid= (left+right)/2 &gt; (left+left)/2= left，<br>mid= (left+right)/2 &lt; (right+right)/2 = right，索引从0开始，<br>即在while循环内，mid始终小于right。<br>因此在while循环内，nums[mid]要么大于要么小于nums[right]，不会等于。<br>这样else {right = mid;}这句判断可以改为更精确的<br>else if (nums[mid] &lt; nums[right]) {right = mid;}。</p>
<p>[0][1][2][3]<br>1234 说的不是具体的值2&lt;2.5，而是索引号1小于3<br>mid &lt; right</p>
<ul>
<li>循环二分</li>
</ul>
<p>1.若中间索引对应的值大于右侧索引的值，最小值在中间值右侧，34512<br>左半部分一定是有序的，中间数mid在前半个非递减数组，<br>mid肯定不是最小值 left = mid + 1<br>假如最小值在左边，那么在非递减数组中间值就不会大于右边<br>2.若中间索引对应的值小于右侧索引的值，最小值在中间值左侧 45123<br>右半部分一定是有序的，中间数位于后半个非递减数组中，<br>mid有可能是最小值 right = mid<br>假如最小值在右边， 53214，那么不能构成非递减 </p>
<p>在rotateArray[mid]==rotateArray[right]时,<br>1.无法判定 m 在左（右）排序数组，<br>即无法判断旋转点 x 在 [left, m] 还是 [m + 1, right] 区间中。：<br>设以下两个旋转点值为 0 的示例数组，<br>则当 left = 0, right = 4 时 m = 2，两示例结果不同。<br>例 [1, 0, 1, 1, 1] ：旋转点 x = 1 ，因此 m = 2 在 右排序数组 中。<br>例 [1, 1, 1, 0, 1] ：旋转点 x = 3 ，因此 m = 2 在 左排序数组 中。</p>
<p>2.right = right - 1 一个个往前去遍历，复杂度跟直接遍历没差别<br>分析:<br>只需证明每次执行此操作后，旋转点 x 仍在 [left, right] 区间内即可。<br>删除的最后这个元素（下标j），在删除后的区间仍存在，所以不会删除掉旋转点x。<br>简单的说，因为相等，所以删掉一个留下一个，我们在剩下区间搜索，仍可以搜索到删除的那个元素值。</p>
<p>有重复，暴力地从右到左进行遍历，right mid往左移动一位<br>为什么rght-不会对结果产生影响?<br>-产生影响条件：删除的元素为唯一最小元素<br>-执行条件: numbers[right]= numbers[mid]<br>矛盾</p>
<p>返回值<br>如果输入数组多于一个数，循环到最后，会只剩两个数，<br>nums[left] == nums[mid]，以及nums[right]，这里的位置left == mid == right - 1。<br>如果nums[left] == nums[mid] &gt; nums[right]，则左边大、右边小，<br>需要执行left = mid + 1，使得left == right，左右边界位置重合，二分循环结束，nums[left]与nums[right]都保存了最小值。</p>
<p>如果nums[left] == nums[mid] &lt; nums[right]，则左边小、右边大，<br>会执行right = mid，使得left == right，左右边界位置重合，二分循环结束，nums[left]、nums[mid]、nums[right]都保存了最小值。</p>
<p>如果数组只有一个数，左右边界位置重合，left == right，不会进入while跳出二分循环，最小值输出nums[left]或nums[right]均可<br>返回值 numbers[left] 等于旋转点值 numbers[min] ；<br>但在少数特例下 left 不是旋转点 min 。<br>本题目只要求返回 “旋转点的值” ，因此本方法可行。</p>
<p>时间复杂度 O(log_2 N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。<br>空间复杂度 O(1) ： left , right , mid 指针使用常数大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        <span class="comment"># 时间复杂度O(n)</span></span><br><span class="line">        <span class="comment"># minNum = 0</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(rotateArray)):</span></span><br><span class="line">        <span class="comment">#     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># return minNum</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时间复杂度O(logn) 对数级别 </span></span><br><span class="line">        <span class="comment"># 若数组大小为0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="comment"># 返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 左侧索引</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 右侧索引</span></span><br><span class="line">        right = len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当左侧索引小于右侧索引时循环</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 直至left&gt;right结束。</span></span><br><span class="line">            <span class="comment"># 中间值为左侧索引和右侧索引求和再除以2，向下取整</span></span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># low + (high - low) // 2 而不是 (high + low) // 2</span></span><br><span class="line">            <span class="comment"># 若中间索引对应的值小于它左侧一个的值，即为要取得值</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &lt; rotateArray[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 返最小标值</span></span><br><span class="line">                <span class="keyword">return</span> rotateArray[mid]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                <span class="comment"># 将右侧索引置为中间索引-1</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># if(rotateArray[mid] &gt; rotateArray[left])</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将左侧索引置为中间索引+1</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>输入一个非减排序的数组的一个旋转，输入为非减排序的数组，即非严格递增的序列，存在重复值，<br>如{1,2,3,3,4,5},旋转后可以是{3,4,5,1,2,3}。<br>输出最小元素。<br>对于未旋转的非减排序array应该有array[start]&lt;array[end]的情况，<br>因此，亦满足array[mid]&lt;array[end];<br>在经过旋转后的rotateArray，<br>满足局部非严格递增，则可以根据rotateArray[mid]&lt;rotateArray[end]<br>初步判断最小值在start-mid之间；<br>否则最小值在mid-end之间。<br>因为存在重复元素，</p>
<p>其他情况对根据需要更新start、mid和end即可，直至start&gt;end结束。<br>可以想到使用二分查找来解决会优化线性查找的性能。<br>没有具体的值用来比较。<br>设置三个指针，left,right,mid。中间值和高低位进行比较，<br>目的：当进行一次比较时，一定能够确定目标值在mid的某一侧。<br>看处于递增还是递减序列，不管是移动第一个还是第二个指针，查找范围都会缩小到原来的一般，<br>接下来再用更新之后的两个指针重复做新一轮的查找。</p>
<p>第一个指针总是指向前面递增数组的元素，<br>而第二个指针总是指向后面递增数组的元素。<br>最终第一个指针将指向前面子数组的最后一个元素，<br>而第二个指针则会指向后面子数组的第一个元素。<br>也就是她们最终会指向两个相邻的元素，<br>而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。    </p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def minArray(self, numbers: List[int]) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[pivot] &lt; numbers[high]:</span><br><span class="line">                high = pivot</span><br><span class="line">            <span class="keyword">elif</span> numbers[pivot] &gt; numbers[high]:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></tbody></table></figure>

<p>转换思路，比较mid与left是先找最大值，最大值偏右，</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def findMin(self, nums: List[int]) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span>   </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:          </span><br><span class="line">            mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>           <span class="comment"># 先加一再除，mid更靠近右边的right     </span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[mid]:         </span><br><span class="line">                left = mid                          <span class="comment"># 向右移动左边界</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &gt; nums[mid]:       </span><br><span class="line">                right = mid - <span class="number">1</span>                     <span class="comment"># 向左移动右边界</span></span><br><span class="line">        <span class="keyword">return</span> nums[(right + <span class="number">1</span>) % len(nums)]        <span class="comment"># 最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="数组：是有序的元素序列。"><a href="#数组：是有序的元素序列。" class="headerlink" title="数组：是有序的元素序列。"></a>数组：是有序的元素序列。</h5><p>[1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。<br>组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。<br>用于区分数组的各个元素的数字编号称为下标。 [1]<br>这些无序排列的同类数据元素的集合称为数组。*</p>
<p>例如：</p>
<p>int (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。<br>a(0)             a(1)          a(2)</p>
<p>数组与python中的 列表比较相似， 用索引去查找。<br>数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。<br>数组还和元组比较像，元组是初始化后，长度指定了就不可以变。<br>但是元组在初始化时给的值，确定了以后就不可以变了。<br>所以可以理解为数组与list 列表很相似。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = ((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">print(len(A))  <span class="comment"># 4，二维元组的行数</span></span><br><span class="line">print(A[<span class="number">0</span>])  <span class="comment"># (1, 1, 1)</span></span><br><span class="line">print(A[<span class="number">1</span>])  <span class="comment"># (2, 2, 2)</span></span><br><span class="line">print(A[<span class="number">2</span>])  <span class="comment"># (3, 3, 3)</span></span><br><span class="line">print(len(A[<span class="number">0</span>]))  <span class="comment"># 3 二维元组的列数</span></span><br></pre></td></tr></tbody></table></figure>

<p>多维，每一维长度应该是len(A[i])</p>
<hr>
<h2 id="3-在二维数组中的查找-本题考点-查找"><a href="#3-在二维数组中的查找-本题考点-查找" class="headerlink" title="3.在二维数组中的查找[^本题考点 查找]"></a>3.在二维数组中的查找[^本题考点 <em>查找</em>]</h2><p><strong>在一个二维有序数组中（每个一维数组的长度相同），<br>每一行都按照从左到右递增的顺序排序，<br>每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">self, target, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 1 2 3 4</span></span><br><span class="line">        <span class="comment"># 3 4 5 6</span></span><br><span class="line">        <span class="comment"># 4 6 8 10</span></span><br><span class="line">        <span class="comment"># 9 11 13 15</span></span><br><span class="line">        <span class="comment"># 方法1: 暴力算法</span></span><br><span class="line">        <span class="comment"># 直接遍历一遍数组，即可判断目标target是否存在</span></span><br><span class="line">        <span class="comment"># 时间复杂度 o(n**n)，因为最坏情况下，数组中的元素都需要遍历一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(len(array)):  # 横</span></span><br><span class="line">        <span class="comment">#     for j in range(len(array[i])):  # 竖</span></span><br><span class="line">        <span class="comment">#         if target == array[i][j]:</span></span><br><span class="line">        <span class="comment">#             return True</span></span><br><span class="line">        <span class="comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择右上角的数字</span></span><br><span class="line">        <span class="comment"># 为什么不从左上角开始搜寻，左上角向右和向下都是递增，</span></span><br><span class="line">        <span class="comment"># 那么对于一个点，对于向右和向下会产生一个岔路</span></span><br><span class="line">        <span class="comment"># 无法确定下一次二分应该往哪边分，由此无法进行二分下去。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果我们找个位置，每次都能确定的往哪个部分二分，即可达到我们想要的结果。</span></span><br><span class="line">        <span class="comment"># 如果我们选择从右上脚开始搜寻的话，         </span></span><br><span class="line">        <span class="comment"># 右上角的值是这一行的最大数，是这一列的最小数。     </span></span><br><span class="line">        <span class="comment"># 向下数字递增，向左数字递减，</span></span><br><span class="line">        <span class="comment"># 当要查找数字比右上角数字小时，左移，剔除这个数字所在的列</span></span><br><span class="line">        <span class="comment"># 要查找数字比右上角数字大时，下移，剔除这个数字所在的行。</span></span><br><span class="line">        <span class="comment"># 这样每次能比较一行或者一列，每一步都可以剔除一行或一列，查找的速度比较快。</span></span><br><span class="line">        <span class="comment"># 当然也可以选择左下角的数字，思路同上。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时间复杂度</span></span><br><span class="line">        <span class="comment"># 时间复杂度：O(m+n) ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</span></span><br><span class="line">        <span class="comment"># 这个二维数组的长度是多少，也就是说这个数组有几行；</span></span><br><span class="line">        row_count = len(array)</span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 初始行号</span></span><br><span class="line">        <span class="comment"># 这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列</span></span><br><span class="line">        column_count = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 给j 一个值，序号从0开始，就是数组列数的值-1，即为j 的最大值。</span></span><br><span class="line">        j = len(array[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 初始列号</span></span><br><span class="line">        <span class="comment"># 循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; row_count <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 根据两个索引下标可以取到 对应的在数组中的值</span></span><br><span class="line">            value = array[i][j]</span><br><span class="line">            <span class="comment"># 如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回True。</span></span><br><span class="line">            <span class="keyword">if</span> value == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，</span></span><br><span class="line">            <span class="comment"># 因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，</span></span><br><span class="line">            <span class="comment"># 给它减-1，找前一列的数做比较</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; value:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果说取到的值 &lt; 我们的目标值。</span></span><br><span class="line">            <span class="comment"># 那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，</span></span><br><span class="line">            <span class="comment"># 这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="4-包含min-函数的栈-本题考点-栈"><a href="#4-包含min-函数的栈-本题考点-栈" class="headerlink" title="4.包含min 函数的栈[^本题考点 栈]"></a>4.包含min 函数的栈[^本题考点 <em>栈</em>]</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数<br>（时间复杂度应为O（1））。</strong></p>
<p>普通栈的 push() 和 pop() 函数的复杂度为 O(1)；<br>而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)。<br>原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗</p>
<p>第一种方法：辅助栈和数据栈不同步，不考虑两个栈的长度必须要保持一致<br>将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现；</p>
<ul>
<li>数据栈 A ： 栈 A ,用于栈的正常操作 存储所有元素，<br>保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</li>
<li>辅助栈 B ： 非严格的单调栈<br>则栈 A 中的最小元素始终对应栈 B 的栈顶元素，<br>只记录从大到小的顺序元素，<br>B等价于遍历stack所有元素，把升序的数字都删除掉，<br>储栈 A 中所有 非严格降序 的元素，<br>每当pop()这些降序元素，B会将相应的栈顶元素pop()出去，<br>保证其栈顶元素始终是stack中的最小元素。<br>min() 函数只需返回栈 B 的栈顶元素获取最小值，即可实现 O(1) 复杂度。</li>
</ul>
<p>函数设计：</p>
<ul>
<li>push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。<br>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空<br>或<br>② x 小于等于 栈 B 的栈顶元素，<br>则将 x 压入栈 B （即 B.add(x) ），即更新了栈顶最小值；</li>
</ul>
<p>假设先后 push 两个相等的最小数字 x ，此时栈 A 最小数字为 x （且有两个 x ）。<br>若使用“小于”作为判断条件，那么此时栈 B 中只有一个最小数字 x 。<br>此时，执行 pop() ，栈 A 会弹出一个最小数字 x ，还留有一个最小数字 x ；<br>栈 B 也弹出了 x ，但栈 B 栈顶元素不是 x 了，<br>此时执行 <code>min()</code> 函数就会判断出错。</p>
<ul>
<li><p>pop() 函数： 重点为保持栈 A,B 的 元素一致性 。<br>执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</p>
</li>
<li><p>top() 函数： 直接返回栈 A 的栈顶元素</p>
</li>
<li><p>min() 函数： 直接返回栈 B 的栈顶元素</p>
</li>
</ul>
<p>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。<br>不论数据规模多大，都只有有限个步骤，<br>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="comment"># 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def push(self, node: int) -&gt; None:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.A.append(node)</span><br><span class="line">        <span class="comment"># B非空，True, not True =False,</span></span><br><span class="line">        <span class="comment"># B空，False, not False =True,直接加元素</span></span><br><span class="line">        <span class="comment"># B最后一个元素小于node，</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= node:</span><br><span class="line">            self.B.append(node)</span><br><span class="line">        <span class="comment"># if self.B:</span></span><br><span class="line">            <span class="comment"># if node &lt;= self.B[-1]:</span></span><br><span class="line">                <span class="comment"># self.B.append(node)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">            <span class="comment"># self.B.append(node)</span></span><br><span class="line">        <span class="comment"># ##############错误代码##################</span></span><br><span class="line">        <span class="comment"># if not self.B:</span></span><br><span class="line">        <span class="comment">#     self.B.append(node)</span></span><br><span class="line">        <span class="comment"># if self.B[-1] &gt;= node:  # 如果node是最小的</span></span><br><span class="line">        <span class="comment">#     self.B.append(node)</span></span><br><span class="line">        <span class="comment"># B为空的时候一下push了两个相同的数，两个条件都符合</span></span><br><span class="line">        <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def pop(self) -&gt; None:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># pop() 本身就是“出栈”函数， 1、删除栈顶元素，2、返回栈顶元素。</span></span><br><span class="line">            <span class="comment"># 无论if判断是与否，原栈的栈顶是被pop了</span></span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def top(self) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def min(self) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = MinStack()</span><br><span class="line">    obj.push(<span class="number">9</span>)</span><br><span class="line">    obj.push(<span class="number">10</span>)</span><br><span class="line">    obj.push(<span class="number">7</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    obj.push(<span class="number">5</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3, 5, 3]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3, 5]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 5, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 3]</span></span><br><span class="line">    print(obj.min())  <span class="comment"># 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>#第二种方法：辅助栈和数据栈同步，考虑两个栈的长度相同，添加一个，另一个栈也会删除一个</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []  <span class="comment"># 空间换时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给栈中推进去数值，推进去元素node，添加函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="comment"># 如果最小值列表里有值为True</span></span><br><span class="line">        <span class="keyword">if</span> self.minValue:</span><br><span class="line">            <span class="comment"># 如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="keyword">if</span> self.minValue[<span class="number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">            <span class="comment"># 如果列表里面的最后一个值，小于node值，那么就说明node这个值大；</span></span><br><span class="line">            <span class="comment">#   那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.minValue.append(self.minValue[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 如果最小值列表里面没有值，就在最小值列表里添加node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">        <span class="comment"># if not self.minValue or self.minValue[-1] &gt;= node:</span></span><br><span class="line">        <span class="comment">#     self.minValue.append(node)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给栈中做删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个</span></span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        <span class="comment"># 有值的话，就需要删除一个，删除做pop 操作；返回我们删除的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出最小值，那么就是我们minvalue 中的最后一个值为最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minValue:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.minValue[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    obj.push(<span class="number">9</span>)</span><br><span class="line">    obj.push(<span class="number">10</span>)</span><br><span class="line">    obj.push(<span class="number">7</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    obj.push(<span class="number">5</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3, 5, 3]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3, 5]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3]</span></span><br><span class="line">    print(obj.min())  <span class="comment"># 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，<br>都只是有限个步骤，因此时间复杂度是：O(1)。<br>空间复杂度：O(N)，这里 N 是读出的数据的个数。</p>
<h2 id="5-替换空格-本题考点-字符串"><a href="#5-替换空格-本题考点-字符串" class="headerlink" title="5.替换空格[^本题考点 字符串]"></a>5.替换空格[^本题考点 <em>字符串</em>]</h2><p><strong>请实现一个函数，将一个字符串中的每个空格替换成<code>“%20”</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># 第一种：python中自带的一个替换的函数</span></span><br><span class="line">        <span class="comment"># return s.replace(' ','%20')</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二种遍历来替换字符串中的空格</span></span><br><span class="line">        strlen = len(s)</span><br><span class="line">        <span class="comment"># 借助第三方的列表来实现时间的节省。</span></span><br><span class="line">        aaa = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(strlen):</span><br><span class="line">            <span class="comment"># 如果是空格的话那就替换为%20.</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">" "</span>:</span><br><span class="line">                <span class="comment"># if s[i] isspace:</span></span><br><span class="line">                aaa.append(<span class="string">"%"</span>)</span><br><span class="line">                aaa.append(<span class="string">"2"</span>)</span><br><span class="line">                aaa.append(<span class="string">"0"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(aaa)</span><br><span class="line"><span class="comment"># 从后往前，先计算需要多少空间，然后从后往前移动，每个空格后面的字符只需要移动一次。</span></span><br><span class="line"><span class="comment"># 从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；</span></span><br><span class="line"><span class="comment"># 当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。</span></span><br><span class="line"><span class="comment"># 从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        strLen = len(s)</span><br><span class="line">        <span class="comment"># 定义空字符串准备接收</span></span><br><span class="line">        rep_str = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 遍历，检测到空格就加上"%20"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(strLen):</span><br><span class="line">            <span class="keyword">if</span> s[i].isspace():</span><br><span class="line">                rep_str += <span class="string">'%'</span></span><br><span class="line">                rep_str += <span class="string">'2'</span></span><br><span class="line">                rep_str += <span class="string">'0'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rep_str += s[i]</span><br><span class="line">        <span class="comment"># 返回辅助字符串</span></span><br><span class="line">        <span class="keyword">return</span> rep_str</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6.斐波那契数列"></a>6.斐波那契数列</h2><p><strong>现在要求输入一个整数n，<br>请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong><br>动态规划：<br>原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<ul>
<li>状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i 个数字 。</li>
<li>转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1) ；</li>
<li>初始状态： dp[0] = 0, dp[1] = 1 ，即初始化前两个数字；</li>
<li>返回值： dp[n] ，即斐波那契数列的第 nn 个数字。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种方法：下面是使用了for循环，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        a，b代表相邻两个斐波那契数；</span></span><br><span class="line"><span class="string">        a是前一个，b是后一个。</span></span><br><span class="line"><span class="string">        经过一次迭代后a代表fib(1)的值，</span></span><br><span class="line"><span class="string">        两次迭代后a代表fib(2)的值，</span></span><br><span class="line"><span class="string">        因此经过n次迭代a代表的是fib(n)的值，</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):  <span class="comment"># 从0取到n-2</span></span><br><span class="line">            a, b = b, a + b  <span class="comment"># 返回大的</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">        <span class="comment"># for _ in range(n):  # 取到n-1</span></span><br><span class="line">        <span class="comment"># a, b = b, a + b</span></span><br><span class="line">        <span class="comment"># return a % 1000000007  # 返回小的</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为-n"><a href="#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为-n" class="headerlink" title="第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n"></a>第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</h1><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">self</span>, n)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="comment">#初始列表值 为 0 1 第三项为 0+1 = 1；</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="comment">#临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。</span></span><br><span class="line">        <span class="keyword">while</span> len(res) &lt;= <span class="symbol">n:</span></span><br><span class="line">               <span class="comment">#取出列表的最后两项，然后求和，并添加到列表中。</span></span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>用Python实现Fibonacci数列 这里使用迭代器进行实现<br>fabonacci数列：后面的数字等于前面两个数之和，第一个数是0， 第二个数是1</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fabonacci</span>(<span class="params">length</span>):</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; length:</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixed_length_fabonacci</span>(<span class="params">length</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> fabonacci(length)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fixed_length_fabonacci(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.first = <span class="number">0</span></span><br><span class="line">        self.second = <span class="number">1</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_fibo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num):</span><br><span class="line">            <span class="keyword">yield</span> self.first</span><br><span class="line">            self.first, self.second = self.second, self.first + self.second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(list(Fibonacci(<span class="number">10</span>).generate_fibo()))</span><br></pre></td></tr></tbody></table></figure>


<h4 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h4><p><strong>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</strong></p>
<p>示例1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br></pre></td></tr></tbody></table></figure>
<p>示例2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​输入：{<span class="number">6</span>, <span class="number">-3</span>,<span class="number">-2</span>, <span class="number">7</span>, <span class="number">-15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>}，</span><br><span class="line">输入：</span><br><span class="line">返回值：<span class="number">8</span></span><br><span class="line">解释: 连从第<span class="number">0</span>个开始，到第<span class="number">3</span>个为止 [<span class="number">6</span>, <span class="number">-3</span>,<span class="number">-2</span>, <span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>示例3:</p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1,-2,3,10,-4,7,2,-5]</span></span><br><span class="line">输出: 18</span><br><span class="line">解释: 连续子数组 <span class="comment">[3,10,-4,7,2]</span> </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">常见解法    时间复杂度    空间复杂度</span><br><span class="line">暴力搜索    O(N^2)      O(1)</span><br><span class="line">分治思想    O(NlogN)    O(logN)</span><br><span class="line">动态规划    O(N)        O(1)</span><br><span class="line"></span><br><span class="line">动态规划是本题的最优解法，以下按照标准流程解题。</span><br><span class="line">两种标志DP适用于数组：</span><br><span class="line">  * 1. 常数空间，沿数组移动并子啊原数组修改；</span><br><span class="line">  * 2. 线性空间，首先沿left-&gt;right方向移动，然后沿right-&gt;left方向移动，最后合并结果。</span><br><span class="line"></span><br><span class="line">动态规划实质上就是空间换时间（画表格方法），分为一维列表、二维矩阵。</span><br><span class="line">自底向上（动态规划）和自底向下（记忆化递归）在一些书里都称为「动态规划」，</span><br><span class="line">可以先弄懂它们的区别；</span><br><span class="line">1. 最优子结构 大问题的最优解通常由小问题的最优解得到，那么我们就需要通过分类讨论，得到大问题的小问题究竟是哪些。 </span><br><span class="line">2. 边界 </span><br><span class="line">3. 状态定义 一般数组、字符串相关的状态定义都是 “以 dp<span class="comment">[i]</span> 为结尾的 xxx ” 这样，</span><br><span class="line">xxx 一般就是求最长、最短、最大、最小这种，dp<span class="comment">[i]</span>就是到当前i这个情况下的最优解，</span><br><span class="line">以某个数作为结尾，意思就是这个数一定会加上去，</span><br><span class="line">那么要看的就是这个数前面的部分要不要加上去。</span><br><span class="line">都存在选与不选两种选择，选了就与前面i-1的结果联系起来，不选就独立出来，</span><br><span class="line">「无后效性」是可以应用动态规划的一个特点：</span><br><span class="line">   1. 后面的决策不会影响到前面的决策</span><br><span class="line">   2. 之前的状态怎么来的并不重要。</span><br><span class="line">4. 转移方程</span><br><span class="line"></span><br><span class="line">以阶为例，最优子结构为f(10)=f(9) + f(8)，边界是f(1)=1, f(2)=2，</span><br><span class="line">状态转移公式f(n)=f(n-1) + f(n-2)跳台</span><br><span class="line"></span><br><span class="line">动态规划解析：</span><br><span class="line">- 数组的子结构通常就是子数组，而本题的最优子结构容易想到是 子数组的连续最大和 </span><br><span class="line">把数组分解成把数组长度个子问题</span><br><span class="line"></span><br><span class="line">- 状态定义（抽象出了子问题）： 设动态规划列表 dp ，</span><br><span class="line"> 定义数组元素dp<span class="comment">[i]</span> 代表当前位置 i 的以元素 nums<span class="comment">[i]</span> 为结尾的连续子数组最大和。</span><br><span class="line">动态规划的问题的分类讨论的标准不是 nums<span class="comment">[i]</span> 的正负，</span><br><span class="line">而是上一个状态值 dp<span class="comment">[i - 1]</span> 的正负。</span><br><span class="line"></span><br><span class="line">  - 为何定义最大和 dp<span class="comment">[i]</span> 中必须包含元素 nums<span class="comment">[i]</span> ：</span><br><span class="line">  保证 dp<span class="comment">[i]</span> 递推到 dp<span class="comment">[i+1]</span> 的正确性、转移方程的有效性，</span><br><span class="line">  如果不包含 nums<span class="comment">[i]</span> ，递推时则不满足题目的 连续子数组 要求。</span><br><span class="line"></span><br><span class="line">  - 转移策略，自带剪枝： </span><br><span class="line">    1. 若 dp<span class="comment">[i−1]</span> ≤ 0 ，说明 dp<span class="comment">[i - 1]</span> 没法给 dp<span class="comment">[i]</span> 带来正增益，那么加上前面的数反而越来越小了，即 dp<span class="comment">[i-1]</span> + nums<span class="comment">[i]</span> 还不如 nums<span class="comment">[i]</span> 本身大，抛弃掉前面的子组合，自己单独的一个 nums<span class="comment">[i]</span>就是最大的了。</span><br><span class="line">    2. 若前一个元素dp<span class="comment">[i−1]</span> &gt; 0，则将其加到当前元素上</span><br><span class="line"></span><br><span class="line">  - 状态转移方程</span><br><span class="line">    - 记为「状态转移方程 1」</span><br><span class="line">    当 dp<span class="comment">[i - 1]</span> &gt; 0 时：执行 dp<span class="comment">[i]</span> = dp<span class="comment">[i-1]</span> + nums<span class="comment">[i]</span> ；  </span><br><span class="line">    当 dp<span class="comment">[i - 1]</span> ≤ 0 时：执行 dp<span class="comment">[i]</span> = nums<span class="comment">[i]</span> ；</span><br><span class="line">    - 反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，</span><br><span class="line">    因此还可以写出「状态转移方程 2」。如下：</span><br><span class="line">      dp<span class="comment">[i]</span> = max(dp<span class="comment">[i-1]</span>, 0) + nums<span class="comment">[i]</span></span><br><span class="line"></span><br><span class="line">    - dp 初始状态得根据题意和你的状态定义而来：dp<span class="comment">[0]</span> = nums<span class="comment">[0]</span> 表示以 nums<span class="comment">[0]</span> 结尾的连续子数组最大和为 nums<span class="comment">[0]</span> 而非 0。如果数组元素只有一个元素，它就是最大和</span><br><span class="line">    </span><br><span class="line">  - 返回值：这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。返回 dp 列表中的最大值应该是把每个位置的 dp<span class="comment">[i]</span> 即dp<span class="comment">[0]</span>、dp<span class="comment">[1]</span>、……、dp<span class="comment">[n-1]</span> 都比较得到全局最大值。</span><br><span class="line"></span><br><span class="line">4.设计dp数组，保存子问题的解，避免重复计算，因此将原数组 nums 用作 dp 列表，即直接在原数组 nums 上修改，由于省去 dp 列表使用的额外空间：</span><br><span class="line">nums<span class="comment">[i]</span> += max(nums<span class="comment">[i-1]</span>,0);</span><br><span class="line"></span><br><span class="line">时间复杂度 O(N) ： 线性遍历一次数组 nums ，使用 O(N) 时间。</span><br><span class="line">空间复杂度 O(1) ： 使用常数大小的额外空间。</span><br><span class="line"></span><br><span class="line">优化空间，</span><br><span class="line">由于每次循环中当前状态只依赖于前一个状态，</span><br><span class="line">就是说 dp<span class="comment">[i]</span> 的更新只取决于 dp<span class="comment">[i-1]</span> , </span><br><span class="line">只用一个存储变量 maxnum 各阶段全局最大和</span><br><span class="line">从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List<span class="comment">[int]</span>) -&gt; int:</span><br><span class="line">        # 动态规划，原地修改数组</span><br><span class="line">        max_sum = nums<span class="comment">[0]</span></span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            # 写法一</span><br><span class="line">            # if nums<span class="comment">[i - 1]</span> &gt; 0:</span><br><span class="line">                # nums<span class="comment">[i]</span> += nums<span class="comment">[i - 1]</span></span><br><span class="line">            # 写法二</span><br><span class="line">            nums<span class="comment">[i]</span> += max(nums<span class="comment">[i - 1]</span>, 0)</span><br><span class="line">    </span><br><span class="line">            max_sum = max(max_sum, nums<span class="comment">[i]</span>)</span><br><span class="line"></span><br><span class="line">        return max_sum</span><br></pre></td></tr></tbody></table></figure>
<p>全是正的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">nums[i] = nums[i] + nums[i - <span class="number">1</span>] </span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + nums[<span class="number">0</span>] = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">1</span>] = <span class="number">3</span> &gt; <span class="number">0</span></span><br><span class="line">nums[i] = nums[i] + nums[i - <span class="number">1</span>] </span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + nums[<span class="number">1</span>] = <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>全是负的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">-2</span> &lt; <span class="number">0</span></span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">-2</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">1</span>] = <span class="number">-1</span> &lt; <span class="number">0</span></span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">-2</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>有负有正</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[<span class="number">1</span>] += max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">1</span>] + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">1</span>  </span><br><span class="line">max_sum = max(mmax_sumaxnum,nums[i]) = max(<span class="number">-2</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] += max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">2</span>] + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">-3</span> + <span class="number">1</span> = <span class="number">-2</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">-2</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] += max(nums[<span class="number">3</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">3</span>] + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">4</span> + <span class="number">0</span> = <span class="number">4</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] += max(nums[<span class="number">4</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">4</span>] + max(<span class="number">4</span>, <span class="number">0</span>) = <span class="number">-1</span> + <span class="number">4</span> = <span class="number">3</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">4</span>, <span class="number">3</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] += max(nums[<span class="number">5</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">5</span>] + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">4</span>, <span class="number">5</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] += max(nums[<span class="number">6</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">6</span>] + max(<span class="number">5</span>, <span class="number">0</span>) = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">5</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">nums[<span class="number">7</span>] += max(nums[<span class="number">7</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">7</span>] + max(<span class="number">6</span>, <span class="number">0</span>) = <span class="number">-5</span> + <span class="number">6</span> = <span class="number">1</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">6</span>, <span class="number">4</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">nums[<span class="number">8</span>] += max(nums[<span class="number">8</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">8</span>] + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">6</span>, <span class="number">5</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_sum = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>未优化的，击败40</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="comment"># max 并不会增加时间复杂度哈。直接代替了以 if else判断相当于把 max 平摊在 for 循环里的 if sum &gt; max: max = sum 操作上，实际上是一样的。</span></span><br><span class="line">            <span class="comment"># 写法一</span></span><br><span class="line">            <span class="comment"># if nums[i - 1] &gt; 0:</span></span><br><span class="line">                <span class="comment"># nums[i] += nums[i - 1]</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.maxSubArray(nums)</span><br><span class="line">    print(res)</span><br><span class="line">    print(nums)  <span class="comment"># [1, 3, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<p>全是正的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">2</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">3</span> + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>全是负的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-1</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-3</span> + max(<span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-3</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>有负有正</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">1</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-3</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">-2</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] = nums[<span class="number">3</span>] + max(nums[<span class="number">3</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">4</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] = nums[<span class="number">4</span>] + max(nums[<span class="number">4</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-1</span> + max(<span class="number">4</span>, <span class="number">0</span>) = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] = nums[<span class="number">4</span>] + max(nums[<span class="number">5</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">2</span> + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] = nums[<span class="number">5</span>] + max(nums[<span class="number">6</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">1</span> + max(<span class="number">5</span>, <span class="number">0</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">nums[<span class="number">7</span>] = nums[<span class="number">6</span>] + max(nums[<span class="number">7</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-5</span> + max(<span class="number">6</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">nums[<span class="number">8</span>] = nums[<span class="number">7</span>] + max(nums[<span class="number">8</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">4</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max(nums) = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：贪心法 O(n)<br>若当前指针所指元素之前的和 cur_sum &lt; 0，则丢弃当前元素之前的数列</p>
<p>cur_sum - 到当前位置i累计最大连续子序列和，<br>max_sum - 全局最大子序列和<br>比较 cur_sum 和 max_sum 的大小，将最大值置为max_sun</p>
<p>cur_sum &lt;= 0，则说明 cur_sum 对结果无增益效果，需要舍弃，则 cur_sum 直接更新为当前遍历数字时，<br>同时更新最大和的值(最大值可能为其中某个值)，<br>当叠加和 cur_sum &gt; 0，则说明 sucur_summ 对结果有增益效果，则 cur_sum 保留并加上当前遍历数字时，<br>同时更新最大和的值，依此继续。</p>
<p>不用max函数快一点，击败95%</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        cur_sum = max_sum = nums[<span class="number">0</span>]  <span class="comment"># 初始值设为列表第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):  <span class="comment"># 遍历列表剩下元素</span></span><br><span class="line">            <span class="comment"># if cur_sum &lt; 0:</span></span><br><span class="line">            <span class="comment">#     cur_sum = nums[i]</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     cur_sum = cur_sum + nums[i]</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            cur_sum = max(nums[i], cur_sum + nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if cur_sum &gt; max_sum:</span></span><br><span class="line">            <span class="comment">#     max_sum = cur_sum</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            max_sum = max(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.maxSubArray(nums)</span><br><span class="line">    print(res)</span><br><span class="line">    print(nums)  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">3</span>, <span class="number">1</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">3</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">6</span>, <span class="number">3</span>) = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">0</span> + (<span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-1</span>, <span class="number">-2</span>) = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">-1</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">0</span> + <span class="number">-3</span> = <span class="number">-3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-3</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">1</span>, <span class="number">-2</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">1</span> + <span class="number">-3</span> = <span class="number">-2</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-2</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">3</span>] = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">4</span>, <span class="number">1</span>) = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">cur_sum = max(<span class="number">5</span>, <span class="number">0</span>) + nums[<span class="number">4</span>] = <span class="number">4</span> + (<span class="number">-1</span>) = <span class="number">3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">3</span>, <span class="number">4</span>) = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">cur_sum = max(<span class="number">3</span>, <span class="number">0</span>) + nums[<span class="number">5</span>] = <span class="number">3</span> + <span class="number">2</span> = <span class="number">5</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">5</span>, <span class="number">4</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">cur_sum = max(<span class="number">5</span>, <span class="number">0</span>) + nums[<span class="number">6</span>] = <span class="number">5</span> + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">6</span>, <span class="number">5</span>) = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">cur_sum = max(<span class="number">6</span>, <span class="number">0</span>) + nums[<span class="number">7</span>] = <span class="number">6</span> + (<span class="number">-5</span>) = <span class="number">1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">1</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">8</span>] = <span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">5</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line"><span class="keyword">return</span> max_sum = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="41-复杂链表的复制-本题考点-链表"><a href="#41-复杂链表的复制-本题考点-链表" class="headerlink" title="41.复杂链表的复制 [^本题考点 链表]"></a>41.复杂链表的复制 [^本题考点 <em>链表</em>]</h4><p>​    <strong>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># 深拷贝也可以</span></span><br><span class="line">        <span class="comment"># return copy.deepcopy(pHead)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制一个一样的node，并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            node = RandomListNode(pTmp.label)</span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            pTmp.next = node</span><br><span class="line">            pTmp = node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现新建的node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            <span class="keyword">if</span> pTmp.random:</span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开原来的node和新node的连接</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="keyword">if</span> pNewTmp.next:</span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            pTmp = pTmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n1 = RandomListNode(<span class="number">1</span>)</span><br><span class="line">    n2 = RandomListNode(<span class="number">2</span>)</span><br><span class="line">    n3 = RandomListNode(<span class="number">3</span>)</span><br><span class="line">    n4 = RandomListNode(<span class="number">4</span>)</span><br><span class="line">    n5 = RandomListNode(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">    n1.next = n2</span><br><span class="line">    n2.next = n3</span><br><span class="line">    n3.next = n4</span><br><span class="line">    n4.next = n5</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    newHead = s.Clone(n1)</span><br><span class="line">    tmp = newHead</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        print(tmp.label)</span><br><span class="line">        tmp = tmp.next</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">            <span class="comment">#判断当pHead 为空值的时候 返回的是none</span></span><br><span class="line">            <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#把第一个 A 的值 赋给 node 为A‘</span></span><br><span class="line">                node = RandomListNode(pTmp.label)</span><br><span class="line">                <span class="comment">#此时 node A' 的结点指向的是 原来A 的结点指向的 值</span></span><br><span class="line">                node.next = pTmp.next</span><br><span class="line">                <span class="comment">#将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">                pTmp.next = node</span><br><span class="line">                <span class="comment">#将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素</span></span><br><span class="line">                pTmp = node.next</span><br><span class="line">        <span class="comment"># 实现新建的node的random的指向</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">                <span class="keyword">if</span> pTmp.random:</span><br><span class="line">                    <span class="comment">#那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。</span></span><br><span class="line">                    pTmp.next.random = pTmp.random.next</span><br><span class="line">            <span class="comment">#建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="comment">#当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。</span></span><br><span class="line">                pTmp = pTmp.next.next</span><br><span class="line">            <span class="comment"># 断开原来的node 和 新的node 之间的链接</span></span><br><span class="line">            <span class="comment">#最后 为断开 链接 的操作</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="comment">#复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">            newHead = pHead.next</span><br><span class="line">            <span class="comment">#复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">            pNewTmp = pHead.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#print(pTmp.label)</span></span><br><span class="line">                <span class="comment">#将旧链表 A 的指向结点 改为  A' 的指向的下一个 的B。</span></span><br><span class="line">                pTmp.next = pTmp.next.next</span><br><span class="line">                <span class="comment">#如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">                <span class="keyword">if</span> pNewTmp.next:</span><br><span class="line">                    <span class="comment">#那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’</span></span><br><span class="line">                    pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                    <span class="comment">#然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘</span></span><br><span class="line">                    pNewTmp = pNewTmp.next</span><br><span class="line">            <span class="comment">#上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B</span></span><br><span class="line">                pTmp = pTmp.next</span><br><span class="line">            <span class="comment">#如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#最后返回这个复制好的新链表。</span></span><br><span class="line">            <span class="keyword">return</span> newHead</span><br></pre></td></tr></tbody></table></figure>

<hr>
<hr>
<h2 id="7-青蛙跳台阶"><a href="#7-青蛙跳台阶" class="headerlink" title="7.青蛙跳台阶"></a>7.青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。<br>求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%5C%E5%89%91%E6%8C%87offer%5C%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.png"></p>
<p>1 (1)<br>2 (11,2)<br>3 (12,21,111)<br>4 (1111,22,112,121,211)<br>5 (11111,221,212,122,1121,2111,1112,1211)<br>6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)</p>
<p>假设有n级台阶，<br>青蛙从最后的第n级开始往前跳，<br>有可能是跳1级台阶，之后还有n-1级台阶，此情况共有 f(n-1)中可能性；<br>也有可能跳2级台阶，之后还有n-2级台阶，此情况共有 f(n-2)种可能性。<br>反过来说，最后一步只有两种情况<br>那么可以从第 n - 1 级台阶跳上去（跳一级），<br>也可以从第 n - 2 级台阶跳上去（跳两级），</p>
<p>f(n) 为以上两种情况之和<br>所以从n级开始跳的跳法就有 f(n) = f(n-1) + f(n-2)种，<br>递推性质为斐波那契数列。求斐波那契数列第 n 项的值 ，<br>唯一的不同在于起始数字不同，从1,2开始</p>
<p>青蛙跳台阶问题：<br>f(0)=1 , 题目就是这么规定的，0 层台阶也有一种跳法（即不跳）。<br>之后遇到类似情况，可以输入 0 测试样例看下输出，然后就确定了~<br>递推公式反推~ 显然， f(2) = 2 f(1) = 1，而 f(2) = f(1) + f(0)，因此f(0) = 1`<br>背包问题里，背包里物品价值为0即背包为空也是一种情况，<br>同理本题台阶为0时青蛙什么也不跳也是一种情况<br>理解dp初值的时候，有时候不需要从定义去理解它，<br>只需要保证状态转移的时候，它作为后面要参考到的值，能得到正确的结果即可。<br>f(3)=f(2)+f(1)；<br>当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来<br>斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 </p>
<p>生成第 n 项的做法有以下几种<br>1.递归法：</p>
<ul>
<li>原理： 把 f(n) 问题的计算拆分成 f(n-1) 和 f(n-2) 两个子问题的计算，<br>并递归，以 f(0) 和 f(1) 为终止条件。</li>
<li>缺点： 大量重复的递归计算会超时，例如 f(n) 和 f(n - 1) 两者向下递归都需要计算 f(n−2) 的值。</li>
</ul>
<p>2.记忆化递归法：</p>
<ul>
<li>原理： 在递归法的基础上，新建一个长度为 n 的数组，<br>用于在递归时存储 f(0) 至 f(n) 的数字值，<br>重复遇到某数字时则直接从数组取用，避免了重复的递归计算。</li>
<li>缺点： 记忆化存储的数组需要使用 O(N) 的额外空间。</li>
</ul>
<p>3.动态规划：<br>原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<p>动态规划解析：</p>
<ul>
<li>状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。</li>
<li>转移方程： dp[i + 1] = dp[i] + dp[i - 1] ，<br>即对应数列定义 f(n + 1) = f(n) + f(n - 1) ；</li>
<li>初始状态： dp[0] = 1, dp[1] = 1 ，即初始化前两个数字；<br>这两个作为边界条件就可以继续向后推导出第 n 级的正确结果</li>
<li>返回值： dp[n] ，即斐波那契数列的第 n 个数字。</li>
</ul>
<p>空间复杂度优化：</p>
<blockquote>
<p>若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。</p>
</blockquote>
<ul>
<li>由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，<br>时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。<br>Python 中整数型数字由于可超过 32 位，取决计算机的内存 （可理解为无限大）<br>因此复杂度不再是 O(1)<br>复杂度为O（N^2），虽说题目的n最大为100，<br>Python代码中间过程没有取MOD， 最终a的值会是指数级别大小，<br>每次加法的复杂度不是O(1)而是O(log(2^n)/64)=O(n)。<br>64是加法运算器位数.</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment">#第一种方法：</span></span><br><span class="line">         a = <span class="number">1</span></span><br><span class="line">         b = <span class="number">1</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):  <span class="comment"># 从0取到n-1</span></span><br><span class="line">             a,b = b,a+b</span><br><span class="line">         <span class="keyword">return</span> a % <span class="number">1000000007</span>  <span class="comment"># int表示的范围有限</span></span><br><span class="line">         <span class="comment"># 答案需要取模 1e9+7（1000000007），</span></span><br><span class="line">         <span class="comment"># 如计算初始结果为：1000000008，请返回 1。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,number+<span class="number">1</span>):  <span class="comment"># 从3加到number</span></span><br><span class="line">            ret = a+b</span><br><span class="line">            a = b</span><br><span class="line">            b = ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="8-变态跳台阶"><a href="#8-变态跳台阶" class="headerlink" title="8.变态跳台阶"></a>8.变态跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1 (1)</span></span><br><span class="line"><span class="string">2 (11,2)</span></span><br><span class="line"><span class="string">3 (111,21,3,12)</span></span><br><span class="line"><span class="string">4 (1111,22,13,31,211,112,121,4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">n  2^(n-1)</span></span><br><span class="line"><span class="string">f(n)  = f(n-1) + f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="string">f(n-1) = f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="string">f(n) = 2f(n-1)  n &gt; 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f(1) = 1 n = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#第一种方法：</span></span><br><span class="line">        <span class="comment"># return pow(2,number-1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#第二种方法：</span></span><br><span class="line">        <span class="comment"># return 2 ** (number - 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#第三种方法：</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,number+<span class="number">1</span>):</span><br><span class="line">            ret = <span class="number">2</span>*n</span><br><span class="line">        <span class="keyword">return</span> n      </span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="9-调整数组顺序使奇数位于偶数前面-本题知识点-数组"><a href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]"></a>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 <em>数组</em>]</h2><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p>
<p>算法流程：<br>初始化： 头指针 left ，尾指针 right，分别指向数组 nums 左右两端；<br>循环交换： 当 i = j 时跳出；<br>指针 left 遇到奇数则执行 left = left + 1 跳过，直到它指向的值为偶数；<br>指针 right 遇到偶数则执行 right = right - 1 跳过，直到它指向的值为奇数；<br>交换 nums[left] 和 nums[right] 值；<br>返回值： 返回已修改的 nums 数组。<br>复杂度分析：<br>时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。<br>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</p>
<p>奇偶性可以由一个整数二进制的最低位决定（想一想一个整数的二进制分解），<br>最低位是 0 是偶数，反之是奇数。</p>
<p>x&amp;1 位运算 等价于 x % 2 取余运算，即皆可用于判断数字奇偶性<br>若 x&amp;1=0 ，则 x 二进制 最右一位 为 0 ，为偶数；<br>若 x&amp;1=1 ，则 x 二进制 最右一位 为 1 ，为奇数。<br>实际编写代码中，编译器一般都会自动优化， $%$ 求余的可读性更好，<br>所以只在解题时候用位运算秀秀操作就好啦~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def exchange(self, nums: List[int]) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="comment"># 因为每次指针移动后，首先要做的是判断索引值的合法性。</span></span><br><span class="line">        <span class="comment"># 只有索引合法才有后续的操作。</span></span><br><span class="line">        <span class="comment"># 因为第二步和第三步循环过程中，有可能遇到 i == j 的边界情况，</span></span><br><span class="line">        <span class="comment"># 此时就应终止，不然 i 就跑到 j 右边了，这和本文方法定义不符。</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#时间复杂度是o(n)</span></span><br><span class="line">        <span class="comment">#空间复杂度o(n)</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>: <span class="keyword">return</span> array</span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># if len(array) &lt; 2: return array</span></span><br><span class="line">        <span class="comment"># for i in array:</span></span><br><span class="line">        <span class="comment">#     # 法一</span></span><br><span class="line">        <span class="comment">#     if i % 2 == 1:</span></span><br><span class="line">        <span class="comment">#         res.append(i)</span></span><br><span class="line">        <span class="comment"># for i in array:</span></span><br><span class="line">        <span class="comment">#     if i % 2 == 0:</span></span><br><span class="line">        <span class="comment">#         res.append(i)</span></span><br><span class="line">        <span class="comment">#     # 法二</span></span><br><span class="line">        <span class="comment">#     # res.append(i) if i % 2 == 1 else even.append(i)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用了冒泡排序的原理，判断奇偶数，</span></span><br><span class="line">        <span class="comment"># 如果一个是偶数而且下一个是奇数，那么两个就互换位置。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array) - i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> array[j] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> array[j + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    array[j], array[j + <span class="number">1</span>] = array[j + <span class="number">1</span>], array[j]</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(Solution.reOrderArray(array))</span><br><span class="line">    <span class="comment"># [1, 3, 5, 2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">i = 0,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 1,  [1, 3, 5, 2, 4, 6]</span></span><br><span class="line"><span class="string">i = 2,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 3,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 4,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 5,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="10-栈的压入，弹出序列-本题考点-栈"><a href="#10-栈的压入，弹出序列-本题考点-栈" class="headerlink" title="10.栈的压入，弹出序列  [^本题考点 栈]"></a>10.栈的压入，弹出序列  [^本题考点 <em>栈</em>]</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，<br>序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>pushed 是 popped 的排列。</strong></p>
<p>分析：<br>给定一个压入序列 pushed 和弹出序列 popped ，<br>则压入 / 弹出操作的顺序（即排列）是 唯一确定 的</p>
<blockquote>
<p>题目指出 pushed 是 popped 的排列 。<br>因此，无需考虑 pushed 和 popped 长度不同 或 包含元素不同 的情况。</p>
</blockquote>
<blockquote>
<p>如果题目没说明 pushed 是 popped 的排列，代码应该做什么改动呢<br>可能输入的 pushed 和 popped 长度会不一样<br>需要提前判断一下 pushed 和 popped 的长度是否相同，<br>若不同直接返回 false。<br>否则，以下案例会出错：<br>[1,2,3,4,5]<br>[4,5,3,2,1,6]</p>
</blockquote>
<p>示例1<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例2<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。栈的数据操作具有 先入后出 的特性</p>
<p>因为若是4为首位出栈的话，123必定还在栈中，<br>无论5什么时候入栈和出栈，都不可能出现1在2前面的现象</p>
<p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。<br>根据是否模拟成功，即可得到结果。</p>
<ul>
<li>入栈操作： 按照压栈序列的顺序执行。</li>
<li>出栈操作： 每次入栈后，循环判断 “压入栈的栈顶元素 == 弹出序列的当前元素” 是否成立，<br>将符合弹出序列顺序的栈顶元素全部弹出。<blockquote>
<p>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，<br>每个元素出栈的位置的可能性是唯一的<br>（若有重复数字，则具有多个可出栈的位置）。<br>因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</p>
</blockquote>
复杂度分析：<br>时间复杂度 O(N) ： 其中 N 为列表 pushed 和 popped 的长度；<br>每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。<br>空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N 个元素。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: list[int], popped: list[int]</span>) -&gt; bool:</span></span><br><span class="line">        stack= []  <span class="comment"># 使用一个栈，开始为空</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(item)  <span class="comment"># num 入栈</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[index]:  <span class="comment"># 弹出的时候是需要循环判断是否需要弹出</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack  <span class="comment"># stack为空返回true，不为空返回False</span></span><br><span class="line">        <span class="comment"># return True if stack == [] else False</span></span><br><span class="line">        <span class="comment"># return index == len(popped)  # popped的每个元素都与pushed对应，长度相等</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    print(obj.validateStackSequences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># True</span></span><br><span class="line">    print(obj.validateStackSequences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">    <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed, popped</span>):</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> pushed:</span><br><span class="line">            tmp.append(item)</span><br><span class="line">            <span class="comment"># 同时检测tmp的最后一个元素是否与popped的第一个元素相同，</span></span><br><span class="line">            <span class="keyword">while</span> tmp <span class="keyword">and</span> popped <span class="keyword">and</span> tmp[<span class="number">-1</span>] == popped[<span class="number">0</span>]:</span><br><span class="line">                tmp.pop()  <span class="comment"># tmp中最后一个元素弹出</span></span><br><span class="line">                popped.pop(<span class="number">0</span>)  <span class="comment"># popped的第一个元素也弹出</span></span><br><span class="line"><span class="comment">#最后判断tmp与popped是否正好相反。</span></span><br><span class="line">        <span class="keyword">return</span> tmp[::<span class="number">-1</span>] == popped</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="11-从栈尾到栈头打印链表-本题知识点-链表"><a href="#11-从栈尾到栈头打印链表-本题知识点-链表" class="headerlink" title="11. 从栈尾到栈头打印链表 [^本题知识点 链表]"></a>11. 从栈尾到栈头打印链表 [^本题知识点 <em>链表</em>]</h2><p><strong>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</strong></p>
<p>因为本题输入的是一个链表，因此你需要先建立好一个链表，再将链表的表头节点输入</p>
<p>在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改</p>
<p>通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_linklist_head</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="comment"># 头插</span></span><br><span class="line">    head = Node(li[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">        node = Node(item)  <span class="comment"># 生成节点</span></span><br><span class="line">        node.next = head  <span class="comment"># next指向原来的头部</span></span><br><span class="line">        head = node  <span class="comment"># head 指向在头部插入的节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回头部</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_linklist_tail</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="comment"># 尾插</span></span><br><span class="line">    head = Node(li[<span class="number">0</span>])</span><br><span class="line">    tail = head</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">        node = Node(item)  <span class="comment"># Node类实例化得到一个node对象。</span></span><br><span class="line">        tail.next = node  <span class="comment"># 把原来尾巴的下一个指针指向当前node</span></span><br><span class="line">        tail = node  <span class="comment"># 尾巴 指向在新部插入的节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回头部</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_linklist</span>(<span class="params">lk</span>):</span></span><br><span class="line">    <span class="keyword">while</span> lk:</span><br><span class="line">        print(lk.val, end=<span class="string">', '</span>)</span><br><span class="line">        lk = lk.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk_head = create_linklist_head([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">print_linklist(lk_head)  <span class="comment"># 3, 2, 1,</span></span><br><span class="line">print(lk_head)  <span class="comment"># &lt;__main__.Node object at 0x0000029F94CEDE50&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'---'</span>)</span><br><span class="line">lk_tail = create_linklist_tail([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print_linklist(lk_tail)  <span class="comment"># 4, 5, 6,</span></span><br></pre></td></tr></tbody></table></figure>

<p>方法一：递归法 既然想到了栈，其实递归本质上就是一个栈结构，所以也可以使用递归来实现。<br>解题思路：<br>先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
<p>Python 算法流程：<br>1.递推阶段： 每次传入 listNode.next ，将 新插入的节点listNode 添加到末尾<br>listNode 从 链表的第一个元,将链表中的节点的值存入一个栈中<br>只要当前节点不为NULL，也就是链表没到头，就一直递归<br>以 listNode == None（即走过链表尾部节点）为递归终止条件，<br>此时返回空列表 [] 。</p>
<p>2.回溯阶段：<br>递归回溯时每次返回 当前 list + 当前节点值 [listNode.val] </p>
<p>在递归结束时，将元素压入<br>这样当递归到头结束即从尾</p>
<p>复杂度分析：<br>时间复杂度 O(N)： 遍历链表，递归 N 次。<br>空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间。<br>递归函数返回后，内存空间得到释放，因此只用记录最上层函数使用的 O(N) 空间</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reversePrint(self, listNode: ListNode) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        <span class="comment"># return self.reversePrint(listNode.next) + [listNode.val] if listNode else []</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">if</span> listNode:</span><br><span class="line">            <span class="comment"># 先递归到最后一层</span></span><br><span class="line">            temp = self.reversePrint(listNode.next)</span><br><span class="line">            print(listNode.next)</span><br><span class="line">            print(listNode.val)</span><br><span class="line">            print(temp)</span><br><span class="line">            temp.append(listNode.val)</span><br><span class="line">            <span class="comment"># 添加值，退出函数，返回到上一层函数中的这行，继续添加值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = []</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(<span class="string">'------'</span>)</span><br><span class="line">    print(s.reversePrint(lk_head))</span><br><span class="line">    <span class="comment"># None</span></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># []</span></span><br><span class="line">    <span class="comment"># &lt;__main__.Node object at 0x000001A05ABC9610&gt;</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># [1]</span></span><br><span class="line">    <span class="comment"># &lt;__main__.Node object at 0x000001A05ACBF640&gt;</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># [1, 2]</span></span><br><span class="line">    <span class="comment"># 打印return</span></span><br><span class="line">    <span class="comment"># [1, 2, 3]</span></span><br><span class="line">    print(s.reversePrint(lk_tail))  <span class="comment"># [6, 5, 4]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        self.arrayList = []</span><br><span class="line">        <span class="keyword">if</span> listNode:</span><br><span class="line">            <span class="keyword">if</span> listNode.next:</span><br><span class="line">                self.printListFromTailToHead(listNode.next)</span><br><span class="line">            self.arrayList.append(listNode.value)</span><br><span class="line">        <span class="keyword">return</span> self.arrayList</span><br></pre></td></tr></tbody></table></figure>

<p>尾插法的方式不同，则输入不同，后续的代码也不同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_end_to_head</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""从尾到头打印单链表"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            print(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tmp = []</span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp.insert(<span class="number">0</span>, cur)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">            print(i.item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sl = SingleLinkedList()</span><br><span class="line">    sl.append(SingleNode(<span class="number">1</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">2</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">3</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">4</span>))</span><br><span class="line">    sl.print_end_to_head()</span><br><span class="line">    <span class="comment"># 4</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>


<p>方法二：辅助栈法<br>解题思路：</p>
<blockquote>
<p>链表特点： 只能从前至后访问每个节点。<br>题目要求： 倒序输出节点值。<br>这种 先入后出 后进先出 的需求可以借助 栈 来实现。</p>
</blockquote>
<p>算法流程：<br>1.入栈：从链表的头节点开始遍历链表，依次将每个节点值使用 append() 方法 push 入栈。<br>2.出栈：返回 stack 的倒序列表，</p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(n)： 正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。</li>
<li>空间复杂度 O(n)： 额外使用一个栈存储链表中的每个节点。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reversePrint(self, listNode: ListNode) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        stack = []  <span class="comment"># 初始化栈</span></span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            stack.append(listNode.val)  <span class="comment"># 尾插</span></span><br><span class="line">            listNode = listNode.next  <span class="comment"># 新插入的节点指向上一个头的下一个值</span></span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]  <span class="comment"># 或者 reverse(stack)</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        arrayList = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            arrayList.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        arrayList2 = []</span><br><span class="line">        <span class="keyword">while</span> arrayList:</span><br><span class="line">            arrayList2.append(arrayList.pop())</span><br><span class="line">        <span class="keyword">return</span> arrayList2</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        stack = []  <span class="comment"># 初始化栈</span></span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            <span class="comment"># 列表.insert(索引，值) 可以在指定位置之前插入元素，</span></span><br><span class="line">            stack.insert(<span class="number">0</span>, listNode.val)  <span class="comment"># 头插</span></span><br><span class="line">            listNode = listNode.next  <span class="comment"># 新插入的节点指向上一个头的下一个值</span></span><br><span class="line">        <span class="keyword">return</span> stack         </span><br></pre></td></tr></tbody></table></figure>


<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h2 id="12-链表中的倒数第k个结点-本题考点-链表"><a href="#12-链表中的倒数第k个结点-本题考点-链表" class="headerlink" title="12.链表中的倒数第k个结点[^本题考点 链表]"></a>12.链表中的倒数第k个结点[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p>
<p>要求链表倒数第 k 个节点，那么正数就应该是从头结点开始往后推（n-k）个，正数第length - k个节点<br>n自然代表所有节点的个数（不包含空节点），也可以说n代表指针的个数，</p>
<p>题目说了返回节点啊，不是返回节点值<br>自己测试还是返回节点值</p>
<p>法一<br>使用双指针则可以不用统计链表长度。<br>算法流程：<br>1.初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head​ 。<br>2.构建双指针距离： 前指针 former 先向前走 k 步，<br>（结束后，双指针 former 和 latter 间相距 k 步）。<br>3.双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，<br>直至 former 走过链表 尾节点 时跳出<br>（跳出后， latter 与尾节点距离为 k-1，latter 与null距离为 k<br>由于index(right) - index(left) = k，<br>所以index(left) = index(right) - k = length - k。<br>即 latter 指向倒数第 k 个节点）。<br>设置两个指针，p2指针先走（k-1）步到达第k个结点，然后再一起走，<br>当p2为最后一个时，p1就为倒数第k个 数</p>
<p>4.返回值： 返回 latter 即可。<br>相当于制造了一个K长度的尺子，把尺子从头往后移动，<br>当尺子的右端与链表的末尾对齐的时候，尺子左端所在的结点就是倒数第k个结点”</p>
<p>复杂度分析：<br>时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k) 步。<br>空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。<br>本题没有 k 大于链表长度的 case ，因此不用考虑越界问题。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        former, latter = head, head</span><br><span class="line">        <span class="comment"># 首先让一个指针先开始移动，那么就是遍历我们的k 值，</span></span><br><span class="line">        <span class="comment"># 让我们的 第一个指针移动 k 步。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment"># 在循环中若是游标为None，则达到临界条件，</span></span><br><span class="line">            <span class="comment"># 说明k比该链表的长度还要长，即返回None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> former:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            former = former.next  <span class="comment"># 第一个指针 移动一步</span></span><br><span class="line">        <span class="keyword">while</span> former:</span><br><span class="line">            former, latter = former.next, latter.next</span><br><span class="line">        <span class="keyword">return</span> latter.val  <span class="comment"># 最后 latter 就指向目标节点</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>先遍历统计链表长度，记为 length ；<br>设置一个指针走 (length-k) 步，即可找到链表倒数第 k 个节点。<br>相当于遍历两遍。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            node = node.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; length:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> length - k:  <span class="comment"># 5-2=3 5-3=2 5-4=1</span></span><br><span class="line">            print(length-k)</span><br><span class="line">            print(head.val)  <span class="comment"># 从头节点开始开始遍历</span></span><br><span class="line">            head = head.next</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.val</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = self.getKthFromEnd(head.next, k)</span><br><span class="line"><span class="comment">#执行了一个函数 elf.getKthFromEnd() ，</span></span><br><span class="line"><span class="comment"># 传入了参数 head.next, k ，返回值赋给 node</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主要考虑的点是捕捉目标节点 head ，并在捕捉后就一直返回这个 node</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == k:</span><br><span class="line">            <span class="keyword">return</span> head.val</span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>将所有值使用容器（列表、堆栈、数组等）保存链表，<br>只遍历一遍，然后直接查询</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head)</span><br><span class="line"><span class="comment"># 这样放的是一个引用，不是整个list，根据这个引用地址可以遍历后面的链表。</span></span><br><span class="line"><span class="comment"># 如果是res.append(head.val)，返回的是节点的值。题目要求返回节点。</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> k &gt; len(res) <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.png"></p>
<p>注意你的提示“’NoneType’ object has no attribute ‘next’”，<br>因为你的while判断条件有问题，要改成while head。<br>你想一下，如果是一个空链表，那么head.next肯定会报错的</p>
<hr>
<p>如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。</p>
<h2 id="13-反转链表-本题考点-链表"><a href="#13-反转链表-本题考点-链表" class="headerlink" title="13.反转链表[^本题考点 链表]"></a>13.反转链表[^本题考点 <em>链表</em>]</h2><p><strong>题目：输入一个链表，反转链表后，输入一个链表，反转链表输出新链表的表头。</strong><br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<ul>
<li><p>第一种方法：迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reverseList(self, head: ListNode) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="comment"># 首先判断这个链表里是否为空或只有一个结点，</span></span><br><span class="line">        <span class="comment"># 只有一个结点那么它就不需要发生变化，</span></span><br><span class="line">        <span class="comment"># 它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="comment"># 这个时候就直接返回这个 head，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 反转过后，第一个数值的指针的结点指向的是none</span></span><br><span class="line">        <span class="comment"># 也就是一个指向反转后的头结点 为none</span></span><br><span class="line">        prev = <span class="literal">None</span>  <span class="comment"># 初始化当前节点的上一个节点</span></span><br><span class="line">        cur = head  <span class="comment"># cur始终指向要反转的结点，初始化为头结点</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 在循环过程中，让旧链表的表头的下一个结点等于新表头，</span></span><br><span class="line">            <span class="comment"># 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 简单写法</span></span><br><span class="line">            <span class="comment"># cur.next, prev, cur = prev, cur, cur.next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 详细执行过程写法</span></span><br><span class="line">            <span class="comment"># 先找到第一个元素的指针指向的元素，赋值给一个临时变量</span></span><br><span class="line">            temp = cur.next  <span class="comment"># 保存当前节点的下一个节点，因为后面更改了当前节点的next指向，</span></span><br><span class="line">            <span class="comment"># 由于节点没有引用其上一个节点，如果缺少了这一句，更改了当前节点的next指向，那原来后面的节点就找不到了</span></span><br><span class="line">            cur.next = prev  <span class="comment"># 每反转一个结点，把当前结点的下一个结点指向上一个节点prev</span></span><br><span class="line">            prev = cur  <span class="comment"># 将上一个节点前移到当前节点，prev成为反转后首结点 </span></span><br><span class="line">            cur = temp  <span class="comment"># 再把cur向前移动一个结点直至None结束</span></span><br><span class="line">        <span class="comment"># 最终就达到了翻转链表的效果，</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 题目要求返回表头，cur == None结束，肯定不会返回None</span></span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n)，n 是列表的长度<br>空间复杂度：O(1) 。</p>
</li>
<li><p>第二种方法：递归：<br>我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，<br>所以反转一下我和我的子节点。</p>
</li>
</ul>
<p>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .<br>此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。<br>同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转<br>当递归函数全部出栈后，链表反转完成。</p>
<p>原来的尾节点变为头节点，next原来指向None，尾部的next为空，<br>将从第二个node开始，循环将next指向前一个节点<br>原来的头节点变为尾节点，next原来指向下一个节点，改为指向None</p>
<p>不妨假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，<br>reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，<br>5-&gt;next = 4, 4-&gt;next = null。这时候返回了p这个节点，<br>也就是链表5-&gt;4-&gt;null，接下来执行reverseList（3），<br>代码解析为4-&gt;next = 3,3-&gt;next = null，这个时候p就变成了，<br>5-&gt;4-&gt;3-&gt;null, reverseList(2), reverseList(1)依次类推，p就是:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null</p>
<p>3 需要一直有一个指针指向还没有反转的链表的头部</p>
<p>使用递归函数需要注意防止递归深度溢出，在Python中，通常情况下，<br>这个深度是1000层，超过将抛出异常。<br>在计算机中，函数递归调用是通过栈（stack）这种数据结构实现的，<br>每当进入一个递归时，栈就会加一层，每当函数返回一次，栈就会减一层。<br>由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reverseList(self, head: ListNode) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件是链表里是否为空或只有一个结点，</span></span><br><span class="line">        <span class="comment"># 只有一个结点那么它就不需要发生变化，</span></span><br><span class="line">        <span class="comment"># 它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="comment"># 这个时候就直接返回这个 head，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        <span class="comment"># 执行了一个函数 elf.reverseList() ，传入了参数 head.next，</span></span><br><span class="line">        <span class="comment"># 直到head.next为空触发终止条件， head.next为最后一个节点作为返回值赋给 cur</span></span><br><span class="line">        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，</span></span><br><span class="line">        <span class="comment"># head.next.next=null,</span></span><br><span class="line">        <span class="comment"># cur = head.next =5</span></span><br><span class="line">        <span class="comment"># head=4</span></span><br><span class="line">        head.next.next = head  <span class="comment"># head的下一个节点head.next不再指向下一个反转指向前一个</span></span><br><span class="line">        <span class="comment"># 4.next.next=4 即5.next=4</span></span><br><span class="line">        <span class="comment"># 不能让cur.next = head，每次拿到的cur都是指向5，如果此时执行到节点2，那么相当于5.next=2，这样就不对了</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># head的下一个指向设置为空，防止循环指向，要断开</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># 判断是否为空值，没有元素</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 判断是否只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> pHead.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="comment"># 左边指针为 头 第一个 指针</span></span><br><span class="line">        leftPointer = pHead</span><br><span class="line">        <span class="comment"># 中间 的指针 为 第二个指针</span></span><br><span class="line">        midPointer = pHead.next</span><br><span class="line">        <span class="comment"># 右边的指针  为 指向 中间 指针后的 所有的元素 </span></span><br><span class="line">        rightPointer = midPointer.next</span><br><span class="line">        <span class="comment"># 左边的指针为 起始 的 元素， 反转后 它的next 为 None；</span></span><br><span class="line">        leftPointer.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。</span></span><br><span class="line">        <span class="keyword">while</span> rightPointer:</span><br><span class="line">            <span class="comment"># 中间指针指向的为上一个 元素 即 leftPointer</span></span><br><span class="line">            midPointer.next = leftPointer</span><br><span class="line">            <span class="comment"># 三个指针开始往右移。每次移一个。</span></span><br><span class="line">            <span class="comment"># 左边指针 往右移一个 就是中间指针的位置</span></span><br><span class="line">            leftPointer = midPointer</span><br><span class="line">            <span class="comment"># 中间指针 往 右 移 一个，就时 右边指针的位置</span></span><br><span class="line">            midPointer = rightPointer</span><br><span class="line">            <span class="comment"># 右边指针往右移 一个 ，就时 右边指针的下一个。</span></span><br><span class="line">            rightPointer = rightPointer.next</span><br><span class="line">        <span class="comment"># 当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。</span></span><br><span class="line">        midPointer.next = leftPointer</span><br><span class="line">        <span class="comment"># 最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。</span></span><br><span class="line">        <span class="keyword">return</span> midPointer</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n) 。假设 n 是列表的长度，那么时间复杂度为 O(n) 。<br>空间复杂度：O(n) 。由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p>
<p>如图所示：</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h2 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14.复杂链表的复制"></a>14.复杂链表的复制</h2><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>一个指向下一个节点，另一个特殊指针指向任意一个节点），<br>返回结果为复制后复杂链表的head。<br>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.png"></p>
<hr>
<p>####第一种方法：<br>算法：深度优先搜索<br>1.从头结点 head 开始拷贝；<br>2.由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；<br>3.如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；<br>4.使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</p>
<p>时间复杂度：O(N)。<br>空间复杂度：O(N)。</p>
<p>首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点<br>我们将原节点作为key，新节点作为value放入哈希表中</p>
<p>原节点和新节点是一一对应的关系，所以</p>
<p>map.get(原节点)，得到的就是对应的新节点<br>map.get(原节点.next)，得到的就是对应的新节点.next<br>map.get(原节点.random)，得到的就是对应的新节点.random<br>只需要再次遍历原链表，然后设置：<br>新节点.next -&gt; map.get(原节点.next)<br>新节点.random -&gt; map.get(原节点.random)<br>这样新链表的next和random都被串联起来了<br>最后，我们然后map.get(head)，也就是对应的新链表的头节点，就可以解决此问题了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 创建一个哈希表，key是原节点，value是新节点</span></span><br><span class="line">        d = dict()</span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 将原节点和新节点放入哈希表中</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            new_node = Node(p.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            d[p] = new_node</span><br><span class="line">            p = p.next</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历原链表，设置新节点的next和random</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="comment"># p是原节点，d[p]是对应的新节点，p.next是原节点的下一个</span></span><br><span class="line">            <span class="comment"># d[p.next]是原节点下一个对应的新节点</span></span><br><span class="line">            <span class="keyword">if</span> p.next:</span><br><span class="line">                d[p].next = d[p.next]</span><br><span class="line">            <span class="comment"># p.random是原节点随机指向</span></span><br><span class="line">            <span class="comment"># d[p.random]是原节点随机指向  对应的新节点</span></span><br><span class="line">            <span class="keyword">if</span> p.random:</span><br><span class="line">                d[p].random = d[p.random]</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="comment"># 主要是第二种是明白在放入hashmap里时候就已经最后指向了null，</span></span><br><span class="line">        <span class="comment"># 返回头结点，即原节点对应的value(新节点)</span></span><br><span class="line">        <span class="keyword">return</span> d[head]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            <span class="comment"># 创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            <span class="comment">#  visited是一个哈希表，即visited = {键：值}，visited[键]=值</span></span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            <span class="comment"># 反复运行，会递归得越来越深，</span></span><br><span class="line">            <span class="comment"># 当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；</span></span><br><span class="line"></span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="comment"># 回溯时，先从尾结点开始回溯：调用dfs(head.random)时，</span></span><br><span class="line">            <span class="comment"># 由于结点都保存在了哈希表中，因此 return visited[head]，</span></span><br><span class="line">            <span class="comment"># 这时完成random指针，完成了最后一个结点，故return copy。</span></span><br><span class="line">            <span class="comment"># 再进行倒数第二个结点的回溯：</span></span><br><span class="line">            <span class="comment"># 调用dfs(head.random)，return visited[head]，return copy.......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一部分的 return 是 dfs(head.next) 和 dfs(head.random) 的终止条件，</span></span><br><span class="line">            <span class="comment"># 您提到了访问过了就直接返回了，</span></span><br><span class="line">            <span class="comment"># 这里的返回可以理解为找到了递归部分 head.next 或 head.random 的终止条件。</span></span><br><span class="line">            <span class="comment"># 这时 copy 的值，next，random 都找到了，</span></span><br><span class="line">            <span class="comment"># 我们可以最终执行第二部分的 return copy 了。</span></span><br><span class="line">            <span class="comment"># copy 是原链表 head 的复制结点，刚开始 next 和 random 都是 null，</span></span><br><span class="line">            <span class="comment"># 然后只是对 next 和 random 进行了递归，copy 应该一直就在那里没动等于 head，</span></span><br><span class="line">            <span class="comment"># 所以很原链表一样返回 copy就行了。</span></span><br><span class="line">            <span class="comment"># 我想问下你说的【return copy之后继续执行copy.random = dfs(head.random)】</span></span><br><span class="line">            <span class="comment"># 意思是第二部分 return copy 之后又执行dfs了嘛；</span></span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></tbody></table></figure>

<p>####方法二：<br>我们也可以不使用哈希表的额外空间来保存已经拷贝过的结点，<br>而是将链表进行拓展，在每个链表结点的旁边拷贝，<br>比如 A-&gt;B-&gt;C 变成 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，<br>然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’，<br>最后返回 A’-&gt;B’-&gt;C’。<br>原链表上进行操作的，最后分开时也是在原链表上进行的操作，所以可以认为没有占用额外空间。<br>比如假如输入为数组，我们进行原地修改，最后返回数组的切片<br>数组切片是shallow copy, 空间复杂度依靠slice长度决定<br>函数要完成的目标所需的空间一般不算在空间复杂度内，<br>时间复杂度：O(N)<br>空间复杂度：O(1) 没有使用辅助空间或者使用了常数个辅助空间的情况下<br>原链表最后一个节点肯定指向null，所以可以不用处理<br>新旧链表断开后，新链表最后一个节点不需要再处理了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 根据遍历到的链表每个原节点创建对应的新节点，每个新创建的节点是在原节点后面加入链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 克隆新结点，把第一个 A 的值 赋给 node 为A‘，</span></span><br><span class="line">            new_node = Node(cur.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># 此时 node A' 的结点指向的是 原来A 的结点指向的下一个值</span></span><br><span class="line">            new_node.next = cur.next</span><br><span class="line">            <span class="comment"># 克隆新结点在cur 后面，将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">            cur.next = new_node</span><br><span class="line">            <span class="comment"># 将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，</span></span><br><span class="line">            <span class="comment"># 即为 A’ 结点 指向的下一个元素</span></span><br><span class="line">            cur = new_node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现新建的node的随机指针random指向的节点</span></span><br><span class="line">        <span class="comment"># 原节点1的随机指针指向原节点3，新节点1的随机指针指向的是原节点3的next</span></span><br><span class="line">        <span class="comment"># 原节点3的随机指针指向原节点2，新节点3的随机指针指向的是原节点2的next</span></span><br><span class="line">        <span class="comment"># 原节点i的随机指针(如果有的话)，指向的是原节点j</span></span><br><span class="line">        <span class="comment"># 那么新节点i的随机指针，指向的是原节点j的next</span></span><br><span class="line">        cur = head  <span class="comment"># 用头节点的随机指针</span></span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 迭代新创建的列表</span></span><br><span class="line">            <span class="comment"># 如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">            <span class="comment"># B 的 random 指针指向 A ，意味着 B 的下一个复制节点 B' 的 random 指针指向 A的random 的下一个节点A' 。</span></span><br><span class="line">            cur.next.random = cur.random.next <span class="keyword">if</span> cur.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 建好 这个元素的 random 的值，然后移动 指针 到下一个元素，</span></span><br><span class="line">            <span class="comment"># 来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="comment"># 当前元素 下一个的下一个 是复制的元素， 也是需要添加random 指向的元素。</span></span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开原来的node 和 新的node 之间的链接分离成原链表和复制的链表</span></span><br><span class="line">        <span class="comment"># =====法一========</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = Node(<span class="number">-1</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cur.next = p.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            p.next = cur.next</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># =====法二========</span></span><br><span class="line">        <span class="comment"># cur_old_list = head</span></span><br><span class="line">        <span class="comment"># # 复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        <span class="comment"># cur_new_list = head.next</span></span><br><span class="line">        <span class="comment"># # 复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        <span class="comment"># new_head = head.next</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="comment"># while cur_old_list:</span></span><br><span class="line">        <span class="comment">#     # 将旧链表 A 的指向结点改为 A’ 的指向的下一个 的B。</span></span><br><span class="line">        <span class="comment">#     cur_old_list.next = cur_old_list.next.next</span></span><br><span class="line">        <span class="comment">#     # 如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">        <span class="comment">#     # 那么就把 这个元素的A’ 的结点指向 改为 A’ 下一个 B 的下一个 的B’</span></span><br><span class="line">        <span class="comment">#     if cur_new_list.next:</span></span><br><span class="line">        <span class="comment">#         cur_new_list.next = cur_new_list.next.next</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         cur_new_list.next = None</span></span><br><span class="line">        <span class="comment">#     # 上面新链表的元素指针改好了，再更改 下一个旧链表的 元素</span></span><br><span class="line">        <span class="comment">#     # 改好的 A 的结点指向的B</span></span><br><span class="line">        <span class="comment">#     cur_old_list = cur_old_list.next</span></span><br><span class="line">        <span class="comment">#     # 将新链表的指针移位，来断开下一个链接，也就是 指针改为了 B’</span></span><br><span class="line">        <span class="comment">#     cur_new_list = cur_new_list.next</span></span><br><span class="line">        <span class="comment">#     # 如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line">        <span class="comment"># return new_head  # 最后返回这个复制好的新链表。</span></span><br><span class="line"> ```   </span><br><span class="line">    </span><br><span class="line">第三种方法：对于 python 可直接调用相关函数：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">return</span> copy.deepcopy(head)</span><br></pre></td></tr></tbody></table></figure>

<p>迭代<br>对于一个结点，<br>分别拷贝此结点、next 指针指向的结点、random 指针指向的结点，<br>然后进行下一个结点…如果遇到已经出现的结点，那么我们不用拷贝该结点，<br>只需将 next 或 random 指针指向该结点即可。</p>
<hr>
<h2 id="15-两个链表之间的第一个公共结点"><a href="#15-两个链表之间的第一个公共结点" class="headerlink" title="15.两个链表之间的第一个公共结点"></a>15.两个链表之间的第一个公共结点</h2><p><strong>输入两个链表，找出它们的第一个公共结点</strong><br>如图：<br><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%9A%84%E7%BB%93%E7%82%B9.png"></p>
<hr>
<p>题目要求输入输入的skipA /skipB 表示之前的节点即使值一样，<br>但是 是new 在堆上的 地址会不一样，而后续节点是通过引用进行连接的链表；<br>=》所以题目可以表述为在两个链表中找到共有的 引用链表的头结点<br>示例1里面输入把相交节点前的节点数分别给定死为2和3了，我试了下改为1和2，相交节点就是1了</p>
<p>A=[4,1,8,4,5]<br>B=[5,0,1,8,4,5]<br>1是值相同的两个不同节点，<br>8是存在于两个链表中的唯一节点，相交于结点 8。<br>链表是用类实现的，每个节点都是一个类的实例，<br>公共交点，节点共用，节点的地址（引用）相同，他的特征是数值和指针都相等，仅值相同不一定是同一节点，<br>判断node1 != node2 不是node1.val==node2.val，</p>
<p>法一：<br>两个链表长度分别为L1+C、L2+C，C为公共部分的长度，<br>L1,L2分别为两个链表在交点之前的开头不重复的部分</p>
<p>使用两个指针 node1，node2 分别指向两个链表 headA, headB 的头结点，</p>
<p>因为只有当node1==node2的时候，才会跳出 while (node1 != node2) 循环，<br>此时，返回node1和node2是一样的，因为相等。<br>而且node1此时只有两种情况：<br>1.node1为相交点</p>
<ol>
<li>如果两个链表的长度不一样,同时分别逐结点遍历，两次遍历，<br>当 node1 走了L1+C步后到达链表 headA 的末尾时，重新定位到链表 headB 的头结点，走L2步<br>当 node2 走了L2+C步后到达链表 headB 的末尾时，重新定位到链表 headA 的头结点，走L1步。</li>
</ol>
<p>L1+C+L2+C == L2+C+L1+C<br>L1+C+L2 == L2+C+L1<br>当两个人走的步数都为L1+L2+C时，一定是同时结束。<br>如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 </p>
<ol start="2">
<li>如果两个链表的长度一样，L1=L2，遍历一次就可以找到相交的起始节点</li>
</ol>
<p>2.不相交 C=0<br>a+None + b+None = b+None+ a+None ，<br>a+none+b长度与b+none+a长度相等<br>循环次数最多为a、b长度之和，如果不相交，会在ha==hb=None条件下（最后一个节点），退出循环。</p>
<p>  1.如果长度不相等，两个指针节点都需要遍历完链表L1+L2(L1+L2）长度，同时移动到尾节点指向None<br>然后node1==node2==None，while条件不成立，跳出循环，返回也是None，表示没有相交结点</p>
<ol start="2">
<li>如果两个链表的长度一样，遍历一次L1=L2，尾节点同时指向None，跳出循环了</li>
</ol>
<p>在每一个链表中使用了迭代，最多循环两次，因为每个指针最多遍历两个链表</p>
<p>法二<br>两个指针分别指向两个链表头部，<br>一起向前走直到其中一个到达末端，另一个与末端距离则是两链表的 长度差。<br>再通过长链表指针先走的方式消除长度差，最终两链表即可同时走到相交点。</p>
<p>换个方式消除长度差： 拼接两链表。<br>设长-短链表为 C，短-长链表为 D （分别代表长链表在前和短链表在前的拼接链表），<br>则当 C 走到长短链表交接处时，D 走在长链表中，且与长链表头距离为 长度差;</p>
<p>[5,0,1,8,4,5][4,1,8,4,5]<br>[4,1,8,4,5][5,0,1,8,4,5]  </p>
<p>短链表走到尽头后继续走长链表，就相当于短链表+长链表。<br>长链表走到尽头后又走短链表，相当于长链表+短链表。<br>所以重新走两次其实本质上还是相当于走两次新的拼接的互补链表，<br>这样，当它们相遇时，所指向的结点就是第一个公共结点。<br>当 ha == hb 时跳出，返回即可</p>
<p>我觉得时会有None出现的，因为headA+headB和headB+ headA长度一定是相等的，<br>假设没有相交，最后一位一定是ha.next == None, hb.next == None，退出循环，<br>然后假设有相交，那就是在某一非链尾位置，ha = =hb 就毋庸置疑了，<br>假设headA长度等于headB，<br>那么第一个None一定会退出，不论是否相交，<br>但是如果相交，既然headA和headB相等，<br>那一定在转换前就能完成==退出循环，<br>如果不相交，这时候ha == None，返回值就是None。</p>
<p>如果两个链表的长度不一样，需要两次遍历，第一次遍历是为了消除长度差，<br>找到长链表到尾结点的长度和短链表到尾结点的长度一样的节点处，<br>第二次遍历找到相交的起始节点。</p>
<p>指向长链表的指针先走 “两个链表长度的差值” 步，再两个指针一起走。<br>因为当短的链表指针走到末尾时，长的链表指针刚好距离末尾 “两个链表长度的差值” 步。<br>然后短链表的指针此时指向长链表的开头，两个指针一起走，靠近链表末尾的指针指向空时，<br>靠近开头的指针便走了 长度差值 步。然后此时指向空的指针再指向短链表的开头。<br>这时开始，两个指针距离相交节点的长度就是相同的，两个指针一起走，就能走到相交节点。</p>
<p>空间复杂度 O(1) 时间复杂度为 O(n)<br>其实也并不是常数系数省略，而是这里的两条链表同时在遍历，总路径是2(m+n)但是迭代次数是m+n所以时间复杂度为O(m+n)。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># 不是node1 = node1.next if node1.next else headB</span></span><br><span class="line">            <span class="comment"># 理解为两条链表最后都指向了同一个 null （None）节点，代替了不相交的特殊情况</span></span><br><span class="line">            <span class="comment"># 如果加next的话，那指针到最后一个结点就直接转链表了，</span></span><br><span class="line">            <span class="comment"># 因为你提前判断了它的next是否为空，就不会有null的情况了</span></span><br><span class="line">            <span class="comment"># 会一直死循环（如果不相交）。</span></span><br><span class="line">            <span class="comment"># 没有交点的情况可以约化为 交点为 None 的情况。（即将两链表末端的 None 看作交点）</span></span><br><span class="line">            <span class="comment"># 不用next，最后不相交的话会都等于None而结束循环</span></span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="16-合并两个排序的链表-本题考点-链表"><a href="#16-合并两个排序的链表-本题考点-链表" class="headerlink" title="16.合并两个排序的链表 [^本题考点  链表]"></a>16.合并两个排序的链表 [^本题考点  链表]</h2><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong><br>示例：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>构造链表的这种题一般都是需要两个量，一个存储链表头，一个不断移动进行构造。</p>
<ul>
<li><p>引入伪头节点：<br>由于初始状态合并链表中无节点，<br>因此循环第一轮时无法将节点添加到合并链表中。<br>解决方案：<br>初始化一个辅助节点 dum 作为合并链表的伪头节点， dum 的 val 属性不保存任何值<br>将各节点添加至 dum 之后，在整个链表合并完之后，返回它的下一位置即可指向结果链表的头部 ，哑结点可以不需要重复判空; </p>
</li>
<li><p>cur记录下一个插入位置的前一个位置，相当于一个游标，不断移动构造链表。<br>遍历链表的指针，每一次会指向新加入节点，将已合并链表添加至此节点后面。<br>如果不赋值给cur，用dum代替cur去做迭代的话，<br>那dum最终指向的是l1或l2的尾节点，<br>相当于没保存合并后链表的头结点，在构建完成后就没法找到链表头了。<br>先调整 cur 的 next 属性，再后移 cur</p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cur.next</span> = dum</span><br><span class="line"><span class="attr">cur</span> = cur.next</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第一种方法：  </p>
</li>
</ul>
<p>解题思路：</p>
<ul>
<li><p>根据题目描述， 链表 l<sub>1</sub> , l<sub>2</sub>是 递增 的，<br>因此容易想到使用双指针 l<sub>1</sub> 和 l<sub>2</sub> 遍历两链表，<br>根据 l<sub>1</sub>.val 和 l<sub>2</sub>.val 的大小关系确定节点添加顺序，<br>两节点指针交替前进，直至遍历完毕。</p>
</li>
<li><p>当 l1 和 l2 都不是空链表时，<br>比较两个链表的首结点，将较小值的节点则添加到第三个链表尾结点，<br>将对应链表中的节点向后移一位，并向前移动一个结点。<br>结果会有一个链表先遍历结束，或者没有<br>第三个链表尾结点指向剩余未遍历结束的链表<br>返回第三个链表首结点</p>
</li>
</ul>
<p>算法流程：  </p>
<ol>
<li><p>初始化： 伪头节点 dum ，节点 cur 指向 dum 。  </p>
</li>
<li><p>循环合并： 当 l<sub>1</sub> 或 l<sub>2</sub>    为空时跳出；</p>
</li>
<li><p>当 l<sub>1</sub>.val &lt; l<sub>2</sub>.val 时：<br>cur 的后继节点指定为 l<sub>1</sub> ，并 l<sub>1</sub> 向前走一步；<br>把 l1 当前的节点接在 cur 节点的后面同时将 l1 指针往后移一位</p>
</li>
<li><p>当 l<sub>1</sub>.val  ≥ l<sub>2</sub> .val 时：<br>cur 的后继节点指定为 l<sub>2</sub> ，并 l<sub>2</sub>向前走一步 ；</p>
</li>
<li><p>不管我们将哪一个元素接在了后面，我们都需要把 cur 向后移一位，即 cur = cur.next 。  </p>
</li>
<li><p>合并剩余尾部： 跳出时有两种情况，即 l<sub>1</sub> 为空 或 l<sub>2</sub> 为空。  </p>
</li>
<li><p>若 l<sub>1</sub> != null ： 将 l<sub>1</sub>添加至节点 cur 之后；</p>
</li>
<li><p>否则： 将 l<sub>2</sub> 添加至节点 cur 之后。<br>在循环终止的时候， l1 和 l2 至多有一个是非空的（还未被合并完），<br>由于输入的两个链表都是有序的，所以不管哪个链表是非空的，<br>它包含的所有元素都比前面已经合并链表中的所有元素都要大。<br>这意味着我们只需要简单地将非空链表接在合并链表的后面</p>
</li>
<li><p>返回值： 返回 dum.next 就是合并链表的头节点</p>
</li>
</ol>
<p>原地调整链表元素的 next 指针完成合并</p>
<p>时间复杂度 O(N) ：链表 l<sub>1</sub>, l<sub>2</sub> 的长度和，<br>l1 和 l2 只有一个元素会被放进合并链表中，<br>因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，</p>
<p>空间复杂度 O(1) ：节点引用 dum , cur 使用常数大小的额外空间存放若干变量。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># ListNode(0) 建立一个值为 0 的节点实例，不可变对象0也可以用None，开辟结点的内存空间，dum 引用 指向这个节点对象ListNode(0)</span></span><br><span class="line">        dum = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dum  <span class="comment"># 然后 cur 引用再指向 dum 对象，</span></span><br><span class="line">        <span class="comment"># cur 实际上就是保存 ListNode(0) 的地址，你可以随意声明变量去指向此节点~</span></span><br><span class="line">        <span class="comment"># 但 cur 和 dum 是两个独立变量，改变 cur，dum 仍然指向这个节点，所以没有变化~</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next, l1 = l1, l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next, l2 = l2, l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">or</span> l2  <span class="comment"># 等价于 x if x else y</span></span><br><span class="line">        <span class="keyword">return</span> dum.next  <span class="comment"># 返回第一个值  </span></span><br></pre></td></tr></tbody></table></figure>

<p>####第二种方法：递归<br>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，<br>所以我们只需要返回非空链表。<br>否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，<br>然后递归地决定下一个添加到结果里的节点。<br>如果两个链表有一个为空，递归结束。</p>
<p>我们判断 l1 和 l2 头结点哪个更小，<br>然后较小结点的 next 指针指向其余结点的合并结果。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></tbody></table></figure>
<p>其中时间复杂度可以这样计算：<br>给出一个递归算法，其时间复杂度 O(T) 通常是递归调用的数量（记作 {R}R） 和<br>计算的时间复杂度的乘积（表示为 O(s)）的乘积：(T) = R ∗ O(s)</p>
<p>时间复杂度：O(m+n)。<br>m，n 为 l<sub>1</sub>} 和 l<sub>2</sub> 的元素个数。<br>递归函数每次去掉一个元素，直到两个链表都为空，<br>因此需要调用 R=O(m+n) 次。<br>而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 O(1)，<br>故递归的总时间复杂度为 O(T)=R∗O(1)=O(m+n) 。</p>
<p>空间复杂度：O(m+n)。</p>
<p>对于递归调用 self.mergeTwoLists()，当它遇到终止条件准备回溯时，<br>已经递归调用了 m+nm+n 次，使用了 m+nm+n 个栈帧，<br>故最后的空间复杂度为 O(m+n)。</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8.png" alt="为两个递增的链表"><br><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8.png" alt="合并成一个单调不减链表"></p>
<p>输入的是两个链表的头结点，<br>最后返回的是合并链表的头结点。<br>但是输出结果却是一个完整的链表</p>
<p>因此我认为应该就是修改两个链表的引用指向实现合并~ 应该不用新建节点~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        <span class="comment">#首先判断两个链表是不是为空。</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="comment">#比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。</span></span><br><span class="line">        newHead = pHead1 <span class="keyword">if</span> pHead1.val &lt; pHead2.val <span class="keyword">else</span> pHead2</span><br><span class="line">        </span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="comment">#判断 如果新表头 是 表1 的头的话 那么 新表头</span></span><br><span class="line">        <span class="keyword">if</span> newHead == pTmp1:</span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        previousPointer = newHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pTmp1 <span class="keyword">and</span> pTmp2:</span><br><span class="line">            <span class="keyword">if</span> pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next = pTmp1</span><br><span class="line">                previousPointer = pTmp1</span><br><span class="line">                pTmp1 = pTmp1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                previousPointer.next = pTmp2</span><br><span class="line">                previousPointer = pTmp2</span><br><span class="line">                pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pTmp1 == <span class="literal">None</span>:</span><br><span class="line">        </span><br><span class="line">            previousPointer.next = pTmp2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            previousPointer.next = pTmp1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h2><p><strong>给你一个链表数组，每个链表都已经按升序排列。</strong><br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2：</p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure>

<p>思路：每个链表的第一个结点入堆，进行比较，最小的出堆，该链表往后移，然后找出堆链表中的后续入堆</p>
<p>python3的堆中链表无法比较大小，我们传入的是val和他所在的list(这是第几个链表)方便查找后续<br>heapq 模块传入的 tuple 对象里面不能有引用对象，就只好传一个索引进去了。<br>元组在heapq里比较的机制是从元组首位0开始，即遇到相同，就比较元组下一位，比如(1,2), (1,3)，前者比后者小。</p>
<p>ListNode无法被比较</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        minHeap = []</span><br><span class="line">        <span class="keyword">for</span> index, node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="comment"># index 用来记录这是第几个链表</span></span><br><span class="line">            <span class="comment"># node 是每个链表的头结点</span></span><br><span class="line">            <span class="keyword">if</span> node:  <span class="comment"># 只要头结点不空</span></span><br><span class="line">                <span class="comment"># 把k个链表的头结点的value以及该头结点所在的链表index入堆</span></span><br><span class="line">                heapq.heappush(minHeap, (node.val, index))</span><br><span class="line">        linkedlistHead = ListNode(<span class="number">-1</span>)  <span class="comment"># 伪头节点</span></span><br><span class="line">        linkedlistTail = linkedlistHead  <span class="comment"># 构建链表的结点</span></span><br><span class="line">        <span class="keyword">while</span> minHeap:</span><br><span class="line">            <span class="comment"># 堆内链表value最小的出堆，找到他是第几个链表，好找他的下一个位置</span></span><br><span class="line">            val, index = heapq.heappop(minHeap)</span><br><span class="line">            linkedlistTail.next = lists[index]  <span class="comment"># 加入到了结果集合中</span></span><br><span class="line">            linkedlistTail = linkedlistTail.next  <span class="comment"># 开始加下一个位置</span></span><br><span class="line">            lists[index] = lists[index].next  <span class="comment"># 找到当前链表的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> lists[index]:  <span class="comment"># 如果不空的话就让他入堆</span></span><br><span class="line">                heapq.heappush(minHeap, (lists[index].val, index))  <span class="comment"># 下一个元素入堆</span></span><br><span class="line">        <span class="keyword">return</span> linkedlistHead.next  <span class="comment"># 返回链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">4</span>, ListNode(<span class="number">5</span>)))</span><br><span class="line">    link2 = ListNode(<span class="number">1</span>, ListNode(<span class="number">3</span>, ListNode(<span class="number">4</span>)))</span><br><span class="line">    link3 = ListNode(<span class="number">2</span>, ListNode(<span class="number">6</span>))</span><br><span class="line">    node = Solution().mergeKLists([link1, link2, link3])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)  <span class="comment"># [1, 1, 2, 3, 4, 4, 5, 6]</span></span><br><span class="line">    print([link1, link2, link3])</span><br><span class="line">    <span class="comment"># [&lt;__main__.ListNode object at 0x000001CF45EA6FA0&gt;, &lt;__main__.ListNode object at 0x000001CF45EDD670&gt;, &lt;__main__.ListNode object at 0x000001CF45EDDC70&gt;]</span></span><br><span class="line">    print(type([link1, link2, link3]))  <span class="comment"># &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># minHeap = []</span></span><br><span class="line"><span class="comment"># index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 0)]</span></span><br><span class="line"><span class="comment"># index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 0), (1, 1)]</span></span><br><span class="line"><span class="comment"># index = 2</span></span><br><span class="line"><span class="comment"># minHeap[(1, 0), (1, 1), (2, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 1, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 1), (2, 2), (4, 0)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 1, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(2, 2), (4, 0)]</span></span><br><span class="line"><span class="comment"># minHeap = [(2, 2), (4, 0), (3, 1)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 2, index = 2</span></span><br><span class="line"><span class="comment"># minHeap = [(3, 1), (4, 0)]</span></span><br><span class="line"><span class="comment"># minHeap = [(3, 1), (4, 0)], (6, 2)]</span></span><br><span class="line"><span class="comment"># 第二个队列的第一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 3, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 0)], (6, 2)]</span></span><br><span class="line"><span class="comment"># 队列剩余元素入堆，调整为最小堆</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 0)], (6, 2), (4, 1)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 4, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 1), (6, 2)]</span></span><br><span class="line"><span class="comment"># 链表剩余元素入堆，调整为最小堆</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 1), (6, 2), (5, 0)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 4, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(5, 0), (6, 2)]</span></span><br><span class="line"><span class="comment"># 第2个链表已经空了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 5, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(6, 2)]</span></span><br><span class="line"><span class="comment"># 第1个链表已经空了</span></span><br><span class="line"><span class="comment"># minHeap = [(6, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 6, index = 2</span></span><br><span class="line"><span class="comment"># minHeap = [None, None, None]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 题目只用返回dum.next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地测试</span></span><br><span class="line"><span class="comment"># res = []</span></span><br><span class="line"><span class="comment"># node = dummy.next = 1</span></span><br><span class="line"><span class="comment"># res = [1]</span></span><br><span class="line"><span class="comment"># node = node.next = 1.next = 1</span></span><br><span class="line"><span class="comment"># res = [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># return </span></span><br></pre></td></tr></tbody></table></figure>

<p>贪心算法、优先队列<br>思路分析：<br>1、由于是 k 个排序链表，那么这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中最小的结点；</p>
<p>2、最小结点所在的链表的头结点就要更新了，更新成最小结点的下一个结点（如果有的话），此时还是这 k 个链表，这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中第 2 小的结点。</p>
<p>每一次都从这 k 个排序的链表头结点中拿出 val 最小的结点“穿针引线”成新的链表，这个链表就是题目要求的“合并后的排序链表”。“局部最优，全局就最优”，这不就是贪心算法的思想吗。</p>
<p>维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。<br>用最小堆完成，堆的元素个数是链表的个数k个。<br>不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。</p>
<p>这里我们举生活中的例子来理解这个思路。</p>
<blockquote>
<p>假设你是一名体育老师，有 3 个班的学生，他们已经按照身高从矮到高排好成了 3 列纵队，现在要把这 3 个班的学生也按照身高从矮到高排列 1 列纵队。我们可以这么做：<br>1、让 3 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身；<br>2、每一次队首的 3 名同学，请最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后面的所有同学都向前走一步（其实走不走都行，只要你能比较出站在你面前的 3 位在队首的同学同学的高矮即可）；<br>3、重复第 2 步，直到 3 个班的同学全部出列完毕。</p>
</blockquote>
<p>具体实现的时候，“每一次队首的 3 名同学，请最矮的同学出列”这件事情可以交给优先队列（最小堆、最小索引堆均可）去完成。在连续的两次出队之间完成“穿针引线”的工作。</p>
<p>时间复杂度：O(Nlogk)， N 是这 k 个链表的结点总数，考虑优先队列中的元素不超过 k 个<br>弹出操作时，比较操作的代价会被优化到O(logk)，同时找到最小值节点的时间为O(1)，<br>每一次从一个优先队列中选出一个最小结点的时间复杂度是 O(logk)，故时间复杂度为 O(Nlogk)。<br>空间复杂度：O(k)，考虑优先队列中的元素不超过 k 个，“穿针引线”需要常数个空间，因此空间复杂度为 O(k)。<br>O(n):创建一个新的链表空间开销为O(n)<br>O(1):以上代码采用了重复利用原有节点，所以只要O(1)的空间。<br>同时优先队列(通常用堆实现)需要O(k)的空间(远比大多数情况的N要小)</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="comment"># 针对一些特殊的测试用例，有的链表可能是空链表</span></span><br><span class="line">            <span class="keyword">if</span> lists[index]:</span><br><span class="line">                heapq.heappush(l, (lists[index].val, index))</span><br><span class="line"></span><br><span class="line">        dummy_node = ListNode(<span class="number">-1</span>)</span><br><span class="line">        cur = dummy_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            <span class="comment">#  _ 可以认为是一个变量的名字，因为这个变量后面不会再用到，所以使用 _ ，其实就是不想给这个变量起名字，但又得占一个位子的意思。</span></span><br><span class="line">            _, index = heapq.heappop(l)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定位到此时应该出列的那个链表的头结点</span></span><br><span class="line">            head = lists[index]</span><br><span class="line">            <span class="comment"># 开始“穿针引线”</span></span><br><span class="line">            cur.next = head</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="comment"># 同样不要忘记判断到链表末尾结点的时候</span></span><br><span class="line">            <span class="keyword">if</span> head.next:</span><br><span class="line">                <span class="comment"># 刚刚出列的那个链表的下一个结点成为新的链表头结点加入优先队列</span></span><br><span class="line">                heapq.heappush(l, (head.next.val, index))</span><br><span class="line">                <span class="comment"># 切断刚刚出列的那个链表的头结点引用</span></span><br><span class="line">                lists[index] = head.next</span><br><span class="line">                head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">4</span>, ListNode(<span class="number">5</span>)))</span><br><span class="line">    link2 = ListNode(<span class="number">1</span>, ListNode(<span class="number">3</span>, ListNode(<span class="number">4</span>)))</span><br><span class="line">    link3 = ListNode(<span class="number">2</span>, ListNode(<span class="number">6</span>))</span><br><span class="line">    node = Solution().mergeKLists([link1, link2, link3])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)</span><br></pre></td></tr></tbody></table></figure>


<p>优先队列</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)  <span class="comment"># 声明伪头节点和构建链表的节点</span></span><br><span class="line">        queue = PriorityQueue()  <span class="comment"># 声明优先队列</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lists:  <span class="comment"># 将输入的节点放入优先队列</span></span><br><span class="line">            <span class="keyword">if</span> item:</span><br><span class="line">                queue.put((item.val, queue))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> queue:  <span class="comment"># 循环迭代队列，队列为空结束</span></span><br><span class="line">            val, node = queue.get()  <span class="comment"># 每次取出队首节点</span></span><br><span class="line">            point.next = ListNode(val)  <span class="comment"># 将这个节点值放入最终有序列表之中</span></span><br><span class="line">            point = point.next  <span class="comment"># 指针指向下一个节点</span></span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node:  <span class="comment"># 下一个节点不为空</span></span><br><span class="line">                queue.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></tbody></table></figure>

<p>分治</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        amount = len(lists)  <span class="comment"># 输入列表的个数</span></span><br><span class="line">        interval = <span class="number">1</span>  <span class="comment"># 初始间隔设置为1</span></span><br><span class="line">        <span class="keyword">while</span> interval &lt; amount:  <span class="comment"># 将队列两两合并</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, amount - interval, interval * <span class="number">2</span>):</span><br><span class="line">                lists[i] = self.merge2Lists(lists[i], lists[i + interval])</span><br><span class="line">            interval *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>] <span class="keyword">if</span> amount &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)  <span class="comment"># 声明头节点和构建链表节点</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:  <span class="comment"># 将两个链表头节点进行比较</span></span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                point.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                point.next = l2</span><br><span class="line">                l2 = l1</span><br><span class="line">                l1 = point.next.next</span><br><span class="line">            point = point.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            point.next = l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            point.next = l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""分治合并"""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span>(<span class="params">list1, list2</span>):</span></span><br><span class="line">            <span class="string">"""list1和list2分别是两个链表的头结点"""</span></span><br><span class="line">            head = ListNode(<span class="number">0</span>)  <span class="comment"># 新建一个头节点用来返回list1和list2的排序后结果</span></span><br><span class="line">            dummy = head  <span class="comment"># 指向head链表的尾部，用来拆入新节点</span></span><br><span class="line">            <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:  <span class="comment"># 两个链表都不为空时</span></span><br><span class="line">                <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                    dummy.next = list1  <span class="comment"># 插入新节点</span></span><br><span class="line">                    dummy = list1  <span class="comment"># dummy指向新插入的节点</span></span><br><span class="line">                    list1 = list1.next  <span class="comment"># 移动list1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dummy.next = list2</span><br><span class="line">                dummy = list2</span><br><span class="line">                list2 = list2.next</span><br><span class="line">            dummy.next = list2 <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">else</span> list1  <span class="comment"># 如果list1为None，说明list1中的元素全部进入了head链表，所以把list2中剩余的元素直接添加进来，反之亦然。</span></span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="comment"># print(merge2Lists(lists[1], lists[2]))</span></span><br><span class="line"></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">divideMergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">            <span class="string">"""分治归并k个链表"""</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            k = len(lists)</span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span>  <span class="comment"># lists为空，直接结束</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span> :  <span class="comment"># 归并结束</span></span><br><span class="line">                res = lists[<span class="number">0</span>]  <span class="comment"># 保存结果</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> == k:  <span class="comment"># k为奇数，i的最后一个取值是k-1，此时i+1已经超出范围</span></span><br><span class="line">                    temp.append(lists[i])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 如果k为偶数，i的最后一个取值永远是k-2</span></span><br><span class="line">                temp.append(merge2Lists(lists[i], lists[i+<span class="number">1</span>]))</span><br><span class="line">            divideMergeKLists(temp)</span><br><span class="line"></span><br><span class="line">        divideMergeKLists(lists)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<h2 id="23-合并K个链表-没有利用各个链表是升序的特点"><a href="#23-合并K个链表-没有利用各个链表是升序的特点" class="headerlink" title="23. 合并K个链表 没有利用各个链表是升序的特点"></a>23. 合并K个链表 没有利用各个链表是升序的特点</h2><p>思路：</p>
<ol>
<li>读取所有链表值</li>
<li>构造一个最小堆 heapq 很容易实现</li>
<li>根据最小堆构造一个链表</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        h = []  <span class="comment"># 定义最小堆</span></span><br><span class="line">        <span class="comment"># 读取所有节点值</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                h.append(node.val)</span><br><span class="line">                node = node.next  <span class="comment"># 后移节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造一个最小堆</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h:  <span class="comment"># h为空，直接返回None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        heapq.heapify(h)  <span class="comment"># 转换成最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造链表</span></span><br><span class="line">        root = ListNode(heapq.heappop(h))  <span class="comment"># 弹出最小的值作为根节点</span></span><br><span class="line">        curnode = root  <span class="comment"># 当前节点</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            nextnode = ListNode(heapq.heappop(h))  <span class="comment"># 构造下一个节点</span></span><br><span class="line">            curnode.next = nextnode  <span class="comment"># 当前next指向下一个节点</span></span><br><span class="line">            curnode = nextnode  <span class="comment"># 当前节点后移</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="comment"># 首先 for 嵌套 while 就是将所有元素都取出放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                heapq.heappush(heap, node.val)</span><br><span class="line">                node = node.next</span><br><span class="line">        dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment"># 依次将小顶堆中的元素取出，每次出来的都是目前堆中值最小的元素，然后重新构建一个列表返回</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            temp_node = ListNode(heappop(heap))</span><br><span class="line">            cur.next = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>删除列表中的重复元素</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list1:</span><br><span class="line">    list1.sort()</span><br><span class="line">last = list1[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> last == list1[i]:</span><br><span class="line">        <span class="keyword">del</span> list1[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last = list1[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>可以使用内置的set方法<br>list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>list2 = list(set(list1))<br>print list2</p>
<p>速度更快的一种方法<br>list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>list2 = {}.fromkeys(list1).keys()<br>print list2<br>1<br>2<br>3<br>但是通过这两种方法获得的list2排序变了，如果想维持原来list的排序可以通过以下方法：</p>
<p>用list类的sort方法<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = list(set(l1))<br>l2.sort(key=l1.index)<br>print l2</p>
<p>也可以这样写<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = sorted(set(l1),key=l1.index)<br>print l2</p>
<p>也可以用遍历（看起来比较蠢）<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = []<br>for i in l1:<br>    if not i in l2:<br>        l2.append(i)<br>print l2</p>
<p>上面的代码也可以这样写<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = []<br>[l2.append(i) for i in l1 if not i in l2]<br>print l2</p>
<hr>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><p><strong>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</strong></p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的肯定连续，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>迭代<br>单指针 解题思路<br>用cur表示当前节点<br>初始化 cur 指针指向头部 head</p>
<p>while循环遍历链表<br>结束条件为：遍历完链表，即 cur.next 为空；头结点 head 可能为空，则也需要判断 cur 是否为空，如果所给链表为空直接返回，否则在执行cur.next这部操作时会因为cur为NULL而造成执行时错误<br>当二者有一个不存在时说明链表没有去重复的必要了</p>
<p>遍历过程中：<br>(1)如果该节点出元素与下一节点元素相同时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果<br>(2)如果不相等则 cur 移动到下一个位置继续循环</p>
<p>细节分析<br>需要判断 head 是否为空:<br>(1) 可在开头判断 head 是否为空<br>(2) 也可在 while 循环中判断 cur 是否为空</p>
<p>为什么如果前后两节点元素相同，删除后节点，而不用 cur = cur.next 操作？<br>答：是因为删除该节点的下一节点，该节点仍需要和新的下一节点进行比较</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，其中 n 是列表中的结点数。</p>
<p>空间复杂度：O(1)，没有使用额外的空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.next.val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">1</span>, ListNode(<span class="number">5</span>, ListNode(<span class="number">5</span>))))</span><br><span class="line">    node = Solution().deleteDuplicates(link1)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)  <span class="comment"># [1, 5]</span></span><br><span class="line"><span class="comment"># cur.val = head.val = 1 = cur.next.val</span></span><br><span class="line"><span class="comment"># cur.next.val = cur.next.next.val = 5</span></span><br><span class="line"><span class="comment"># cur.val = cur.next.val = 5</span></span><br><span class="line"><span class="comment"># cur.next.val = cur.next.next.val = 5.next.next.val = None</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：双指针<br>定义两个指针，一个指向头节点，另外一个指向头节点的下一节点，不断遍历；</p>
<p>边遍历边比较这两个指针指向的节点的值，如果值相等的话，当前节点就指向其下下个节点（相当于删除了其下一节点），然后继续遍历，否则不做处理直接继续遍历，直到遍历完整个链表。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        cur, next = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> next:</span><br><span class="line">            <span class="keyword">if</span> next.val != cur.val: cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>: cur.next = next.next</span><br><span class="line">            next = next.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        slow = dummy</span><br><span class="line">        fast = dummy.next</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> slow.val == fast.val:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow.next = fast</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line"><span class="comment"># slow = dummy = 0</span></span><br><span class="line"><span class="comment"># fast = head = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 1.next = 1</span></span><br><span class="line"><span class="comment"># slow = slow.next = 0.next = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 1.next = 5</span></span><br><span class="line"><span class="comment"># slow.next = fast = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 5.next = 5</span></span><br><span class="line"><span class="comment"># slow = slow.next = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 5.next = None</span></span><br><span class="line"><span class="comment"># slow.next = fast = None</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三：递归<br>解题思路<br>递归写法的删除节点操作是 通过返回下一节点 连接到上一节点，实现参数节点(即当前节点)的删除</p>
<p>把一个链表看成头节点后挂接一个更短的链表，依次类推。所以可以先处理头节点后面挂接的更短的链表，如果头节点的值等于其挂接的更短的链表的头节点的值，则直接返回更短的链表的头节点，否则返回原链表的头节点。</p>
<p>终止条件: 遍历完链表<br>(1) head 为空，即空链表<br>(2) head.next 为空 链表只有头节点。</p>
<p>终止处理: 返回当前节点</p>
<p>提取重复逻辑:<br>(1) 节点的”连接”: 利用函数返回值作为下一节点<br>(2) 节点的”删除”: 判断是否当前节点元素与下一节点元素是否相同, 返回相应的节点</p>
<p>递归函数返回的不重复子链的头结点，<br>在回溯过程中，比较当前节点和子链头结点的val是否相同，若相同则保留当前节点（删除子链的头结点）。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line">        <span class="keyword">if</span> head.val == head.next.val:</span><br><span class="line">            head.next = head.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"><span class="comment"># 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6</span></span><br><span class="line"><span class="comment"># head = 1</span></span><br><span class="line"><span class="comment"># self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#     head = head.next = 1.next = 1</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(1)</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#         head = head.next = 1.next = 5</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#         因为 head.next = 5.next = 5，所以</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#             head = head.next = 5.next = 5</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#                 head = head.next = 5.next = 6</span></span><br><span class="line"><span class="comment">#                 self.deleteDuplicates(6)</span></span><br><span class="line"><span class="comment">#                 因为head.next = 5.next = None，所以</span></span><br><span class="line"><span class="comment">#                 return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             返回上一层，</span></span><br><span class="line"><span class="comment">#             head.next = return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             head.val = 5 != head.next.val = 6</span></span><br><span class="line"><span class="comment">#             return head = 5</span></span><br><span class="line"><span class="comment">#         返回上一层</span></span><br><span class="line"><span class="comment">#         head.val = 5 = head.next.val</span></span><br><span class="line"><span class="comment">#         head.next = head.next.next = 6</span></span><br><span class="line"><span class="comment">#         return head = 5</span></span><br><span class="line"><span class="comment">#     返回上一层</span></span><br><span class="line"><span class="comment">#     head.val = 1 != head.next.val = 5</span></span><br><span class="line"><span class="comment">#     return head = 1</span></span><br><span class="line"><span class="comment"># 返回上一层</span></span><br><span class="line"><span class="comment"># head.val = 1 = head.next.val</span></span><br><span class="line"><span class="comment"># head.next = head.next.next = 5</span></span><br><span class="line"><span class="comment"># return head = 1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 删除头节点后面挂接的链表中的重复元素</span></span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 头节点与后面挂接的链表中的节点值相同，则头节点也删除，否则不删除</span></span><br><span class="line">        <span class="keyword">return</span> head.next <span class="keyword">if</span> head.val == head.next.val <span class="keyword">else</span> head</span><br><span class="line"><span class="comment"># 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6</span></span><br><span class="line"><span class="comment"># head = 1</span></span><br><span class="line"><span class="comment"># self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#     head = head.next = 1.next = 1</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(1)</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#         head = head.next = 1.next = 5</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#         因为 head.next = 5.next = 5，所以</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#             head = head.next = 5.next = 5</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#                 head = head.next = 5.next = 6</span></span><br><span class="line"><span class="comment">#                 self.deleteDuplicates(6)</span></span><br><span class="line"><span class="comment">#                 因为head.next = 5.next = None，所以</span></span><br><span class="line"><span class="comment">#                 return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             返回上一层</span></span><br><span class="line"><span class="comment">#             head.next = return head = 6</span></span><br><span class="line"><span class="comment">#             head.val = 5 != head.next.val = 6</span></span><br><span class="line"><span class="comment">#             return head = 5</span></span><br><span class="line"><span class="comment">#         返回上一层</span></span><br><span class="line"><span class="comment">#         head.val = 5 = head.next.val</span></span><br><span class="line"><span class="comment">#         return head.next = 5</span></span><br><span class="line"><span class="comment">#     返回上一层</span></span><br><span class="line"><span class="comment">#     head.val = 1 != head.next.val = 5</span></span><br><span class="line"><span class="comment">#     return head = 1</span></span><br><span class="line"><span class="comment"># 返回上一层</span></span><br><span class="line"><span class="comment"># head.val = 1 = head.next.val</span></span><br><span class="line"><span class="comment"># return head.next = 1</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == head.next.val:</span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(head.next)</span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>


<hr>
<h2 id="17-圆圈中最后剩下的数-本题考点-模拟"><a href="#17-圆圈中最后剩下的数-本题考点-模拟" class="headerlink" title="17.圆圈中最后剩下的数 [^本题考点 模拟]"></a>17.圆圈中最后剩下的数 [^本题考点 <em>模拟</em>]</h2><p><strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%B8%B8%E6%88%8F.png"><br>思路分析：</p>
<p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p>
<p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p>
<p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p>
<p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p>
<p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p>
<p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p>
<p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p>
<p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p>
<p>f(n-1) = iii</p>
<p>所以 f(n) = f `(n-1) = (iii+m)%n</p>
<p>所以 f(n) = (f(n-1)+m)</p>
<p>那么这个通项表达式我们就找到了，再去编写代码。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="comment">#返回编号</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="18-链表中环的入口点-本题知识点-链表"><a href="#18-链表中环的入口点-本题知识点-链表" class="headerlink" title="18.链表中环的入口点 [^本题知识点  链表]"></a>18.链表中环的入口点 [^本题知识点  链表]</h2><p><strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span></span><br><span class="line">        <span class="comment">#循环跳</span></span><br><span class="line">        <span class="comment">#要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        <span class="comment">#定义两个指针，一个快的一个慢的。</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        slowPointer = pHead</span><br><span class="line">        <span class="comment">#当快指针存在时，而且快指针的结点指向的下一个也存在</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer <span class="keyword">and</span> fastPointer.next :</span><br><span class="line">            <span class="comment">#那么让快指针走两步</span></span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            <span class="comment">#让慢指针走一步</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">            <span class="comment">#如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span></span><br><span class="line">            <span class="keyword">if</span> fastPointer == slowPointer:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span></span><br><span class="line">        <span class="keyword">if</span> fastPointer == <span class="literal">None</span> <span class="keyword">or</span> fastPointer.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span></span><br><span class="line">        <span class="comment">#假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 那么  L = s + d</span></span><br><span class="line">        <span class="comment">#假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span></span><br><span class="line">        <span class="comment"># fast 走的长度 就是 ( m + d ) * n + d + s = 2 L</span></span><br><span class="line">        <span class="comment">#带入 ( m + d ) * n + d + s = 2 （s + d ）</span></span><br><span class="line">        <span class="comment"># s = m + (n-1)(m+d)</span></span><br><span class="line">        <span class="comment">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        <span class="comment">#此时慢指针还在环里走着，没有走到结点</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer != slowPointer:</span><br><span class="line">            fastPointer = fastPointer.next</span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        <span class="comment">#当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span></span><br><span class="line">        <span class="keyword">return</span> fastPointer</span><br></pre></td></tr></tbody></table></figure>



<p>定义：</p>
<p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p>
<p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p>
<p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p>
<p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p>
<p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p>
<p>那么 L = s + d</p>
<p>2L = 2(s+d) = n*(m + d) + d + s</p>
<p>由上面公式 推导出 n(m+d) = s + d</p>
<p>得到：s = n(m+d) -d；</p>
<p>s = nm + (n-1)(d)<br>s = m + (n-1)(m+d)</p>
<hr>
<h2 id="19-二进制中的1的个数"><a href="#19-二进制中的1的个数" class="headerlink" title="19.二进制中的1的个数"></a>19.二进制中的1的个数</h2><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</strong></p>
<p>输入是整数~ 但是都是二进制存储的，当我们用位运算操作时，就应该展开成二进制来分<br>输出该二进制串的 1 的个数</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a><code>知识点:</code></h4><p>方法一：逐位判断</p>
<ul>
<li>根据 与运算 定义，设二进制数字 n ，则有：<ul>
<li>若 n&amp;1=0 ，则 n 二进制 最右一位 为 0 ；</li>
<li>若 n&amp;1=1 ，则 n 二进制 最右一位 为 1 。</li>
</ul>
</li>
<li>根据以上特点，考虑以下 循环判断 ：<ol>
<li>判断 n 最右一位是否为 1 ，根据结果计数。</li>
<li>将 n 右移一位（本题要求把数字 n 看作无符号数unsigned value，因此使用 无符号右移 操作，输入是正数负数都可以）。</li>
</ol>
</li>
</ul>
<p>算法流程：<br>1.初始化数量统计变量 res = 0 。<br>2.循环逐位判断： 当 n = 0 时跳出。<br>  1.res += n &amp; 1 ： 若 n&amp;1=1 ，则统计数 res 加一。<br>  2.n &gt;&gt;= 1 ： 将二进制数字 n 无符号右移一位。<br>  对于负数，最高位为 1 ，有符号右移 最高位填1，因此无法达到 n = 0，就无法跳出循环了<br>返回统计数量 res 。</p>
<p>时间复杂度 O(log_2 n)此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；<br>取决于循环次数，而循环次数取决于数字 n 的“位数”，数字 n 的位数是 log n<br>逐位判断需循环 log_2 n 次，<br>log n 代表数字 n 最高位的 1 的所在位数，<br>因为二进制最高位 $1$ 决定了循环位移次数~<br>（例如 log_2 4 = 2, log_2 16 = 4）。</p>
<p>空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。</p>
<p>无符号的整数</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<p>python的int无限宽度，是不会溢出的，达到界限后会自己转为long<br>算法中需要用到了32位int的溢出来参与运算，<br>有的结果却需要溢出的int作为参数继续参与运算<br>在python上想实现溢出效果，找到一个函数<br>这个函数可以得到32位int溢出结果</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="number">123456789</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 129453825982464</span></span><br><span class="line">print(bin(ret))</span><br><span class="line"><span class="comment"># 0b11101011011110011010001010100000000000000000000</span></span><br><span class="line"><span class="comment"># 明显已经超出32位了</span></span><br></pre></td></tr></tbody></table></figure>

<p>在JS上<br>document.writeln(123456789 &lt;&lt; 20);<br>得到结果是-783286272<br>这就是溢出后截取的</p>
<p>无符号右移&gt;&gt;&gt;，就是将有符号int a和b转为无符号uint后，再进行普通右移&gt;&gt;运算<br>比如-1的有符号int就是-1，无符号int就是4294967295<br>在JS中，可以使用 a&gt;&gt;&gt;b来实现无符号位移，<br>python中没有这个运算符，只能自己实现了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_overflow</span>(<span class="params">val</span>):</span></span><br><span class="line">    maxint = <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> -maxint - <span class="number">1</span> &lt;= val &lt;= maxint:</span><br><span class="line">        val = (val + (maxint + <span class="number">1</span>)) % (<span class="number">2</span> * (maxint + <span class="number">1</span>)) - maxint - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = int_overflow(<span class="number">123456789</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">print(ret)  <span class="comment"># -783286272 和JS的结果一样</span></span><br><span class="line">print(bin(ret))</span><br><span class="line"><span class="comment"># -0b101110101100000000000000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsigned_right_shitf</span>(<span class="params">n, i</span>):</span></span><br><span class="line">    <span class="string">"""无符号右移"""</span></span><br><span class="line">    <span class="comment"># 数字小于0，则转为32位无符号uint</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        n = ctypes.c_uint32(n).value</span><br><span class="line">    <span class="comment"># 正常位移位数是为正数，但是为了兼容js之类的，</span></span><br><span class="line">    <span class="comment"># 负数就右移变成左移好了</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -int_overflow(n &lt;&lt; abs(i))</span><br><span class="line">    <span class="comment"># print(n)</span></span><br><span class="line">    <span class="keyword">return</span> int_overflow(n &gt;&gt; i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = unsigned_right_shitf(<span class="number">-1</span>, <span class="number">20</span>)</span><br><span class="line">print(ret)  <span class="comment"># 4095</span></span><br><span class="line"><span class="comment"># 和JS上执行 -1 &gt;&gt;&gt; 20 一样。</span></span><br></pre></td></tr></tbody></table></figure>


<p>如果 python 输入有符号整数时的情况，由于 python 存储负数的特殊性，<br>循环右移操作不能正常终止，因此需要先获取n 的补码，再开始右移~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二：巧用 n&amp;(n − <span class="number">1</span>)</span><br><span class="line">- (n - <span class="number">1</span>) 解析： 二进制数字 n 最右边的 <span class="number">1</span> 变成 <span class="number">0</span> ，此 <span class="number">1</span> 右边的 <span class="number">0</span> 都变成 <span class="number">1</span> 。</span><br><span class="line">- n&amp;(n − <span class="number">1</span>) 解析： 二进制数字 n 最右边的 <span class="number">1</span> 变成 <span class="number">0</span> ，其余不变。</span><br><span class="line"></span><br><span class="line">算法流程：  </span><br><span class="line"><span class="number">1.</span>初始化数量统计变量 res 。  </span><br><span class="line"><span class="number">2.</span>循环消去最右边的   </span><br><span class="line">  <span class="number">1.</span> 当 n = <span class="number">0</span> 时说明没有一个<span class="number">1</span>了,跳出。</span><br><span class="line">  <span class="number">1.</span> res += <span class="number">1</span> ： 统计变量加 <span class="number">1</span> ；</span><br><span class="line">  <span class="number">2.</span> n &amp;= n - <span class="number">1</span> ： 消去数字 n 最右边的 <span class="number">1</span>  </span><br><span class="line">  我们消除了多少<span class="number">1</span>变成一个<span class="number">1</span>都没有了， 就说明n有多少个<span class="number">1</span>了</span><br><span class="line">  n&amp;(n<span class="number">-1</span>) 还可以用来判断 n 是否是 <span class="number">2</span> 的幂~</span><br><span class="line">   </span><br><span class="line"><span class="number">3.</span>返回统计数量 res 。</span><br><span class="line">时间复杂度 O(M) ： n&amp;(n−<span class="number">1</span>) 操作仅有减法和与运算，占用 O(<span class="number">1</span>) ；</span><br><span class="line">设 M 为二进制数字 n 中 <span class="number">1</span> 的个数，则需循环 M 次（每轮消去一个 <span class="number">1</span> ），占用 O(M) 。</span><br><span class="line">空间复杂度 O(<span class="number">1</span>) ： 变量 res 使用常数大小额外空间。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<hr>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>给你两个&nbsp;非空 的链表，表示两个非负的整数。它们每位数字都是按照&nbsp;逆序&nbsp;的方式存储的，并且每个节点只能存储&nbsp;一位&nbsp;数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。<br>示例 1：<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br>示例 2：</p>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]<br>示例 3：</p>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">system_change</span>(<span class="params">self, l3</span>):</span></span><br><span class="line">        pp = l3</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> l3.val &gt;= <span class="number">10</span>:</span><br><span class="line">                l3.val = l3.val - <span class="number">10</span></span><br><span class="line">                tm, l3 = l3, l3.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> l3:</span><br><span class="line">                    tm.next = ListNode(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l3.val += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l3 = l3.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l3:</span><br><span class="line">                <span class="keyword">return</span> pp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p3 = p3h = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">                <span class="keyword">if</span> p3:</span><br><span class="line">                    p3.next = ListNode(p1.val + p2.val)</span><br><span class="line">                    p3 = p3.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p3h = p3 = ListNode(p1.val + p2.val)</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p2 = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> p2 <span class="keyword">and</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p1 = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (p1 <span class="keyword">and</span> p2):</span><br><span class="line">                <span class="keyword">return</span> self.system_change(p3h)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="20-不用加减乘除做加法-本题考点-按位运算"><a href="#20-不用加减乘除做加法-本题考点-按位运算" class="headerlink" title="20.不用加减乘除做加法[^本题考点 按位运算]"></a>20.不用加减乘除做加法[^本题考点 <em>按位运算</em>]</h2><p>*<em>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、</em>、/四则运算符号。**</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E6%B3%95%E7%AE%97%E5%92%8C%E8%BF%90%E7%AE%97.png"><br>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数 Overflow<br>题目给定的输入值的位数不会超过32，</p>
<p>题目说不能使用运算符 + 和 -，那么我们就要使用其他方式来替代这两个运算符的功能。</p>
<p>以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；<br>101 + 10001 = 10110<br>第一步：各位相加 但不进位： 不进位的话 结果为 10100 </p>
<p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p>
<p>第三步： 把前面两个结果相加，得到的结果是 10110.</p>
<p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p>
<p>位运算中的两数加法，不考虑 进位<br>其实来来回回就只有下面这四种：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       无进位和        进位 </span><br><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span>             <span class="number">0</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span>             <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span>             <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span>             <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>无进位和 符合 相同位为 0，不同位为 1 的异或运算规律，无进位加法。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span> = <span class="number">0101</span></span><br><span class="line">b = <span class="number">4</span> = <span class="number">0100</span></span><br><span class="line"></span><br><span class="line">a ^ b 如下：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">-------</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>a ^ b 得到了一个无进位加法结果，如果要得到 a + b 的最终值，<br>我们还要找到进位的数，把这二者相加。<br>在位运算中，我们可以使用与 &amp; 运算：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span> = <span class="number">0101</span></span><br><span class="line">b = <span class="number">4</span> = <span class="number">0100</span></span><br><span class="line"></span><br><span class="line">a &amp; b 如下：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">-------</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>由计算结果可见，0100 并不是我们想要的进位，<br>1 + 1 所获得的进位应该要放置在它的更高位，即左侧位上，<br>因此我们还要把 0100 左移一位，a&amp;b&lt;&lt;1，得到它 向前进位的值</p>
<p>总结一下：<br>1.a + b 和 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)<br>2.无进位加法使用异或运算计算得出 a^b<br>3.进位结果使用与运算和左移一位移位运算计算得出 。a&amp;b&lt;&lt;1<br>4.将上述两结果“相加”即可得到最终结果，但是，我们没有加号，<br>循环此过程，重复把前面两个步骤的结果再相加，但是这次的 数值 改为上次的两个结果，<br>判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。<br>直到进位为 0，此时 和 = 无进位结果 ，返回 无进位结果</p>
<p>时间复杂度 O(1) ： 最差情况下，例如 a = 0x7fffffff , b = 1 时，<br>每次循环b左移一位，b 从右数 必增加一个 0 ,<br>循环31次后，b=0x80000000，也就是最高位还是1，<br>还得再循环一次，所以一共32次将 b 变为 0 。<br>每轮中的常数次位操作</p>
<p>空间复杂度 O(1) ： 使用常数大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, a: int, b: int</span>) -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 由于 b = (a &amp; b) &lt;&lt; 1 &amp; x 中有左移操作，</span></span><br><span class="line">            <span class="comment"># 因此需要每轮和 x 与一下，</span></span><br><span class="line">            <span class="comment"># 以保证 b 是 32 位数（高位全部为 0 ）</span></span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="comment"># a &lt;= 0x7fffffff(最大的正数的补码)， a 是正数，</span></span><br><span class="line">        <span class="comment"># 正常的补码直接返回自己本身</span></span><br><span class="line">        <span class="comment"># 是负数 32 位以上的位取反，1 至 32 位不变</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></tbody></table></figure>
<p>Q :  若数字 a 和 b 中有负数，则变成了减法，如何处理？<br>A ： 在计算机系统中，数值一律用 补码 来表示和存储、运算<br>补码的优势： 加法、减法可以统一处理（CPU只有加法器）。</p>
<p>c java等是有位数限制的，所以可以直接做。<br>C语言版本输出a时，是采用补码格式输出的，<br>问题是在于C语言版本中int是32位的，进入下最后一个循环后，<br>b左移一位后，最高位的1就溢出了，那么b就变成了0.</p>
<p>其实和python输出的前32项是一模一样的，<br>在32位的系统中int类型的表示范围为[-231,231-1],<br>在python 是某种程度上位数可以无限扩展，<br>也就无所谓补码，因为补码都是相对于位数来说的，32 位补码和 16 位补码，<br>肯定是不一样的。但是这样就导致了一个问题，就是无法直接得到32位二进制补码。<br>如果补码超过了2**31-1这个边界,那么他代表的原码就是一个负数,<br>我们需要将它转换成对应的源码<br>0x80000000 的二进制是 0b10000000000000000000000000000000，为2^31次方<br>0x8000000是32位有符号整型的最小值,<br>直接输入大于0x80000000的数时，计算机将其处理为原码而非补码。</p>
<p>结果左移的1跑到33位，b仍然不是0，实际上永远也不是0，<br>于是就无限循环了，不会导致溢出.</p>
<hr>
<h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</strong><br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a><br>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">长度为<span class="number">9</span>的数组。由于数字<span class="number">2</span>在数组中出现了<span class="number">5</span>次，超过数组长度的一半，因此输出<span class="number">2</span>。。</span><br></pre></td></tr></tbody></table></figure>

<p>众数（Mode）是指在统计分布上具有明显集中趋势点的数值，代表数据的一般水平。<br>也是一组数据中出现次数最多的数值，有时众数在一组数中有好几个。</p>
<p>本题超过长度一般</p>
<p>法一：<br>摩尔投票法Boyer-Moore：</p>
<ul>
<li><p>票数和： 由于众数出现的次数超过数组长度的一半；<br>若记候选 众数 的票数为 +1 ，非众数 的票数为 -1 ，<br>则一定有所有数字的 票数和 &gt; 0 。</p>
</li>
<li><p>票数正负抵消： 设数组 nums 中的众数为 candidate ，数组长度为 n 。<br>若 nums 的前 a 个数字的 票数和 = 0 ，<br>则 数组后 (n-a) 个数字的 票数和一定仍 &gt;0<br>（即后 (n−a) 个数字的 众数仍为 candidate ）</p>
</li>
</ul>
<p>算法原理：</p>
<ul>
<li><p>为构建正负抵消，假设数组首个元素 n_1 为众数，<br>遍历统计票数，当发生正负抵消时，<br>剩余数组的众数一定不变 ，这是因为（设真正的众数为 candidate ）：</p>
<ul>
<li>当 n_1 = candidate： 抵消的所有数字中，有一半是众数 candidate 。</li>
<li>当 n_1 !=candidate ： 抵消的所有数字中，少于或等于一半是众数 candidate 。</li>
</ul>
</li>
<li><p>利用此特性，每轮假设都可以 缩小剩余数组区间 。<br>当遍历完成时，最后一轮假设的数字即为众数<br>（由于众数超过一半，最后一轮的票数和必为正数）。</p>
</li>
</ul>
<p>算法流程:  </p>
<ol>
<li>初始化： 票数统计 votes = 0 ， 众数 candidate可以为任意值；  </li>
<li>循环抵消： 遍历数组 nums 中的每个元素 num ；</li>
<li>当 票数 votes 等于 0 ，则假设 当前数字 num 的值赋予为 众数 candidate ；</li>
<li>当 num = candidate 时，票数 votes 自增 1 ；<br>否则，num != candidate 时，票数 votes 自减 1 。<br>遍历完成后，candidate 即为整个数组的众数。</li>
<li>返回值： 返回 众数 candidate </li>
</ol>
<p>若没有选中众数，那么迭代的时候这个数就会因为它出现次数小于一半，而重新选择其他数。如果选中了众数，那么count可能大于零小于0，最终是大于0.<br>如果是其他数，又会count到0.</p>
<p>时间复杂度 O(N) ： N 为数组 nums 长度，对数组进行了一次遍历。<br>空间复杂度 O(1) ： votes 变量使用常数级别大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        votes = <span class="number">0</span></span><br><span class="line">        candidate = <span class="literal">None</span>  <span class="comment"># 可省略</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            <span class="keyword">if</span> num == candidate:</span><br><span class="line">                votes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                votes += <span class="number">-1</span></span><br><span class="line">            <span class="comment"># votes += (1 if num == candidate else -1)</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.majorityElement(arr))  <span class="comment"># 2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = None</span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">1</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> != candidate = <span class="number">1</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">3</span> </span><br><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">3</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> </span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> != candidate = <span class="number">3</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> = candidate</span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">5</span> != candidate = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">4</span> != candidate = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> = candidate </span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。<br>首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p>
<p>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment">#dict [key] = count</span></span><br><span class="line">        <span class="comment">#o(n) 空间复杂度为O(n)</span></span><br><span class="line">     <span class="comment">#第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。</span></span><br><span class="line">        numsCount = {}</span><br><span class="line">        numLen = len(numbers)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> numsCount:</span><br><span class="line">                numsCount[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numsCount[num] = <span class="number">1</span></span><br><span class="line">             <span class="comment">#如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.</span></span><br><span class="line">            <span class="keyword">if</span> numsCount[num] &gt; (numLen &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#想要空间复杂度为O（1），时间复杂度为o(n)</span></span><br><span class="line"><span class="comment">#第二种：</span></span><br><span class="line">        <span class="comment">#定义变量 上次出现的数字为0</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="comment">#上次出现的数字的数量为0 </span></span><br><span class="line">        lastCount = <span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历数组中的数字</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="comment">#如果说这个数字出现的次数为0了。</span></span><br><span class="line">            <span class="keyword">if</span> lastCount == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#那么就把上次出现的数字，变为需要保存的那个数字。</span></span><br><span class="line">                last = num</span><br><span class="line">                <span class="comment">#并把次数设置为1 次，出现了这一次。</span></span><br><span class="line">                lastCount = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span></span><br><span class="line">                <span class="keyword">if</span> num == last:</span><br><span class="line">                    lastCount += <span class="number">1</span></span><br><span class="line">                <span class="comment">#如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lastCount -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span></span><br><span class="line">        <span class="keyword">if</span> lastCount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#否则的话，就说明 数组里面 留下了没有抵消掉的数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#这种情况是last可能是大于一半的数字</span></span><br><span class="line">            <span class="comment">#这个时候把 记录数字次数的变量 计数 为0 </span></span><br><span class="line">            lastCount = <span class="number">0</span></span><br><span class="line">            <span class="comment">#遍历数组中的数</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">                <span class="comment">#如果这个数与我们记录的数相等的话</span></span><br><span class="line">                <span class="keyword">if</span> num == last:</span><br><span class="line">                    <span class="comment">#让这个计数加1</span></span><br><span class="line">                    lastCount += <span class="number">1</span></span><br><span class="line">            <span class="comment">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span></span><br><span class="line">            <span class="keyword">if</span> lastCount &gt; (len(numbers)&gt;&gt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> last</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>


<p>哈希表统计法： 遍历数组 nums ，用 HashMap 统计每个元素出现的次数。<br>最终超过数组长度一半的数字则为众数。</p>
<p>算法<br>用哈希映射（HashMap）来存储每个元素以及出现的次数。<br>对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。<br>用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。<br>在这之后，遍历哈希映射中的所有键值对，返回值最大的键。<br>我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，<br>这样省去了最后对哈希映射的遍历。</p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 O(n)（可参考下文的空间复杂度分析），那么遍历的时间不会超过 O(n)。因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)。哈希表最多包含 n - [n/2] 个键值对，所以占用的空间为 O(n)。这是因为任意一个长度为 n 的数组最多只能包含 n 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） [n/2]+1 个数字。因此最多有 n - ([n/2]+1) 个不同的其他数字，所以最多有 n - [n/2] 个不同的元素。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        votes = collections.Counter(nums)</span><br><span class="line">        <span class="comment"># count.keys()返回是键 </span></span><br><span class="line">        <span class="comment"># 求的不是票数个数最大的元素key</span></span><br><span class="line">        <span class="comment"># max里面比较的就是值（个数）</span></span><br><span class="line">        <span class="comment"># 加了key=votes.get表示比较票数的大小，</span></span><br><span class="line">        <span class="keyword">return</span> max(votes.keys(), key=votes.get)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">votes = {<span class="number">2</span>: <span class="number">5</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>}</span><br><span class="line">print(votes.keys())  # dict_keys([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">print(max(votes))  # <span class="number">5</span></span><br><span class="line">print(max(votes.keys()))  # <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 数组为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        hashset = {}</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># hashset[num] = hashset[num] + 1 if hashset.get(num) else 1</span></span><br><span class="line">            <span class="keyword">if</span> hashset.get(num):</span><br><span class="line">                hashset[num] = hashset[num] + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashset[num] =  <span class="number">1</span> </span><br><span class="line">            <span class="comment"># if hashset[num] &gt; len(nums) / 2:   </span></span><br><span class="line">            <span class="comment"># Python3.6之后下面的字典迭代要比这里的列表迭代要快，</span></span><br><span class="line">            <span class="comment"># 所以验证众数使用下面的字典迭代</span></span><br><span class="line">            <span class="comment">#     return num</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> hashset.items():</span><br><span class="line">            <span class="keyword">if</span> value &gt; len(nums) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> key</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 不存在众数</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>数组排序法：</p>
<p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，<br>由于众数的数量超过数组长度一半，<br>因此 数组中点的元素 下标为 [n/2] 的元素（下标从 0 开始）一定是众数。</p>
<p>我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。<br>下面的图中解释了为什么这种策略是有效的。<br>在下图中，第一个例子是 n 为奇数的情况，<br>第二个例子是 n 为偶数的情况。</p>
<p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，<br>数组下面的线表示如果众数是数组中的最大值时覆盖的下标。<br>对于其他的情况，这条线会在这两种极端情况的中间。<br>对于这两种极端情况，它们会在下标为⌋ [n/2] 的地方有重叠。<br>因此，无论众数是多少，返回  [n/2]  下标对应的值都是正确的。</p>
<p>时间复杂度： O(NlogN)， Python内置排序算法Timsort的时间复杂度<br>空间复杂度：不需要用到额外的空间</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums) // <span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="22-数组中只出现一次的数字-数组"><a href="#22-数组中只出现一次的数字-数组" class="headerlink" title="22.数组中只出现一次的数字[^数组]"></a>22.数组中只出现一次的数字[^数组]</h2><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</strong></p>
<p>思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#如果两个数相同那么两个数的异或操作为0</span></span><br><span class="line">        <span class="comment">#数组的长度如果小于2，那么就就不会有数字出现了偶数次。</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#变量赋值 两个数的异或为none</span></span><br><span class="line">        twoNumXor = <span class="literal">None</span></span><br><span class="line">        <span class="comment">#遍历 数组中的数字</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="comment">#判断 如果 两个数的数字异或的结果为0 的话，</span></span><br><span class="line">            <span class="keyword">if</span> twoNumXor == <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。</span></span><br><span class="line">                twoNumXor = num</span><br><span class="line">            <span class="comment">#如果数 这个数不为 空 的话</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。</span></span><br><span class="line">                twoNumXor = twoNumXor ^ num</span><br><span class="line">        <span class="comment">#变量  计数 为 0 </span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#当异或的 结果 为偶数时</span></span><br><span class="line">        <span class="keyword">while</span> twoNumXor % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">            <span class="comment">#那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。</span></span><br><span class="line">            twoNumXor  = twoNumXor &gt;&gt; <span class="number">1</span>  <span class="comment"># 右移以为 相当于 除以2</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1</span></span><br><span class="line">        </span><br><span class="line">        mask = <span class="number">1</span> &lt;&lt; count   <span class="comment">#向左 移 位 count 位。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。</span></span><br><span class="line">        </span><br><span class="line">        firstNum = <span class="literal">None</span></span><br><span class="line">        secondNum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> mask &amp; num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> firstNum == <span class="literal">None</span>:</span><br><span class="line">                    firstNum = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    firstNum = firstNum ^ num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> secondNum == <span class="literal">None</span>:</span><br><span class="line">                    secondNum = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    secondNum = secondNum ^ num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstNum,secondNum</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="23-整数中1出现的次数-本题考点-数组"><a href="#23-整数中1出现的次数-本题考点-数组" class="headerlink" title="23.整数中1出现的次数[^本题考点 数组]"></a>23.整数中1出现的次数[^本题考点 数组]</h2><p><strong>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了<br>把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png"></p>
<hr>
<p>解题思路：<br>将 1 ~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>
<p>密码锁，就是那种几个滚轮的密码锁，<br>固定其中的一位密码，拨动其他位置的密码。<br>每次计算是按照位数来的，而不是看整体的数值，<br>是在计算当 cur 位出现的 1 的数量,<br>一位一位地统计，目标就是防止重复统计啦</p>
<p>比如当前计算的是十位上的1的个数，那么对于0011来说，<br>虽然出现了两次1，但是十位上1的只有1个。</p>
<p>1 位数含1最多为: 1 个  1<br>2 位数含1最多为: 20 个 1, 11, 12, 13 ..19, 21, 31, 41, 51, …, 91<br>我们要分开两部分讨论：<br>只看个位：这个位置能出现’1’的次数为(十位的最大值+1) * 1位数能出现’1’的最大次数，在这里有10次(1,11,21,…91)<br>只看十位：这个位置能出现’1’，即只有当十位为’1’的时候的次数，即10^位数（这里是2，即十位），在这里有10次(10,11,12,…,19)<br>将个位出现过的次数与十位出现过的次数相加，便是我们的答案 = 20。</p>
<p>3 位数含1最多为: 300 个 1, 11, 12, 13 ..19, 100~199, 201, 211, 12, 13 ..19<br>4 位数含1最多为: 4000 个</p>
<p>设数字 n 是个 x 位数，记 n 的第 i 位为 n_in，<br>则可将 n 写为 n_{x} n_{x-1} \cdots n_{2} n_{1}n<br>称 “ n_in “ 为 当前位 ，记为 cur ，<br>将 “ n_{i-1} n_{i-2} \cdots n_{2} n_{1}n “ 称为 低位 ，记为 low ；<br>将 “ n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}n “ 称为 高位 ，记为 high 。<br>将 10^i 称为 位因子 ，记为 digit 。<br>某位中 1 出现次数的计算方法：<br>根据当前位 cur 值的不同，分为以下三种情况：<br>1.当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，<br>计算公式为：high×digit</p>
<p>假如 104，计算十位出现1的个数(此时cur=0)，那么10，11，12···19都符合。<br>出现 1 的数字范围：010<del>019<br>只看高低位：00</del>09<br>易得 1 出现次数为：9-0+1=10 0~9 总共是十个数啊<br>1 x 10 =10</p>
<p>假如 2304，计算十位出现1的次数(此时cur=0)<br>首先可以把0010~2219范围内，十位是1的所有数字枚举出来。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0010</span>，<span class="number">0011.</span>.<span class="number">.0019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">0110</span>，<span class="number">0111.</span>.<span class="number">.0119</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line">...</span><br><span class="line"><span class="number">0910</span>，<span class="number">0911.</span>.<span class="number">.0919</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">1010</span>，<span class="number">1011.</span>.<span class="number">.1019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line">...</span><br><span class="line"><span class="number">1910</span>，<span class="number">1911.</span>.<span class="number">.1919</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2010</span>，<span class="number">2011.</span>.<span class="number">.2019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2110</span>，<span class="number">2111.</span>.<span class="number">.2119</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2210</span>，<span class="number">2211.</span>.<span class="number">.2219</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到高位（前两位）的变化范围是00<del>22，有23种选择。<br>固定高位是某一种情况时，低位（个位）变化范围是0</del>9，有10种选择。<br>高位和低位组合，就有23*10=230种组合。<br>总结规律，你会发现，其实可以把0010<del>2219里的十位数字直接“抠”掉，<br>剩下的就是000</del>229，一共就是230个数字。</p>
<p>因为十位上面的1已经是固定的，所以其实000<del>229里的每个数，<br>和上面所枚举的230个数字是一一对应的。<br>比如000对应着0010，001对应着0011…所以000</del>229范围内数字的个数，<br>就是0010~2219范围内十位出现1的数字个数。<br>因为十位固定了 0， 能变得是 23 、 4 这三位数字。<br>因此当十位固定是 1 时，只能取 0 ~ 229 ，因此是 23 * 10 。</p>
<p>出现 1 的数字范围：0010<del>2219<br>只看高低位：000</del>229<br>易得 1 出现次数为：229-0+1=230<br>结论<br>high×digit = 23 x 10 =230</p>
<p>2.当 cur = 1 时： 此位 1 的出现次数只由高位 high 和 低位 low 决定，<br>计算公式为：high×digit+low+1</p>
<p>假如 2314，计算十位出现1的次数(此时cur=1)<br>出现 1 的数字范围：0010<del>2314<br>只看高低位：000</del>234<br>易得 1 出现次数为：234-0+1=235<br>high×digit+low+1 = 23 x 10 + 4 +1 = 235</p>
<p>3.当 cur &gt; 1, 即cur = 2,3,…,9 时： 此位 1 的出现次数只由高位 high 决定，<br>计算公式为：(high+1)×digit</p>
<p>假如 2324，计算十位出现1的次数(此时cur=2)<br>出现 1 的数字范围：0010<del>2319<br>只看高低位：000</del>239<br>易得 1 出现次数为：234-0+1=240<br>(high+1)×digit = (23 + 1) x 10 = 240</p>
<p>设计按照 “个位、十位、…” 的顺序计算，则 high / cur / low / digit 应初始化为：</p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">high</span> = n // <span class="number">10</span>  <span class="comment"># 整数除法</span></span><br><span class="line"><span class="attr">cur</span> = n % <span class="number">10</span></span><br><span class="line"><span class="attr">low</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">digit</span> = <span class="number">1</span> <span class="comment"># 个位</span></span><br></pre></td></tr></tbody></table></figure>

<p>从个位到最高位的变量递推公式为：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 cur = 0, high != 0 时，此时还要计算cur</span></span><br><span class="line"><span class="comment"># 当 high = 0, cur != 0 时，cur处于最高位，此时还要计算cur</span></span><br><span class="line"><span class="comment"># 当 high = cur = 0 时，cur已经越过最高位，因此跳出循环</span></span><br><span class="line"><span class="string">while</span> <span class="string">high</span> <span class="type">!=</span> <span class="number">0</span> <span class="string">or</span> <span class="string">cur</span> <span class="type">!=</span> <span class="attr">0:</span> </span><br><span class="line">   <span class="string">low</span> <span class="string">+=</span> <span class="string">cur</span> <span class="string">*</span> <span class="string">digit</span> <span class="comment"># 将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">   <span class="string">cur</span> <span class="string">=</span> <span class="string">high</span> <span class="string">%</span> <span class="number">10</span> <span class="comment"># 下轮 cur 是本轮 high 的最低位</span></span><br><span class="line">   <span class="string">high</span> <span class="string">//=</span> <span class="number">10</span> <span class="comment"># 将本轮 high 最低位删除，得到下轮 high</span></span><br><span class="line">   <span class="string">digit</span> <span class="string">*=</span> <span class="number">10</span> <span class="comment"># 位因子每轮 × 10</span></span><br></pre></td></tr></tbody></table></figure>
<p>32104</p>
<ul>
<li><p>从个位开始, digit = 1<br>cur =4&gt;1, low =0, high =3210<br>res += (high+1)×digit = (3210 + 1) x 1 = 3211<br>高位从0~3209变化的过程中，每一个变化中1只出现1次，即（高位1）这样的数字；<br>高位是3210时，因为当前位是4，所以1只能出现一次，即32101。</p>
</li>
<li><p>十位, digit= 10<br>cur =0, low = 4, high =321<br>res += 3211 + high ×digit = 3211 + 321 x 10 = 6421<br>res =  (high - 1 +1）× digit = (321 -1 +1) x 10 = 3210<br>那么高位从0~ 320的过程中，有321种，每一个变化1出现10次，<br>这样的数字i位置要想为1，就必须向高位借1，因此此时低位部分是都可以取到0-9的；<br>高位为321的时候，因为当前位为0，所以不存在出现1的可能性。</p>
</li>
</ul>
<p>百位, digit = 100<br>cur =1, low = 04, high =32<br>res += 6421 + high×digit+low+1 = 6421 + 32 x 100 + 4 +1 = 9626<br>高位从0~ 31变化的过程中，32种可能，每一个变化中1出现100次，<br>即（高位10）<del>（高位19）这样的数字，低位部分是可取到0-9的<br>高位为32的时候，因为当前位是1，<br>所以我们要看低位来决定出现的次数，<br>低位部分的每个位置不能取到0-9，低位为4，所以此时出现5次，<br>即32100</del>32104这样的数字。</p>
<p>千位, digit = 1000<br>cur =2&gt;1, low = 104, high = 3<br>res += 9626 + (high+1)×digit = 9626 + (3+1) x 1000 = 13626<br>高位从0<del>2变化的过程中，每一个变化中1只出现1000次，即（高位1）这样的数字；<br>高位是3时，因为当前位是2，所以1能出现1000次，低位部分的每一个位置都可以取到0-9<br>即31000</del>31999。</p>
<p>万位, digit = 10000<br>cur =3&gt;1, low = 2104, high = 0<br>res += 9626 + (high+1)×digit = 13626 + (0+1) x 10000 = 23626<br>没有高位所以直接看当前位，因为当前位为3，<br>所以1出现的次数为10000，即10000~19999这样的数字。</p>
<p>因为本题的时间复杂度由 “循环次数” 决定，<br>而循环次数由数字的位数决定，<br>因为十进制数进位出现在 10 100 1000 ……，<br>假设 n = 10 ^ i ，那么 n 的位数就是 i ～<br>所以一个数字 n 的位数是 log_10 n</p>
<p>因此复杂度即为 log n ~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        digit, res = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        high, cur, low = n // <span class="number">10</span>, n % <span class="number">10</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> high != <span class="number">0</span> <span class="keyword">or</span> cur != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>: res += high * digit</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>: res += high * digit + low + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: res += (high + <span class="number">1</span>) * digit</span><br><span class="line">            low += cur * digit</span><br><span class="line">            cur = high % <span class="number">10</span></span><br><span class="line">            high //= <span class="number">10</span></span><br><span class="line">            digit *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p>
<p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p>
<p>**若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ **</p>
<p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p>
<p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p>
<p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p>
<p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p>
<p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p>
<p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p>
<p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4 </code>种情况。</p>
<p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p>
<p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p>
<p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p>
<p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p>
<p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p>
<p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        <span class="comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        <span class="comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="number">1</span></span><br><span class="line">        highValue = <span class="number">1</span></span><br><span class="line">        lowValue = <span class="number">1</span></span><br><span class="line">        midValue =<span class="number">1</span></span><br><span class="line">        <span class="comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="number">0</span></span><br><span class="line">        <span class="comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="keyword">while</span> highValue != <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="number">10</span>)</span><br><span class="line">            <span class="comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="number">10</span></span><br><span class="line">            <span class="comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="number">10</span></span><br><span class="line">            <span class="comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> midValue == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="keyword">elif</span> midValue &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="number">1</span>)*pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="number">10</span>,count)+(lowValue+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="keyword">return</span> sumNum</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="24-丑数"><a href="#24-丑数" class="headerlink" title="24.丑数"></a>24.丑数</h2><p><strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p>
<p>思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？</p>
<p>因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#死循环，找丑数</span></span><br><span class="line">        <span class="comment">#判断一个数是不是丑数，先循环除以2，直到不能整除，</span></span><br><span class="line">        <span class="comment">#循环除以3 直到不能整除，循环除以5 直到不能整除</span></span><br><span class="line">        <span class="comment">#这时如果剩余的值是1  我们就说它是丑数</span></span><br><span class="line">        <span class="comment">#其他情况就都不是丑数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isUglyNumber</span>(<span class="params">num</span>):</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> isUglyNumber(num):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == index:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            num += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>方法二:</p>
<p>x6 x 2&gt; x9 = x5 x 2<br>6 x 2 = 12 &gt; 10 &gt;= 5 x 2 </p>
<p>x4 x 3&gt; x9 = x3 x 3<br>4 x 3 = 12 &gt; 10 &gt;= 3 x 3</p>
<p>x3 x 5&gt; x9 = x2 x 5<br>3 x 5 = 12 &gt; 10 &gt;= 2 x 5<br>x10 = min(12, 12, 15) = 12</p>
<p>用空间换时间，先排后存<br>创建一个 列表，<br>里面的数字是排好序的 丑数，<br>每个丑数都是前面的丑数乘以2,3，或者5得到的。</p>
<p>给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，<br>第一个丑数为1，那么我们在这个列表的起始位置设置三个指针，<br>这三个指针代表的值  分别为a,b,c.<br>又由于这个列表中的所有的丑数从小到大排列的，<br>1是丑数, 那么1乘以2,3,5得到的乘积也肯定是丑数(根据丑数的定义可知),<br>也就是说每一个已知的丑数, 乘上2,3,5之后都会得到3个更大的丑数(可能有重复)<br>要与前面的丑数比较大小，要把三个指针所在位置的元素做个对比,<br>取最小的那个元素, 就是下一个丑数了.<br>接着三个指针必须往下移动, 直到指向的元素都大于已知丑数才可以停下来,<br>再继续比较，把丑数放入丑数数组中, 继续计算下一个丑数, 直到算出第n个丑数出来即可.</p>
<p>一开始，丑数只有{1}，1可以同2，3，5相乘，<br>那么 1 * 2 得到的是2,1*3 得到的是3，1 乘以5 得到的是5，<br>那么三个数中比较大小，最小的是 1 乘以2，<br>那么 取最小的1×2=2添加到丑数序列中，<br>现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，<br>所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。</p>
<p>现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，<br>但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，<br>只需要比较2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，<br>下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，<br>以此类推，那么现在的到的丑数的顺序就是1,2,3,4 …</p>
<p>依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，<br>选择最小的那个作为下一个丑数，<br>假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，<br>所以它失去了同i相乘的资格，把对应的i+=1，让pi指向下一个丑数即可。</p>
<p>动态规划解析：<br>状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。<br>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。</p>
<p>pi的含义是有资格同 i（i=2，3，5）相乘的最小丑数的位置。<br>这里资格指的是：如果一个丑数dp[pi]通过乘以i可以得到下一个丑数，<br>那么这个丑数dp[pi]就永远失去了同i相乘的资格（没有必要再乘了），<br>我们把i+=1让dp[pi]指向下一个丑数即可。</p>
<p>实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，<br>若相等则将对应索引 a , b , c 加 1 。<br>dp[a]×2&gt;dp[i−1]≥dp[a−1]×2<br>dp[b]×3&gt;dp[i−1]≥dp[b−1]×3<br>dp[c]×5&gt;dp[i−1]≥dp[c−1]×5</p>
<ul>
<li>初始状态： dp[0] = 1 ，即第一个丑数为 1 ；</li>
<li>递推计算 dp[i]=min(dp[a]×2,dp[b]×3,dp[c]×5)​<br>若 dp[i]= dp[a]×2 = dp[b]×3，两个索引都需要加1</li>
<li>更新索引<br>dp[a]×2 = dp[i] 执行a += 1<br>dp[b]×3 = dp[i] 执行b += 1<br>dp[c]×5 = dp[i] 执行c += 1</li>
<li>返回值： dp[n-1] ，即返回第 n 个丑数。</li>
</ul>
<p>时间复杂度 O(N) ： 其中 N = n ，动态规划需遍历计算 dp 列表。<br>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。</p>
<p>主要还是通过 丑数可以拆分为几个小丑数 的性质 来得到的。<br>这样每次取到最接近的丑数，<br>对应的因子就 +1，就能保证取到所有的丑数（不会遗漏）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 初始化三个指针的 索引位置是0，</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># print([1] * 2)  # [1, 1]</span></span><br><span class="line">        <span class="comment"># print([1] * 3)  # [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因此 dp[0] 要对应第 1 个丑数，</span></span><br><span class="line">        <span class="comment">#  dp[i] 为 i + 1 个丑数。</span></span><br><span class="line">        <span class="comment"># 要求第 n 个丑数，就是要求 dp[n-1] ，</span></span><br><span class="line">        <span class="comment"># 因此是 range(1, n) ，最后会遍历到 n - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 给列表中的 a, b, c 这三个指针所在位置的丑数 分别 乘以2,3,5</span></span><br><span class="line">            n2, n3, n5 = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">            dp[i] = min(n2, n3, n5)</span><br><span class="line">            <span class="comment"># 也可用dp=[1], dp.append(min(n2, n3, n5))</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新索引不能使用elif  因为存在2*某个丑数 ,3*某个丑数,5*某个丑数相同的情况，因此对应指针全部都要移动，保证数组中不会加入重复元素。</span></span><br><span class="line">            <span class="comment"># 这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最终返回丑数列表的最后一个值即为第 n 个丑数</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>n2、n3、n5几个变量的声明不用放在循环外，<br>执行到下一轮时，上一轮应该会释放的～ 这个高级语言会帮我们解决啦</p>
<hr>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，<br>请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>数组中两个值相同的元素并不是相同元素，数组不是集合</p>
<p>法一：<br>保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。<br>哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。<br>我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。<br>但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>由于哈希查找的时间复杂度为 O(1)，<br>比index索引速度快；dict替换item in list提速</p>
<p>如果存在则找到了两个值，<br>如果不存在则将当前的 num当作key,i当作value 存入 map 中，<br>继续遍历直到找到为止</p>
<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        hashset = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># if hashset.get(target - nums[i]) is not None:</span></span><br><span class="line">            <span class="comment"># return hashset.get(target - nums[i]), i</span></span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> hashset[target - nums[i]], i</span><br><span class="line">            hashset[nums[i]] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    target = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    index = solution.twoSum(nums, target)</span><br><span class="line">    print(index)</span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的实现使用了两次迭代。在第一次迭代中，<br>我们将每个元素的值和它的索引添加到表中。<br>然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。<br>注意，该目标元素不能是 nums[i] 本身！<br>题干中并没有说 nums 是有序的，当碰到相同的元素时，<br>dct[n] = i 会将最近遍历的元素索引写入字典。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        hashmap = {}</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="comment"># 每个值都判断map中是否存在 target-nums[i] 的 key 值</span></span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># return [hashmap[target - num],i]</span></span><br><span class="line">                <span class="keyword">return</span> [i, hashmap[target - num]]</span><br><span class="line">            <span class="comment"># 如果不存在</span></span><br><span class="line">            <span class="comment"># 则将当前的num当作key,i当作value存入 hashmap 中,保证遍历的时候有值</span></span><br><span class="line">            hashmap[num] = i  <span class="comment">#  给字典创建键值对，不是查找，</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于每一个新的数，先找是否有存的数能满足条件的，<br>如果没有，或是重复数不满足求和条件，或者不重复数不满足求和条件。<br>重复数的覆盖是不怕的，因为题目说只有一个满足要求的答案，<br>所以这个重复数字如果没找到满足要求的结果，那就可以放弃这个数字了。</p>
<p>实现去重：每次执行if语句 i，num这一组值还没有加入到字典当中去，所以就可以避免了<br>这句不能放在if语句之前，解决hashmap中有重复值或target-num=num的情况</p>
<p>nums = [2, 7, 11, 15], target = 13<br>i=0, num=2, 13-2=11不在hashmap={},hashmap={2:0}<br>i=1, num=7, 13-7=6不在hashmap={2:0} hashmap={2:0, 7:1}<br>i=2, num=11, 13-11=2在hashmap={2:0, 7:1} 返回2的下标和11的下标</p>
<p> 1.每次写入时，判断条件 不是当前的key本身存不存在，<br> 而是key和 tag 之间的差值存不存在，这一点很重要。<br> 2.题目命题说明了一点，假定只有一个解。也就是说重复元素再多都无所谓。<br> case 1：如果有3个或者以上的重复元素，代表这个重复元素不可能是解，所以写入map的时候直接覆盖也无所谓；<br> case2：如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于tag。这种情况下，当遇到第二个重复元素时，不会写入map，这个时候直接已经取到解了。 所以这种方式，不用考虑hash冲突的问题。</p>
<p>法三：<br>用1个for循环<br>直接用target 减去 取出的数字，看结果有没有在数组里</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self,nums,target</span>):</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a = target - nums[x]</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> nums: <span class="comment"># 判断a有没有在nums数组里</span></span><br><span class="line">                y = nums.index(a) <span class="comment"># 有的话，那么用index获取到该数字的下标</span></span><br><span class="line">                <span class="keyword">if</span> x == y: </span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># 同样的数字不能重复用，所以这里如果是一样的数字，那么就不满足条件，跳过</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 否则就返回结果</span></span><br><span class="line">                    <span class="keyword">return</span> x,y </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 上面的条件都不满足就跳过，进行下一次循环</span></span><br></pre></td></tr></tbody></table></figure>


<p>法四 暴力最慢 时间复杂度O（n²），空间复杂度O（1）</p>
<p>拿数组里的第一个数字和后面的数字分别相加，看是否等于target；<br>如果不等于target，那么就继续拿数组里的第二个数字和后面的数字相加；<br>不停的去一个个试…直到等于target，返回这2个数字所在的下标</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self,nums,target</span>):</span></span><br><span class="line">        n = len(nums) <span class="comment"># 获取nums的长度，是4</span></span><br><span class="line">        <span class="comment"># 外层循环先取出下标0，对应着数组里的第一个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n): </span><br><span class="line">            <span class="comment"># 内层循环取出下标1，对应着数组里的第二个数字</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(x+<span class="number">1</span>,n): </span><br><span class="line">                <span class="comment"># 如果第一个数字+第二个数字=target</span></span><br><span class="line">                <span class="keyword">if</span> nums[x] + nums[y] == target: </span><br><span class="line">                    <span class="keyword">return</span> x,y <span class="comment"># 上面的判断是对的话，那么就返回下标</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i, itm <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            other = target - itm</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                posi = nums.index(other)</span><br><span class="line">                <span class="keyword">if</span> posi != i:</span><br><span class="line">                    <span class="keyword">return</span> sorted([posi, i])</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><strong>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</strong></p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<blockquote>
<p>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"()[]{}"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"{[]}"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>


<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p>
<p>辅助栈法</p>
<figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"{()[()]}"</span></span><br><span class="line"><span class="string">"{  [()]}"</span></span><br><span class="line"><span class="string">"{  [  ]}"</span></span><br><span class="line"><span class="string">"{      }"</span></span><br><span class="line"><span class="string">"        "</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>算法原理</p>
<ul>
<li><p>栈的先进后出，后进先出的特点恰好与本题括号排序特点一致，<br>即若先遇到左括号入栈，当遇到匹配的最里面右括号时，将这对应左括号从栈中删除，也就是将对应栈顶左括号出栈。</p>
</li>
<li><p>为了快速判断括号的类型，我们可以使用哈希映射（HashMap）存储每一种左右括号对应关系。哈希表 dic的键key 为左括号，值value为相同类型的右括号，这样查询 2 个括号是否对应只需 O(1) 时间复杂度；</p>
</li>
</ul>
</li>
</ul>
<p>建立栈 stack，遍历字符串 s 并按照算法流程一一判断。</p>
<blockquote>
<p>空字符串不会进入for循环</p>
</blockquote>
<ul>
<li><p>算法流程</p>
<ol>
<li>如果 char 是左括号，则入栈 push；</li>
<li>否则通过哈希表判断括号对应关系，<br>若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 char 不对应，<br>则提前返回 false。</li>
</ol>
</li>
<li><p>提前返回 false</p>
<ul>
<li><p>提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。</p>
</li>
<li><p>解决边界问题： </p>
<ul>
<li><p>栈 stack 为空： 此时 stack.pop() 操作会报错；<br>假设s中第一个元素是右括号，此时就会报错了。<br>因此，我们采用一个取巧方法，给 stack 赋初值 ? 就可以避免这个问题<br>并在哈希表 dic 中建立 key: ‘?’，value:’?’ 的对应关系予以配合。<br>有这个 ? 后： 当 stack 为空且 char 为右括号时，可以正常提前返回 false ；<br>若没有则会报错。</p>
</li>
<li><p>字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，<br>但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，<br>以判断是否是有效的括号组合。则遍历完所有括号后 stack 仍然为空，</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>复杂度分析<ul>
<li>时间复杂度 O(N)：正确的括号组合或者全是左括号需要遍历 1 遍 s；出栈和入栈都是0(1) n 是字符串 s 的长度。</li>
<li>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希映射使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。哈希表和栈使用线性的空间大小。</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict1 = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'1'</span>: <span class="string">'c'</span>}</span><br><span class="line"><span class="comment"># 判断的是key是否在字典里而不是判断value</span></span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">in</span> dict1)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> dict1)  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'1'</span> <span class="keyword">in</span> dict1)  <span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 先排除一半的情形（奇数）</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dic = {<span class="string">'{'</span>: <span class="string">'}'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'?'</span>: <span class="string">'?'</span>}</span><br><span class="line">        <span class="comment"># 若stack = [] 栈 stack 为空时，执行 stack.pop() 操作会报错，</span></span><br><span class="line">        <span class="comment"># 假设s中单个右括号入栈 ，此时就会报错了。</span></span><br><span class="line">        <span class="comment"># 但在最开始加一个?就可以避免这个问题。用一点空间换每次不用判空,</span></span><br><span class="line">        stack = [<span class="string">'?'</span>]  </span><br><span class="line">        <span class="comment"># 判断的是key是否在字典里而不是判断value</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> dic:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != char:  <span class="comment"># elif不等于if，if 和 elif只能同时执行一个</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solution = Solution()</span><br><span class="line"><span class="comment"># print(solution.isValid(''))  # True</span></span><br><span class="line"><span class="comment"># print(solution.isValid('}'))  # False</span></span><br><span class="line">print(solution.isValid(<span class="string">'}}'</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># print(solution.isValid('[{}()]'))  # True</span></span><br><span class="line"><span class="comment"># print(solution.isValid('[}(){()[]}]'))  # False</span></span><br><span class="line">print(solution.isValid(<span class="string">'[['</span>))  <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1</span></span><br><span class="line">s = <span class="string">''</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">0</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = None 错错错，不会执行这一句</span><br><span class="line">直接跳过循环，</span><br><span class="line"><span class="keyword">return</span> len(stack) = len([<span class="string">'?'</span>]) = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span></span><br><span class="line">s = <span class="string">'}'</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">1</span> % <span class="number">2</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">3</span></span><br><span class="line">s = <span class="string">'}}'</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'?'</span>] = <span class="string">'?'</span> != <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">4</span></span><br><span class="line">s =<span class="string">'[{}()]'</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span>  = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'{'</span> </span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'{'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'}'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'{'</span>] = <span class="string">'}'</span> = <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'('</span> </span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'('</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">')'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'('</span>] = <span class="string">')'</span> = <span class="keyword">char</span> = <span class="string">')'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">']'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'['</span>] = <span class="string">']'</span> = <span class="keyword">char</span> = <span class="string">']'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>]    </span><br><span class="line"><span class="keyword">return</span> len(stack) == <span class="number">1</span> = Ture</span><br><span class="line"></span><br><span class="line">例子<span class="number">5</span></span><br><span class="line">s =<span class="string">'[}(){()[]}]'</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'['</span>] = <span class="string">']'</span> != <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">6</span></span><br><span class="line">s =<span class="string">'[['</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'['</span>]] </span><br><span class="line"><span class="keyword">return</span> len(stack) == <span class="number">3</span> != <span class="number">1</span> = <span class="keyword">False</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>对给定的字符串 s 进行遍历，对每一个字符进行如下操作<br>当遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>
<p>当我们遇到一个右括号时，栈为空 或者 该右括号与取出的栈顶的左括号类型不一样，则返回false</p>
<p>否则，即如果栈非空,且栈顶元素与接下来的字符(闭括号)相同类型,出栈</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，若栈非空,意味着开括号多了,返回 False。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pairs = {</span><br><span class="line">            <span class="string">")"</span>: <span class="string">"("</span>,</span><br><span class="line">            <span class="string">"]"</span>: <span class="string">"["</span>,</span><br><span class="line">            <span class="string">"}"</span>: <span class="string">"{"</span>,</span><br><span class="line">        }</span><br><span class="line">        stack = list()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>] != pairs[ch]:  <span class="comment"># 顺序不能换</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        <span class="comment"># 如果栈中如果for遍历完后,栈非空,意味着左括号多了,则非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1</span></span><br><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">0</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = None 错错错，不会执行这一句</span><br><span class="line">直接跳过循环，</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = True</span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span></span><br><span class="line">s = <span class="string">'}'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">例子<span class="number">3</span></span><br><span class="line">s = <span class="string">'}}'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> </span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span> </span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">例子<span class="number">4</span></span><br><span class="line">s =<span class="string">'[{}()]'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> </span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'{'</span> </span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'{'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'{'</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'('</span> </span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'('</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">')'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'{'</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">']'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'['</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line">    stack = []    </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = Ture</span><br><span class="line"></span><br><span class="line">例子<span class="number">5</span></span><br><span class="line">s =<span class="string">'[}(){()[]}]'</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span></span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'['</span> != <span class="built_in">pairs</span>[<span class="built_in">char</span>] = <span class="string">'{'</span></span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">例子<span class="number">6</span></span><br><span class="line">s =<span class="string">'[['</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'['</span>]]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = False</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 入栈与出栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># compare with top element</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((stack[<span class="number">-1</span>] + c) <span class="keyword">in</span> [<span class="string">'()'</span>, <span class="string">'{}'</span>, <span class="string">'[]'</span>]):</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        para_map = {<span class="string">')'</span>:<span class="string">'('</span>, <span class="string">']'</span>:<span class="string">'['</span>, <span class="string">'}'</span>:<span class="string">'{'</span>}</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> para_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != para_map.get(c):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>字符串处理版</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>).replace(<span class="string">'[]'</span>, <span class="string">''</span>).replace(<span class="string">'{}'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">while</span> len(s) != length:</span><br><span class="line">            length = len(s)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>).replace(<span class="string">'[]'</span>, <span class="string">''</span>).replace(<span class="string">'{}'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>




<hr>
<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。<br>示例 2：</p>
<p>输入：nums = [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums = [0]<br>输出：0<br>示例 4：</p>
<p>输入：nums = [-1]<br>输出：-1<br>示例 5：</p>
<p>输入：nums = [-100000]<br>输出：-100000</p>
<hr>
<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：</p>
<p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：</p>
<p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：</p>
<p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：</p>
<p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        num = len(nums1)</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            index = (num + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> nums1[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = num / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            ri = (num + <span class="number">2</span>) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (nums1[li] + nums1[ri]) / <span class="number">2.0</span></span><br></pre></td></tr></tbody></table></figure>


<hr>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p>示例 1：</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。<br>示例 2：</p>
<p>输入：height = [1,1]<br>输出：1<br>示例 3：</p>
<p>输入：height = [4,3,2,1,4]<br>输出：16<br>示例 4：</p>
<p>输入：height = [1,2,1]<br>输出：2</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cap = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                cur = height[i] * (j - i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = height[j] * (j - i)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; cap:</span><br><span class="line">                cap = cur</span><br><span class="line">        <span class="keyword">return</span> cap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print Solution().maxArea([1, 2, 3, 4])</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<ol start="12">
<li>整数转罗马数字<br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</li>
</ol>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: 3<br>输出: “III”<br>示例 2:</p>
<p>输入: 4<br>输出: “IV”<br>示例 3:</p>
<p>输入: 9<br>输出: “IX”<br>示例 4:</p>
<p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p>
<p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        roman_dict = {<span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">                      <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">                      <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">                      <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">                      <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                      <span class="string">'M'</span>: <span class="number">1000</span>}</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s.upper():</span><br><span class="line">            num = roman_dict[i]</span><br><span class="line">            <span class="keyword">if</span> num &gt; last:</span><br><span class="line">                total -= last</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total += num</span><br><span class="line">            last = num</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># print Solution().romanToInt('MCMLXXXIV')</span></span><br></pre></td></tr></tbody></table></figure>



<p>桶排序（最快最简单的排序）桶排序的基本思想是将一个数据表分割成许多 buckets，然后每个 bucket 各自排序，或用不同的排序算法，或者递归的使用 bucket sort 算法。也是典型的 divide-and-conquer 分而治之的策略。它是一个分布式的排序，介于 MSD 基数排序和LSD 基数排序之间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 选择最大的数</span></span><br><span class="line">    max_num = max(nums)</span><br><span class="line">    <span class="comment"># 创建一个元素全是0的列表，当做桶</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * (max_num + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 把所有元素的个数放入桶中与其值相等的下标对应的位置</span></span><br><span class="line">    <span class="comment"># 即其值对应位置的元素的值为其在原列表中的个数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        bucket[num] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># sort_nums存储排序好的元素</span></span><br><span class="line">    sort_nums = []</span><br><span class="line">    <span class="comment"># 取出桶中的元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bucket)): <span class="comment"># 下标i 其实就是原列表的值</span></span><br><span class="line">        <span class="keyword">if</span> bucket[i] != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 下标i对应的值不为0的话，说明原列表存在i这个值，bucket[i]就是i在原列表的个数</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(bucket[i]):</span><br><span class="line">                sort_nums.append(i)</span><br><span class="line">    <span class="keyword">return</span> sort_nums</span><br></pre></td></tr></tbody></table></figure>
<p>1、桶排序是稳定的 2、桶排序是常见排序里最快的一种, 大多数情况下比快排还要快3、但是同时也非常耗空间,基本上是最耗空间的一种排序算法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/property-zhuang-shi-qi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/property-zhuang-shi-qi/" class="post-title-link" itemprop="url">property装饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-31 01:04:49" itemprop="dateModified" datetime="2021-05-31T01:04:49Z">2021-05-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Python中属性和方法访问权限不建议将属性设置为私有的，<br>但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效，导致可以把属性随便改，甚至类型错误都可以。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, score</span>):</span></span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student(<span class="number">100</span>)</span><br><span class="line">    print(s.score)  <span class="comment"># 100</span></span><br><span class="line">    s.score = <span class="number">50</span></span><br><span class="line">    print(s.score)  <span class="comment"># 50</span></span><br><span class="line">    s.score = <span class="string">'abc'</span></span><br><span class="line">    print(s.score)  <span class="comment"># abc</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>为了限制score的范围，<br>可以通过一个set_score()方法来设置成绩，<br>再通过一个get_score()方法来获取成绩，<br>这样，在set_score()方法里就可以检查参数了。<br>对任意的Student实例进行操作，就不能随心所欲的设置score了。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer !'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0-100 !'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student()</span><br><span class="line">    s.set_score(<span class="number">50</span>)</span><br><span class="line">    print(s.get_score())  <span class="comment"># 50</span></span><br><span class="line">    s.set_score(<span class="string">'abc'</span>)  <span class="comment"># ValueError: score must be an integer !</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的调用方法虽然已经可以实现相关功能，但是使用起来略显复杂，<br>设置和获取属性都需要通过调用方法来实现，没有直接用属性这么简洁明了。</p>
<p>在写python类的时候，虽然可以通过<code>实例名.变量名</code>的方式对实例中的变量进行读取和赋值。但出于规范性等等原因，<br>我们最好还是写 <code>getter</code> 和 <code>setter</code> ，不过这样的话在读取变量和赋值时代码就显得有些臃肿，也不那么随心所欲了。<br>那么有没有即保证数据规范性能检查参数又可以用类似属性这样简单的方式来访问类的变量?<br>有，使用<code>property()</code> 函数和 @<code>property</code> 修饰符。</p>
<h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a><code>@property</code>装饰器</h3><p>我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，<br>那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。<br>如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，<br><code>@property</code>，<code>@setter</code>，<code>@deleter</code>这三个装饰器提供了更加友好的方式来获取、设置或删除类中的属性。<br>@property装饰器所装饰的函数可以像访问属性一样调用函数，而不再当作函数方法<br><code>@property</code>装饰器 getter 必须先于<code>@setter</code>，<code>@deleter</code>使用，且三者所装饰的函数必须同名，否则会出错。<br>加上@property就可以了，把一个类的getter方法变成属性，<br>创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，拥有属性操作。<br>我们在对实例属性操作的时候，就知道该属性不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        print(<span class="string">'实例化一个A类对象……'</span>)</span><br><span class="line">        self.__value = v</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这是getter，getter必须写在setter前面，且函数名变成property修饰符名</span></span><br><span class="line">        print(<span class="string">'取值时被调用'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @value.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="comment"># 这是setter，setteer的函数名跟getter一样，必须为property修饰符名</span></span><br><span class="line">        print(<span class="string">'赋值时被调用'</span>)</span><br><span class="line">        self.__value = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @value.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这是deleter，函数名同上</span></span><br><span class="line">        print(<span class="string">'删除值时被调用……'</span>)</span><br><span class="line">        <span class="keyword">del</span> self.__value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = A(<span class="number">123</span>)</span><br><span class="line">    print(<span class="string">'-------------'</span>)</span><br><span class="line">    print(<span class="string">'__value的值为：{}'</span>.format(a.value))</span><br><span class="line">    print(<span class="string">'-------------'</span>)</span><br><span class="line">    a.value = <span class="number">234</span></span><br><span class="line">    print(<span class="string">'__value的值为：{}'</span>.format(a.value))</span><br><span class="line">    print(<span class="string">'--------------'</span>)</span><br><span class="line">    <span class="keyword">del</span> a.value</span><br><span class="line">    print(<span class="string">'__value的值为：{}'</span>.format(a.value))  <span class="comment"># 访问了已经删除了的元素</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实例化一个A类对象……</span><br><span class="line">-------------</span><br><span class="line">取值时被调用</span><br><span class="line">_<span class="emphasis">_value的值为：123</span></span><br><span class="line"><span class="emphasis">-------------</span></span><br><span class="line"><span class="emphasis">赋值时被调用</span></span><br><span class="line"><span class="emphasis">取值时被调用</span></span><br><span class="line"><span class="emphasis">_</span><span class="emphasis">_value的值为：234</span></span><br><span class="line"><span class="emphasis">--------------</span></span><br><span class="line"><span class="emphasis">删除值时被调用……</span></span><br><span class="line"><span class="emphasis">取值时被调用</span></span><br><span class="line"><span class="emphasis">Traceback (most recent call last):</span></span><br><span class="line"><span class="emphasis">  File "c:/1.py", line 31, in &lt;module&gt;</span></span><br><span class="line"><span class="emphasis">    print('_</span><span class="emphasis">_value的值为：{}'.format(a.value))</span></span><br><span class="line"><span class="emphasis">  File "c:/python/1.py", line 9, in value</span></span><br><span class="line"><span class="emphasis">    return self._</span><span class="emphasis">_value</span></span><br><span class="line"><span class="emphasis">AttributeError: 'A' object has no attribute '_</span>A_<span class="emphasis">_value'</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_value</span>(<span class="params">self</span>):</span>  <span class="comment"># 这是getter，getter必须写在setter前面，且函数名变成property修饰符名</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name_value.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_value</span>(<span class="params">self, name</span>):</span>  <span class="comment"># 这是setter，setteer的函数名跟getter一样，必须为property修饰符名</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name_value.deleter  # 这是deleter，函数名同上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.name_value = <span class="string">'chb'</span></span><br><span class="line">n = p.name_value</span><br><span class="line">print(n)  <span class="comment"># chb</span></span><br><span class="line"><span class="keyword">del</span> p.name_value</span><br><span class="line">print(p.name_value)  <span class="comment"># AttributeError: 'Person' object has no attribute '_Person__name'</span></span><br></pre></td></tr></tbody></table></figure>
<p>有的时候，为了不让修改属性，只定义<code>getter</code>方法、不定义<code>setter</code>方法就是在类中定义一个只读属性，<code>property</code>函数只写第一个参数即可。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># birth是可读写属性</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'birth must be an integer !'</span>)</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># age是一个只读属性，根据birth和当前年份计算出来。</span></span><br><span class="line">        <span class="keyword">return</span> datetime.datetime.now().year - self._birth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student()</span><br><span class="line">    s.birth = <span class="number">1997</span></span><br><span class="line">    print(s.age)  <span class="comment"># 25</span></span><br><span class="line">    s.age = <span class="number">26</span>  <span class="comment"># AttributeError: can't set attribute</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer !'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 - 100 !'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Student()</span><br><span class="line">    s.score = <span class="number">50</span>  <span class="comment"># 实际转化为s.set_score()</span></span><br><span class="line">    print(s.score)  <span class="comment"># 50 实际转化为s.get_score()</span></span><br><span class="line">    s.score = <span class="number">101</span>  <span class="comment"># ValueError: score must between 0 - 100 !</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩飞行棋.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩斗地主.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    person = Person(<span class="string">'王大锤'</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p><code>property(fget=None,fset=None,fdel=None,doc=None)</code></p>
<p>在新式类中返回类属性值。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这是getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    name_value = property(getName, setName)  <span class="comment"># 名字可以随便去，这里使用name_value是为了直观，直接用一个n命名更简单</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()  <span class="comment"># 实例化</span></span><br><span class="line">p.name_value = <span class="string">'chb'</span>  <span class="comment"># 直接赋值，这行代码等同于 p.setName('chb')</span></span><br><span class="line">n = p.name_value  <span class="comment"># 直接读取数据 ，等同于使用 p.getName()</span></span><br><span class="line">print(n)  <span class="comment"># chb</span></span><br></pre></td></tr></tbody></table></figure>
<p>在写好了setteer和getter后，加上一句<code>property</code>函数赋值代码。<br>property可以再一个deleter，上面代码中没有加。如果加上，<code>deleter</code> 写法代码如下：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delName</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">del</span> self.__name</span><br></pre></td></tr></tbody></table></figure>


<p>然后 <code>property</code> 赋值语句变为：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_value=property(getName, setName, delName)</span><br></pre></td></tr></tbody></table></figure>

<p>使用方法为：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> p.name_value</span><br><span class="line">print(p.name_value)  <span class="comment"># 运行会出错</span></span><br></pre></td></tr></tbody></table></figure>

<p>这种方法的好处是你可以按照原来的方法写 <code>getter</code> 和 <code>setter</code>，连 <code>getter</code> 和 <code>setter</code> 的函数名都可以不用改，只需要写完 <code>getter</code> 和 <code>setter</code> 是加一条 <code>property</code> 赋值语句。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">webserver</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num</span>):</span></span><br><span class="line">        self.num=num</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"Stop the server !!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"Start the server !!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restart</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stop()</span><br><span class="line">        self.start()</span><br><span class="line">        print(<span class="string">"Restart the server"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_test</span>():</span></span><br><span class="line">        print(<span class="string">"Reload the server"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    server=webserver(<span class="number">1</span>)</span><br><span class="line">    server2=webserver(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hasattr(server,sys.argv[<span class="number">1</span>]):</span><br><span class="line">    <span class="function"><span class="keyword">func</span>=<span class="title">getattr</span><span class="params">(server,sys.argv[1])</span>  # <span class="title">getattr</span>其实是在<span class="title">server</span>这个实例中寻找和<span class="title">sys</span>.<span class="title">argv</span>[1]这个字符串相同的方法，并且返回一个内存地址</span></span><br><span class="line">       <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setattr</span><span class="params">(server,<span class="string">'reload'</span>,run_test)</span></span></span><br><span class="line">server.reload()</span><br></pre></td></tr></tbody></table></figure>


<p>setattr 是这么玩： setattr(x, ‘y’, v) is equivalent to ``x.y = v’’,意思是第一个输入的是实例的名字，第二个是属性的别名，第三个函数名(类里面已有的方法)</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setattr</span><span class="params">(server,<span class="string">'reload'</span>,run_test)</span></span></span><br><span class="line">server.reload()</span><br></pre></td></tr></tbody></table></figure>


<p>delattr 是这么玩 delattr(x, ‘y’) is equivalent to ``del x.y’’ ，x是类名，y是类的方法名</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delattr</span><span class="params">(webserver,<span class="string">'start'</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>此时我们把类的start方法删除后，对象server就没有start方法了，执行下面句的时候就会报错了</p>
<p>类的继承之广度优先</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f1 from A"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f2 from A"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f1 from B"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f2 from B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f1 from C"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"f2 from C"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B,C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d=D()</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/base64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/base64/" class="post-title-link" itemprop="url">base64</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-16 07:34:24" itemprop="dateModified" datetime="2021-06-16T07:34:24Z">2021-06-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>BASE64<br>编码和解码，根据规则可以转回去不是加密，加解密需要钥匙<br>它是一种编码算法，但是具有不可读性，所以可以说是防君子不防小人</p>
<p>0-9A-Za-z+/<br>1100 0101 1001 0011 0111 0110<br>00110001 00011001 00001101 00110110<br>base64<br>b64encode / b64decode</p>
<p>默认情况，可视字符基于ASCII码显示出来，</p>
<p>Base64是一种用64个可视/可打印字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，<br>刚好可以使用在Base64中的可打印字符包括大小写字母A-Z、a-z、数字0-9，这样共有62个字符以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态。</p>
<h3 id="base64怎么转换"><a href="#base64怎么转换" class="headerlink" title="base64怎么转换"></a>base64怎么转换</h3><p>1,将字符串拆成每三个字符一组,对应3个字节<br>2,计算每一个字符对应的ASCI码二进制,一共24个二进制位<br>3,将8位的二进制码,由于 log{2}64=6，所以按照每6个二进制位一组重新分组为一个单元，不足6位的在低位补0，对应某个可打印字符。对应于4个Base64单元，<br>4,计算对应的十进制编码<br>5,按照base64索引表,查看对应的字符<br>即3个字节可由4个可打印字符来表示，将3个字节编码为4个字符，<br>base64结果的长度一定是4的倍数</p>
<p>如果要编码的字节数不能被3整除，位数不够填满一组，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：<br>先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，<br>当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；<br>如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 参考下表：</p>
<p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。</p>
<h2 id="base64-是-Python-内建模块，我们只需要-import-导入模块就可以使用"><a href="#base64-是-Python-内建模块，我们只需要-import-导入模块就可以使用" class="headerlink" title="base64 是 Python 内建模块，我们只需要 import 导入模块就可以使用"></a><code>base64</code> 是 Python 内建模块，我们只需要 import 导入模块就可以使用</h2><p>把超越 ascii 范围的字符用 base64 编码为可见字符，</p>
<p>base64.b64encode(data)) data为byte字节类型数据。a bytes-like object is required, not ‘str’<br>当解码Base64的时候，字节字符串和Unicode文本都可以作为参数。 但是，Unicode字符串只能包含ASCII字符。</p>
<p>urlsafe 形式的编码方式，目的是将<code>+</code>和<code>/</code> 替换成 <code>-</code>和<code>_</code>，<br>因为标准的Base64并不适合直接放在URL里传输，<br>URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，<br>而这些“%”号在存入数据库时还需要再进行转换。</p>
<p><code>urlsafe_b64encode()</code>作用同b64encode(),会将+替换成-，/替换成_编码，不能 <code>b64encode</code>解码，用什么方式转码用同样的方式转回去</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># Some byte data</span></span><br><span class="line">s = <span class="string">b'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode as Base64</span></span><br><span class="line">a = base64.b64encode(s)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># b'aGVsbG8='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode from Base64</span></span><br><span class="line">print(base64.b64decode(a))</span><br><span class="line"><span class="comment"># b'hello'</span></span><br><span class="line"></span><br><span class="line">print(base64.b64encode(<span class="string">b'i\xcf\xbf'</span>))</span><br><span class="line"><span class="comment"># b'ac+/'</span></span><br><span class="line"></span><br><span class="line">print(base64.urlsafe_b64encode(<span class="string">b'i\xcf\xbf'</span>))</span><br><span class="line"><span class="comment"># b'ac-_'</span></span><br></pre></td></tr></tbody></table></figure>

<p>用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），<br>但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">读写二进制文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'mm.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="comment"># print(type(data))</span></span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    print(<span class="string">'字节数:'</span>, len(data))</span><br><span class="line">    <span class="comment"># 将图片处理成BASE-64编码</span></span><br><span class="line">    print(base64.b64encode(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'girl.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line">print(<span class="string">'写入完成!'</span>)</span><br></pre></td></tr></tbody></table></figure>


<p>如果直接使用<code>base64.b64decode()</code>函数将base64解码，是得到的16进制字符串是有问题的．<br>此时要使用<code>base64.b64decode(base64_data).hex()</code>来转换成16进制字符串．</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base64解码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_decode</span>(<span class="params">base64_data</span>):</span></span><br><span class="line">    temp = base64.b64decode(base64_data).hex()</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">"qgEeAGBFRQAAZEIAAFhCAAAAAAAAE0LFEAVqAAAHZhbn9rs="</span></span><br><span class="line">tem = base64_decode(data)</span><br><span class="line">print(tem)</span><br><span class="line"><span class="comment"># aa011e0060454500006442000058420000000000001342c510056a0000076616e7f6bb</span></span><br></pre></td></tr></tbody></table></figure>


<p>Base64编码仅仅用于面向字节的数据比如字节字符串和字节数组。 此外，编码处理的输出结果总是一个字节字符串。<br>如果你想混合使用Base64编码的数据和Unicode文本，你必须添加一个额外的解码步骤。例如：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = base64.b64encode(s).decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'aGVsbG8='</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth <span class="keyword">as</span> django_auth</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户认证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_auth</span>(<span class="params">request</span>):</span></span><br><span class="line">    get_http_auth = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>, <span class="string">b''</span>)</span><br><span class="line">    auth = get_http_auth.split()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        auth_parts = base64.b64decode(auth[<span class="number">1</span>]).decode(<span class="string">'iso-8859-1'</span>).partition(<span class="string">':'</span>)</span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    userid, password = auth_parts[<span class="number">0</span>], auth_parts[<span class="number">2</span>]</span><br><span class="line">    user = django_auth.authenticate(username=userid, password=password)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> user.id_active:</span><br><span class="line">        django_auth.login(request, user)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布会查询接口---增加用户认证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_event_list</span>(<span class="params">request</span>):</span></span><br><span class="line">    auth_result = user_auth(request)  <span class="comment"># 调用认证函数</span></span><br><span class="line">    <span class="keyword">if</span> auth_result == <span class="string">"null"</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse({<span class="string">'status'</span>: <span class="number">10011</span>, <span class="string">'message'</span>: <span class="string">'user auth null'</span>})</span><br><span class="line">    <span class="keyword">if</span> auth_result == <span class="string">"fail"</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse({<span class="string">'status'</span>: <span class="number">10012</span>, <span class="string">'message'</span>: <span class="string">'user auth fail'</span>})</span><br><span class="line">    eid = request.GET.get(<span class="string">"eid"</span>, <span class="string">""</span>)  <span class="comment"># 发布会 id</span></span><br><span class="line">    name = request.GET.get(<span class="string">"name"</span>, <span class="string">""</span>)  <span class="comment"># 发布会名称</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> loads</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    client = socket()</span><br><span class="line">    client.connect((<span class="string">'192.168.1.2'</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 定义一个保存二进制数据的对象</span></span><br><span class="line">    in_data = bytes()</span><br><span class="line">    <span class="comment"># 由于不知道服务器发送的数据有多大每次接收1024字节</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="comment"># 将收到的数据拼接起来</span></span><br><span class="line">        in_data += data</span><br><span class="line">        data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将收到的二进制数据解码成JSON字符串并转换成字典</span></span><br><span class="line">    <span class="comment"># loads函数的作用就是将JSON字符串转成字典对象</span></span><br><span class="line">    my_dict = loads(in_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    filename = my_dict[<span class="string">'filename'</span>]</span><br><span class="line">    filedata = my_dict[<span class="string">'filedata'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/Hao/'</span> + filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将base64格式的数据解码成二进制数据并写入文件</span></span><br><span class="line">        f.write(b64decode(filedata))</span><br><span class="line">    print(<span class="string">'图片已保存.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义线程类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileTransferHandler</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cclient</span>):</span></span><br><span class="line">            super().__init__()</span><br><span class="line">            self.cclient = cclient</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">            my_dict = {}</span><br><span class="line">            my_dict[<span class="string">'filename'</span>] = <span class="string">'guido.jpg'</span></span><br><span class="line">            <span class="comment"># JSON是纯文本不能携带二进制数据</span></span><br><span class="line">            <span class="comment"># 所以图片的二进制数据要处理成base64编码</span></span><br><span class="line">            my_dict[<span class="string">'filedata'</span>] = data</span><br><span class="line">            <span class="comment"># 通过dumps函数将字典处理成JSON字符串</span></span><br><span class="line">            json_str = dumps(my_dict)</span><br><span class="line">            <span class="comment"># 发送JSON字符串</span></span><br><span class="line">            self.cclient.send(json_str.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            self.cclient.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket()</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">'192.168.1.2'</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    print(<span class="string">'服务器启动开始监听...'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'guido.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将二进制数据处理成base64再解码成字符串</span></span><br><span class="line">        data = b64encode(f.read()).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 用一个字典(键值对)来保存要发送的各种数据</span></span><br><span class="line">        <span class="comment"># 待会可以将字典处理成JSON格式在网络上传递</span></span><br><span class="line">        FileTransferHandler(client).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">序列化 - 将对象变成字节序列(bytes)或者字符序列(str) - 串行化/腌咸菜</span></span><br><span class="line"><span class="string">反序列化 - 把字节序列或者字符序列还原成对象</span></span><br><span class="line"><span class="string">Python标准库对序列化的支持：</span></span><br><span class="line"><span class="string">json - 字符形式的序列化</span></span><br><span class="line"><span class="string">pickle - 字节形式的序列化</span></span><br><span class="line"><span class="string">dumps / loads</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> example02 <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonJsonEncoder</span>(<span class="params">json.JSONEncoder</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span>(<span class="params">self, o</span>):</span></span><br><span class="line">        <span class="keyword">return</span> o.__dict__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cli = redis.StrictRedis(host=<span class="string">'120.77.222.217'</span>, port=<span class="number">6379</span>, </span><br><span class="line">                            password=<span class="string">'123123'</span>)</span><br><span class="line">    data = base64.b64decode(cli.get(<span class="string">'guido'</span>))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'guido2.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file_stream:</span><br><span class="line">        file_stream.write(data)</span><br><span class="line">    <span class="comment"># with open('guido.jpg', 'rb') as file_stream:</span></span><br><span class="line">    <span class="comment">#     result = base64.b64encode(file_stream.read())</span></span><br><span class="line">    <span class="comment"># cli.set('guido', result)</span></span><br><span class="line">    <span class="comment"># persons = [</span></span><br><span class="line">    <span class="comment">#     Person('骆昊', 39), Person('王大锤', 18),</span></span><br><span class="line">    <span class="comment">#     Person('白元芳', 25), Person('狄仁杰', 37)</span></span><br><span class="line">    <span class="comment"># ]</span></span><br><span class="line">    <span class="comment"># persons = json.loads(cli.get('persons'))</span></span><br><span class="line">    <span class="comment"># print(persons)</span></span><br><span class="line">    <span class="comment"># cli.set('persons', json.dumps(persons, cls=PersonJsonEncoder))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight scheme"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scheme"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight scheme"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```</span><br></pre></td></tr></tbody></table></figure>
<p>```</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/django-jing-tai-zi-yuan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/django-jing-tai-zi-yuan/" class="post-title-link" itemprop="url">django加载配置静态资源文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-24 13:16:54" itemprop="dateModified" datetime="2021-05-24T13:16:54Z">2021-05-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果要在Django项目中使用静态资源，可以先创建一个用于保存静态资源的目录。<br>在<code>vote</code>项目中，我们将静态资源置于名为<code>static</code>的文件夹中，<br>在该文件夹包含了三个子文件夹：css、js和images，<br>分别用来保存外部CSS文件、外部JavaScript文件和图片资源，如下图所示。</p>
<p><img src="/2020/08/21/django-jing-tai-zi-yuan/pycharm-django-static.png"></p>
<p>为了能够找到保存静态资源的文件夹，我们还需要修改Django项目的配置文件<code>settings.py</code>，如下所示：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置静态文件的存储路径</span></span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, <span class="string">'static'</span>), ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># STATIC_ROOT = os.path.join(BASE_DIR, 'static')    # 生产环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置静态文件的访问路径(指通过哪个url地址找静态文件) 访问静态文件的路由地址</span></span><br><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br></pre></td></tr></tbody></table></figure>

<p>配置好静态资源之后，大家可以运行项目，然后看看之前我们写的页面上的图片是否能够正常加载出来。需要说明的是，在项目正式部署到线上环境后，我们通常会把静态资源交给专门的静态资源服务器（如Nginx、Apache）来处理，而不是有运行Python代码的服务器来管理静态资源，所以上面的配置并不适用于生产环境，仅供项目开发阶段测试使用。使用静态资源的正确姿势我们会在后续的章节为大家讲解。</p>
<p>项目处于线下时(DEBUG=TRUE)，放了新的静态文件，需要重启服务：manage.py runserver,<br>django才能接管你的静态文件；处于线上时(DEBUG=False),nginx代替django接管</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/javascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/javascript/" class="post-title-link" itemprop="url">js</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-22 03:23:09" itemprop="dateModified" datetime="2021-05-22T03:23:09Z">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；指变量声明语句位置的改变（提升）<br>使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；<br>使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。对数组下的某个元素或者对象下的某个属性赋值，修改数组的某个元素，或对象的某个属性不会报错，引用类型中变量存储的只是指针，const要求的是指针地址不变而不是指针指向对象内部发生了什么。不能修改的是栈内存在的值和地址。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/django-shi-wu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/django-shi-wu/" class="post-title-link" itemprop="url">django事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-30 15:04:44" itemprop="dateModified" datetime="2021-05-30T15:04:44Z">2021-05-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>需要事务控制的情况：<br>对多个ORM模型操作时（比如：用户信息表和用户详细信息表，必须一致）<br>对结果要求严格一致（要么成功，要么失败）</p>
<p>在django中使用事务：<br>    一：加装饰器自动提交</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">viewfunc</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="comment"># 事务内的代码</span></span><br><span class="line">do_stuff()</span><br></pre></td></tr></tbody></table></figure>

<p>atomic自动提交过程解析<br>a. 进入到最外层的atomic代码块时会打开一个事务<br>b. 进入到内层atomic代码块时会创建一个标记<br>c. 退出内部块时会释放或回滚至标记<br>d. 退出外部块时提交或回退事务</p>
<p>手动提交和回滚</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 放弃自动提交</span></span><br><span class="line">transaction.set_autocommit(<span class="literal">False</span>)</span><br><span class="line">a.save()</span><br><span class="line">b.save()</span><br><span class="line">transaction.commit() <span class="comment"># 提交事务</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">transaction.rollback() <span class="comment"># 回滚</span></span><br></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="meta">@transaction.atomic()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="string">""" 事务练习：用户发布微博时候，顺便发布一条评论，只能同时成功，否则发生回滚 """</span></span><br><span class="line"><span class="comment"># 获得一个用户</span></span><br><span class="line">user = WeiboUser.objects.get(pk=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 发布一条微博和评论</span></span><br><span class="line">weibo = Weibo.objects.create(user=user, content=<span class="string">'事务练习'</span>, source=<span class="string">'other'</span>)</span><br><span class="line">WeiboComment.objects.create(user=user, content=<span class="string">'事务练习'</span>, weibo=<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'ojbk'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>上例中会weibo不能为空值，会触发回滚机制，若事务机制不存在，则只会将weibo对象创建成功<br>通过with来完成自动的事务提交：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transaction_with</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="string">""" 事务练习：用户发布微博时候，顺便发布一条评论，只能同时成功，否则发生回滚 """</span></span><br><span class="line"><span class="comment"># 获得一个用户</span></span><br><span class="line">user = WeiboUser.objects.get(pk=<span class="number">3</span>)</span><br><span class="line"><span class="keyword">with</span> transaction.atomic():</span><br><span class="line"><span class="comment"># 发布一条微博和评论</span></span><br><span class="line">weibo = Weibo.objects.create(user=user, content=<span class="string">'事务练习_with'</span>, source=<span class="string">'other'</span>)</span><br><span class="line">WeiboComment.objects.create(user=user, content=<span class="string">'事务练习_with'</span>, weibo=<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'ojbk'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>手动提交事务</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transaction_hand</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="string">""" 事务练习：用户发布微博时候，顺便发布一条评论，只能同时成功，否则发生回滚 """</span></span><br><span class="line"><span class="comment"># 获得一个用户</span></span><br><span class="line">user = WeiboUser.objects.get(pk=<span class="number">3</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 放弃自动提交</span></span><br><span class="line">transaction.set_autocommit(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 发布一条微博和评论</span></span><br><span class="line">weibo = Weibo.objects.create(user=user, content=<span class="string">'事务练习_hand'</span>, source=<span class="string">'other'</span>)</span><br><span class="line">WeiboComment.objects.create(user=user, content=<span class="string">'事务练习_hand'</span>, weibo=<span class="literal">None</span>)</span><br><span class="line">transaction.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">transaction.rollback()</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'ojbk'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><code>atomic()</code> 在<code>with</code>语句结束时，会自动进行提交，或当数据库代码出错时，自动进行回滚</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="keyword">with</span> transaction.atomic():</span><br><span class="line"><span class="comment"># with 语句下面的代码，凡是涉及到数据库操作的代码，</span></span><br><span class="line"><span class="comment"># 在进行数据库操作时，都会放在同一个事物中。</span></span><br><span class="line">    p1 = transaction.savepoint（）</span><br><span class="line">    <span class="comment"># 在进行数据库操作时，设置事物保存点</span></span><br><span class="line">    ..................</span><br><span class="line">    transaction.savepoint_rollback（p1）</span><br><span class="line">    <span class="comment"># 在进行数据库操作时，回滚到指定的保存点</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="meta">    @transaction.atomic</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/django-zhong-jian-jian-zhi-xian-zhi-ip-fang-wen-ci-shu-he-hei-ming-dan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/django-zhong-jian-jian-zhi-xian-zhi-ip-fang-wen-ci-shu-he-hei-ming-dan/" class="post-title-link" itemprop="url">Django中间件之限制ip访问次数和黑名单</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-06 11:30:54" itemprop="dateModified" datetime="2021-06-06T11:30:54Z">2021-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="限制ip访问频率"><a href="#限制ip访问频率" class="headerlink" title="限制ip访问频率"></a>限制ip访问频率</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.http.response <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> caches</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 频率限制访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpLimitMiddleware</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        ip = request.META.get(<span class="string">"REMOTE_ADDR"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择缓存的数据库 redis缓存</span></span><br><span class="line">        cache = caches[<span class="string">'redis_backend'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首先缓存中，根据ip获取数据，假如没有数据，值为空列表 []</span></span><br><span class="line">        requests = cache.get(ip, [])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果值存在，且当前时间 - 最后一个时间 &gt; 30 则清洗掉这个值  这里我们插入请求的时间为头插</span></span><br><span class="line">        <span class="keyword">while</span> requests <span class="keyword">and</span> time.time() - requests[<span class="number">-1</span>] &gt; <span class="number">30</span>:</span><br><span class="line">            requests.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若没有存在值，则添加，过期时间为30秒，这个过期时间与上面判断的30 保持一致</span></span><br><span class="line">        requests.insert(<span class="number">0</span>, time.time())</span><br><span class="line">        cache.set(ip, requests, timeout=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 限制访问次数为 5 次</span></span><br><span class="line">        print(len(requests))</span><br><span class="line">        <span class="keyword">if</span> len(requests) &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"请求过于频繁，请稍后重试！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.http.response <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> caches</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 频率限制访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpLimitMiddleware</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        ip = request.META.get(<span class="string">"REMOTE_ADDR"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择缓存的数据库 redis缓存</span></span><br><span class="line">        cache = caches[<span class="string">'redis_backend'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取黑名单</span></span><br><span class="line">        black_list = cache.get(<span class="string">'black'</span>, [])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ip <span class="keyword">in</span> black_list:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"黑名单用户！"</span>)</span><br><span class="line"></span><br><span class="line">        requests = cache.get(ip, [])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果值存在，且当前时间 - 最后一个时间 &gt; 30 则清洗掉这个值  这里我们插入请求的时间为头插</span></span><br><span class="line">        <span class="keyword">while</span> requests <span class="keyword">and</span> time.time() - requests[<span class="number">-1</span>] &gt; <span class="number">60</span>:</span><br><span class="line">            requests.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若没有存在值，则添加，过期时间为30秒，这个过期时间与上面判断的30 保持一致</span></span><br><span class="line">        requests.insert(<span class="number">0</span>, time.time())</span><br><span class="line">        cache.set(ip, requests, timeout=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果访问次数大于30次，假如黑名单，封2分钟</span></span><br><span class="line">        <span class="keyword">if</span> len(requests) &gt; <span class="number">30</span>:</span><br><span class="line">            black_list.append(ip)</span><br><span class="line">            cache.set(<span class="string">'black'</span>, black_list, timeout=<span class="number">60</span> * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 限制访问次数为 5 次</span></span><br><span class="line">        print(len(requests))</span><br><span class="line">        <span class="keyword">if</span> len(requests) &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"请求过于频繁，请稍后重试！"</span>)</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/django-zi-ding-yi-cha-xun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/21/django-zi-ding-yi-cha-xun/" class="post-title-link" itemprop="url">django自定义查询</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-12 03:09:10" itemprop="dateModified" datetime="2021-06-12T03:09:10Z">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自定义查询函数Q(条件判断)<br>Q对象：用于条件之间的逻辑关系（&amp; | <del>）<br>多个可选的查询条件：<br>    实现复杂的查询<br>    优先级从高到低：</del> &amp; | 非  或 与，对应SQL中的AND和OR<br>    可以混合使用 Q 对象和关键字参数，<br>    Q 对象和关键字参数是用”and”拼在一起的（即将逗号看成 and ），<br>    但是 Q 对象必须位于所有关键字参数的前面。</p>
<p>自定义查询函数F(“字段名称”)<br>之前构造的过滤器都只是将字段值与某个常量做比较，<br>如果想要对两个字段的值做比较，就需要用到 F()。<br>F() 的实例可以在查询中引用字段，<br>来比较同一个 model 实例中两个不同字段的值。</p>
<p>F()函数从数据库操作层面修改数据<br>F()函数可避免同时操作时竞态条件</p>
<p>F对象：用于类属性之间的比较。</p>
<p>使用前要先从 django.db.models 引入 F:<br>from django.db.models import F<br>F 动态获取对象字段的值，可以进行运算。<br>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取余的操作。<br>修改操作（update）也可以使用 F() 函数。</p>
<p>使用SQL查询<br>关联多张表的时候需要使用sql查询</p>
<p>在视图中获取表单值<br>◆GET请求<br>request.GET.get( name, None)<br>◆POST请求<br>request.POST.get( name, None)</p>
<p>管理器raw(sql)查询<br>Python<br>1    raw(raw_query,params=None,translations=None)<br>2    # 返回django.db.models.query.RawQuerySet实例<br>def raw_sql(request):</p>
<h1 id="通过url传入指定参数，在视图中获取表单值"><a href="#通过url传入指定参数，在视图中获取表单值" class="headerlink" title="通过url传入指定参数，在视图中获取表单值"></a>通过url传入指定参数，在视图中获取表单值</h1><p>username = request.GET.get(‘name’, None)<br>sql = (<br>‘SELECT id FROM weibo_user ‘<br>‘WHERE username=%s’<br>)<br>user_list = WeiboUser.objects.raw(sql, (username,))</p>
<h1 id="user-list对象是一个RawQuerySet"><a href="#user-list对象是一个RawQuerySet" class="headerlink" title="user_list对象是一个RawQuerySet"></a>user_list对象是一个RawQuerySet</h1><p>for user in user_list:</p>
<h1 id="user也只是单个Query-可指定其字段"><a href="#user也只是单个Query-可指定其字段" class="headerlink" title="user也只是单个Query,可指定其字段"></a>user也只是单个Query,可指定其字段</h1><p>print(user.nickname)<br>return HttpResponse(‘ok’)</p>
<p>获取数据库连接、游标、直接执行sql<br>类似于python操作数据库，举例：</p>
<p>def sql(request):<br>    # 获取数据库的连接<br>    from django.db import connection<br>    # 根据连接获取游标<br>    cursor = connection.cursor()<br>    sql = (<br>        ‘SELECT id,username,nickname FROM weibo_user ‘<br>        ‘WHERE id=%s’<br>    )<br>    # 执行sql<br>    cursor.execute(sql, (3,))<br>    # 查询结果<br>    user_list = cursor.fetchall()<br>    # user_list对象是一个元组<br>    for user in user_list:<br>        print(user)<br>    return HttpResponse(‘ok’)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/34/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
