<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:type" content="website">
<meta property="og:title" content="外心人D的博客">
<meta property="og:url" content="https://bubbleboy11.github.io/page/3/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">359</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/19/gin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/19/gin/" class="post-title-link" itemprop="url">gin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-18 17:46:44" itemprop="dateCreated datePublished" datetime="2021-07-18T17:46:44Z">2021-07-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-10 07:03:50" itemprop="dateModified" datetime="2021-09-10T07:03:50Z">2021-09-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">    <span class="string">"go.uber.org/zap"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyRequestId = <span class="string">"requestId"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    logger, err := zap.NewProduction()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//  Middleware 调用</span></span><br><span class="line">    r.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">        s := time.Now()</span><br><span class="line"></span><br><span class="line">        c.Next()</span><br><span class="line"></span><br><span class="line">        logger.Info(<span class="string">"incoming request"</span>,</span><br><span class="line">            zap.String(<span class="string">"path"</span>, c.Request.URL.Path),</span><br><span class="line">            zap.Int(<span class="string">"status"</span>, c.Writer.Status()),</span><br><span class="line">            zap.Duration(<span class="string">"elapsed"</span>, time.Now().Sub(s)))</span><br><span class="line">    }, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">        c.Set(keyRequestId, rand.Int())</span><br><span class="line"></span><br><span class="line">        c.Next()</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">        h := gin.H{</span><br><span class="line">            <span class="string">"message"</span>:   <span class="string">"pong"</span>,</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> rid, exists := c.Get(keyRequestId); exists {</span><br><span class="line">            h[keyRequestId] = rid</span><br><span class="line">        }</span><br><span class="line">        c.JSON(<span class="number">200</span>, h)</span><br><span class="line">    })</span><br><span class="line">    r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">        c.String(<span class="number">200</span>, <span class="string">"hello"</span>)</span><br><span class="line">    })</span><br><span class="line">    r.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/16/go-bi-bao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/16/go-bi-bao/" class="post-title-link" itemprop="url">go闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-15 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-15T16:21:41Z">2021-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-18 09:59:27" itemprop="dateModified" datetime="2021-09-18T09:59:27Z">2021-09-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>闭包是一个函数，是函数与函数外部数据的引用（在函数体内部访问引用到了定义函数体外部的变量），被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，<br><strong>匿名函数 + 自由变量的引用环境(定义它的上下文) = 闭包</strong></p>
<p>同一个函数与不同引用环境组合，可以形成不同的实例</p>
<p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，<br>函数是编译期静态的概念，而闭包是运行期动态的概念。</p>
<h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span> <span class="comment">// 准备一个字符串</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 创建一个匿名函数</span></span><br><span class="line">    <span class="comment">// 在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包，匿名函数中访问str</span></span><br><span class="line">    fmt.Printf(<span class="string">"str is %s\n"</span>, str)</span><br><span class="line">    str = <span class="string">"hello dude"</span></span><br><span class="line">}</span><br><span class="line">foo() <span class="comment">// str is hello world 调用匿名函数，执行闭包，打印后 str 发生修改</span></span><br><span class="line">fmt.Println(str) <span class="comment">// hello dude</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(ReturnClosure(<span class="string">"Tom"</span>)()) <span class="comment">// Hello, Tom</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReturnClosure</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h4><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。<br>闭包函数每次调用，均保留上次的执行结果，并参与下一次调用时候的运算<br>闭包延时绑定<br>闭包里面使用的闭包外的参数，其值是在最终调用的时候确定下来的</p>
<p>累加器的实现：<br>创建了函数 Accumulate(value int)<br>函数输出一个初始值提供一个值，调用时返回另外一个为初始值创建的闭包函数。</p>
<p>以一个例子来定义一个闭包，该闭包函数每调用一次，每次调用函数会指定对变量进行累加1</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 返回一个闭包函数，每次返回会创建一个新的函数实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        <span class="comment">// 对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</span></span><br><span class="line">        value++</span><br><span class="line">        <span class="comment">// 将修改后的值通过闭包的返回值返回一个累加值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建一个累加器，初始值为0，返回的 accumulator 是类型为 func() int 的函数变量</span></span><br><span class="line">    accumulator := Accumulate(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 每调用一次 accumulator()，代码 return func() int 开始执行匿名函数逻辑，直到 return value 返回，会自动对引用的变量进行累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator()) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(accumulator()) <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator) <span class="comment">// 0xc000006018</span></span><br><span class="line"></span><br><span class="line">    accumulator1 := Accumulate(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(accumulator1()) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(accumulator1()) <span class="comment">// 3</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator1) <span class="comment">// 0xc000006028</span></span><br><span class="line"></span><br><span class="line">accumulator2 := Accumulate(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(accumulator2()) <span class="comment">// 11</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator2) <span class="comment">//0xc000006038</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对比输出的日志发现 accumulator 与 accumulator1 与 accumulator2 输出的函数地址不同，因此它们是不同的闭包实例。</p>
<p>创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">    nextNumber := getSequence()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">    fmt.Println(nextNumber())       <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(nextNumber())       <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(nextNumber())       <span class="comment">// 3</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nextNumber) <span class="comment">// 0xc000006028</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">    nextNumber1 := getSequence()</span><br><span class="line">    fmt.Println(nextNumber1())       <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(nextNumber1())       <span class="comment">// 2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;nextNumber1) <span class="comment">// 0xc000006038</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    Delay()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Delay</span><span class="params">()</span></span> {</span><br><span class="line">    fns := <span class="built_in">make</span>([]<span class="function"><span class="keyword">func</span><span class="params">()</span>, 0, 10)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        fns = <span class="built_in">append</span>(fns, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Printf(<span class="string">"hello, this is : %d\n"</span>, i) <span class="comment">// 拿到最后更新的变量</span></span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> fns {</span><br><span class="line">        fn()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br><span class="line">hello, this is : <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>同一个包中，函数不支持重载即不能有相同的函数名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    sum := <span class="number">0</span> <span class="comment">// 自由变量</span></span><br><span class="line">    <span class="comment">// 函数返回的时候不只是返回一个函数，而是返回一个闭包 包括自由变量和局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> { <span class="comment">// value 局部变量</span></span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    a := adder() <span class="comment">// is trivial and also works.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        fmt.Printf(<span class="string">"0 + 1 + ... + %d = %d\n"</span>, i, a(i))</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">9</span> = <span class="number">45</span></span><br></pre></td></tr></tbody></table></figure>

<p>“正统”函数编程<br>不可变性：不能有状态，只有常量和函数<br>函数只能有一个参数<br>修改为正统函数式编程</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iAdder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">iAdder</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span> {</span><br><span class="line">        <span class="keyword">return</span> base + v, adder2(base + v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">    b := adder2(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">var</span> s <span class="keyword">int</span></span><br><span class="line">        s, b = b(i)</span><br><span class="line">        fmt.Printf(<span class="string">"0 + 1 + ... + %d = %d\n"</span>, i, s)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + ... + <span class="number">9</span> = <span class="number">45</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/16/go-de-aop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/16/go-de-aop/" class="post-title-link" itemprop="url">go的aop</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-15 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-15T16:21:41Z">2021-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-20 03:04:18" itemprop="dateModified" datetime="2021-09-20T03:04:18Z">2021-09-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>AOP：用闭包来实现责任链<br>• 为 server 支持一些 AOP逻辑<br>• AOP：横向关注点，一般用于解决 Log, tracing，metric，熔断，限流等<br>• filter：我们希望请求在真正被处理之前能够经过一大堆的 filter</p>
<p>责任链是很常见的用于解决 AOP 的一种方式。<br>2. 类似的也叫做 middleware, interceptor… 本质是一样的<br>3. Go 函数是一等公民，所以可以考虑用闭包来实现责任链<br>4. filter 很常见，比如说鉴权，日志，tracing，以及跨域等都可以用 filter 来实现</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/15/go-zuo-yong-yu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/15/go-zuo-yong-yu/" class="post-title-link" itemprop="url">go作用域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-14 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-14T16:21:41Z">2021-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-15 10:22:23" itemprop="dateModified" datetime="2021-07-15T10:22:23Z">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。</p>
<p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。<br>作用域（Scope）为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。权限的概念，可见性就是变量可以在哪个范围以内使用。有些变量可以在所有代码文件中使用，有些变量只能在当前的文件中使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<h3 id="局部变量-（Local-Variable）"><a href="#局部变量-（Local-Variable）" class="headerlink" title="局部变量 （Local Variable）"></a>局部变量 （Local Variable）</h3><p>函数体内定义的变量，作用域只在函数体内有效，在函数外部是不可知的。<br>函数的参数和返回值变量也是局部变量。<br>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量定义的内存空间就会被释放。销毁。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明局部变量 */</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化参数 */</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"结果： a = %d, b = %d and c = %d\n"</span>, a, b, c)</span><br><span class="line"><span class="comment">// 结果： a = 10, b = 20 and c = 30</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外定义声明的变量，全局变量只需要在一个源文件中定义声明后，就可以在整个程序所有源文件中使用，<br>可以在整个包甚至外部包（被导出后）不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。<br>在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">    <span class="comment">/* 初始化参数 */</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    g = a + b</span><br><span class="line">    fmt.Printf(<span class="string">"结果： a = %d, b = %d and g = %d\n"</span>, a, b, g)</span><br><span class="line">    <span class="comment">// 结果： a = 10, b = 20 and g = 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> g <span class="keyword">int</span> = <span class="number">30</span></span><br><span class="line">    fmt.Printf(<span class="string">"结果： g = %d\n"</span>, g) <span class="comment">// 结果： g = 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量<br>会作为函数体内的局部变量。<br>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。<br>如果与全局变量同名它们会优先使用。</p>
<p>形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p>
<h4 id="函数值传递"><a href="#函数值传递" class="headerlink" title="函数值传递"></a>函数值传递</h4><p>指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">/* main 函数中声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"main()函数中 a = %d\n"</span>, a)</span><br><span class="line">    <span class="comment">// main()函数中 a = 10</span></span><br><span class="line">    c = sum(a, b)</span><br><span class="line">    <span class="comment">// sum() 函数中 a = 10</span></span><br><span class="line">    <span class="comment">// sum() 函数中 b = 20</span></span><br><span class="line">    fmt.Printf(<span class="string">"main()函数中 c = %d\n"</span>, c)</span><br><span class="line">    <span class="comment">// main()函数中 c = 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义-两数相加 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"sum() 函数中 a = %d\n"</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">"sum() 函数中 b = %d\n"</span>, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testScope</span><span class="params">(args <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    args = <span class="number">100</span></span><br><span class="line">    fmt.Println(args)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args <span class="keyword">int</span></span><br><span class="line">    testScope(args) <span class="comment">// 100</span></span><br><span class="line">    fmt.Println(args) <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(params ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> params {</span><br><span class="line">        sum += v</span><br><span class="line">    }</span><br><span class="line">    params[<span class="number">0</span>] = <span class="number">9</span> <span class="comment">// 值传递不影响</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数引用传递"><a href="#函数引用传递" class="headerlink" title="函数引用传递"></a>函数引用传递</h4><p>在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，</p>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>在程序运行期间变量有效存在的时间间隔。</p>
<p>变量的生命周期与变量的作用域有着不可分割的联系：</p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">        blackIndex, <span class="comment">// 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span></span><br><span class="line">    )               <span class="comment">// 小括号另起一行缩进，和大括号的风格保存一致</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，在每次循环的开始会创建临时变量 t，然后在每次循环迭代中创建临时变量 x 和 y。临时变量 x、y 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/14/go-di-gui-han-shu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/14/go-di-gui-han-shu/" class="post-title-link" itemprop="url">go递归函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-13 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-13T16:21:41Z">2021-07-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-14 01:11:12" itemprop="dateModified" datetime="2021-08-14T01:11:12Z">2021-08-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>递归函数指的是在运行的过程中函数内部调用函数自身的函数，<br>从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，</p>
<p>递归函数 在一个循环体当中执行，必须有一个条件可以在满足某个条件时终止当前的循环，否则为死循环</p>
<p>构成递归需要具备以下条件：</p>
<ul>
<li>一个问题可以被拆分成多个子问题；</li>
<li>拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；</li>
<li>不能无限制的调用本身，子问题需要有退出递归状态的条件。<br>注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> {</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   recursion()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>位置     值<br>1        1<br>2        1<br>3        2<br>4        3<br>..    ..<br>n    func(n-1) + func(n-2)</p>
<p>传递一个位置，返回当前位置的值</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf(<span class="string">"fibonacci(%d) is: %d\n"</span>, i, result)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> {</span><br><span class="line">        res = <span class="number">1</span> <span class="comment">// res = n</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        res = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> {</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">fibonacci(<span class="number">1</span>) is: <span class="number">1</span></span><br><span class="line">fibonacci(<span class="number">2</span>) is: <span class="number">1</span></span><br><span class="line">fibonacci(<span class="number">3</span>) is: <span class="number">2</span></span><br><span class="line">fibonacci(<span class="number">4</span>) is: <span class="number">3</span></span><br><span class="line">fibonacci(<span class="number">5</span>) is: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> { <span class="comment">// 闭包</span></span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="built_in">println</span>(f()) <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">println</span>(f()) <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">println</span>(f()) <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">println</span>(f()) <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">println</span>(f()) <span class="comment">// 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">intGen</span></span> {</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> intGen <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为接收者类型也就是作为参数实现Read接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g intGen)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> {</span><br><span class="line">    next := g()</span><br><span class="line">    <span class="keyword">if</span> next &gt; <span class="number">200</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">    }</span><br><span class="line">    s := fmt.Sprintf(<span class="string">"%d\n"</span>, next)</span><br><span class="line">    <span class="keyword">return</span> strings.NewReader(s).Read(p) <span class="comment">// 找个代理帮助我们读取</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFileContents</span><span class="params">(reader io.Reader)</span></span> {</span><br><span class="line">    scanner := bufio.NewScanner(reader)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() {</span><br><span class="line">        fmt.Println(scanner.Text())</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> f intGen = Fibonacci()</span><br><span class="line">    printFileContents(f)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="number">144</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a>数字阶乘</h3><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作n!</p>
<p>例如，n!=1×2×3×…×n，阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p>
<p>使用递归函数计算给定数的阶乘，示例代码如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">uint64</span>)</span> <span class="params">(result <span class="keyword">uint64</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> {</span><br><span class="line">        result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d 的阶乘是 %d\n"</span>, i, Factorial(<span class="keyword">uint64</span>(i)))</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">10</span> 的阶乘是 <span class="number">3628800</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多个函数组成递归"><a href="#多个函数组成递归" class="headerlink" title="多个函数组成递归"></a>多个函数组成递归</h3><p>Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%d is even: is %t\n"</span>, <span class="number">16</span>, even(<span class="number">16</span>)) <span class="comment">// 16 is even: is true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d is odd: is %t\n"</span>, <span class="number">17</span>, odd(<span class="number">17</span>))</span><br><span class="line">    <span class="comment">// 17 is odd: is true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d is odd: is %t\n"</span>, <span class="number">18</span>, odd(<span class="number">18</span>))</span><br><span class="line">    <span class="comment">// 18 is odd: is false</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">even</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> odd(RevSign(nr) - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">odd</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> even(RevSign(nr) - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RevSign</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> -nr</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nr</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">16</span> is even: is <span class="literal">true</span></span><br><span class="line"><span class="number">17</span> is odd: is <span class="literal">true</span></span><br><span class="line"><span class="number">18</span> is odd: is <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/12/grpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/grpc/" class="post-title-link" itemprop="url">grpc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-11 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-11T16:21:41Z">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-29 04:14:49" itemprop="dateModified" datetime="2021-09-29T04:14:49Z">2021-09-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>gRPC</p>
<p>“A high-performance, open-source universal RPC framework”</p>
<ul>
<li>多语言：语言中立，支持多种语言。</li>
<li>轻量级、高性能：序列化支持 PB (Protocol Buffer) 和 JSON，PB 是一种语言无关的高性能序列化框架。<br>可插拔</li>
<li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。<br>设计理念<br>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量</li>
<li>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。<br>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。<br>流：Streaming API。<br>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。<br>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。<br>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/12/grpc-de-go-de-rpc-ru-men/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/grpc-de-go-de-rpc-ru-men/" class="post-title-link" itemprop="url">grpc的go的rpc入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-11 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-11T16:21:41Z">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-05 03:26:03" itemprop="dateModified" datetime="2021-10-05T03:26:03Z">2021-10-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html</a></p>
<h3 id="RPC版”Hello-World”"><a href="#RPC版”Hello-World”" class="headerlink" title="RPC版”Hello, World”"></a>RPC版”Hello, World”</h3><p>Go语言的RPC包的路径为net/rpc，也就是放在了net包目录下面。因此我们可以猜测该RPC包是建立在net包基础之上的。在第一章“Hello, World”革命一节最后，我们基于http实现了一个打印例子。下面我们尝试基于rpc实现一个类似的例子。</p>
<p>我们先构造一个HelloService类型，其中的Hello方法用于实现打印功能</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    *reply = <span class="string">"hello "</span>+ request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中Hello方法必须满足<strong>Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法</strong>。</p>
<p>然后就可以将HelloService类型的对象注册为一个RPC服务：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">    <span class="comment">// rpc.RegisterName("HelloService", &amp;HelloService{})</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>) <span class="comment">// 省略127.0.0.1</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("监听端口失败")</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"Accept error:"</span>, err) <span class="comment">// 当一个新的连接进来的时候</span></span><br><span class="line">        <span class="comment">// panic("建立链接失败")</span></span><br><span class="line">    }</span><br><span class="line">    rpc.ServeConn(conn)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>rpc.Register</code>函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在“HelloService”服务空间之下。然后我们建立一个唯一的TCP链接，并且通过<code>rpc.ServeConn</code>函数在该TCP链接上为对方提供RPC服务。</p>
<p>下面是客户端请求HelloService服务的代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先是通过<code>rpc.Dial</code>拨号RPC服务，然后通过<code>client.Call</code>调用具体的RPC方法。在调用<code>client.Call</code>时，第一个参数是用点号链接的RPC服务名字和方法名字，第二和第三个参数分别我们定义RPC方法的两个参数。</p>
<p>先运行服务端，再运行客户端，执行结果</p>
<figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">hello:</span>hello</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更安全的RPC接口"><a href="#更安全的RPC接口" class="headerlink" title="更安全的RPC接口"></a>更安全的RPC接口</h3><p>在涉及RPC的应用中，作为开发人员一般至少有三种角色：首先是服务端实现RPC方法的开发人员，其次是客户端调用RPC方法的人员，最后也是最重要的是制定服务端和客户端RPC接口规范的设计人员。在前面的例子中我们为了简化将以上几种角色的工作全部放到了一起，虽然看似实现简单，但是不利于后期的维护和工作的切割。</p>
<p>如果要重构HelloService服务，第一步需要明确服务的名字和接口：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hanlder</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称前缀解决冲突的问题</span></span><br><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">"handler/HelloService"</span></span><br><span class="line"><span class="comment">// const HelloServiceName = "path/to/pkg.HelloService"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="comment">// 关心的是NewHelloService 这个结构体中的方法而不是名字</span></span><br><span class="line"><span class="keyword">type</span> NewHelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *NewHelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server_proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServicer <span class="keyword">interface</span> {</span><br><span class="line">    Hello(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果做到解耦 - 我们关系的是函数 鸭子类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(srv HelloServicer)</span> <span class="title">error</span></span> { <span class="comment">// 用接口不用导入结构体，增强解耦</span></span><br><span class="line">    <span class="keyword">return</span> rpc.RegisterName(hanlder.HelloServiceName, srv)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将RPC服务的接口规范分为三个部分：首先是服务的名字，然后是服务要实现的详细方法列表，最后是注册该类型服务的函数。为了避免名字冲突，我们在RPC服务的名字中增加了包路径前缀（这个是RPC服务抽象的包路径，并非完全等价Go语言的包路径）。RegisterHelloService注册服务时，编译器会要求传入的对象满足HelloServiceInterface接口。</p>
<p>在定义了RPC服务接口规范之后，客户端就可以根据规范编写RPC调用的代码了：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 1. 建立连接</span></span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(hanlder.HelloServiceName+<span class="string">".Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中唯一的变化是client.Call的第一个参数用<code>HelloServiceName+".Hello"</code>代替了<code>"HelloService.Hello"</code>。然而通过client.Call函数调用RPC方法依然比较繁琐，同时参数的类型依然无法得到编译器提供的安全保障。</p>
<p>为了简化客户端用户调用RPC函数，我们在可以在接口规范部分增加对客户端的简单包装：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client_proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServiceStub <span class="keyword">struct</span> {</span><br><span class="line">    *rpc.Client</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在go语言中没有类、对象 就意味着没有初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHelloServiceClient</span><span class="params">(protcol, address <span class="keyword">string</span>)</span> <span class="title">HelloServiceStub</span></span> {</span><br><span class="line">    conn, err := rpc.Dial(protcol, address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        <span class="comment">// panic("connect error!")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> HelloServiceStub{Client: conn}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HelloServiceStub)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    err := c.Call(hanlder.HelloServiceName+<span class="string">".Hello"</span>, request, reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们在接口规范中针对客户端新增加了HelloServiceClient类型，该类型也必须满足HelloServiceInterface接口，这样客户端用户就可以直接通过接口对应的方法调用RPC函数。同时提供了一个DialHelloService方法，直接拨号HelloService服务。</p>
<p>基于新的客户端接口，我们可以简化客户端用户的代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/client_proxy"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//封装后，像本地调用函数一样</span></span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    client, err := client_proxy.NewHelloServiceClient(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 只想写业务逻辑 不想关注每个函数的名称</span></span><br><span class="line">    <span class="comment">// 客户端部分</span></span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err := client.Hello(<span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在客户端用户不用再担心RPC方法名字或参数类型不匹配等低级错误的发生。</p>
<p>最后是基于RPC接口规范编写真实的服务端代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/server_proxy"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    server_proxy.RegisterHelloService(&amp;hanlder.NewHelloService{})</span><br><span class="line">    <span class="comment">// server_proxy.RegisterHelloService(new(hanlder.NewHelloService))</span></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept() <span class="comment">//当一个新的连接进来的时候</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在新的RPC服务端实现中，我们用RegisterHelloService函数来注册函数，这样不仅可以避免命名服务名称的工作，同时也保证了传入的服务对象满足了RPC接口的定义。最后我们新的服务改为支持多个TCP链接，然后为每个TCP链接提供RPC服务。</p>
<h3 id="跨语言的RPC"><a href="#跨语言的RPC" class="headerlink" title="跨语言的RPC"></a>跨语言的RPC</h3><p>标准库的RPC默认采用Go语言特有的gob编码，因此从其它语言调用Go语言实现的RPC服务将比较困难。在互联网的微服务时代，每个RPC以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代RPC的一个首要条件。得益于RPC的框架设计，Go语言的RPC其实也是很容易实现跨语言支持的。</p>
<p>Go语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的<code>io.ReadWriteCloser</code>接口之上的，我们可以将RPC架设在不同的通讯协议之上。这里我们将尝试通过官方自带的<code>net/rpc/jsonrpc</code>扩展实现一个跨语言的RPC。</p>
<p>首先是基于json编码重新实现RPC服务：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, &amp;HelloService{})</span><br><span class="line">    <span class="comment">// rpc.RegisterName("HelloService", new(HelloService))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    <span class="keyword">for</span> { <span class="comment">// 死循环，运行完不退出</span></span><br><span class="line">        conn, err := listener.Accept() <span class="comment">//当一个新的连接进来的时候，</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) <span class="comment">// 并发</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码中最大的变化是用<code>rpc.ServeCodec</code>函数替代了<code>rpc.ServeConn</code>函数，传入的参数是针对服务端的json编解码器。</p>
<p>然后是实现json版本的客户端：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先手工调用net.Dial函数建立TCP链接，然后基于该链接建立针对客户端的json编解码器。</p>
<p>在确保客户端可以正常调用RPC服务的方法之后，我们用一个普通的TCP服务代替Go语言版本的RPC服务，这样可以查看客户端调用时发送的数据格式。比如通过nc命令<code>nc -l 1234</code>在同样的端口启动一个TCP服务。然后再次执行一次RPC调用将会发现nc输出了以下的信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"method"</span>:<span class="string">"HelloService.Hello"</span>,<span class="attr">"params"</span>:[<span class="string">"hello"</span>],<span class="attr">"id"</span>:<span class="number">0</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个json编码的数据，其中method部分对应要调用的rpc服务和方法组合成的名字，params部分的第一个元素为参数，id是由调用端维护的一个唯一的调用编号。</p>
<p>请求的json数据对象在内部对应两个结构体：客户端是clientRequest，服务端是serverRequest。<br>clientRequest和serverRequest结构体的内容基本是一致的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientRequest <span class="keyword">struct</span> {</span><br><span class="line">    Method <span class="keyword">string</span>         <span class="string">`json:"method"`</span></span><br><span class="line">    Params [<span class="number">1</span>]<span class="keyword">interface</span>{} <span class="string">`json:"params"`</span></span><br><span class="line">    Id     <span class="keyword">uint64</span>         <span class="string">`json:"id"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverRequest <span class="keyword">struct</span> {</span><br><span class="line">    Method <span class="keyword">string</span>           <span class="string">`json:"method"`</span></span><br><span class="line">    Params *json.RawMessage <span class="string">`json:"params"`</span></span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:"id"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在获取到RPC调用对应的json数据后，我们可以通过直接向架设了RPC服务的TCP服务器发送json数据模拟RPC方法调用：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">'{"method":"HelloService.Hello","params":["hello"],"id":1}'</span> | nc localhost 1234</span></span><br></pre></td></tr></tbody></table></figure>

<p>返回的结果也是一个json格式的数据：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"result"</span>:<span class="string">"hello:hello"</span>,<span class="attr">"error"</span>:<span class="literal">null</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>其中id对应输入的id参数，result为返回的结果，error部分在出问题时表示错误信息。对于顺序调用来说，id不是必须的。但是Go语言的RPC框架支持异步调用，当返回结果的顺序和调用的顺序不一致时，可以通过id来识别对应的调用。</p>
<p>返回的json数据也是对应内部的两个结构体：客户端是clientResponse，服务端是serverResponse。两个结构体的内容同样也是类似的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientResponse <span class="keyword">struct</span> {</span><br><span class="line">    Id     <span class="keyword">uint64</span>           <span class="string">`json:"id"`</span></span><br><span class="line">    Result *json.RawMessage <span class="string">`json:"result"`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>{}      <span class="string">`json:"error"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverResponse <span class="keyword">struct</span> {</span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:"id"`</span></span><br><span class="line">    Result <span class="keyword">interface</span>{}      <span class="string">`json:"result"`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>{}      <span class="string">`json:"error"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此无论采用何种语言，只要遵循同样的json结构，以同样的流程就可以和Go语言编写的RPC服务进行通信。这样我们就实现了跨语言的RPC。</p>
<p>python客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONClient</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        self.socket = socket.create_connection(addr)</span><br><span class="line">        self.id_counter = itertools.count()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, name, *params</span>):</span></span><br><span class="line">        request = dict(id=next(self.id_counter),</span><br><span class="line">                    params=list(params),</span><br><span class="line">                    method=name)</span><br><span class="line">        self.socket.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This must loop if resp is bigger than 4K</span></span><br><span class="line">        response = self.socket.recv(<span class="number">4096</span>)</span><br><span class="line">        response = json.loads(response.decode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.get(<span class="string">'id'</span>) != request.get(<span class="string">'id'</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"expected id=%s, received id=%s: %s"</span></span><br><span class="line">                            %(request.get(<span class="string">'id'</span>), response.get(<span class="string">'id'</span>),</span><br><span class="line">                              response.get(<span class="string">'error'</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.get(<span class="string">'error'</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(response.get(<span class="string">'error'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.get(<span class="string">'result'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">    self._socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rpc = JSONClient((<span class="string">"localhost"</span>, <span class="number">1234</span>))</span><br><span class="line">    args = <span class="string">"hello"</span></span><br><span class="line">    print(rpc.call(<span class="string">"HelloService.Hello"</span>, args))</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go_json_rpc_client</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">request = {</span><br><span class="line">    <span class="string">"id"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"params"</span>:[<span class="string">"bobby"</span>],</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"HelloService.Hello"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">client = socket.create_connection((<span class="string">"localhost"</span>, <span class="number">1234</span>))</span><br><span class="line">client.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取服务器返回的数据</span></span><br><span class="line">This must loop <span class="keyword">if</span> resp <span class="keyword">is</span> bigger than <span class="number">4</span>K</span><br><span class="line">rsp = client.recv(<span class="number">1024</span>)</span><br><span class="line">rsp = client.recv(<span class="number">4096</span>)</span><br><span class="line">rsp = json.loads(rsp.decode())</span><br><span class="line"></span><br><span class="line">print(rsp)  <span class="comment"># {'id': 0, 'result': 'hello, bobby', 'error': None}</span></span><br><span class="line">print(rsp[<span class="string">"result"</span>])  <span class="comment"># hello, bobby</span></span><br><span class="line">client.close() <span class="comment">#关闭这个链接</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request = {</span><br><span class="line">    <span class="string">"id"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"params"</span>:[<span class="string">"bobby"</span>],</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"HelloService.Hello"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">rsp = requests.post(<span class="string">"http://localhost:1234/jsonrpc"</span>, json=request)</span><br><span class="line">print(rsp.text)  <span class="comment"># {"id":0,"result":"hello, bobby","error":null}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Http上的RPC"><a href="#Http上的RPC" class="headerlink" title="Http上的RPC"></a>Http上的RPC</h3><p>替换rpc的传输协议为http</p>
<p>Go语言内在的RPC框架已经支持在Http协议上提供RPC服务。但是框架的http服务同样采用了内置的gob协议，并且没有提供采用其它协议的接口，因此从其它语言依然无法访问的。在前面的例子中，我们已经实现了在TCP协议之上运行jsonrpc服务，并且通过nc命令行工具成功实现了RPC方法调用。现在我们尝试在http协议上提供jsonrpc服务。</p>
<p>新的RPC服务其实是一个类似REST规范的接口，接收请求并采用相应处理流程：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, &amp;HelloService{})</span><br><span class="line">    http.HandleFunc(<span class="string">"/jsonrpc"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">        <span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> {</span><br><span class="line">            io.Writer</span><br><span class="line">            io.ReadCloser</span><br><span class="line">        }{</span><br><span class="line">            ReadCloser: r.Body,</span><br><span class="line">            Writer:     w,</span><br><span class="line">        }</span><br><span class="line">        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    })</span><br><span class="line">    http.ListenAndServe(<span class="string">":1234"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RPC的服务架设在“/jsonrpc”路径，在处理函数中基于http.ResponseWriter和http.Request类型的参数构造一个io.ReadWriteCloser类型的conn通道。然后基于conn构建针对服务端的json编码解码器。最后通过rpc.ServeRequest函数为每次请求处理一次RPC方法调用。</p>
<p>模拟一次RPC调用的过程就是向该链接发送一个json字符串：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:1234/jsonrpc -X POST \</span></span><br><span class="line">    --data '{"method":"HelloService.Hello","params":["hello"],"id":0}'</span><br></pre></td></tr></tbody></table></figure>

<p>返回的结果依然是json字符串：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"id"</span>:<span class="number">0</span>,<span class="attr">"result"</span>:<span class="string">"hello:hello"</span>,<span class="attr">"error"</span>:<span class="literal">null</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就可以很方便地从不同语言中访问RPC服务了。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-kou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-jie-kou/" class="post-title-link" itemprop="url">go接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-23 14:57:44" itemprop="dateModified" datetime="2021-09-23T14:57:44Z">2021-09-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。概念的地位和java中接口的地位是不一样<br>Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。</p>
<p>接口的实现是隐式的，没有具体表明是怎么实现了接口</p>
<p>go接口是由调用者定义，而不是有实现者定义，实现者可以实现他想要的任何方法，<br>然后调用者根据<br>一个类型上定义的方法在形式上（名称、参数和返回值）和接口里面定义的所有方法一样，<br>那么这个类型就实现了这个接口，类型不仅仅结构体，也可以是内置类型，就可以使用这个接口变量来指向这个结构体对象变量，这个类型的实例可以赋给它所实现的任意接口类型的变量<br>里面只能有方法，方法声明不需要 <code>func</code> 关键字<br>go语言的接口实际上就是python中的协议 - 鸭子类型 python语言本身设计上是采用了完全的基于鸭子类型 - 协议 影响了python语法的，例如 for len()</p>
<ul>
<li><p>同时具有 Python, C++的 duck typing 的灵活性</p>
</li>
<li><p>又具有 Java 的类型检查<br>java的缺点就是如果我以后还需要在某个接口里面增加某个方法，那我所有的实现这个接口的代码都要改，go就不需要<br>假如我写了一个类：<br><code>public class AB implements A,B</code><br>我这样写很可能是因为你的C是后来才定义的。然而我已经写了implements A,B<br>你想把我这个<code>class AB</code>的<code>instance</code>直接传给<code>downloader</code>，是不行的。要想传进去要么你改（增加一个adapter）要么我改（改成implements C）<br>Go语言在这种类似下就不需要改动，可以直接传。</p>
</li>
<li><p>是一种抽象类型，不能实例化</p>
</li>
<li><p>struct是具象，具象能实例化</p>
</li>
</ul>
<p>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。<br>接口有一个默认的规范  接口的名称一般以 er 结尾</p>
<p>鸭子类型是多态的一种形式，在这种形式中，不管对象属于哪个，也不管声明的具体接口是什么，<br>只要对象实现了相应的方法，函数就可以在对象执行操作，<br>即忽略了真正的类型，转而关注对象有没有实现所需的方法，签名和语义。<br>duck typing 是动态绑定的，go语言是编译时绑定，严格来说go不是duck typing，但是从行为上属于duck typing，属于结构化类型系统</p>
<h2 id="用接口来模拟多态"><a href="#用接口来模拟多态" class="headerlink" title="用接口来模拟多态"></a>用接口来模拟多态</h2><p>方法不能实现</p>
<p>多态 声明类型的时候你申明的类型是一种兼容类型， 但是实际赋值的时候是另一种类型</p>
<p>接口是一种特殊的容器，它可以容纳多种不同的对象，只要这些对象都同样实现了接口定义的方法。如果我们将容纳的对象替换成另一个对象，</p>
<p>使用这种方式模拟多态本质上是<br>结构体组合 属性变量（Name）和 接口变量（Fruitable）来做到的，<br>属性变量是对象的数据，<br>而接口变量是对象的功能，<br>将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<p>自定义类型可以实现多个接口</p>
<p>对已有的类型添加功能，扩充系统类型或别人已有类型</p>
<ul>
<li>组合</li>
<li>定义别名</li>
<li>内嵌</li>
</ul>
<p>类型和接口是松耦合的，</p>
<p>python中不需要多态 python是动态语言</p>
<h3 id="定义接口与类型，让类型去实现接口中的方法"><a href="#定义接口与类型，让类型去实现接口中的方法" class="headerlink" title="定义接口与类型，让类型去实现接口中的方法"></a>定义接口与类型，让类型去实现接口中的方法</h3><p>goland 在结构体内部，右键 generate - choose interface to implement - 输入接口名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> {</span><br><span class="line">    方法名<span class="number">1</span>（参数列表）（返回值）</span><br><span class="line">    方法名<span class="number">2</span>（参数列表）（返回值）</span><br><span class="line">    方法名<span class="number">3</span>（参数列表）（返回值）</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 通过自定义类型来实现接口中的所有方法</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> TT <span class="keyword">string</span></span><br><span class="line"><span class="comment">//方法接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名1<span class="params">()</span>（返回值）</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名2<span class="params">()</span>（返回值）</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名3<span class="params">()</span>（返回值）</span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中定义一个接口pay，增加两个方法topay()，info()</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pay <span class="keyword">interface</span> {</span><br><span class="line">    topay()</span><br><span class="line">    info()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个结构体payment</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> payment <span class="keyword">struct</span> {</span><br><span class="line">    paymentmethod <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>让这个结构体去实现接口pay中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">topay</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"topay:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"info:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义结构体 payment 类型的变量 _payment，可以通过这个变量去调用接口中的方法了，因为结构体payment实现了接口 pay 中所有的方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_payment := &amp;payment{paymentmethod: <span class="string">"alipay"</span>}</span><br><span class="line">_payment.info() <span class="comment">// info: alipay</span></span><br><span class="line">_payment.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>一个变量实现了接口当中所有方法，接口变量就可以指向这个变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _pay pay</span><br><span class="line">_pay = _payment</span><br><span class="line">_pay.info() <span class="comment">// info: alipay</span></span><br><span class="line">_pay.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们一般不这样使用，后面我们会讲解他的使用场景</p>
<h3 id="自定义类型（非结构体）也可以实现接口"><a href="#自定义类型（非结构体）也可以实现接口" class="headerlink" title="自定义类型（非结构体）也可以实现接口"></a>自定义类型（非结构体）也可以实现接口</h3><p>在main.go文件中，定义两个接口</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> {</span><br><span class="line">    echo()</span><br><span class="line">    out()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> read <span class="keyword">interface</span> {</span><br><span class="line">    scan()</span><br><span class="line">    input()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基于内置类型创建自定义类型</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readwrite <span class="keyword">string</span></span><br></pre></td></tr></tbody></table></figure>

<p>自定义的类型readwrite实现上面定义的两个接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">scan</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:scan()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">input</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:input()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go文件中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _readwrite readwrite</span><br><span class="line">_readwrite.echo() <span class="comment">// readwrite:echo()</span></span><br></pre></td></tr></tbody></table></figure>

<p>多重继承可以通过实现多个接口实现，所有的方法都要实现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多重继承格式</span></span><br><span class="line"><span class="keyword">type</span> InterfaceAA <span class="keyword">interface</span> {</span><br><span class="line">    InterfaceA</span><br><span class="line">    InterfaceB</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>综合案例</p>
<p>企业项目中经常涉及到与日志存储的业务，比如针对web项目的日志存储</p>
<p>比如磁盘IO操作的日志：磁盘进行数据拷贝读取一般会有读写日志，记录读取到的位置，即当前数据在磁盘的哪个碰头哪个扇区上</p>
<p>比如网络请求的日志：去访问某个网站一般会有请求日志的记录，用于分析来访客户，刻画出用户的区域，访问兴趣爱好（网购时的一个典型例子，用户浏览记录写cookie）</p>
<p>这里我们模拟一个网络读写日志与磁盘读写日志的例子</p>
<p>定义公共日志结构体Log，做为父类，并为其增加方法writeLog()，传递一个write接口类型的变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> {</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">    addtime <span class="keyword">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">writeLog</span><span class="params">(_write write)</span></span> {</span><br><span class="line">    fmt.Println(l.name + <span class="string">"---"</span> + l.content)</span><br><span class="line">    _write.echo()</span><br><span class="line">    _write.out()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义网络读写结构体与磁盘读写结构体，继承自父类Log</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NetLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IOLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义自定义类型，iowrite与netwrite，分别实现write接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iowrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netwrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:out()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>父类引用指向子类对象<br>main.go文件中</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">log := &amp;Log{</span><br><span class="line">    name:    <span class="string">"微信小程序支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _iowrite *iowrite</span><br><span class="line"><span class="keyword">var</span> _netwrite *netwrite</span><br><span class="line"><span class="comment">// writeLog的参数是一个write类型，我们这里的iowrite实现了write接口中的所有方法，所以可以传递iowrite</span></span><br><span class="line"><span class="comment">// 相当于write（指向）-&gt; iowrite</span></span><br><span class="line">log.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// writeLog的参数是一个write类型，我们这里的netwrite实现了write接口中的所有方法，所以可以传递netwrite</span></span><br><span class="line"><span class="comment">// 相当于write（指向）-&gt; netwrite</span></span><br><span class="line">log.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<p>调用者多态的一面</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">netlog := &amp;NetLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序网络支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序网络支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">// writeLog的调用者是Log,我们的NetLog继承自Log，所以可直接调用</span></span><br><span class="line">netlog.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序网络支付日志---微信小程序网络支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br><span class="line"></span><br><span class="line">filelog := &amp;IOLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序文件支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序文件支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">// writeLog的调用者是Log,我们的IOLog继承自Log，所以可直接调用</span></span><br><span class="line">filelog.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序文件支付日志---微信小程序文件支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h4><p><a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Type_assertions">类型断言</a>的单个返回值形式针对不正确的类型将产生 panic。<br>始终使用“comma ok”的惯用法形式：<code>t, ok := x.(T)</code> x是不是T。<br>T 可以是结构体或者指针。</p>
<p>类型断言的本质，跟类型转换类似，都是类型之间进行转换，<br>不同之处在于，类型断言是在接口之间进行，相当于在Java中 instanceOf + 强制类型转换合体，对于一个对象，把一种接口的引用转换成另一种。</p>
<ul>
<li>如果 x 是 nil，那么永远是 false</li>
<li>编译器不会帮你检查</li>
</ul>
<h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )  <span class="comment">// 非安全类型断言</span></span><br><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="正例"><a href="#正例" class="headerlink" title="正例"></a>正例</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) <span class="comment">// 安全类型断言</span></span><br><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok {</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test6</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>{} = <span class="string">"kk"</span></span><br><span class="line">    j := i.(<span class="keyword">int</span>) <span class="comment">// 把i转换成int类型 系统内部检测到不匹配 会调用panic 抛出异常</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T-&gt;%d\n"</span>, j, j)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test7</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>{} = <span class="string">"TT"</span></span><br><span class="line">    j, ok := i.(<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> ok { <span class="comment">// 安全类型的断言</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T-&gt;%d\n"</span>, j, j)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Println(<span class="string">"类型不匹配"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>任意结构体都隐式地实现了空接口。</p>
<p>Go 语言为了避免用户重复定义很多空接口，它自己内置了一个，这个空接口 <code>interface{}</code> 。之所以这个类型名带上了大括号，那是在告诉用户括号里什么也没有。</p>
<p>空接口里面没有定义任何方法，所以它也不具有任何能力，其作用相当于 Java和python中 的 Object 类型，可以容纳任意对象，它是一个万能容器，即所谓的继承树根节点。<br>可以把任何类型都赋值给空接口变量<br>比如一个字典的 key 是字符串，但是希望 value 可以容纳任意类型的对象，这时候就可以使用空接口类型 interface{}。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">    url   <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> {</span><br><span class="line">    printInfo() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">printInfo</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"课程信息"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="comment">// 判断是不是int类型，是返回ture，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := x.(<span class="keyword">int</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是不是string类型</span></span><br><span class="line">    <span class="keyword">if</span> s, ok := x.(<span class="keyword">string</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, s)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//fmt.Printf("%v\n", i)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print1</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%v(本来值)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>{} <span class="comment">// 空接口</span></span><br><span class="line">    <span class="comment">// 参数传递</span></span><br><span class="line">    i = Course{}</span><br><span class="line">    fmt.Println(i) <span class="comment">// { 0 }</span></span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// 10(整数)</span></span><br><span class="line">    i = <span class="string">"bobby"</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// bobby(字符串)</span></span><br><span class="line">    i = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>}</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// [django scrapy](本来值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空接口可以作为map的 value 值，可以是任何类型，而不是固定的指定类型</span></span><br><span class="line">    <span class="keyword">var</span> teacherInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">    teacherInfo[<span class="string">"name"</span>] = <span class="string">"bobby"</span></span><br><span class="line">    teacherInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">    teacherInfo[<span class="string">"weight"</span>] = <span class="number">75.2</span></span><br><span class="line">    teacherInfo[<span class="string">"courses"</span>] = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>, <span class="string">"sanic"</span>}</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, teacherInfo) <span class="comment">// map[age:18 courses:[django scrapy sanic] name:bobby weight:75.2]</span></span><br><span class="line">    <span class="comment">//类型断言0-, 接口引入了</span></span><br><span class="line">    c := &amp;Course{}</span><br><span class="line">    c.printInfo()</span><br><span class="line">    c1 := Course{}</span><br><span class="line">    c1.printInfo()</span><br><span class="line">    <span class="comment">//var c Printer = Course{}  // 实现了方法可以实例化</span></span><br><span class="line">    <span class="comment">//c.printInfo()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"age"</span>:     <span class="number">30</span>,</span><br><span class="line">    <span class="string">"address"</span>: <span class="string">"Beijing Tongzhou"</span>,</span><br><span class="line">    <span class="string">"married"</span>: <span class="literal">true</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(user)        <span class="comment">// map[age:30 address:Beijing Tongzhou married:true]</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, user) <span class="comment">// map[string]interface {}</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, user) <span class="comment">// map[age:30 address:Beijing Tongzhou married:true]</span></span><br><span class="line"></span><br><span class="line">fmt.Println(user[<span class="string">"age"</span>], user[<span class="string">"address"</span>], user[<span class="string">"married"</span>]) <span class="comment">// 30 Beijing Tongzhou true</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %T %T\n"</span>, user[<span class="string">"age"</span>], user[<span class="string">"address"</span>], user[<span class="string">"married"</span>]) <span class="comment">// int string bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换语法</span></span><br><span class="line"><span class="keyword">var</span> age = user[<span class="string">"age"</span>].(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> address = user[<span class="string">"address"</span>].(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> married = user[<span class="string">"married"</span>].(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(age, address, married)              <span class="comment">// 30 Beijing Tongzhou true</span></span><br><span class="line">fmt.Printf(<span class="string">"%T %T %T\n"</span>, age, address, married) <span class="comment">// int string bool</span></span><br></pre></td></tr></tbody></table></figure>

<p>从这个字典中直接读取得到的 value 类型是 interface{}，需要通过类型转换才能得到期望的变量？</p>
<h2 id="接口变量的本质"><a href="#接口变量的本质" class="headerlink" title="接口变量的本质"></a>接口变量的本质</h2><p>在使用接口时，我们要将接口看成一个特殊的容器，这个容器只能容纳一个对象，只有实现了这个接口类型的对象才可以放进去。</p>
<p>接口变量作为变量来说它也是需要占据内存空间的，通过翻阅 Go 语言的源码可以发现，接口变量也是由结构体来定义的，<br>这个结构体包含两个指针字段，一个字段指向被容纳的对象内存，<br>另一个字段指向一个特殊的结构体 itab，这个特殊的结构体包含了接口的类型信息和被容纳对象的数据类型信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface structure</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> {</span><br><span class="line">  tab *itab  <span class="comment">// 类型指针</span></span><br><span class="line">  data unsafe.Pointer  <span class="comment">// 数据指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> {</span><br><span class="line">  inter *interfacetype <span class="comment">// 接口类型信息</span></span><br><span class="line">  _type *_type <span class="comment">// 数据类型信息</span></span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>既然接口变量只包含两个指针字段，那么它的内存占用应该是 2 个机器字，下面我们来编写代码验证一下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>{}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s)) <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(arr)) <span class="comment">// 80</span></span><br><span class="line">    s = arr</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s)) <span class="comment">// 16</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>数组的内存占用是 10 个机器字，但是这丝毫不会影响到接口变量的内存占用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口是一个协议</span></span><br><span class="line"><span class="comment">// 程序员 - 只要你能够 1. 写代码 2. 解决bug 其实就是一组方法的集合</span></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> {</span><br><span class="line">    Coding() <span class="keyword">string</span> <span class="comment">//方法只是申明</span></span><br><span class="line">    Debug() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计师 - 只要你能够 1. 设计</span></span><br><span class="line"><span class="keyword">type</span> Designer <span class="keyword">interface</span> {</span><br><span class="line">    Design() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manger <span class="keyword">interface</span> {</span><br><span class="line">    Programmer <span class="comment">// 接口继承</span></span><br><span class="line">    Designer   <span class="comment">// 接口继承</span></span><br><span class="line">    Manage() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java里面一种类型只要继承一个接口 才行 如果你继承了这个接口的话 那么这个接口里面的所有方法你必须要全部实现</span></span><br><span class="line"><span class="keyword">type</span> UIDesigner <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d UIDesigner)</span> <span class="title">Design</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会ui设计"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会ui设计"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于Pythoner这个结构体来说 你实现任何方法都可以，但是你只要不全部实现Coding Debug的话 那你Pythoner就不是一个Programmer类型</span></span><br><span class="line"><span class="comment">// Pythoner本身自己就是一个类型 那我何必在意我是不是Programmer</span></span><br><span class="line"><span class="keyword">type</span> Pythoner <span class="keyword">struct</span> {</span><br><span class="line">    UIDesigner          <span class="comment">// 匿名内嵌接口变量，会python也会设计</span></span><br><span class="line">    lib        []<span class="keyword">string</span> <span class="comment">// 属性变量</span></span><br><span class="line">    framework  []<span class="keyword">string</span></span><br><span class="line">    years      <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// go开发者既能开发又能调式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"go开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"go开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会go的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会go的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// python开发者既能开发又能调式还会管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"python开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"python开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会python的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会python的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Manage</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"不好意思，管理我也懂"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"不好意思，管理我也懂"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (p Pythoner) Design() string {</span></span><br><span class="line"><span class="comment">//    fmt.Println("我是一个python开发者，但是我会ui设计")</span></span><br><span class="line"><span class="comment">//    return "我是一个python开发者，但是我会ui设计"</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 新的语言出来了, 接口帮我们完成了go语言的多态</span></span><br><span class="line">    <span class="keyword">var</span> pro Programmer = Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, pro) <span class="comment">// main.Pythoner</span></span><br><span class="line">    pro.Coding()            <span class="comment">// python开发者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pro3 Programmer</span><br><span class="line">    <span class="keyword">var</span> py3 = Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, py3) <span class="comment">// main.Pythoner</span></span><br><span class="line"></span><br><span class="line">    pro3 = py3</span><br><span class="line">    pro3.Coding() <span class="comment">// python开发者</span></span><br><span class="line">    pro3.Debug()  <span class="comment">// 我会python的debug</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pros []Programmer</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Pythoner{})</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Gopher{})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m Manger = Pythoner{}</span><br><span class="line">    m.Design() <span class="comment">// 我会ui设计</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">    eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Fruitable  <span class="comment">// 匿名内嵌接口变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">want</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"I like "</span>)</span><br><span class="line">    f.eat() <span class="comment">// 外结构体会自动继承匿名内嵌的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apple)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating apple"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Banana)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating banana"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> f1 = Fruit{<span class="string">"Apple"</span>, Apple{}}</span><br><span class="line">    <span class="keyword">var</span> f2 = Fruit{<span class="string">"Banana"</span>, Banana{}}</span><br><span class="line">    f1.want() <span class="comment">// I like eating apple</span></span><br><span class="line">    f2.want()<span class="comment">// I like eating banana</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用这种方式模拟多态本质上是通过组合属性变量（Name）和接口变量（Fruitable）来做到的，属性变量是对象的数据，而接口变量是对象的功能，将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<h2 id="接口的组合继承"><a href="#接口的组合继承" class="headerlink" title="接口的组合继承"></a>接口的组合继承</h2><p>go语言中并不支持继承<br>接口的定义支持组合继承，比如我们可以将两个接口定义合并为一个接口如下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Smellable <span class="keyword">interface</span> {</span><br><span class="line">    smell()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eatable <span class="keyword">interface</span> {</span><br><span class="line">    eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">    Smellable</span><br><span class="line">    Eatable</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时 Fruitable 接口就自动包含了 smell() 和 eat() 两个方法，它和下面的定义是等价的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">    smell()</span><br><span class="line">    eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="接口变量的赋值"><a href="#接口变量的赋值" class="headerlink" title="接口变量的赋值"></a>接口变量的赋值</h2><ul>
<li>接口类型变量的赋值浅拷贝值传递，</li>
<li>接口变量自带实现者的指针，所以一般用接口类型的值类型就够用了，不用使用接口的指针类型</li>
<li>指针接收者实现只能以指针方式使用，值接受者实现能以指针方式或值使用</li>
<li>接口里面包含的东西是：实现者的类型，实现者的值或指针</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width  <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, a, a, &amp;a) <span class="comment">// &lt;nil&gt; &lt;nil&gt; 0xc000088220</span></span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, r, r, &amp;r) <span class="comment">// main.Rect {50 50} 0xc00000a0f0</span></span><br><span class="line"></span><br><span class="line">    a = r</span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, a, a, &amp;a) <span class="comment">// main.Rect {50 50} 0xc000088220</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rx = a.(Rect)</span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, rx, rx, &amp;rx) <span class="comment">// main.Rect {50 50}} 0xc0000aa0a0</span></span><br><span class="line"></span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, rx, rx, &amp;rx) <span class="comment">// main.Rect {50 50}} 0xc0000aa0a0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的输出结果中可以推断出结构体的内存发生了复制，这个复制可能是因为赋值（a = r）也可能是因为类型转换（rx = a.(Rect)），也可能是两者都进行了内存复制。那能不能判断出究竟在接口变量赋值时有没有发生内存复制呢？不好意思，就目前来说我们学到的知识点还办不到。到后面的高级阶段我们将会使用 unsafe 包来洞悉其中的更多细节。不过我可以提前告诉你们答案是什么，那就是两者都会发生数据内存的复制 —— 浅拷贝。</p>
<h2 id="指向指针的接口变量"><a href="#指向指针的接口变量" class="headerlink" title="指向指针的接口变量"></a>指向指针的接口变量</h2><p>如果将上面的例子改成指针，将接口变量指向结构体指针，那结果就不一样了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span> {}</span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line"></span><br><span class="line">    a = &amp;r <span class="comment">// 指向了结构体指针</span></span><br><span class="line"></span><br><span class="line">    rx1 := a.(*Rect)                         <span class="comment">// 转换成指针类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, rx1, rx1, &amp;rx1) <span class="comment">// *main.Rect &amp;{100 100} 0xc000006030</span></span><br><span class="line"></span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T %v %p\n"</span>, rx1, rx1, &amp;rx1) <span class="comment">// *main.Rect &amp;{100 100} 0xc000006030</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从输出结果中可以看出指针变量 rx 指向的内存和变量 r 的内存是同一份。因为在类型转换的过程中只发生了指针变量的内存复制，而指针变量指向的内存是共享的。</p>
<h2 id="接口断言"><a href="#接口断言" class="headerlink" title="接口断言"></a>接口断言</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AliOss <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LocalFile <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> AliOss:</span><br><span class="line">        <span class="comment">// 此处要做一些特殊的处理，我设置阿里云的权限问题</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    <span class="keyword">case</span> LocalFile:</span><br><span class="line">        <span class="comment">// 检查路径的权限</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer is implemented by any value that has a String method,</span></span><br><span class="line"><span class="comment">// which defines the ``native'' format for that value.</span></span><br><span class="line"><span class="comment">// The String method is used to print values passed as an operand</span></span><br><span class="line"><span class="comment">// to any format that accepts a string or to an unformatted printer</span></span><br><span class="line"><span class="comment">// such as Print.</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> {</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringer</span><span class="params">(s fmt.Stringer)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> s.String()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>fmt.Println</code> 和 <code>fmt.Printf</code> 底层都会继承 <code>String()</code></p>
<hr>
<p>以下两个方法都实现了Get方法，所以都实现了这个接口</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    test <span class="string">"imooc.com/ccmouse/learngo/lang/basic/branch/b"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRetriever</span><span class="params">()</span> <span class="title">retriever</span></span> {</span><br><span class="line">    <span class="keyword">return</span> test.Retriever{} <span class="comment">//由使用者来定义这个结构体是不是实现了retriever接口，而test.Retriever{}本身并没有和retriever有任何的关系</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口 接口的作用就是</span></span><br><span class="line"><span class="comment">// something can Get</span></span><br><span class="line"><span class="keyword">type</span> retriever <span class="keyword">interface</span> {</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    retriever := getRetriever()                         <span class="comment">// 在这里我不用每次换一个具体的实现就要改很多的代码，getRetriever返回的是一个接口类型，只要有Get的方法，下面的代码就可以运行下去</span></span><br><span class="line">    fmt.Println(retriever.Get(<span class="string">"https://www.imooc.com"</span>)) <span class="comment">// test</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//infra</span></span><br><span class="line"><span class="keyword">package</span> infra</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"error"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bytes)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    infra <span class="string">"imooc.com/ccmouse/learngo/lang/basic/branch/c"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRetriever</span><span class="params">()</span> <span class="title">retriever</span></span> {</span><br><span class="line">    <span class="keyword">return</span> infra.Retriever{} <span class="comment">//由使用者来定义这个结构体是不是实现了retriever接口，而test.Retriever{}本身并没有和retriever有任何的关系</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口 接口的作用就是</span></span><br><span class="line"><span class="comment">// something can Get</span></span><br><span class="line"><span class="keyword">type</span> retriever <span class="keyword">interface</span> {</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    retriever := getRetriever()                         <span class="comment">//在这里我不用每次换一个具体的实现就要改很多的代码，getRetriever返回的是一个接口类型，只要有Get的方法，下面的代码就可以运行下去</span></span><br><span class="line">    fmt.Println(retriever.Get(<span class="string">"https://www.imooc.com"</span>)) <span class="comment">// 输出为下面的html</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>慕课网-程序员的梦工厂<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="built_in">real</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> {</span><br><span class="line">    UserAgent <span class="keyword">string</span></span><br><span class="line">    TimeOut   time.Duration</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    result, err := httputil.DumpResponse(</span><br><span class="line">        resp, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> {</span><br><span class="line">    Contents <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Retriever: {Contents=%s}"</span>, r.Contents)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (r Retriever) Post(url string, // 值接收者不改变原值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, form <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    r.Contents = form[<span class="string">"contents"</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (r *Retriever) Get(url string) string {</span></span><br><span class="line"><span class="comment">//    return r.Contents</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> r.Contents</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"imooc.com/ccmouse/learngo/lang/retriever/mock"</span></span><br><span class="line">    <span class="string">"imooc.com/ccmouse/learngo/lang/retriever/real"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> {</span><br><span class="line">    Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Poster <span class="keyword">interface</span> {</span><br><span class="line">    Post(url <span class="keyword">string</span>, form <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口组合，只要有一个struct类型实现了 Get Post 他就实现了这个接口</span></span><br><span class="line"><span class="keyword">type</span> RetrieverPoster <span class="keyword">interface</span> {</span><br><span class="line">    Retriever <span class="comment">// 没有其他包的前缀，则就是本包的接口而不是另外一个包同名的结构体</span></span><br><span class="line">    Poster</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">"https://www.imooc.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(s RetrieverPoster)</span> <span class="title">string</span></span> {</span><br><span class="line">    s.Post(url, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{</span><br><span class="line">        <span class="string">"contents"</span>: <span class="string">"another faked imooc.com"</span>,</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> s.Get(url)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> r Retriever  <span class="comment">// 让调用者来决定用哪个类型</span></span><br><span class="line"></span><br><span class="line">    mockRetriever := mock.Retriever{ <span class="comment">// 有其他包的前缀，则就不是本包的接口而是另外一个包同名的结构体</span></span><br><span class="line">        Contents: <span class="string">"this is a fake imooc.com"</span>}</span><br><span class="line"></span><br><span class="line">    inspect(mockRetriever)</span><br><span class="line">    <span class="comment">//Inspecting {this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type:mock.Retriever Value:{this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type switch: Contents: this is a fake imooc.com</span></span><br><span class="line"></span><br><span class="line">    inspect(&amp;mockRetriever)</span><br><span class="line">    <span class="comment">// 没有用到自定义的 func (r *Retriever) String() string</span></span><br><span class="line">    <span class="comment">//Inspecting &amp;{this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type:*mock.Retriever Value:&amp;{this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type switch: Contents: this is a fake imooc.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用到自定义的 func (r *Retriever) String() string {return fmt.Sprintf("Retriever: {Contents=%s}", r.Contents)}</span></span><br><span class="line">    <span class="comment">//Inspecting Retriever: {Contents=this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type:*mock.Retriever Value:Retriever: {Contents=this is a fake imooc.com}</span></span><br><span class="line">    <span class="comment">//&gt; Type switch: Contents: this is a fake imooc.com</span></span><br><span class="line"></span><br><span class="line">    r = &amp;<span class="built_in">real</span>.Retriever{</span><br><span class="line">        UserAgent: <span class="string">"Mozilla/5.0"</span>,</span><br><span class="line">        TimeOut:   time.Minute,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    inspect(r)</span><br><span class="line">    <span class="comment">//Inspecting &amp;{Mozilla/5.0 1m0s}</span></span><br><span class="line">    <span class="comment">//&gt; Type:*real.Retriever Value:&amp;{Mozilla/5.0 1m0s}</span></span><br><span class="line">    <span class="comment">//&gt; Type switch: UserAgent: Mozilla/5.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type assertion 查看接口类型</span></span><br><span class="line">    <span class="comment">//mockRetriever = r.(mock.Retriever)</span></span><br><span class="line">    <span class="comment">//fmt.Println(mockRetriever.Contents)</span></span><br><span class="line">    <span class="comment">//panic: interface conversion: main.Retriever is *real.Retriever, not mock.Retriever</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mockRetriever, ok := r.(mock.Retriever); ok {</span><br><span class="line">        fmt.Println(mockRetriever.Contents)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Println(<span class="string">"r is not a mock retriever"</span>) <span class="comment">// r is not a mock retriever 因为r被赋值成&amp;real.Retriever{}</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mockRetriever, ok := r.(*mock.Retriever); ok {</span><br><span class="line">        fmt.Println(mockRetriever.Contents)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Println(<span class="string">"r is not a mock retriever"</span>) <span class="comment">// r is not a mock retriever 因为r被赋值成&amp;real.Retriever{}</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> realRetriever, ok := r.(*<span class="built_in">real</span>.Retriever); ok {</span><br><span class="line">        fmt.Println(realRetriever.UserAgent, realRetriever.TimeOut) <span class="comment">// Mozilla/5.0 1m0s</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Println(<span class="string">"r is not a real retriever"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println(</span><br><span class="line">        <span class="string">"Try a session with mockRetriever"</span>) <span class="comment">// Try a session with mockRetriever</span></span><br><span class="line">    fmt.Println(session(&amp;mockRetriever)) <span class="comment">// another faked imooc.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(session(mockRetriever))</span></span><br><span class="line">    <span class="comment">// cannot use mockRetriever (type mock.Retriever) as type RetrieverPoster in argument to session:</span></span><br><span class="line">    <span class="comment">// mock.Retriever does not implement RetrieverPoster (Post method has pointer receiver)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type switch 查看接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inspect</span><span class="params">(r Retriever)</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"Inspecting"</span>, r)              <span class="comment">// 用到自定义的 func (r *Retriever) String() string</span></span><br><span class="line">    fmt.Printf(<span class="string">" &gt; Type:%T Value:%v\n"</span>, r, r) <span class="comment">// 用到自定义的 func (r *Retriever) String() string</span></span><br><span class="line">    fmt.Print(<span class="string">" &gt; Type switch: "</span>)</span><br><span class="line">    <span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> mock.Retriever:</span><br><span class="line">        fmt.Println(<span class="string">"Contents:"</span>, v.Contents)</span><br><span class="line">    <span class="keyword">case</span> *mock.Retriever:</span><br><span class="line">        fmt.Println(<span class="string">"Contents:"</span>, v.Contents)</span><br><span class="line">    <span class="keyword">case</span> *<span class="built_in">real</span>.Retriever:</span><br><span class="line">        fmt.Println(<span class="string">"UserAgent:"</span>, v.UserAgent)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="一种常用的GO设计模式"><a href="#一种常用的GO设计模式" class="headerlink" title="一种常用的GO设计模式"></a>一种常用的GO设计模式</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于确保HandlerBasedOnMap肯定实现了这个接口</span></span><br><span class="line"><span class="keyword">var</span> _ Handler = &amp;HandlerBasedOnMap{}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>常用接口类型<br>Stringer ==&gt; String():定义打印格式<br>Reader ==&gt; Read<br>Writer ==&gt; Write<br>ReaderWriter</p>
<hr>
<p>接口实现的注册与查找？<br>现在我们的 filter 都是用户手动创建传下去的。但是有些时候，我们看到的设计是，按名索引。<br>而这些名字是通过配置文件读取的</p>
<p>一般步骤：</p>
<ol>
<li>定义一个类型或者接口</li>
<li>维护一个 map，它维持着实现的名字到实现的Builder （or 工厂方法）的映射</li>
<li>内部使用按名索引</li>
<li>框架作者和用户自定义实现，都通过 map 来注册自己的实现</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-gou-ti-tong-guo-nei-qian-jie-gou-ti-shi-xian-ji-cheng-de-xiao-guo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-jie-gou-ti-tong-guo-nei-qian-jie-gou-ti-shi-xian-ji-cheng-de-xiao-guo/" class="post-title-link" itemprop="url">go结构体通过内嵌结构体实现继承的效果</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-23 14:13:34" itemprop="dateModified" datetime="2021-09-23T14:13:34Z">2021-09-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>结构体作为一种变量它可以放进另外一个结构体作为另一个结构体字段的类型<br>这种内嵌结构体的形式在 Go 语言里称之为「组合」。<br>组合可以是接口组合，也可以是结构体组合。结构体也可以组合接口</p>
<p>go语言当中继承：主要是通过类型组合的方式来实现：<br>内嵌一个（或多个）包含想要的行为（字段和方法）的类型；<br>多重继承可以通过内嵌多个类型实现</p>
<p>一个结构体中嵌套另一个结构体，那外面的结构体将直接继承内嵌结构体类型所有字段和方法，这种做法其实就是 语法糖</p>
<h2 id="内嵌有名结构体"><a href="#内嵌有名结构体" class="headerlink" title="内嵌有名结构体"></a>内嵌有名结构体</h2><p>在嵌套结构体时有指定结构体变量名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> {</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Teacher)</span> <span class="title">teacherInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"姓名:%s, 年龄:%d, 职称:%s\n"</span>, t.Name, t.Age, t.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    Teacher Teacher <span class="comment">// 如果讲师的信息比较多怎么办 将另一个结构体的变量放进来</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">courseInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">courseInfo1</span><span class="params">(c Course)</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Teacher)</span> <span class="title">show</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(t.Name, t.Age, t.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    t := Teacher{</span><br><span class="line">        Name:  <span class="string">"bobby"</span>,</span><br><span class="line">        Age:   <span class="number">18</span>,</span><br><span class="line">        Title: <span class="string">"程序员"</span>,</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// var c Course = Course {</span></span><br><span class="line">    c := Course{</span><br><span class="line">        Teacher: t,</span><br><span class="line">        Price:   <span class="number">100</span>,</span><br><span class="line">        Url:     <span class="string">""</span>,</span><br><span class="line">        Name:    <span class="string">"django"</span>,</span><br><span class="line">    }</span><br><span class="line">    c.courseInfo() <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line">    courseInfo1(c) <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)                                                   <span class="comment">// {Teacher:{Name:bobby Age:18 Title:程序员} Name:django Price:100 Url:}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c.Teacher)                                           <span class="comment">// {Name:bobby Age:18 Title:程序员}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title) <span class="comment">// bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    c.Teacher.show() <span class="comment">// bobby 18 程序员</span></span><br><span class="line">    fmt.Println(t, c) <span class="comment">// {bobby 18 程序员} {{bobby 18 程序员} django 100 }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userinfo <span class="keyword">struct</span> {</span><br><span class="line">    name      <span class="keyword">string</span></span><br><span class="line">    age       <span class="keyword">int</span></span><br><span class="line">    height    <span class="keyword">float32</span></span><br><span class="line">    eduschool <span class="keyword">string</span></span><br><span class="line">    hobby     []<span class="keyword">string</span></span><br><span class="line">    moreinfo  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台管理系统中，权限问题，这里涉及了角色，超级管理员，管理员，普通用户</span></span><br><span class="line"><span class="keyword">type</span> role <span class="keyword">struct</span> {</span><br><span class="line">    user          userinfo</span><br><span class="line">    authorization Integer <span class="comment">// 1=超级管理员，2=管理员，3=普通用户</span></span><br><span class="line">}</span><br><span class="line">    superadmin := role{</span><br><span class="line">        user: userinfo{</span><br><span class="line">            name:      <span class="string">"超级管理员"</span>,</span><br><span class="line">            age:       <span class="number">0</span>,</span><br><span class="line">            height:    <span class="number">0</span>,</span><br><span class="line">            eduschool: <span class="string">""</span>,</span><br><span class="line">            hobby:     <span class="literal">nil</span>,</span><br><span class="line">            moreinfo:  <span class="literal">nil</span>,</span><br><span class="line">        },</span><br><span class="line">        authorization: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">    admin := role{</span><br><span class="line">        user: userinfo{</span><br><span class="line">            name:      <span class="string">"管理员"</span>,</span><br><span class="line">            age:       <span class="number">0</span>,</span><br><span class="line">            height:    <span class="number">0</span>,</span><br><span class="line">            eduschool: <span class="string">""</span>,</span><br><span class="line">            hobby:     <span class="literal">nil</span>,</span><br><span class="line">            moreinfo:  <span class="literal">nil</span>,</span><br><span class="line">        },</span><br><span class="line">        authorization: <span class="number">2</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(superadmin, admin)</span><br><span class="line">    <span class="comment">// {{超级管理员 0 0  [] map[]} 1} {{管理员 0 0  [] map[]} 2}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="匿名内嵌结构体"><a href="#匿名内嵌结构体" class="headerlink" title="匿名内嵌结构体"></a>匿名内嵌结构体</h2><p>在嵌套结构体时没有指定结构体变量名</p>
<p>结构体继承访问流程</p>
<ol>
<li>先判断字段是否属于子结构体，如果有就访问</li>
<li>如果没有，继续去找他继承的父结构体，如果有就访问</li>
<li>如果没有继续去找这个结构体的所继承的结构体，如果有就访问，没有就报错</li>
</ol>
<p>如果嵌入结构的字段和外部结构或一个结构中继承了多个结构体的字段相同，<br>想要访问或修改嵌入结构的字段值需要必须指定加上外部结构中声明的嵌入结构体变量名或者匿名结构体名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Course1 <span class="keyword">struct</span> {</span><br><span class="line">    Teacher <span class="comment">// 匿名内嵌结构体：不写参数名称</span></span><br><span class="line">    Name    <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Course2 <span class="keyword">struct</span> {</span><br><span class="line">    *Teacher <span class="comment">// 匿名内嵌结构体：不写参数名称</span></span><br><span class="line">    Name    <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course1)</span> <span class="title">courseInfo2</span><span class="params">()</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    <span class="comment">// c.Teacher.Name的Teacher可以省略，但是Course struct也有Name，重名的字段会取外嵌的字段，所以不省略Teacher</span></span><br><span class="line">    <span class="comment">// c.Teacher.Age, c.Teacher.Title的Teacher都可以省略</span></span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Age, c.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">courseInfo3</span><span class="params">(c Course1)</span></span> {</span><br><span class="line">    <span class="comment">// c.Teacher.Name的Teacher可以省略，但是Course struct也有Name，重名的字段会取外嵌的字段，所以不省略Teacher</span></span><br><span class="line">    <span class="comment">// c.Teacher.Age, c.Teacher.Title的Teacher都可以省略</span></span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Age, c.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">courseInfo2</span><span class="params">()</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Printf(<span class="string">"讲师信息：%s %d %s\n"</span>, t.Name, t.Age, t.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    c1 := Course1{</span><br><span class="line">        Teacher: t,</span><br><span class="line">        Price:   <span class="number">100</span>,</span><br><span class="line">        Url:     <span class="string">""</span>,</span><br><span class="line">        Name:    <span class="string">"django"</span>,</span><br><span class="line">    }</span><br><span class="line">    c1.courseInfo2() <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line">    courseInfo3(c1)  <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c1)                                                     <span class="comment">// {Teacher:{Name:bobby Age:18 Title:程序员} Name:django Price:100 Url:}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c1.Teacher)                                             <span class="comment">// {Name:bobby Age:18 Title:程序员}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c1.Teacher.Name, c1.Teacher.Age, c1.Teacher.Title) <span class="comment">// bobby 18 程序员</span></span><br><span class="line">    <span class="comment">// 继承了字段</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c1.Teacher.Name, c1.Age, c1.Title)                 <span class="comment">// bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    c1.Teacher.show() <span class="comment">// bobby 18 程序员</span></span><br><span class="line">    <span class="comment">// 继承了方法</span></span><br><span class="line">    c1.show()         <span class="comment">// bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    c2 := Course2{</span><br><span class="line">        Teacher: &amp;t,</span><br><span class="line">        Price:   <span class="number">100</span>,</span><br><span class="line">        Url:     <span class="string">""</span>,</span><br><span class="line">        Name:    <span class="string">"django"</span>,</span><br><span class="line">    }</span><br><span class="line">    c2.courseInfo2() <span class="comment">// 讲师信息：bobby 18 程序员</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继承仅仅是形式上的语法糖，<code>c.show()</code> 被转换成二进制代码后和 <code>c.Teacher.show()</code> 是等价的，<code>c.Age</code> 和 <code>c.Teacher.Age</code> 也是等价的。</p>
<p>支付是一个企业项目变现的重要手段，做为企业应用必不可少的功能，支付系统包括微信支付，支付宝，银联，银行卡京东等等，在开发中如何避免重复代码来实现类似的支付功能？由此引出继承<br>你的系统支持各种类型的支付 每一种支付类型都有统一的接口<br>我们通过封装一个公共的支付结构体，把它做为父类，同时实现4个不同支付平台的结构体，把这4个不同支付平台的结构体做为子类，来实现继承的功能</p>
<p>定一个协议 1. 创建订单 2. 支付 3. 查询支付状态 4. 退款<br>支付发起了<br>你现在有一个缓存 - 这个地方你一开始使用的缓存是redis 但是后期你考虑到可能使用其他的缓存技术 - 本地 memcache<br>如果后期接入一种新的支付 或者取消已有的支付</p>
<p>定义一个model包，新建payment.go文件</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付</span></span><br><span class="line"><span class="comment">// 支付宝</span></span><br><span class="line"><span class="comment">// 银联</span></span><br><span class="line"><span class="comment">// 银行卡</span></span><br><span class="line"><span class="keyword">type</span> PaymentArgs <span class="keyword">struct</span> {</span><br><span class="line">    AppID       <span class="keyword">string</span></span><br><span class="line">    MchID       <span class="keyword">string</span></span><br><span class="line">    Key         <span class="keyword">string</span></span><br><span class="line">    CallbackUrl <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在model包，新建Alipay.go文件，这里我们让结构体 Alipay 继承 PaymentArgs<br>同一个结构体继承了多个不同的结构体</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Alipay <span class="keyword">struct</span> {</span><br><span class="line">    PaymentArgs               <span class="comment">// 匿名结构体，自动拥有PaymentArgs的信息</span></span><br><span class="line">    PaymentOther PaymentOther <span class="comment">// 有名结构体</span></span><br><span class="line">    AlipayOpenID <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WeChatPay <span class="keyword">struct</span> {</span><br><span class="line">    PaymentArgs</span><br><span class="line">    WeChatOpenID <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b Bank</span><br><span class="line"><span class="keyword">var</span> a AliPay</span><br><span class="line"><span class="keyword">var</span> w WeChat</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中这样来实现结构体变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alipay := &amp;model.Alipay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"alipay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"alipaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"alipayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/alipay"</span>,</span><br><span class="line">    },</span><br><span class="line">    AlipayOpenID: <span class="string">"alipayopenid"</span>,</span><br><span class="line">}</span><br><span class="line">wechatpay := &amp;model.WechatPay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"wechatpay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"wechatpaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"wechatpayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/wechatpay"</span>,</span><br><span class="line">    },</span><br><span class="line">    WechatOpenID: <span class="string">"wechatpayopenid"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中，如下的访问</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(alipay.PaymentArgs.AppID) <span class="comment">// alipay123</span></span><br><span class="line">fmt.Println(wechatpay.WechatOpenID)   <span class="comment">// wechatpayopenid</span></span><br><span class="line"></span><br><span class="line">alipay.PaymentOther.AppID = <span class="string">"ailpay_paymentother"</span></span><br><span class="line">fmt.Println(alipay.PaymentOther.AppID) <span class="comment">// ailpay_paymentother</span></span><br><span class="line">fmt.Println(alipay.AppID)              <span class="comment">// alipay123 默认继承第一个结构体的字段</span></span><br><span class="line">fmt.Println(alipay.PaymentArgs.AppID)  <span class="comment">// alipay123</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法的继承与重载"><a href="#方法的继承与重载" class="headerlink" title="方法的继承与重载"></a>方法的继承与重载</h4><p>为payment.go文件中PaymentArgs结构体增加方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PaymentArgs)</span> <span class="title">Info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"Info = %v\n"</span>, p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们定义的Alipay结构体与WechatPay结构体自动就继承了PaymentArgs的方法<br>我们在main.go中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paymentArgs := model.PaymentArgs{</span><br><span class="line">    AppID:       <span class="string">"superAppid"</span>,</span><br><span class="line">    MchID:       <span class="string">"superMchid"</span>,</span><br><span class="line">    Key:         <span class="string">"superKey"</span>,</span><br><span class="line">    CallbackUrl: <span class="string">"https://api.imooc.com/super"</span>,</span><br><span class="line">}</span><br><span class="line">paymentArgs.Info()</span><br><span class="line"><span class="comment">//Info = &amp;{superAppid superMchid superKey https://api.imooc.com/super}</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样的我们可以对继承的方法进行重定义<br>在我们的Alipay.go中为Alipay结构体增加重写了Info()方法，</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alipay)</span> <span class="title">Info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"alipay = %v\n"</span>, a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alipay := &amp;model.Alipay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"alipay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"alipaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"alipayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/alipay"</span>,</span><br><span class="line">    },</span><br><span class="line">    AlipayOpenID: <span class="string">"alipayopenid"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载info方法</span></span><br><span class="line">alipay.Info()</span><br><span class="line"><span class="comment">//alipay = &amp;{{alipay123 alipaymchid alipayfjkadsfjkasfjas</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问"><a href="#一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问" class="headerlink" title="一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问"></a>一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringStruct <span class="keyword">struct</span> {</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line">    ss := StringStruct{<span class="string">"hello"</span>}</span><br><span class="line">    fmt.Println(ss.<span class="keyword">string</span>) <span class="comment">// hello</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Go-语言没有重写"><a href="#Go-语言没有重写" class="headerlink" title="Go 语言没有重写"></a>Go 语言没有重写</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    son := Son{</span><br><span class="line">        Parent{},</span><br><span class="line">    }</span><br><span class="line">    son.SayHello() <span class="comment">// I am Parent Go 没有重写</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Parent <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Parent)</span> <span class="title">SayHello</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"I am "</span> + p.Name())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Parent)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Parent"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son <span class="keyword">struct</span> {</span><br><span class="line">    Parent</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了自己的 Name() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Son)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Son"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当你写下类似继承的代码的时候，千万要先试试它会调过去哪个方法</p>
<p>而在典型的支持重写的语言，如Java，我们可以期望它输出 I am Son</p>
<h2 id="Go-语言的结构体没有多态性"><a href="#Go-语言的结构体没有多态性" class="headerlink" title="Go 语言的结构体没有多态性"></a>Go 语言的结构体没有多态性</h2><p>Go 语言不是面向对象语言在于它的结构体不支持多态，它不能算是一个严格的面向对象语言。</p>
<p>下面的例子呈现了 Java 类的多态性。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat fruit"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"smell first"</span>);</span><br><span class="line">    eat();</span><br><span class="line">    System.out.println(<span class="string">"clean finally"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat apple"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat banana"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">    Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">    apple.enjoy();</span><br><span class="line">    banana.enjoy();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">smell first</span><br><span class="line">eat apple</span><br><span class="line">clean <span class="keyword">finally</span></span><br><span class="line">smell first</span><br><span class="line">eat banana</span><br><span class="line">clean <span class="keyword">finally</span></span><br></pre></td></tr></tbody></table></figure>

<p>父类 Fruit 定义的 enjoy 方法调用了子类实现的 eat 方法，子类的方法可以对父类定义的方法进行覆盖，父类的 eat 方法被隐藏起来了。</p>
<p>多态的定义格式与实现方式<br>结构体与自定义类型都可以实现接口中的方法<br>接口的多重继承实现方式</p>
<p>Go 语言的结构体明确不支持这种形式的多态，外结构体的方法不能覆盖内部结构体的方法。</p>
<p>比如我们用 Go 语言来改写上面的水果例子观察一下输出结果。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat fruit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">enjoy</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"smell first"</span>)</span><br><span class="line">    f.eat()</span><br><span class="line">    fmt.Println(<span class="string">"clean finally"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> {</span><br><span class="line">    Fruit</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apple)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat apple"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> {</span><br><span class="line">    Fruit</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Banana)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat banana"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> apple = Apple {}</span><br><span class="line">    <span class="keyword">var</span> banana = Banana {}</span><br><span class="line">    apple.enjoy()</span><br><span class="line">    banana.enjoy()</span><br><span class="line">}</span><br><span class="line">----------</span><br><span class="line">smell first</span><br><span class="line">eat fruit</span><br><span class="line">clean finally</span><br><span class="line">smell first</span><br><span class="line">eat fruit</span><br><span class="line">clean finally</span><br></pre></td></tr></tbody></table></figure>

<p>enjoy 方法调用的 eat 方法还是 Fruit 自己的 eat 方法，它没能被外面的结构体方法覆盖掉。这意味着面向对象的代码习惯不能直接用到 Go 语言里了，我们需要转变思维。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-tong-guo-jie-kou-xie-yi-qu-li-jie-sort-de-ben-zhi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-tong-guo-jie-kou-xie-yi-qu-li-jie-sort-de-ben-zhi/" class="post-title-link" itemprop="url">go通过接口协议去理解sort的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-09 07:09:55" itemprop="dateModified" datetime="2021-07-09T07:09:55Z">2021-07-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> {</span><br><span class="line">    n := data.Len()</span><br><span class="line">    quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An implementation of Interface can be sorted by the routines in this package.</span></span><br><span class="line"><span class="comment">// The methods refer to elements of the underlying collection by integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Less reports whether the element with index i</span></span><br><span class="line">    <span class="comment">// must sort before the element with index j.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If both Less(i, j) and Less(j, i) are false,</span></span><br><span class="line">    <span class="comment">// then the elements at index i and j are considered equal.</span></span><br><span class="line">    <span class="comment">// Sort may place equal elements in any order in the final result,</span></span><br><span class="line">    <span class="comment">// while Stable preserves the original input order of equal elements.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Less must describe a transitive ordering:</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.</span></span><br><span class="line">    <span class="comment">//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that floating-point comparison (the &lt; operator on float32 or float64 values)</span></span><br><span class="line">    <span class="comment">// is not a transitive ordering when not-a-number (NaN) values are involved.</span></span><br><span class="line">    <span class="comment">// See Float64Slice.Less for a correct implementation for floating-point values.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">    Url   <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Courses []Course <span class="comment">// 基于slice创建新的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Courses)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Courses)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> c[i].Price &lt; c[j].Price</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Courses)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    c[i], c[j] = c[j], c[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//通过sort来排序</span></span><br><span class="line">    <span class="comment">//让你写一个排序算法， 冒泡 插入 快速 归并 桶排序 算法本质是一样 比较 计数排序</span></span><br><span class="line">    <span class="comment">//你的排序算法是否能应付各种类型的排序</span></span><br><span class="line">    courses := Courses{ <span class="comment">// 切片</span></span><br><span class="line">        Course{<span class="string">"django"</span>, <span class="number">300</span>, <span class="string">""</span>},</span><br><span class="line">        Course{<span class="string">"scrapy"</span>, <span class="number">100</span>, <span class="string">""</span>},</span><br><span class="line">        Course{<span class="string">"go"</span>, <span class="number">400</span>, <span class="string">""</span>},</span><br><span class="line">        Course{<span class="string">"torando"</span>, <span class="number">200</span>, <span class="string">""</span>},</span><br><span class="line">    }</span><br><span class="line">    sort.Sort(courses) <span class="comment">//协议 你的目的不是要告诉别人具体的类型，重要的是你的类型必要提供具体的方法</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> courses {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//{scrapy 100 }</span></span><br><span class="line">    <span class="comment">//{torando 200 }</span></span><br><span class="line">    <span class="comment">//{django 300 }</span></span><br><span class="line">    <span class="comment">//{go 400 }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
