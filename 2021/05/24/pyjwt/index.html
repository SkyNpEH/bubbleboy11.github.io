<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="前后端分离下&#x2F;微信小程序&#x2F;app的用户登录HTTP是无状态的，一次请求结束连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。但是对于一个Web应用而言，它是需要有状态管理的，这样才能让服务器知道HTTP请求来自哪个用户，从而判断是否允许该用户请求以及为用户提供更好的服务，这个过程就是常说的会话管理。 之前我们做会话管理（用户跟踪）的方法是：用户登录成功后，在服务器端通过一个se">
<meta property="og:type" content="article">
<meta property="og:title" content="drf认证和权限">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/05/24/pyjwt/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="前后端分离下&#x2F;微信小程序&#x2F;app的用户登录HTTP是无状态的，一次请求结束连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。但是对于一个Web应用而言，它是需要有状态管理的，这样才能让服务器知道HTTP请求来自哪个用户，从而判断是否允许该用户请求以及为用户提供更好的服务，这个过程就是常说的会话管理。 之前我们做会话管理（用户跟踪）的方法是：用户登录成功后，在服务器端通过一个se">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bubbleboy11.github.io/2021/05/24/pyjwt/json-web-token.png">
<meta property="article:published_time" content="2021-05-23T16:21:41.000Z">
<meta property="article:modified_time" content="2021-06-12T04:46:31.180Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bubbleboy11.github.io/2021/05/24/pyjwt/json-web-token.png">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/05/24/pyjwt/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/05/24/pyjwt/","path":"2021/05/24/pyjwt/","title":"drf认证和权限"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>drf认证和权限 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8B-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-app%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="nav-text">前后端分离下&#x2F;微信小程序&#x2F;app的用户登录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JWT%E6%A6%82%E8%BF%B0"><span class="nav-text">JWT概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JWT%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">JWT的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8PyJWT"><span class="nav-text">使用PyJWT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8PyJWT%E7%94%9F%E6%88%90%E4%BB%A4%E7%89%8CToken"><span class="nav-text">利用PyJWT生成令牌Token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86%E5%B9%B6%E6%A0%A1%E9%AA%8CToken"><span class="nav-text">解密并校验Token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8base64%E5%AF%B9Header%E5%92%8CPayload%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%E5%BE%97%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-text">用base64对Header和Payload进行解码得到相应的信息</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">341</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/05/24/pyjwt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          drf认证和权限
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-23 16:21:41" itemprop="dateCreated datePublished" datetime="2021-05-23T16:21:41Z">2021-05-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-12 04:46:31" itemprop="dateModified" datetime="2021-06-12T04:46:31Z">2021-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前后端分离下-微信小程序-app的用户登录"><a href="#前后端分离下-微信小程序-app的用户登录" class="headerlink" title="前后端分离下/微信小程序/app的用户登录"></a>前后端分离下/微信小程序/app的用户登录</h1><p>HTTP是无状态的，一次请求结束连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。<br>但是对于一个Web应用而言，它是需要有状态管理的，这样才能让服务器知道HTTP请求来自哪个用户，从而判断是否允许该用户请求以及为用户提供更好的服务，这个过程就是常说的<strong>会话管理</strong>。</p>
<p>之前我们做会话管理（用户跟踪）的方法是：用户登录成功后，在服务器端通过一个session对象保存用户相关数据，然后把session对象的ID写入浏览器的cookie中；<br>下一次请求时，HTTP请求头中携带cookie的数据，<br>服务器从HTTP请求头读取cookie中的sessionid，根据这个标识符找到对应的session对象，这样就能够获取到之前保存在session中的用户数据。</p>
<p>REST架构是最适合互联网应用的架构，它强调了HTTP的无状态性，这样才能保证应用的水平扩展能力（当并发访问量增加时，可以通过增加新的服务器节点来为系统扩容）。<br>基于session实现用户跟踪的方式需要服务器保存session对象在内存中，每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，而随着认证用户和多个客户端的增多，在做水平扩展增加新的服务器节点时，需要复制和同步session对象，服务端的开销会明显增大</p>
<ol>
<li>相比<code>JWT</code>，最大的优势就在于可以主动清除 <code>session</code>。</li>
<li><code>session</code>保存在服务器端，相对较为安全。</li>
<li>结合<code>cookie</code>使用，较为灵活，兼容性较好。但是在跨域场景表现不好。<br>cookie是用来前后端传输来做用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
</ol>
<p>解决这个问题有两种方案，<br>一种是架设缓存服务器（如Redis），让多个服务器节点共享缓存服务并将session对象直接置于缓存服务器中；<br>当用户对其他的接口访问时，必须携带这个token，接着服务器判断这个token是否存在与redis中，来判断用户是否已经登陆或者是否有相应的权限</p>
<p>另一种方式放弃基于session的用户跟踪，使用<strong>基于token令牌的用户跟踪</strong>。<br>传统的token是某个用户登录成功之后，服务器生成一个随机token给用户保存，并且服务器(数据库或缓存)保留同一份token，以后用户再来访问时需携带 token，服务端接收到 token 之后，去数据库或缓存中进行校验 token 的是否超时、是否合法</p>
<p>基于token的用户跟踪具体流程如下：</p>
<ol>
<li>用户使用用户名密码来请求服务器，服务器进行验证用户的信息，如果登录成功，服务器为用户加密生成一个字符串（token）令牌发给作客户端作为请求的一个身份标识，<br>该令牌中通常包含了用户标识、过期时间等信息而且需要加密并生成指纹（避免伪造或篡改令牌），</li>
<li>前端获取到服务器返回的token，保存在浏览器本地存储（可以保存在<code>localStorage</code>或<code>sessionStorage</code>中，对于使用Vue.js的前端项目来说，还可以通过Vuex进行状态管理）；</li>
<li>对于使用了前端路由的项目来说，前端每次路由跳转，可以先判断<code>localStroage</code>中有无token，如果没有则跳转到登录页；通过js取出本地数据按需使用这个数据，</li>
<li>以后每次请求后端数据接口，客户端只需在HTTP请求头里携带token来请求数据，无需再次带上用户名和密码。服务端后端接口判断请求头有无token，如果没有token以及token是无效的或过期的，服务器统一返回401；</li>
<li>如果前端收到HTTP响应状态码401，则重定向到登录页面。</li>
</ol>
<p>在很多项目案例中，需要实现账户的功能，客户端所有的功能都基于用户已登陆的前提下才可以使用。<br>这就要求每次客户端像服务器请求数据时都要验证账户是否正确，<br>如果正确则按正常方式返回数据，如果错误则进行拦截并返回错误信息。<br>但是当客户端频繁向服务器请求数据的话，每次服务器都要频繁地查询数据库。<br>而Token正是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。并取代传统使用session的方法来进行验证。</p>
<p>相比于sesssion保存在服务器，JWT是不用保存的。<br>这样的话服务器不需要保存用户状态，从而可以很容易的做到水平扩展。</p>
<p>生成token的方法很多，其中一种比较成熟的解决方案是使用JSON Web Token。</p>
<h2 id="JWT概述"><a href="#JWT概述" class="headerlink" title="JWT概述"></a>JWT概述</h2><p>官网<a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a> 根据前2个部分和右小叫的key，计算第三部分的signature，和自己生成的对比<br>JSON Web Token JWT，它是一种开放标准（RFC 7519）。<br>它定义了一套简洁紧凑（compact）且 URL 安全（URL-safe）的方案，<br>以安全地在客户端和服务器网络应用环境之间传输 JSON 格式的信息。<br>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密<br>随着RESTful架构前后端分离、分布式站点的单点登录（SSO）场景的项目使用JWT作为用户身份认证的方式。</p>
<p><img src="/2021/05/24/pyjwt/json-web-token.png"></p>
<ol>
<li><p>头部</p>
 <figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <code>alg</code>属性表示签名的hash算法，默认是HMAC SHA256（简写成<code>HS256</code>）<br> <code>typ</code>属性表示这个令牌的类型，为大写的<code>JWT</code>。<br> 该部分数据需要转换成json串并用base64编码</p>
</li>
<li><p>载荷<br>用来存放实际需要传递的数据。<br>格式为字典-此部分分为公有声明和私有声明</p>
</li>
</ol>
<p>公共声明：JWT提供了内置关键字用于描述常见的问题<br>用户根据自己需求按需添加key，<br>JWT官方文档中规定了7个可选的字段 常见公共声明如下<br>    - iss：Issuer签发人<br>    - exp：Expiration过期时间，按当地时间确定，所以设置时要使用utc时间。<br>    - sub：jwt所面向的用户<br>    - aud：Audience受众接收者，分为web端、Android、iOS端<br>    - nbf：生效时间，当前时间在nbf里的定义时间之前，则Token不被接受<br>    - iat：Issued At签发时间<br>    - jti：编号，唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>
<p>我们可以根据业务需要添加自定义的字段，如下所示。<br>第一部分是一个Json对象，称为payload可以存储一些不敏感的有效的信息，<br>例如用户名，过期时间等等所有你想要传递的信息，<br>不建议添加密码等敏感信息，因为该部分在客户端可解密</p>
<p>在“用户鉴权”方法中，解析token完成后要利用这个username来查找并返回用户信息给用户。<br>这里的data声明是自定义需要传递的信息，</p>
<p>公共声明和私有声明均在同一个字典中<br>转成json串并用base64加密</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class="highlight json"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="attr"&gt;&amp;quot;sub&amp;quot;&lt;/span&gt;: &lt;span class="string"&gt;&amp;quot;1234567890&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="attr"&gt;&amp;quot;nickname&amp;quot;&lt;/span&gt;: &lt;span class="string"&gt;&amp;quot;jackfrued&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="attr"&gt;&amp;quot;role&amp;quot;&lt;/span&gt;: &lt;span class="string"&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>其中第一部分Header和第二部分Payload只是对原始输入的信息转成了base64编码，</p>
<ol start="3">
<li>签名<ul>
<li>保证Token在传输的过程中没有被篡改或者损坏<br>实现签名首先需要读取配置文件中的SECRET_KEY配置变量，<br>这个秘钥your-256-bit-secret主要用在下文Signature签名中，服务端用来校验Token合法性，<br>这个密钥只有服务器才知道，不能泄露给用户。</li>
</ul>
</li>
</ol>
<p>签名规则如下:<br>根据header头部的alg算法（默认是<code>HS256</code>） 以下用HS256为例，按照下面的公式产生签名。</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class="highlight python"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;HS256(base64Encode(header) + &lt;span class="string"&gt;&amp;#x27;.&amp;#x27;&lt;/span&gt; + base64Encode(payload), secret_key)&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;HS256(自定义的key, base64后的 header + &lt;span class="string"&gt;&amp;quot;.&amp;quot;&lt;/span&gt; + base64后的payload)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>解释：用自定义的key,对base64后的 header+”+”.”+base64后的payload进行hmac计算</p>
<p>JWT生成的Token相当于是三个JSON对象经过编码后，<br>把头部、载荷、签名三个部分用两个点<code>.</code>拼接成一个字符串，如下图所示。</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class="highlight python"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;base64Encode(header) + &lt;span class="string"&gt;&amp;#x27;.&amp;#x27;&lt;/span&gt; + base64Encode(payload) + &lt;span class="string"&gt;&amp;#x27;.&amp;#x27;&lt;/span&gt; + base64Encode(sign)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<h4 id="JWT的优缺点"><a href="#JWT的优缺点" class="headerlink" title="JWT的优缺点"></a>JWT的优缺点</h4><p>使用JWT的优点非常明显，包括：</p>
<ol>
<li>更容易实现水平扩展，因为令牌保存在浏览器中，服务器不需要做状态管理。</li>
<li>更容易防范CSRF攻击，因为在请求头中添加<code>localStorage</code>或<code>sessionStorage</code>中的token必须靠JavaScript代码完成，而不是自动添加到请求头中的。</li>
<li>可以防伪造和篡改，因为JWT有签名，伪造和篡改的令牌无法通过签名验证，会被认定是无效的令牌。<br>体积小，因而传输速度快<br>传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输<br>严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。<br>支持跨域验证，可以应用于单点登录。<br>jwt 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>jwt在不加密的情况下，不能将涉密信息写入jwt</li>
</ol>
<p>当然，任何技术不可能只有优点没有缺点，JWT也有诸多缺点，大家需要在使用的时候引起注意，具体包括：</p>
<ol>
<li>可能会遭受到XSS攻击（跨站脚本攻击），通过注入恶意脚本执行JavaScript代码获取到用户令牌。</li>
<li>在令牌过期之前，无法作废已经颁发的令牌，要解决这个问题，还需要额外的中间层和代码来辅助。</li>
<li>JWT是用户的身份令牌，一旦泄露，任何人都可以获得该用户的所有权限。为了降低令牌被盗用后产生的风险，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应通过其他方式再次对用户进行认证，例如短信验证码等。</li>
</ol>
<p>与session共享机制的对比<br>代码侵入，在每个服务上必须有存取session鉴权判断的代码；<br>不安全，虽然redis等可以很方便的进行分布式部署，假若session服务器挂掉，系统便完全无法使用，不满足分布式系统中的高可用；<br>内存无法控制，若用户访问量激增极可能冲破内存，对内存要求高；<br>与之相反这些正是JWT的优势所在：</p>
<p>无代码侵入 ，只需要配置一个认证服务，其他服务可以无需关注权限，并可以提高到API网关进行权限拦截；<br>JWT不依赖session，对内存无要求，大量的访问也从容应对，不易产生硬件瓶颈；<br>可以在JWT中存储角色等信息，减少数据库查询或无需查询；</p>
<p>1、首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。<br>2、后端校验用户名和密码成功后，把用户的相关信息(比如用户id)以及过期时间等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。<br>3、后端将JWT字符串作为登录成功的返回结果返回给客户端前端。客户端前端将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。<br>4、前端以后在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)<br>5、服务器在接收到需要登录的API请求候，检查是否存在，若存在对这个 token进行解密验证有效性。,然后获取过期时间和用户信息(比如用户id) ，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。<br>6、验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p>
<p>JWT无法被破解的关键，是在其第三部分签名里的哈希加密中的Signature<br>由于哈希加密是无法直接解密的，所以jwt实际上只是重复使用加密的过程进行验证而已。</p>
<h3 id="使用PyJWT"><a href="#使用PyJWT" class="headerlink" title="使用PyJWT"></a>使用PyJWT</h3><p>用于编码和解码JSON Web令牌（JWT）</p>
<p>在Python代码中，可以使用三方库<code>PyJWT</code>生成和验证JWT，下面是安装<code>PyJWT</code>的命令。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyjwt</span><br></pre></td></tr></tbody></table></figure>

<h4 id="利用PyJWT生成令牌Token"><a href="#利用PyJWT生成令牌Token" class="headerlink" title="利用PyJWT生成令牌Token"></a>利用PyJWT生成令牌Token</h4><p><code>jwt.encode(payload=payload, key=key, algorithms='HS256', headers=headers)</code></p>
<ul>
<li><code>payload</code>:具体内容自己添加，分为公有声明和私有声明，字典类型</li>
<li><code>key</code>:自定义的加密key，字符串str类型</li>
<li><code>algorithm</code>:使用的加密算法[HS256, RSA256] str字符串</li>
<li><code>headers</code>:，字典类型</li>
<li>返回值为token串 新版本返回类型：str字节,1.7版本是byte</li>
</ul>
<h4 id="解密并校验Token"><a href="#解密并校验Token" class="headerlink" title="解密并校验Token"></a>解密并校验Token</h4><ul>
<li><code>jwt.decode(jwt, key, algorithms='HS256')</code></li>
<li><code>jwt</code>: str,</li>
<li><code>key</code>: str = “”, 秘钥和生成token的秘钥一样</li>
<li><code>algorithms</code>: List[str] = None,</li>
<li>返回值payload明文 返回类型：dict</li>
</ul>
<p>dic 有官方指定的 key，程序在解密的时候会根据 key 的 Value 判断是否合法。这些 key 有：<br><code>issuer</code>: 发布者，若encode payload中添加 ‘iss’ 字段，则可针对该字段校验 参数类型：str，若iss校验失败，则抛出<code>jwt.exceptions.InvalidIssuerError: Invalid issuer</code><br><code>audience</code>：签发的受众群体，若encode payload中添加’aud’字段，则可针对该字段校验 参数类型：str<br>若aud校验失败，则抛出<code>jwt.exceptions.InvalidAudienceError: Invalid audience</code></p>
<ol>
<li>比对从token中取出的key对应的值，和各种请求中传来的值</li>
<li><code>exp</code>：在生成 token 时，可以设置该 token 的有效时间，检查到exp字段，且token过期，则抛出<code>jwt.ExpiredSignatureError</code><br>若encode得时候 payload中添加了exp字段;<br>则exp字段得值需为 当前时间戳+此token得有效期时间，<br>例如希望token 300秒后过期 {‘exp’: time.time() + 300};<br>在执行decode时，</li>
</ol>
<p><code>nbf</code>：它指的是该 token 的生效时间，如果使用但是没到生效时间则抛出：<br><code>jwt.exceptions.ImmatureSignatureError: The token is not yet valid (nbf)</code></p>
<p>iat：token 的开始时间，如果当前时间在开始时间之前则抛出<br><code>jwt.exceptions.InvalidIssuedAtError: Issued At claim (iat) cannot be in the future.</code></p>
<p><code>setting.py</code></p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SECURITY WARNING: keep the secret key used in production secret!</span></span><br><span class="line">SECRET_KEY = <span class="string">'django-insecure-ko!(dd)glepzzin%r%l--jbvg3=xm%v1fmx=uj1=6l#er06rgg'</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings  <span class="comment"># 不要用相对导入的方式导入配置文件</span></span><br><span class="line"></span><br><span class="line">headers = {  <span class="comment"># 默认内容</span></span><br><span class="line">    <span class="string">'typ'</span>: <span class="string">'jwt'</span>,</span><br><span class="line">    <span class="string">'alg'</span>: <span class="string">'HS256'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">payload = {</span><br><span class="line">    <span class="comment"># 设置过期时间要设置 UTC 时间 因为内部检查使用的也是 UTC 时间</span></span><br><span class="line">    <span class="comment"># Expiration time will be compared to the current UTC time</span></span><br><span class="line">    <span class="comment"># (as given by timegm(datetime.utcnow().utctimetuple())),</span></span><br><span class="line">    <span class="comment"># so be sure to use a UTC timestamp or datetime in encoding</span></span><br><span class="line">    <span class="string">'exp'</span>:</span><br><span class="line">        datetime.datetime.utcnow() +</span><br><span class="line">        datetime.timedelta(days=<span class="number">1</span>, minutes=<span class="number">5</span>, seconds=<span class="number">10</span>),</span><br><span class="line">    <span class="string">'iat'</span>:</span><br><span class="line">        datetime.datetime.utcnow(),  <span class="comment"># 开始时间</span></span><br><span class="line">    <span class="string">'iss'</span>:</span><br><span class="line">        <span class="string">'Ashe'</span>,  <span class="comment"># 签名</span></span><br><span class="line">    <span class="string">'data'</span>: {  <span class="comment"># 自定义的数据，一般存放该用户id和开始时间</span></span><br><span class="line">        <span class="string">'userid'</span>: <span class="number">10001</span>,  <span class="comment"># 'id':user_id,</span></span><br><span class="line">        <span class="string">'username'</span>: <span class="string">'Jack'</span>,</span><br><span class="line">        <span class="comment"># 'login_time': login_time</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># key = settings.SECRET_KEY  # 这个可以自定义密钥，为了方便直接使用Django的密钥</span></span><br><span class="line">key = <span class="string">'123'</span></span><br><span class="line"></span><br><span class="line">encoded_jwt = jwt.encode(payload=payload, key=key, algorithm=<span class="string">'HS256'</span>, headers=headers)</span><br><span class="line">print(encoded_jwt)  <span class="comment"># 查看生成的Token</span></span><br><span class="line"><span class="comment"># b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Ilx1OGZkMFx1N2VmNFx1NTQ5Nlx1NTU2MVx1NTQyNyIsInNpdGUiOiJodHRwczovL29wcy1jb2ZmZWUuY24ifQ.fIpSXy476r9F9i7GhdYFNkd-2Ndz8uKLgJPcd84BkJ4'</span></span><br><span class="line">print(type(encoded_jwt))  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">verified_payload = jwt.decode(encoded_jwt, key=key, issuer=<span class="string">'Ashe'</span>, algorithms=[<span class="string">'HS256'</span>])</span><br><span class="line">print(verified_payload)</span><br><span class="line"><span class="comment"># {'exp': 1622044499, 'iat': 1621957789, 'iss': 'Ashe', 'data': {'userid': 10001, 'username': 'Jack'}}</span></span><br><span class="line">print(type(verified_payload))  <span class="comment"># &lt;class 'dict'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="用base64对Header和Payload进行解码得到相应的信息"><a href="#用base64对Header和Payload进行解码得到相应的信息" class="headerlink" title="用base64对Header和Payload进行解码得到相应的信息"></a>用base64对Header和Payload进行解码得到相应的信息</h4><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部分源码</span></span><br><span class="line">signing_input, crypto_segment = jwt.rsplit(<span class="string">b"."</span>, <span class="number">1</span>)</span><br><span class="line">header_segment, payload_segment = signing_input.split(<span class="string">b"."</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        segments.append(base64url_encode(json_header))  <span class="comment"># 通过</span></span><br><span class="line">        segments.append(base64url_encode(payload))  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Segments</span></span><br><span class="line">        signing_input = <span class="string">b"."</span>.join(segments)  <span class="comment"># 用点拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            alg_obj = self._algorithms[algorithm]</span><br><span class="line">            key = alg_obj.prepare_key(key)</span><br><span class="line">            signature = alg_obj.sign(signing_input, key)</span><br><span class="line">        segments.append(base64url_encode(signature))</span><br></pre></td></tr></tbody></table></figure>

<p>将token分割成 <code>header_segment</code> 、<code>payload_segment</code> 、<code>crypto_segment</code> 三部分</p>
<ul>
<li>对第一部分 header_segment 进行 base64url 解密，得到 header</li>
<li>对第二部分 payload_segment 进行 base64url 解密，得到 payload</li>
<li>对第三部分 crypto_segment 进行 <code>base64url</code> 解密，得到 signature，针对 signature 部分数据进行合法性校验<ul>
<li>拼接前两段密文，即：<code>signing_input</code></li>
<li>从第一段明文中获取加密算法，默认：HS256</li>
<li>使用算法+盐 对 <code>signing_input</code> 进行加密，将得到的结果和 <code>signature</code> 密文进行比较</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(<span class="string">'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'</span>)</span><br><span class="line"><span class="string">b'{"typ":"JWT","alg":"HS256"}'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(<span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwic2l0ZSI6Imh0dHA6Ly9zdWliaWFuLnN0YXJtZW93LmNuIn0=="</span>)</span><br><span class="line"><span class="string">b'{"typ":"JWT","alg":"HS256"}{"username":"admin","site":"http://testdomain.starmeow.cn"}'</span></span><br></pre></td></tr></tbody></table></figure>
<p>加<code>==</code>：如果要base64编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？此时，需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。<br>然后，在编码后的字符串后面添加1个或2个等号“=”，表示所添加的零值字节数。解码的时候，会自动去掉。<br>第二部分主要存放有效信息，由于这里用的是可逆的base64 编码，所以第二部分的数据实际上是明文的。应该避免在这里存放不能公开的隐私信息。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(<span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwic2l0ZSI6Imh0dHA6Ly9zdWliaWFuLnN0YXJtZW93LmNuIn0.5CzNoZ2aWyNYYnImrJvGJuLZlJbUeCVTg-_PFq_XF7o=="</span>)</span><br><span class="line"><span class="string">b'{"typ":"JWT","alg":"HS256"}{"username":"admin","site":"http://testdomain.starmeow.cn"}9\x0b3hgf\x96\xc8\xd6\x18\x9c\x89\xab&amp;\xf1\x89\xb8\xb6e%\xb5\x1e\tT\xe0&lt;Z\x97\x17\xba'</span></span><br></pre></td></tr></tbody></table></figure>
<p>三部分一起解码，可以看到最后一部分被加密了无法查看</p>
<p>校验jwt规则<br>​1，解析header, 确认alg<br>2，签名校验 - 根据传过来的header和payload按 alg指明的算法进行签名，将签名结果和传过来的sign进行对比，若对比一致，则校验通过<br>3，获取payload自定义内容，有exp,则校验过期时间</p>
<p>服务端在有秘钥的情况下可以直接对JWT生成的Token进行解密，解密成功说明Token正确，且数据没有被篡改</p>
<p>当然我们前文说了JWT并没有对数据进行加密，如果没有secret_key也可以直接获取到Payload里边的数据，只是缺少了签名算法无法验证数据是否准确，pyjwt也提供了直接获取Payload数据的方法</p>
<p>如果不清楚JWT具体的使用方式，可以先看看第55天的内容，里面提供了完整的投票项目代码的地址。</p>
<p>从<code>django.contrib.auth.get_user_model</code>去<code>setting</code>中找<code>AUTH_USER_MODEL</code>，源码</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_model</span>():</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the User model that is active in this project.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">raise</span> ImproperlyConfigured(<span class="string">"AUTH_USER_MODEL must be of the form 'app_label.model_name'"</span>)</span><br><span class="line">    <span class="keyword">except</span> LookupError:</span><br><span class="line">        <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">            <span class="string">"AUTH_USER_MODEL refers to model '%s' that has not been installed"</span> % settings.AUTH_USER_MODEL</span><br><span class="line">        )</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>django 案例</p>
<p>在用户登录成功之后，生成token并返回，用户再次来访问时需携带token。<br>从token中取出用户名并从数据库中取出该用户对象</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_id</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 取token</span></span><br><span class="line">    token = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>)</span><br><span class="line">    <span class="comment"># 若没取出token，则用户未登录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若token不对，返回一个none</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = jwt.decode(token, TOKEN_KEY, algorithms=<span class="string">'HS256'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果没报错，拿出username</span></span><br><span class="line">    username = res[<span class="string">'username'</span>]</span><br><span class="line">    <span class="comment"># 从数据库中取出用户对象</span></span><br><span class="line">    users = UserProfile.objects.filter(username=username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> users:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    user = users[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>封装获取 token 函数</p>
<p><code>views.py</code></p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings  <span class="comment"># 不要用相对导入的方式导入配置文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_token</span>(<span class="params">username, expire=<span class="number">3600</span> * <span class="number">24</span></span>):</span></span><br><span class="line">    <span class="string">"""生成 token，有效期一天"""</span></span><br><span class="line">    <span class="keyword">import</span> jwt</span><br><span class="line">    now = time.time()</span><br><span class="line">    key = settings.SECRET_KEY</span><br><span class="line">    payload = {<span class="string">'username'</span>: username, <span class="string">'exp'</span>: int(now + expire)}</span><br><span class="line">    <span class="keyword">return</span> jwt.encode(payload, key, algorithm=<span class="string">'HS256'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>封装校验 token 函数</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings  <span class="comment"># 不要用相对导入的方式导入配置文件</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> user.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># token 验证装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_check</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取token</span></span><br><span class="line">        token = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>)</span><br><span class="line">        <span class="comment"># 没有 token，则用户未登录</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            result = {<span class="string">'code'</span>: <span class="number">403</span>, <span class="string">'error'</span>: <span class="string">u'用户未登录 - 没有权限！'</span>}</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(result)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = jwt.decode(token,</span><br><span class="line">                             settings.LIZI_TOKEN_KEY,</span><br><span class="line">                             algorithms=<span class="string">'HS256'</span>)</span><br><span class="line">        <span class="comment"># 若token不对，</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'jwt error {}'</span>.format(e))</span><br><span class="line">            result = {<span class="string">'code'</span>: <span class="number">403</span>, <span class="string">'msg'</span>: <span class="string">u'用户未登录!'</span>}</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(result)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果没报错，拿出username</span></span><br><span class="line">        username = res[<span class="string">'username'</span>]</span><br><span class="line">        user = User.objects.get(username=username)</span><br><span class="line">        <span class="comment"># user 挂载 request 上，以便后面方法可以直接取出用户</span></span><br><span class="line">        request.myuser = user</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_token</span>(<span class="params">username, password</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">  生成jwt</span></span><br><span class="line"><span class="string">  :param payload: dict 载荷</span></span><br><span class="line"><span class="string">  :param expiry: datetime 有效期</span></span><br><span class="line"><span class="string">  :param JWT_KEY: 密钥</span></span><br><span class="line"><span class="string">  :return: jwt</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">    payload = {</span><br><span class="line">        <span class="string">"iat"</span>: int(time.time()),</span><br><span class="line">        <span class="string">"exp"</span>: int(time.time()) + <span class="number">3600</span> * <span class="number">12</span>,</span><br><span class="line">        <span class="string">"password"</span>: password,</span><br><span class="line">        <span class="string">"username"</span>: username,</span><br><span class="line">    }</span><br><span class="line">    token = jwt.encode(payload, JWT_KEY, algorithm=<span class="string">'HS256'</span>)</span><br><span class="line">    <span class="keyword">return</span> token.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">token, db</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">  :param token: jwt</span></span><br><span class="line"><span class="string">  :param JWT_KEY: 密钥</span></span><br><span class="line"><span class="string">  :return: dict: payload</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = jwt.decode(token, JWT_KEY, algorithm=[<span class="string">'HS256'</span>])</span><br><span class="line">        user = db.query(User).filter(</span><br><span class="line">            User.account == payload[<span class="string">'username'</span>]).first()</span><br><span class="line">        <span class="keyword">if</span> user == <span class="literal">None</span>:</span><br><span class="line">            msg = <span class="string">'用户不存在'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line">        <span class="keyword">if</span> user.status == <span class="number">1</span>:</span><br><span class="line">            msg = <span class="string">'用户被禁用'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, user</span><br><span class="line">    <span class="keyword">except</span> jwt.PyJWTError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="string">'Token异常！'</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>此示例在django的中间件中对token进行校验，内部编写了两个中间件来支持用户通过两种方式传递token。</p>
<p>Postman-Header-Authorization请求头</p>
<p>Django要兼容session认证的方式，还需要同时支持JWT，并且两种验证需要共用同一套权限系统，该如何处理呢？我们可以参考Django的解决方案：<br>装饰器，例如用来检查用户是否登录的login_required和用来检查用户是否有权限的permission_required两个装饰器，<br>我们可以自己实现一个装饰器，检查用户的认证模式，同时认证完成后验证用户是否有权限操作</p>
<p>于是一个auth_permission_required的装饰器产生了：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings  <span class="comment"># 不要用相对导入的方式导入配置文件</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> PermissionDenied</span><br><span class="line"></span><br><span class="line">UserModel = get_user_model()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_permission_required</span>(<span class="params">perm</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">view_func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_wrapped_view</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 格式化权限</span></span><br><span class="line">            perms = (perm, ) <span class="keyword">if</span> isinstance(perm, str) <span class="keyword">else</span> perm</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> request.user.is_authenticated:</span><br><span class="line">                <span class="comment"># 正常登录用户判断是否有权限</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> request.user.has_perms(perms):</span><br><span class="line">                    <span class="keyword">raise</span> PermissionDenied</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    auth = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>).split()</span><br><span class="line">                <span class="keyword">except</span> AttributeError:</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                        <span class="string">"code"</span>: <span class="number">401</span>,</span><br><span class="line">                        <span class="string">"message"</span>: <span class="string">"No authenticate header"</span></span><br><span class="line">                    })</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用户通过API获取数据验证流程</span></span><br><span class="line">                <span class="keyword">if</span> auth[<span class="number">0</span>].lower() == <span class="string">'token'</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        dict = jwt.decode(auth[<span class="number">1</span>],</span><br><span class="line">                                          settings.SECRET_KEY,</span><br><span class="line">                                          algorithms=[<span class="string">'HS256'</span>])</span><br><span class="line">                        username = dict.get(<span class="string">'data'</span>).get(<span class="string">'username'</span>)</span><br><span class="line">                    <span class="keyword">except</span> jwt.ExpiredSignatureError:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>: <span class="number">401</span>,</span><br><span class="line">                            <span class="string">"message"</span>: <span class="string">"Token expired"</span></span><br><span class="line">                        })</span><br><span class="line">                    <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>: <span class="number">401</span>,</span><br><span class="line">                            <span class="string">"message"</span>: <span class="string">"Invalid token"</span></span><br><span class="line">                        })</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>:</span><br><span class="line">                            <span class="number">401</span>,</span><br><span class="line">                            <span class="string">"message"</span>:</span><br><span class="line">                            <span class="string">"Can not get user object"</span></span><br><span class="line">                        })</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        user = UserModel.objects.get(username=username)</span><br><span class="line">                    <span class="keyword">except</span> UserModel.DoesNotExist:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>: <span class="number">401</span>,</span><br><span class="line">                            <span class="string">"message"</span>: <span class="string">"User Does not exist"</span></span><br><span class="line">                        })</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> user.is_active:</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>:</span><br><span class="line">                            <span class="number">401</span>,</span><br><span class="line">                            <span class="string">"message"</span>:</span><br><span class="line">                            <span class="string">"User inactive or deleted"</span></span><br><span class="line">                        })</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Token登录的用户判断是否有权限</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> user.has_perms(perms):</span><br><span class="line">                        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                            <span class="string">"status_code"</span>: <span class="number">403</span>,</span><br><span class="line">                            <span class="string">"message"</span>: <span class="string">"PermissionDenied"</span></span><br><span class="line">                        })</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> JsonResponse({</span><br><span class="line">                        <span class="string">"status_code"</span>: <span class="number">401</span>,</span><br><span class="line">                        <span class="string">"message"</span>: <span class="string">"Not support auth type"</span></span><br><span class="line">                    })</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view_func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _wrapped_view</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></tbody></table></figure>

<p>在view使用时就可以用这个装饰器来代替原本的login_required和permission_required装饰器了</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@auth_permission_required('account.select_user')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        _jsondata = {<span class="string">"user"</span>: <span class="string">"ops-coffee"</span>, <span class="string">"site"</span>: <span class="string">"https://ops-coffee.cn"</span>}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JsonResponse({<span class="string">"state"</span>: <span class="number">1</span>, <span class="string">"message"</span>: _jsondata})</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse({</span><br><span class="line">            <span class="string">"state"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Request method 'POST' not supported"</span></span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure>

<p>需要一个生成用户Token的方法，通过给User model添加一个token的静态方法来处理</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">AbstractBaseUser, PermissionsMixin</span>):</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>, verbose_name=<span class="string">'创建时间'</span>)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=<span class="literal">True</span>, verbose_name=<span class="string">'更新时间'</span>)</span><br><span class="line">    username = models.EmailField(max_length=<span class="number">255</span>,</span><br><span class="line">                                 unique=<span class="literal">True</span>,</span><br><span class="line">                                 verbose_name=<span class="string">'用户名'</span>)</span><br><span class="line">    fullname = models.CharField(max_length=<span class="number">64</span>, null=<span class="literal">True</span>, verbose_name=<span class="string">'中文名'</span>)</span><br><span class="line">    phonenumber = models.CharField(max_length=<span class="number">16</span>,</span><br><span class="line">                                   null=<span class="literal">True</span>,</span><br><span class="line">                                   unique=<span class="literal">True</span>,</span><br><span class="line">                                   verbose_name=<span class="string">'电话'</span>)</span><br><span class="line">    is_active = models.BooleanField(default=<span class="literal">True</span>, verbose_name=<span class="string">'激活状态'</span>)</span><br><span class="line"></span><br><span class="line">    objects = UserManager()</span><br><span class="line"></span><br><span class="line">    USERNAME_FIELD = <span class="string">'username'</span></span><br><span class="line">    REQUIRED_FIELDS = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">token</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._generate_jwt_token()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_jwt_token</span>(<span class="params">self</span>):</span></span><br><span class="line">        token = jwt.encode(</span><br><span class="line">            {</span><br><span class="line">                <span class="string">'exp'</span>: datetime.utcnow() + timedelta(days=<span class="number">1</span>),</span><br><span class="line">                <span class="string">'iat'</span>: datetime.utcnow(),</span><br><span class="line">                <span class="string">'data'</span>: {</span><br><span class="line">                    <span class="string">'username'</span>: self.username</span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">            settings.SECRET_KEY,</span><br><span class="line">            algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> token.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        default_permissions = ()</span><br><span class="line"></span><br><span class="line">        permissions = (</span><br><span class="line">            (<span class="string">"select_user"</span>, <span class="string">"查看用户"</span>),</span><br><span class="line">            (<span class="string">"change_user"</span>, <span class="string">"修改用户"</span>),</span><br><span class="line">            (<span class="string">"delete_user"</span>, <span class="string">"删除用户"</span>),</span><br><span class="line">        )</span><br></pre></td></tr></tbody></table></figure>

<p>直接通过用户对象来生成Token：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> accounts.models <span class="keyword">import</span> User</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User.objects.get(username=<span class="string">'admin@ops-coffee.cn'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.token</span><br><span class="line"><span class="string">'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NDgyMjg3NzksImlhdCI6MTU0ODE0MjM3OSwiZGF0YSI6eyJ1c2VybmFtZSI6ImFkbWluQDE2My5jb20ifX0.akZNU7t_z2kwPxDJjmc-QxtNdICK0yhnwWmKxqqXKLw'</span></span><br></pre></td></tr></tbody></table></figure>

<p>生成的Token给到客户端，客户端就可以拿这个Token进行鉴权了</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>token = <span class="string">'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NDgyMjg4MzgsImlhdCI6MTU0ODE0MjQzOCwiZGF0YSI6eyJ1c2VybmFtZSI6ImFkbWluQDE2My5jb20ifX0.oKc0SafgksMT9ZIhTACupUlz49Q5kI4oJA-B8-GHqLA'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://localhost/api/user'</span>, headers={<span class="string">'Authorization'</span>: <span class="string">'Token '</span>+token})</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.json()</span><br><span class="line">{<span class="string">'username'</span>: <span class="string">'admin@ops-coffee.cn'</span>, <span class="string">'fullname'</span>: <span class="string">'运维咖啡吧'</span>, <span class="string">'is_active'</span>: <span class="literal">True</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一个auth_permission_required方法就可以搞定上边的全部需求</p>
<hr>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime, jwt, time</span><br><span class="line"><span class="keyword">from</span> app.dao.userDao <span class="keyword">import</span> UserDao</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> common</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span>():</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode_auth_token</span>(<span class="params">user_id, login_time</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成认证Token</span></span><br><span class="line"><span class="string">        :param user_id: int</span></span><br><span class="line"><span class="string">        :param login_time: int(timestamp)</span></span><br><span class="line"><span class="string">        :return: string</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = {</span><br><span class="line">                <span class="string">'exp'</span>: datetime.datetime.utcnow() + datetime.timedelta(days=<span class="number">0</span>, seconds=<span class="number">10</span>),</span><br><span class="line">                <span class="string">'iat'</span>: datetime.datetime.utcnow(),</span><br><span class="line">                <span class="string">'iss'</span>: <span class="string">'ken'</span>,</span><br><span class="line">                <span class="string">'data'</span>: {</span><br><span class="line">                    <span class="string">'id'</span>:user_id,</span><br><span class="line">                    <span class="string">'login_time'</span>: login_time</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> jwt.encode(</span><br><span class="line">                payload,</span><br><span class="line">                <span class="string">'secret'</span>,</span><br><span class="line">                algorithm=<span class="string">'HS256'</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> Exception  <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode_auth_token</span>(<span class="params">auth_token</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        验证Token</span></span><br><span class="line"><span class="string">        :param auth_token:</span></span><br><span class="line"><span class="string">        :return: integer|string</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = jwt.decode(auth_token, <span class="string">'secret'</span>, options= {<span class="string">'verify_exp'</span>:<span class="literal">False</span>})</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'data'</span> <span class="keyword">in</span> payload <span class="keyword">and</span> <span class="string">'id'</span> <span class="keyword">in</span> payload[<span class="string">'data'</span>]):</span><br><span class="line">                <span class="keyword">return</span> payload</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> jwt.InvalidTokenError</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> jwt.ExpiredSignatureError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Token过期"</span></span><br><span class="line">        <span class="keyword">except</span> jwt.InvalidTokenError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"无效的Token"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用户登录，登录成功返回token，写将登录时间写入数据库；登录失败返回失败原因</span></span><br><span class="line"><span class="string">        根据用户名/密码，到DB中进行校验，如果是合法的用户名/密码，调用encode_auth_token生成token返回；username加入到token的payload中。</span></span><br><span class="line"><span class="string">        :param password:</span></span><br><span class="line"><span class="string">        :return: json</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        userDao = UserDao()</span><br><span class="line">        user = userDao.search(username)</span><br><span class="line">        <span class="keyword">if</span> (user <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> jsonify(common.falseReturn(<span class="string">''</span>, <span class="string">'找不到用户'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (user.password == password):</span><br><span class="line">                login_time = int(time.time())</span><br><span class="line">                token = self.encode_auth_token(user.username, login_time)</span><br><span class="line">                <span class="keyword">return</span> jsonify(common.trueReturn(token.decode(), <span class="string">'登陆成功'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> jsonify(common.falseReturn(<span class="string">''</span>, <span class="string">'密码不正确'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">identify</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用户鉴权，用户的请求需要携带token信息，这个函数对request进行校验，调用decode_auth_token完成的校验。</span></span><br><span class="line"><span class="string">        :return: list</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        auth_header = request.headers.get(<span class="string">'Authorization'</span>)</span><br><span class="line">        <span class="keyword">if</span> (auth_header):</span><br><span class="line">            auth_tokenArr = auth_header.split(<span class="string">" "</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> auth_tokenArr <span class="keyword">or</span> auth_tokenArr[<span class="number">0</span>]!= <span class="string">'jwt'</span> <span class="keyword">or</span> len(auth_tokenArr) != <span class="number">2</span> ):</span><br><span class="line">                result = common.falseReturn(<span class="string">''</span>,<span class="string">'请传递正确的验证头信息'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                auth_token = auth_tokenArr[<span class="number">1</span>]</span><br><span class="line">                payload = self.decode_auth_token(auth_token)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isinstance(payload, str):</span><br><span class="line">                    userDao = UserDao()</span><br><span class="line">                    user = userDao.search(payload[<span class="string">'data'</span>][<span class="string">'id'</span>])</span><br><span class="line">                    <span class="keyword">if</span> (user <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">                        result = common.falseReturn(<span class="string">''</span>, <span class="string">'找不到该用户信息'</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        result = common.trueReturn(<span class="string">''</span>, <span class="string">'请求成功'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result = common.falseReturn(<span class="string">''</span>, payload)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = common.falseReturn(<span class="string">''</span>,<span class="string">'没有提供认证token'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>

<p>拦截所有的请求，都进行token校验</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span>():</span></span><br><span class="line">    Auth.identify(Auth,request )</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/22/zhuang-shi-qi-yu-zhi-shu/" rel="prev" title="python装饰器与质数">
                  <i class="fa fa-chevron-left"></i> python装饰器与质数
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/29/drf-simplejwt/" rel="next" title="drf-simplejwt">
                  drf-simplejwt <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
