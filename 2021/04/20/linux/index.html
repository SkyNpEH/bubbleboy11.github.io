<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="操作系统是电脑和应用程序之间的连接工具 操作系统的核心称为“内核″，但内核并不就等于操作系统内核提供系统服务，比如文件管理、虚拟內存、设备I&#x2F;O等它管理着整台计算机的硬件，负责应用程序和硬件之间的交互工作。除内核以外，在应用软件与内核之间通常还有些作为中间件的API还包含一些基本的程序，例如文本编辑器，编译器，外壳程序 ShellLinux 是操作系统内核，单独的 Linux内核没办法工作,须要有">
<meta property="og:type" content="article">
<meta property="og:title" content="linux">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/04/20/linux/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="操作系统是电脑和应用程序之间的连接工具 操作系统的核心称为“内核″，但内核并不就等于操作系统内核提供系统服务，比如文件管理、虚拟內存、设备I&#x2F;O等它管理着整台计算机的硬件，负责应用程序和硬件之间的交互工作。除内核以外，在应用软件与内核之间通常还有些作为中间件的API还包含一些基本的程序，例如文本编辑器，编译器，外壳程序 ShellLinux 是操作系统内核，单独的 Linux内核没办法工作,须要有">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-19T16:21:41.000Z">
<meta property="article:modified_time" content="2021-08-15T05:21:55.988Z">
<meta property="article:author" content="外心人D">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/04/20/linux/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/04/20/linux/","path":"2021/04/20/linux/","title":"linux"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>linux | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E8%84%91%E5%90%AF%E5%8A%A8%E6%97%B6-%E6%8C%89%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%E5%8F%91%E7%94%9F%E7%9A%84"><span class="nav-text">电脑启动时,按先后顺序发生的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bootloader"><span class="nav-text">bootloader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shell"><span class="nav-text">Shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Console-%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-text">Console(控制台)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="nav-text">Linux 的目录组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%8C%87%E9%80%BB%E8%BE%91%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%9C%80%E4%B8%8A%E4%B8%80%E7%BA%A7%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%AE%83%E6%98%AF%E7%9B%B8%E5%AF%B9%E5%AD%90%E7%9B%AE%E5%BD%95%E6%9D%A5%E8%AF%B4%E7%9A%84%E3%80%82"><span class="nav-text">根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E7%9B%B4%E5%B1%9E%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="nav-text">Linux 的根目录的直属子目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E9%98%85%E6%89%8B%E5%86%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">其他查阅手册的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%AC%A6%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%9B%B8%E5%BA%94%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%AD%97%E6%AF%8D%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%9C%89%E7%9B%B8%E5%BA%94%E6%9D%83%E9%99%90%E3%80%82"><span class="nav-text">文件访问权限符：如果相应位置有字母，表示有相应权限。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%95%B0%E5%AD%97%E6%9D%A5%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90%EF%BC%9Achmod-%E7%9A%84%E7%BB%9D%E5%AF%B9%E7%94%A8%E6%B3%95"><span class="nav-text">用数字来分配权限：chmod 的绝对用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%AD%97%E6%AF%8D%E6%9D%A5%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90%EF%BC%9Achmod-%E7%9A%84%E7%9B%B8%E5%AF%B9%E7%94%A8%E6%B3%95"><span class="nav-text">用字母来分配权限：chmod 的相对用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E6%9D%83%E9%99%90%E5%AD%97%E6%AF%8D%E9%85%8D%E5%90%88%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AC%A6%E5%8F%B7"><span class="nav-text">和权限字母配合的几个符号</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CST-Central-Standard-Time-%E2%80%9C%E4%B8%AD%E5%A4%AE%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4%E2%80%9D"><span class="nav-text">CST  Central Standard Time “中央标准时间”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#which-%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">which 命令：显示一个命令的对应的可执行文件程序的位置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#usr-bin-pwd"><span class="nav-text">&#x2F;usr&#x2F;bin&#x2F;pwd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E5%8F%82%E6%95%B0%EF%BC%88%E4%B8%80%E4%B8%AA%E6%A8%AA%E6%9D%A0%E3%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AF%8D-%E7%BC%A9%E5%86%99%E5%90%8D%E7%A7%B0%EF%BC%89"><span class="nav-text">短参数（一个横杠、一个字母 缩写名称）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%88%E4%B8%A4%E4%B8%AA%E6%A8%AA%E6%9D%A0%E3%80%81%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AF%8D-%E5%85%A8%E7%A7%B0%EF%BC%89"><span class="nav-text">长参数（两个横杠、多个字母 全称）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="nav-text">参数的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CentOS-%E7%9A%84%E7%BB%88%E7%AB%AF%E9%BB%98%E8%AE%A4%E6%98%AF%E6%9C%89%E9%A2%9C%E8%89%B2%E6%A0%87%E6%B3%A8%E7%9A%84%E3%80%82"><span class="nav-text">CentOS 的终端默认是有颜色标注的。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%88%97"><span class="nav-text">第一列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%88%97%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%8B%A5%E6%9C%89%E7%9B%B8%E5%90%8C-inode-%E5%8F%B7%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0"><span class="nav-text">第二列，表示拥有相同 inode 号的文件数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%88%97%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85"><span class="nav-text">第三列，表示文件或目录的所有者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%88%97%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E5%9C%A8%E7%9A%84%E7%BE%A4%E7%BB%84"><span class="nav-text">第四列，表示文件或目录的所在的群组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-text">方法一</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%8C%87%E5%AE%9A%E7%9A%84%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%85%B6%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84adc%E4%B8%BAbcd%E3%80%82"><span class="nav-text">替换指定的目录及其子目录下所有文件中的adc为bcd。</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">343</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/04/20/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-04-19T16:21:41Z">2021-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-15 05:21:55" itemprop="dateModified" datetime="2021-08-15T05:21:55Z">2021-08-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>操作系统是电脑和应用程序之间的连接工具</p>
<p>操作系统的核心称为“内核″，但内核并不就等于操作系统<br>内核提供系统服务，比如文件管理、虚拟內存、设备I/O等<br>它管理着整台计算机的硬件，负责应用程序和硬件之间的交互工作。<br>除内核以外，在应用软件与内核之间通常还有些作为中间件的API<br>还包含一些基本的程序，例如文本编辑器，编译器，外壳程序 Shell<br>Linux 是操作系统内核，单独的 Linux内核没办法工作,须要有GNU项目 提供操作系统的外围应用程序<br>两者合称为 GNU操作系统，Linux的官方称谓应该是“GNU/ Linux”,一般简称 Linux<br>GNU 牛羚 GNU’s Not Unix! 是一个操作系统项目<br>GNU + Linux （系统内核）= GNU/Linux完整的操作系统</p>
<p>自由的软件意味着源代码必须公开<br>自由的软件大部分时候是免费的,但也可以复制,修改和出售<br>自由运动的口号是:“团结就是力量”</p>
<p>Centos是 Community Enterprise Operating System “社区企业操作系统”<br>Centos兼具 Community(社区)和 Enterprise(企业)的特性</p>
<p>macoS和 Windows的源代码是闭源的(看不到), Linux则开源<br>有很多不同的 Linux变体,术语称为“ Linux发行版”</p>
<p>主板 Motherboard 或 Mainboard</p>
<ul>
<li>构成复杂电子系统例如电子计算机的中心或者主电路板</li>
</ul>
<h3 id="电脑启动时-按先后顺序发生的"><a href="#电脑启动时-按先后顺序发生的" class="headerlink" title="电脑启动时,按先后顺序发生的"></a>电脑启动时,按先后顺序发生的</h3><ol>
<li>启动界面（主板）</li>
<li>bootloader</li>
<li>操作系统（例如Windows）的启动</li>
<li>其他程序</li>
</ol>
<p>Windows启动的必要性</p>
<ul>
<li>Windows启动后,才可以使用各种应用程序</li>
<li>你的电脑需要一个类似“大管家”的软件</li>
<li>“大管家”软件起到连接电脑硬件和软件的“桥梁”的作用</li>
</ul>
<h3 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h3><p>boot(“启动”的意思) loader(“加载器”的意思)<br>通过这段小程序，初始化硬件设备、建立內存空间的映射图<br>为最终调用操作系统内核准备好正确的环境</p>
<p>一台电脑可以拥有两个(甚至更多)的操作系统<br>当启动界面结束后，会有一个被称为bootloader的程序显示出来<br>bootloader让你做出选择，到底选择哪个操作系统来启动<br>然后是操作系统的内核运行</p>
<p>通常, bootloader严重依赖于硬件而实现的,特别是在嵌入式领域<br>一般在 Linux和 Windows之间做出选择的 bootloader叫GRUB<br>如果没有做岀选择，GRUB在几秒之后就会启动默认的操作系统</p>
<p>云服务器相当于一台独立的服务器<br>虚拟主机相当于在云服务器上分出多个虚拟的“小服务器<br>一般云服务器比虚拟主机的价格要高</p>
<p>图形化界面(Graphical User Interface GUI)这种方式简单直观,使用者易于接受,容易上手操作。可以用鼠标来操作各种窗口</p>
<ul>
<li>图形界面有不同的变体,称之桌面管理器(gnome、KDE、XFCE、unity)的作用是管理窗口,以及它们的外观,选项</li>
<li>在 Windows下并没有“桌面管理器”这个概念</li>
<li>我们只能换换 Windows的“皮肤</li>
</ul>
<p>命令行界面(Command Line Interface CLI)需要有个控制台,是在图形用户界面得到普及之前使用最为广泛的用户界面，<br>它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行完成些操作。<br>Command Line CMD</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>「壳」，即人与电脑的接口，实际上是个命令解释程序，从标准输入读取你的命令，把命令结果输出到标准输出和标准错误等设备。Shell 通常指的是命令行界面的解析器，一个为操作系统提供访问内核的程序<br>Windows 下的 cmd、PowerShell，这些都是 shell，这个应该很容易理解。<br>win终端 虚拟终端<br>cmd是DOS窗口，而powershell才是真正的Windows Terminal窗口</p>
<p>Linux 下的 Bash、Zsh，<br>bash，全名叫做 Bourne-Again SHell，绝大多数 Linux 发行版的默认 shell。<br>zsh，全名叫做 Z shell，新版 MacOS 的默认 shell。对 Bourne shell 做出了大量改进，同时加入了 Bash、ksh 及 tcsh 的某些功能<br>Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，然后把执行结果返回给终端。<br>终端干的活儿是从用户（通过键盘和鼠标）这里接收输入，然后扔给 Shell，然后把 Shell 返回的结果展示给用户（通过显示器）。</p>
<h3 id="Console-控制台"><a href="#Console-控制台" class="headerlink" title="Console(控制台)"></a>Console(控制台)</h3><p>真正的终端<br>没有图形界面，只有黑底白字的全屏幕的终端<br>即在 Linux 下按 <code>Ctrl-Alt-F?</code> 看到的那个命令界面。<br>进入登录tty1~tty5这五个真正的全屏幕的tty终端的快捷键</p>
<ul>
<li><code>Ctr+At+F2</code>: terminal 1(:0大致等于tty1)</li>
<li><code>Ctrl +Alt +F3</code>: terminal 2(tty2)</li>
<li><code>Ctrl+ Alt+ F4</code>: terminal 3(tty3)</li>
<li><code>Ctrl+ Alt+F5</code>: terminal 4(tty4)</li>
<li><code>Ctrl + Alt + F6</code>: terminal5(tty5)</li>
</ul>
<p>退出tty终端</p>
<ul>
<li><code>ctrl+Alt+F1</code>:回到图形界面(感谢上帝)</li>
</ul>
<p>Ctrl + c 组合快捷键（同时按下）可以终止大部分终端的命令和正在执行的程序，有点类似 Windows 中的 Alt + F4</p>
<p>事实上，在远古的 Unix 大型机时代，console 应该是指物理连接在主机上的输入输出设备，<br>而 terminal 是指与 console 进行远程通信的串行设备。<br>而如今的 Linux 控制台实际上是内核模拟的 /dev/ttyn 终端，/dev/console 一般就是 /dev/tty0，<br>只有 root 用户才能写入。</p>
<p>TTY是 TeleTYpe 或者 teletypewriters,原来指的是电传打字机<br>远程连接到控制台的串行设备，现在来说通常也就是 /dev/ttyn 这些设备啦</p>
<p>图形模式的终端:<br>一般在 Centos等 Linux发行版下日常使用<br>可以配置终端的外观,用鼠标操作,可以同时运行其他应用程序</p>
<p>打开图形模式终端的方式</p>
<ul>
<li>调出系统搜索框，在搜索框中输入”terminal”</li>
<li>用快捷键来调出终端，比如可以自己设置快捷键:Ctr|+At+T</li>
</ul>
<h3 id="Linux-的目录组织"><a href="#Linux-的目录组织" class="headerlink" title="Linux 的目录组织"></a>Linux 的目录组织</h3><p>普通的文件<br>文本类型的文件（.txt，.doc，.odt，等等<br>声音文件（.wav，.mp3，.ogg），还有程序，等<br>这样的文件在 Windows 中也有</p>
<p>特殊的文件<br>你的光盘驱动器就是这类特殊的文件</p>
<p>Linux 中一切都是文件</p>
<h3 id="根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。"><a href="#根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。" class="headerlink" title="根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。"></a>根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。</h3><p>点开手机内部储存看到的就是手机的根目录</p>
<p>Linux 根目录<code>/</code>是Linux 最顶层的目录，没有比根目录再高一阶的目录了，没有目录包含根目录<br>用斜杠 <code>/</code> 来标明目录的层级与包含关系<br>目录形式是这样的 /usr/bin<br>bin 是 usr 目录的子目录，usr 是 / 这个根目录的子目录<br>Linux 的文件和目录都是由根目录 / 开始自顶向下呈乔木状分散的</p>
<p>Windows 中用反斜杠 \ 来标明目录的层级与包含关系<br>C 盘（C:\）是硬盘的根目录（假如没有把 C 盘磁盘分区的话）<br>可以有好几个根目录，双击C盘就进入C盘的根目录，双击D盘就进入D盘的根目录，<br>H 盘可能是光盘驱动器的根目录<br>点开游戏文件夹看到的就是游戏的根目录。<br>一个目录的形式是这样的 C:\Program Files\Baidu<br>Baidu 这个目录是 Program Files 这个目录的一个子目录<br>Program Files 这个目录是 C 盘这个根目录的一个子目录<br>目录名称可以包含空格等符号<br>在 Linux 下命名目录时尽量不使用空格或者其他特殊的符号<br>尽量用小写英文字母</p>
<h3 id="Linux-的根目录的直属子目录"><a href="#Linux-的根目录的直属子目录" class="headerlink" title="Linux 的根目录的直属子目录"></a>Linux 的根目录的直属子目录</h3><p>目录的列表形式，在类 Unix 的操作系统里是类似的<br>苹果的桌面操作系统 macOS 的目录结构也是从根目录 / 开始的</p>
<ul>
<li><p>bin：是 binary “二进制文件” ，可执行文件是二进制的<br>bin 目录包含了会被所有用户使用的可执行程序</p>
</li>
<li><p>boot 目录包含与 Linux 启动密切相关的文件</p>
</li>
<li><p>dev： device “设备”<br>包含外设。它里面的子目录，每一个对应一个外设<br>比如光盘驱动器的文件就会出现在这个目录下</p>
</li>
<li><p>etc：是法语 et cetera ，包含系统的配置文件</p>
</li>
<li><p>home： home 表示“家”。用户的私人目录，我们放置私人的文件<br>类似 Windows 中的 Documents 文件夹，也叫“我的文档<br>除了root外每个用户都在 home 目录下有一个私人目录存放自己私人文件<br>假如我的用户名是 oscar，那么我的私人目录就是 /home/oscar</p>
</li>
<li><p>lib：library“库”，目录包含被程序所调用的库文件，例如 .so 结尾的文件，<br>Windows 下这样的库文件则是以 .dll 结尾</p>
</li>
<li><p>media 可移动的外设（USB 盘，SD卡，DVD，光盘，等等）插入电脑时，访问这些外设中的内容</p>
</li>
<li><p>mnt： mount “挂载”，mnt： mount “挂载”</p>
</li>
<li><p>opt： optional application software package ，“可选的应用软件包”， 安装多数第三方软件和插件</p>
</li>
<li><p><code> root</code> 超级用户 root 的家目录<br>一般的用户的家目录位于 /home 下，root 用户是个例外</p>
</li>
<li><p>sbin： system binary “系统二进制文件“，比 bin 目录多了一个前缀 system（“系统”），包含系统级的重要可执行程序</p>
</li>
<li><p>srv： service “服务”，包含一些网络服务启动之后所需要取用的数据</p>
</li>
<li><p>tmp： temporary “临时的”，普通用户和程序存放临时文件的地方，</p>
</li>
<li><p>usr：是 Unix Software Resource “Unix操作系统软件资源”，类似 Windows 中的 C:\Windows，和 C:\Program Files 这两个文件夹的集合，usr 目录里安装了大部分用户要调用的程序</p>
</li>
<li><p>var：variable “动态的，可变的”，包含程序的数据，<br>/var/log 中有很多日志文件，log 文件记录电脑中发生了什么事</p>
</li>
</ul>
<p><code>pwd</code>  print working directory打印当前工作目录的路径</p>
<p>在 Linux 中，命令和函数都有使用手册，每次遇到命令和函数的用法不明确的情况，都可以通过查考手册来解决</p>
<p><code>man command</code> manual 命令使用手册 后接你想要显示使用手册的命令，函数，查看系统中自带的各种参考手册</p>
<ul>
<li>可执行程序或 Shell 命令</li>
<li>系统调用（Linux 内核提供的函数）</li>
<li>库调用（程序库中的函数）</li>
<li>文件（例如 /etc/passwd）</li>
<li>特殊文件（通常在 /dev 下）</li>
<li>游戏</li>
<li>杂项（比如 man(7)，groff(7)）</li>
<li>系统管理命令（通常只能被 root 用户使用）</li>
<li>内核子程序<br><code>sudo yum install -y man-pages</code> man 的手册安装<br><code>sudo mandb</code> 更新手册</li>
</ul>
<p><code>man + 数字 + 命令/函数</code> 可以查到相关的命令和函数<br>若不加数字，man 默认从数字较小的手册中寻找相关命令和函数</p>
<p><code>man ls</code> 会出现ls命令的使用说明。</p>
<p>手册的各部分区域说明：<br>区域的名字是用大写和粗体表示，且靠左对齐，</p>
<p><strong>NAME</strong> 手册页对应的命令或函数名字的全称，后接简单描述</p>
<p><strong>SYNOPSIS</strong> 概要，使用此命令的所有参数及其所有可能方法<br><code>ls [OPTION]... [FILE]...</code></p>
<blockquote>
<p>中括号<code>[]</code>中的内容表示可选，不一定要添加选项参数<br><code>...</code> ：省略号表示可以有多个此类内容<br>在 <code>[OPTION]</code> 和 <code>[FILE]</code> 后都有省略号，分别表示可以有多个选项和多个文件名，可以同时指定多个选项参数，同时查看多个目录</p>
</blockquote>
<ul>
<li>粗体的文字表示要原封不动输入</li>
<li>下划线的文字表示要用实际的内容替换</li>
</ul>
<p>在手册中移动</p>
<ul>
<li>键盘上的方向键：向上和向下键使我们实现上一行和下一行的跳转</li>
<li>PgUp 和 PgDn（或者空格键）键：实现上一页和下一页的跳转</li>
<li>键盘上的 Home 和 End 键：实现开始和结尾的跳转</li>
<li>/ 键（斜杠）：实现搜索，和之前在 less 命令中功能类似</li>
<li>键盘上的 q 键：退出手册页</li>
</ul>
<p><code>[-hvc]</code>表示<code>-h</code>，<code>-v</code> 和 <code>-c</code> 选项都是可选的，非强制性的<br><code>a|b</code>输入a或b 选项，但是不能够同时输入 a 和<br><code>option...</code>：省略号表示前面的内容可以输入任意多个</p>
<p>DESCRIPTION 列出所有参数和用法</p>
<p>其他区域：AUTHOR, REPROTIONG BUGS, COPYRIGHT, SEE ALSO另见</p>
<p>apropos 查找命令<br>apropos命令后面添加关键字即可（根据手册中的关键字），在所有手册页中查找相关关键字 的命令<br>apropos 命令与 man 命令有点对立的关系<br>man 命令用于显示命令的使用手册<br>apropos 命令用于根据手册中的关键字来找到命令</p>
<p><code>apropos sound</code> 查找控制音量 列出了所有使用手册中有 sound 这个关键字的命令<br>，左侧是命令的名字，后边是命令的手册中出现关键字的句子</p>
<h3 id="其他查阅手册的方法"><a href="#其他查阅手册的方法" class="headerlink" title="其他查阅手册的方法"></a>其他查阅手册的方法</h3><p>很多命令都支持<code>-h</code>参数 等价的参数 <code>--help</code> 显示帮助文档，没有 man 命令显示的使用手册那么详细，比 <code>man</code> 显示的手册稍显简便、易于阅读 <code>help</code> 命令查看保留关键字</p>
<p><code>yum -h</code> 查看 yum 命令的帮助文档</p>
<p><code>whatis</code>命令是 <code>man</code> 的精简版，显示<code>man</code>手册的开头部分的<code>NAME</code>区域，就是概述命令的作用<br><code>whatis ls</code> 查看 ls 命令的作用， 只显示 list directory contents</p>
<p><code>code &lt;文件路径/文件名&gt;</code>vscode中打开项目</p>
<p>终端在每一行的开头处会有一个被称为“命令行提示符”的字符串，我们在命令提示符后面输入命令，告诉电脑我们想要它完成的任务<br>这个提示符的格式可以自行设置<br><code>[]</code>：提示符的分隔符号，没有特殊含义。<br><code>root</code>：当前的登录用户。Linux 是多用户的操作系统<br><code>@</code>：分隔符号，没有特殊含义。前面是用户名，后面是所在的域<br><code>localhost</code>：当前系统的简写电脑/主机的名字（hostname127.0.0.1<br>（完整主机名是localhost.localdomain）。<br><code>~</code>：用户当前所在的目录名字，会随着用户进入不同目录而改变。刚打开一个终端（Terminal），当前所在的目录是你的用户家目录（home directory<br><code>#</code>：root超级用户的提示符，登录的用户权限等级，有 Linux 系统的所有权限，可以读、写、运行任意文件<br><code>$</code> 普通用户的权限的提示符</p>
<p>reboot、shutdown -h now、init、halt、user管理，<br>在普通用户身份上都是操作不了，<br>但是有些特殊的情况下又需要有执行权限。<br>又不可能让root用户把自己的密码告诉普通用户，这个问题该怎么解决？</p>
<p>该问题是可以被解决的，可以使用<code>sudo</code>（switch/substitute user do）命令来进行权限设置。<br>法一：暂时成为 root</p>
<ul>
<li><code>sudo command</code>运行只有 root 才可以运行的命令，在此命令前面加上 sudo 命令，终端会提示你输入密码，至少第一次会要求输入密码，此密码是你个人用户的密码，在我的情况，就是 ashe 的账户密码。<br>法二： 一直成为 root<br><code>sudo su</code>用户切换为root<br>退出 root 身份，用 <code>Ctrl + D</code> 的组合键或者 <code>exit</code> 命令<br>法三：<br><code>su</code>root用户，终端会提示你输入密码，至少第一次会要求输入密码，此密码是root用户的密码</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# su ashe</span><br><span class="line">[ashe@VM-0-9-centos root]$ cd /home/ashe/</span><br><span class="line">[ashe@VM-0-9-centos ~]$ su</span><br><span class="line">Password:</span><br><span class="line">[root@VM-0-9-centos ashe]# pwd</span><br><span class="line">/home/ashe 还是在ashe的家目录</span><br></pre></td></tr></tbody></table></figure>

<p><code>su -</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[ashe@VM-0-9-centos ~]$ su -</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Dec  3 21:11:32 CST 2020 from 180.136.85.44 on pts/0</span><br><span class="line">Last failed login: Tue Apr 20 15:11:52 CST 2021 on pts/1</span><br><span class="line">There were 12329 failed login attempts since the last successful login.</span><br><span class="line">[root@VM-0-9-centos ~]# pwd</span><br><span class="line">/root root的家目录</span><br><span class="line"></span><br><span class="line">[root@VM-0-9-centos ~]# logout</span><br><span class="line">[root@VM-0-9-centos ashe]# pwd</span><br><span class="line">/home/ashe</span><br><span class="line"></span><br><span class="line">[root@VM-0-9-centos ashe]# sudo -i</span><br><span class="line">[root@VM-0-9-centos ~]# pwd</span><br><span class="line">/root root的家目录</span><br><span class="line"></span><br><span class="line">[root@VM-0-9-centos ~]# logout</span><br><span class="line">[root@VM-0-9-centos ashe]# exit</span><br><span class="line">[root@VM-0-9-centos ashe]# exit</span><br><span class="line">[ashe@VM-0-9-centos ~]$ pwd 变为了ashe</span><br><span class="line">/home/ashe</span><br><span class="line">[ashe@VM-0-9-centos ~]$ sudo -i</span><br></pre></td></tr></tbody></table></figure>

<p>法三：  root<br>Sudo可以让管理员（root）事先定义某些特殊命令谁可以执行。<br>默认sudo中是没有除root之外用户的规则，要想使用则先配置sudo配置文件<code>/etc/sudoers</code><br>配置sudo文件请使用<code>#visudo</code>，打开之后其使用方法和vim一致<br>配置普通用户的权限<br><code>allow root to run any commands anywhere root   ALL=(ALL)   ALL</code><br>Root表示用户名，如果是用户组，则可以写成“%组名”<br>ALL：表示允许登录的主机（地址白名单）<br>(ALL)：表示以谁的身份执行，ALL表示root身份<br>ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割</p>
<p>案例：本身test用户不能添加用户，要求使用sudo配置，<br>将其设置为可以添加用户，并且可以修改密码（但是不能修改root用户密码）。<br>注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。<br>路径可以使用which命令来查看<br>语法：#which 指令名称<br>在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码。<br> 此处按照案例要求，不能让test用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：<br>禁止修改root密码的配置（先允许全部，再拒绝root密码设置）： /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root<br><code>sudo -l</code> 在普通用户下查看自己具有哪些特殊权限<br>sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。</p>
<p>理论上说来，只有 root 用户才可以创建无数个用户，</p>
<ul>
<li>Linux 中每一个用户都属于一个特定的群组</li>
</ul>
<p><code>useradd</code> 和 <code>adduser</code>都可以</p>
<ul>
<li><code>sudo useradd username</code></li>
<li>先执行<code>sudo su</code><br>再执行<code>useradd username</code> 创建用户，在不添加选项的时候，默认创建同名的家目录/<code>home/username</code>，默认创建同名的用户群组，并且把用户划归到这个群组</li>
</ul>
<p>验证是否成功<br><code>cat /etc/passwd</code> 最后一行，是否有zhangsan的信息<br><code>ls /home</code> 创建好用户随之产生一个同名家目录</p>
<p><code>passwd username</code>设置或修改密码<br><code>su ashe</code><br><code>whoami</code>显示当前登录的用户名<br>④<br><code>userdel 用户名</code>不加参数的话，终端不会提示你确认删除，直接删除了用户，但是不会删除在 /home 目录中的用户家目录<br><code>userdel 选项 用户名</code> 终端不会提示你确认删除，直接删除了用户<br><code>userdel -r 用户名</code>或者<code>userdel --remove 用户名</code> 删除用户的同时，删除其家目录，已经登录的用户不能删除</p>
<p><code>groups</code> 命令单独用，不加任何参数，会显示当前用户所在群组</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# groups</span><br><span class="line">root</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">`groups username`以获知一个用户属于哪个（些）群组</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">[root@VM-0-9-centos ~]# groups root</span><br><span class="line">root : root</span><br></pre></td></tr></tbody></table></figure>

<p>修改modify 用户<br><code>usermod -g 用户名</code> 修改指定用户的用户主群组，使用户的家目录里面的所有文件所在群组会相应改变。选项的值可以是用户组的id，也可以是组名，会把用户从原先的群组里剔除，加入到新的群组，root用户权限才行</p>
<p><code>usermod -g friends ashe</code>将 ashe 用户放到创建的 friends 这个群组<br>默认情况用户 ashe 之前的群组是 ashe，运行后 ashe 的群组变成friends</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# usermod -g friends ashe</span><br><span class="line">[root@VM-0-9-centos ~]# ll /home/</span><br><span class="line">total 8</span><br><span class="line">drwx------ 4 ashe friends 4096 Apr 20 15:10 ashe</span><br><span class="line">drwx------ 2 Jack Jack    4096 Apr 20 16:50 Jack</span><br><span class="line">[root@VM-0-9-centos ~]# groups ashe</span><br><span class="line">ashe : friends</span><br></pre></td></tr></tbody></table></figure>

<p><code>usermod -G 用户名</code> 添加指定用户的用户附件组，选项的值可以是用户组的id，也可以是组名<br><code>usermod -G friends,sniper,hero ashe</code>令把 ashe 添加到 friends，sniper 和 hero 三个群组</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# groupadd hero</span><br><span class="line">[root@VM-0-9-centos ~]# groupadd sniper</span><br><span class="line">[root@VM-0-9-centos ~]# usermod -G friends,sniper,hero ashe</span><br><span class="line">[root@VM-0-9-centos ~]# groups ashe</span><br><span class="line">ashe : friends hero sniper</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不想离开原先的群组，又想加入新的群组，以在 <code>-G</code> 参数的基础上加上 <code>-a</code> 参数，append “追加”<br>追加群组的时候，一定要用大写的 G 参数，即使只追加一个群组</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]<span class="comment"># groupadd family</span></span><br><span class="line">[root@VM-0-9-centos ~]<span class="comment"># usermod -aG family ashe</span></span><br><span class="line">[root@VM-0-9-centos ~]<span class="comment"># groups ashe</span></span><br><span class="line">ashe : friends hero sniper family</span><br></pre></td></tr></tbody></table></figure>

<p><code>useradd -g 用户名 添加指定用户的用户组</code>，选项的值可以是用户组的id，也可以是组名<br><code>useradd -G 用户名 添加指定用户的用户附件组</code>，选项的值可以是用户组的id，也可以是组名</p>
<p><code>useradd -u  用户名</code>  uid用户的id（用户的标识符）系统 默认会从500之后按顺序分配uid，如果不想使用系统分配的，可通过该选项自定义<br><code>useradd -c  用户名</code> comment添加注释</p>
<p>eg.添加选项，创建用户lisi，让lisi属于501主组，附加组500，自选靓号666<br>useradd -g 501 -G 500 -u  lisi<br>cat或者tail -3 /etc/passwd 查看主组<br>cat或者tail -3 /etc/group 查看附加组</p>
<p>usermod -u  用户名  uid用户的id（用户的标识符）系统 默认会从500之后按顺序分配uid，如果不想使用系统分配的，可通过该选项自定义<br><code>usermod -l 新用户名 旧用户名</code> 对用户重命名。/home 中的用户家目录名不改变，需要手动修改<br>eg. 修改zhangsan主组为500，附加组为501<br>usermod -g 500 -G 501 zhangsan<br>cat或者tail -3 /etc/passwd 查看主组<br>cat或者tail -3 /etc/group 查看附加组</p>
<p>只有 root 用户可以修改一个文件的所有者和群组</p>
<p><code>groupadd group_name</code> 添加一个新的用户群组<br>groupadd -g 用户组名 类似用户添加-u 选择设置一个自定义的用户组id数字，若自己不指定，则默认从500之后递增</p>
<p><code>groupdel 选项 用户群组名</code>当如果需要删除一个已存在的组，但是这个组是某个用尸的主组时 ，则不允许删除；如果确实需要删除，则先从组内移出所有用户到</p>
<p>用户组<br><code>groupmod -g 用户组名</code> 类似用户修改里的-u 选择设置一个自定义的用户组id数字，<br><code>groupmod -n  新用户组名 旧用户组名</code>:类似于用户修改<code>-l</code>，表示设置新的用户组的名称 </p>
<p>eg.修改administrator用户组，将组ID从502改成520，将名称改为admins<br><code>groupmod -g 502 -n admin administrator</code><br><code>tail -1 /etc/group</code> 查看</p>
<p><code>hostname</code>显示当前登录的主机名<br><code>hostname -f</code> 输出当前主机名中的FQDN全限定域名<br><code>hostname 设置的主机名 临时设置主机名</code></p>
<p>chown  username:groupname  文档路径 同时更改所属的用户和所属的用户组，root用户权限才行<br>chown  -R  username:groupname  文档路径 同时更改所属的用户和所属的用户组，并且包含其子目录</p>
<p><code>chown 新的所有者的用户名username 文件路径file_path</code>更改文件的所属用户、所有者 change owner<br><code>chown oscar:friends file.txt</code>改变文件的群组，把 file.txt 文件的所有者改为 oscar，群组改为 friends</p>
<p><code>chown -R  username 文件夹路径</code> 递归设置子目录和子文件 ，使得被修改的目录的所有子目录和子文件都改变所属用户、所有者，或者连群组也改变，用上述冒号的方法来同时修改所有者和群组，只能用大写的 R，小写的 r 不起作用，<br><code>chown test oo/</code>将刚才root用户创建的oo目录，所有者更改为test<br><code>chown -R oscar:oscar /home/thomas</code>把用户 thomas 的家目录的所有子目录和文件都归oscar所有</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]<span class="comment"># cd /home/ashe/</span></span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 ashe friends 0 Apr 20 21:34 file.txt</span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># chown Jack file.txt</span></span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># chgrp Jack file.txt</span></span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 Jack friends 0 Apr 20 21:34 file.txt</span><br></pre></td></tr></tbody></table></figure>

<p>file.txt 的所有者改为 Jack 之后，所在群组是不变的，还是 friends</p>
<p><code>chgrp  groupname file_path</code> 文件的路径 更改文件的所属用户群组，root用户权限才行<br><code>chgrp  -R  groupname</code> 文件的路径 更改文件夹的所属用户组<br><code>chgrp  test  oo/</code>：将刚才root用户创建的oo目录，所有者更改为test，并且将所属用户组也改为test</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># chgrp Jack file.txt</span></span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 Jack Jack 0 Apr 20 21:34 file.txt</span><br><span class="line">[root@VM-0-9-centos ashe]<span class="comment"># </span></span><br></pre></td></tr></tbody></table></figure>

<p>Linux 系统里，每个文件和目录都有一列权限属性<br>访问权限是按照用户来划分的：指明了谁有读的权利，谁有修改的权利，谁有运行的权利</p>
<h5 id="文件访问权限符：如果相应位置有字母，表示有相应权限。"><a href="#文件访问权限符：如果相应位置有字母，表示有相应权限。" class="headerlink" title="文件访问权限符：如果相应位置有字母，表示有相应权限。"></a>文件访问权限符：如果相应位置有字母，表示有相应权限。</h5><ul>
<li> <code>r</code>：读               4<br>  对于文件夹来说，读权限影响用户是否能够列出目录结构<br>  对于文件来说，读权限影响用户是否可以查看文件内容</li>
<li> <code>w</code>：写/修改/删除       2<br>  对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档<br>  对于文件来说，写权限影响用户是否可以编辑文件内容</li>
<li> <code>x</code>：执行/运行execute   1<br>  一般都是对于文件来说，特别脚本文件。</li>
<li>   <code>-</code>：没有任何权限       0</li>
</ul>
<p>如果要删除一个文件，不是看文件有没有对应的权限，<br>而是看<strong>文件所在的目录是否有写权限</strong>，如果有才可以删除。<br>同样还不允许创建文件/文件夹、移动文件、重命名文件<br>权限分配中，均是rwx的三个参数组合，且位置顺序不会变化。没有对应权限就用 <code>–</code> 代替。<br>如果一个权限数字中但凡出现2与3的数字，则该权限有不合理的情况。<br>如果 x 权限在一个目录上，那么表示的是这个目录可以被读，<br>就是可以打开此目录来看其子目录和子文件，如果同时有 r 权限的话</p>
<p><code>chmod 权限模式 文件</code> 修改文件的访问权限 操作者要么是root用户，要么就是文档的所有者。<br><code>chmod 权限模式-R 文件夹</code>递归地修改文件访问权限<br>权限模式：就是该文档需要设置的权限信息</p>
<h4 id="用数字来分配权限：chmod-的绝对用法"><a href="#用数字来分配权限：chmod-的绝对用法" class="headerlink" title="用数字来分配权限：chmod 的绝对用法"></a>用数字来分配权限：chmod 的绝对用法</h4><ul>
<li>访问权限的三组（所有者的权限，群组用户的权限，其他用户的权限）</li>
<li>只要分别做加法就可以了，然后把三个和连起来<br>合并这些权限，就需要做简单的加法了：将对应的数字相加<br>假如我们要分配读，写权限，那么我们就要用 4 + 2 = 6 表示具有读和写权限<br><code>640</code>6：文件的所有者有读和写的权限，4：文件所在群组的其他用户具有读的权限，0：除此之外的其他用户没有任何权限<br><code>777</code>所有者，群组用户，其他用户都有读，写和运行的权限</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ashe]# ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 Jack Jack 0 Apr 20 21:34 file.txt</span><br><span class="line">[root@VM-0-9-centos ashe]# chmod 600 file.txt</span><br><span class="line">[root@VM-0-9-centos ashe]# ll</span><br><span class="line">total 0</span><br><span class="line">-rw------- 1 Jack Jack 0 Apr 20 21:34 file.txt</span><br></pre></td></tr></tbody></table></figure>

<h4 id="用字母来分配权限：chmod-的相对用法"><a href="#用字母来分配权限：chmod-的相对用法" class="headerlink" title="用字母来分配权限：chmod 的相对用法"></a>用字母来分配权限：chmod 的相对用法</h4><p>不需要一次性把三组权限都写出来<br>给谁设置：</p>
<ul>
<li><code>u</code>：表示所有者owner（user）</li>
<li><code>g</code>：表示给所有者同组用户（group）</li>
<li><code>o</code>：表示others，给其他用户</li>
<li><code>a</code>：表示all，给所有用户（包含ugo部分）<br>如果在设置权限的时候不指定给谁设置，则默认给所有用户设置</li>
</ul>
<h4 id="和权限字母配合的几个符号"><a href="#和权限字母配合的几个符号" class="headerlink" title="和权限字母配合的几个符号"></a>和权限字母配合的几个符号</h4><ul>
<li><p><code>+</code>：加号，表示给具体的用户新增添加权限（相对当前）</p>
</li>
<li><p><code>-</code>：减号，表示去除删除用户的权限（相对当前）</p>
</li>
<li><p><code>=</code>：等号，表示将权限设置成具体的值（注重结果）【赋值】</p>
</li>
<li><p><code>chmod u+rx file</code> 文件 file 的所有者增加读和运行的权限</p>
</li>
<li><p><code>chmod g+r file</code> 文件 file 的群组其他用户增加读的权限</p>
</li>
<li><p><code>chmod o-r file</code> 文件 file 的其他用户移除读的权限</p>
</li>
<li><p><code>chmod g+r o-r file</code> 文件file 的群组其他用户增加读的权限，其他用户移除读的权限</p>
</li>
<li><p><code>chmod go-r file</code> 文件file的群组其他用户和其他用户均移除读的权限</p>
</li>
<li><p><code>chmod +x file</code> 文件 file 的所有用户增加运行的权限</p>
</li>
</ul>
<p><code>chmod u=rwx,g=r,o=- file</code>文件 file 的所有者分配读，写和执行的权限，群组其他用户分配读的权限，不能写或执行；其他用户没有任何权限</p>
<p><code>chmod -R 700 /home/oscar</code>只允许 oscar 能读，写，运行/home/oscar目录的所有文件</p>
<p>例如：需要给anaconda-ks.cfg文件（-rw——-.）设置权限，要求所有者拥有全部的权限，同组用户拥有读和执行权限，其他用户只读权限。<br><code>chmod u+x,g+rx,o+r anaconda-ks.cfg</code><br><code>chmod 754 anaconda-ks.cfg</code><br>权限几个判断，如果只有一个部分符合，则认为是有权限的<br>当文档拥有执行权限（任意部分），则其颜色在终端中是绿色<br>3个部分中有一个部分拥有全部权限的时候，<br><code>chmod u=rwx,g</code><br><code>chmod a=--- 文件</code>  设置没有权限</p>
<p>前面的那个root就是属主，创建该文件的用户名<br>后面的那个root就是属组，创建该文件用户所属的主组名称）。</p>
<p>如果有时候去删除某个用户，<br>则该用户对应的文档的属主和属组信息就需要去修改。</p>
<p>`shell<br>[root@VM-0-9-centos ~]# date<br>Mon Mar  1 16:46:16 CST 2021</p>
<h1 id="CST-Central-Standard-Time-“中央标准时间”"><a href="#CST-Central-Standard-Time-“中央标准时间”" class="headerlink" title="CST  Central Standard Time “中央标准时间”"></a>CST  Central Standard Time “中央标准时间”</h1><p>[root@VM-0-9-centos ~]# date +%F<br>2021-03-01<br>[root@VM-0-9-centos ~]# date “+%Y-%m-%d”<br>2021-03-01<br>[root@VM-0-9-centos ~]# date “+%Y %T”<br>2021 16:51:47<br>[root@VM-0-9-centos ~]# date “+%Y-%m-%d %H:%M:%S”<br>2021-03-01 16:54:21</p>
<p>[root@VM-0-9-centos ~]# cal<br>     March 2021<br>Su Mo Tu We Th Fr Sa<br>    1  2  3  4  5  6<br> 7  8  9 10 11 12 13<br>14 15 16 17 18 19 20<br>21 22 23 24 25 26 27<br>28 29 30 31<br>`</p>
<p>修改系统时间<br>date -s “20120827 15:04:00”<br>或者<br>date -s “2012-08-27 15:04:00”<br>或者<br>date -s “15:04:00 2012-08-27”<br>或者</p>
<p>date -s “15:04:00 20120827”<br>记得 双引号</p>
<p>引号表示让“年月日与时分秒”成为一个不可分割的整体</p>
<p>Windows 可执行程序以 .exe 结尾<br>Linux 每一条命令其实对应了一个可执行程序，一般是没有后缀名的</p>
<ul>
<li>在终端中输入命令，按回车的时候，就是执行了对应的那个程序，</li>
<li>一个命令，其实只不过是一个我们随时可以调用的程序罢了</li>
</ul>
<h3 id="which-命令：显示一个命令的对应的可执行文件程序的位置"><a href="#which-命令：显示一个命令的对应的可执行文件程序的位置" class="headerlink" title="which 命令：显示一个命令的对应的可执行文件程序的位置"></a>which 命令：显示一个命令的对应的可执行文件程序的位置</h3><p>which命令接受一个参数，是你想知道其可执行程序位于哪里的那个命令</p>
<ul>
<li>pwd 命令对应的 pwd 这个可执行程序位于 Linux 中的 /usr/bin 目录中<br>`shell<br>[root@VM-0-9-centos ~]# which pwd<h1 id="usr-bin-pwd"><a href="#usr-bin-pwd" class="headerlink" title="/usr/bin/pwd"></a>/usr/bin/pwd</h1>`</li>
</ul>
<p>selinux 安全模块</p>
<p>bin binary 二进制，可执行文件<br>dev device 硬件<br>etc 系统配置文件，root才能登<br>home 家目录  类似window user<br>prov 进程</p>
<p>usr 对应 win program files</p>
<p><code>q</code> 退出 quit</p>
<p>folder 文件夹<br>file 文件<br><code>command parameters</code>参数写在命令之后的一些补充选项，命令和参数之间有空格隔开，<br>改变命令的行为，同一个命令不同功能<br>区分大小写</p>
<h3 id="短参数（一个横杠、一个字母-缩写名称）"><a href="#短参数（一个横杠、一个字母-缩写名称）" class="headerlink" title="短参数（一个横杠、一个字母 缩写名称）"></a>短参数（一个横杠、一个字母 缩写名称）</h3><p>最常用的参数形式就是</p>
<ul>
<li>一个短横线后接一个字母 command -p</li>
<li>一次加好几个短参数，可以用空格隔开：command -p -a -T -c</li>
<li>多个短参数也可以合并在一起，效果是叠加：command -paT</li>
</ul>
<h3 id="长参数（两个横杠、多个字母-全称）"><a href="#长参数（两个横杠、多个字母-全称）" class="headerlink" title="长参数（两个横杠、多个字母 全称）"></a>长参数（两个横杠、多个字母 全称）</h3><p>格式：<code>command --parameter</code><br>多个长参数，是不能像多个短参数那样合并写的<br>而是只能以空格隔开：<code>command --parameter1 --parameter2</code><br>可以组合使用短参数和长参数<br>例如 <code>command -paTc --parameter1 --parameter2</code><br>有时候，同一个意义的参数有短参数和长参数两种形式<br>效果是一样的：例如 <code>ls -a</code> 和 <code>ls --all</code></p>
<h3 id="参数的值"><a href="#参数的值" class="headerlink" title="参数的值"></a>参数的值</h3><p>有一些参数需要赋值。短参数和长参数的赋值方式不一样<br>短参数赋值，通常是这样的：command -p 10<br>长参数赋值，通常是这样的：command –parameter=10</p>
<p><code>tab</code> 在输入了一个命令的首字母或前几个字母后，自动补全命令或文件名、路径名，按两下有提示 可以增加效率，防止手动输入路径时将名字写错，同时想不起来一个命令到底是如何拼写 </p>
<p><code>#</code>开头 注释<br>向上键：按时间顺序向前查找用过的命令，每按一次就前进一个命令<br>向下键：按时间顺序向后查找用过的命令，每按一次就前进一个命令</p>
<p><code>Ctrl + R</code> 用于查找使用过的命令<br><code>history</code> 列出之前使用过的所有命令<br><code>!编号</code>这样的格式来重新运行 history输出中对应编号的命令</p>
<p>空格下一页<br>回车：运行，下一行</p>
<h3 id="CentOS-的终端默认是有颜色标注的。"><a href="#CentOS-的终端默认是有颜色标注的。" class="headerlink" title="CentOS 的终端默认是有颜色标注的。"></a>CentOS 的终端默认是有颜色标注的。</h3><ul>
<li>蓝色 –&gt; 目录</li>
<li>绿色 –&gt; 可执行文件</li>
<li>红色 –&gt; 压缩文件</li>
<li>浅蓝色 –&gt; 链接文件</li>
<li>灰色 –&gt; 其他文件</li>
</ul>
<p><code>ls</code>列出当前目录下的文件和目录<br><code>ls -l 路径</code> ：缩写<code>ll</code>，以详细信息列表的形式列出当前目录下的文件和目录，查看权限 每一个文件或目录都有对应的一行信息，列出的文件详细信息中，文件大小是以字节为单位的，<br>在我们运行 ls -l 命令的时候<br>显示的每个文件或目录的</p>
<h4 id="第一列"><a href="#第一列" class="headerlink" title="第一列"></a>第一列</h4><p>十位字符表示含义：<br>第1位：文件或目录属性的符号，取值常见的有</p>
<ul>
<li><code>d</code>：directory 文件夹目录 蓝色</li>
<li><code>-</code>表示文件”黑色</li>
<li><code>l</code>： link 链接</li>
<li><code>d</code> 存储设备</li>
<li><code>s</code>表示套接字</li>
<li><code>c</code> 串行设备 鼠标键盘 </li>
</ul>
<p>第2-4位：表示文件的所有者对于此文件的访问权限，第2位表示读权限的情况，取值有r、-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x、-。</p>
<p>第5-7位：表示文件所属的群组的其他用户对于此文件的访问权限，第5位表示读权限的情况，取值有r、-；第6位表示写权限的情况，w表示可写，-表示不可写，第7位表示执行权限的情况，取值有x、-。</p>
<p>第8-10位：表示除了上面的前2部分的用户之外的其他用户对于此文件的访问权限，第8位表示读权限的情况，取值有r、-；第9位表示写权限的情况，w表示可写，-表示不可写，第10位表示执行权限的情况，取值有x、-。</p>
<h4 id="第二列，表示拥有相同-inode-号的文件数"><a href="#第二列，表示拥有相同-inode-号的文件数" class="headerlink" title="第二列，表示拥有相同 inode 号的文件数"></a>第二列，表示拥有相同 inode 号的文件数</h4><h4 id="第三列，表示文件或目录的所有者"><a href="#第三列，表示文件或目录的所有者" class="headerlink" title="第三列，表示文件或目录的所有者"></a>第三列，表示文件或目录的所有者</h4><h4 id="第四列，表示文件或目录的所在的群组"><a href="#第四列，表示文件或目录的所在的群组" class="headerlink" title="第四列，表示文件或目录的所在的群组"></a>第四列，表示文件或目录的所在的群组</h4><p>最后可能会有一个点<code>.</code>是 SELinux 的安全标签</p>
<p><code>ls -a</code> ：显示所有文件和目录，包括隐藏的（以<code>.</code>开头）</p>
<p>不包括开头的两个 . 和 ..<br><code>.</code> （一个点）表示当前目录； <code>..</code> （两个点）表示上一级目录<br><code>ls -A</code> ：作用和小写的 -a 几乎一样，唯一不同就是 -A 不列出 . 和 .. 这两个文件</p>
<p><code>ls -la 路径</code> ：所以文件（夹） ，并显示隐藏文件，以.开头，<br><code>ls -i 路径</code> ：-i 参数可以显示文件的 inode）</p>
<p><code>ls --color=auto</code> 来开启颜色标注<br><code>ls --color=none</code>关闭颜色标注</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]<span class="comment"># ls -l /root</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root    0 Feb 28 23:13 authorized_keys</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar  1 00:37 dev</span><br></pre></td></tr></tbody></table></figure>
<p>上述列表中的第一列字符表示文档的类型，其中<br>“-”表示改行对应的文档类型为文件,<br>“d”表示文档类型为文件夹。<br>a. 其是文件夹类型<br>b. 文件的所有者：拥有全部权限（读写执行）<br>c. 文件所在的群组同组用户：可读、可执行<br>d. 其他用户：可读、可执行<br>e.文件链接数量3个<br>文件大小：单位是 octet， byte“字节”<br>最近一次修改的时间<br>最后一列 文件或目录的名</p>
<p><code>ls -h</code>human readable，“适合人类阅读的” 以 Ko，Mo，Go 的形式显示文件大小<br><code>ls -lh 路径</code> 列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的 时候以可读性较高的形式显示</p>
<p><code>ls -t</code>按照文件或目录最近一次修改时间的降序排列</p>
<p><code>ls -l |grep jpg | wc -l</code>一个目录里,有各种文件类型:文本文件,图片,音频,视频。如果你想知道这里面有多少个JPEG类型的图片。<br><code>ls -l |grep jpg | wc -l &gt; jpeg_num.txt</code>把统计的数目存储到一个文本文件(jpeg_nb.txt)里</p>
<p><code>ls -l |grep jpg | wc -l &gt; jpeg_num.txt | mail -s "jpeg number" ashe@gmail.com</code>先统计这个数目,保存到 jpeg nb. txt文件里,再把这个文件用emai传给一个朋友</p>
<p><code>ctrl+L</code>用于清理终端的内容,清屏。同 <code>clear</code>命令,  并不是真的清除了之前的信息,而是把之前的信息的隐藏到了最上面,通过滚动条继续查看以前的信息。<br><code>Ctrl+D</code>给终端传递EOF( End of file,文件结束符)<br><code>Shift+PgUp</code>用于向上滚屏,与鼠标的滚轮向上滚屏是一个效果<br><code>Shift + PgDn</code> 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果<br><code>ctrl+a</code> 光标移动到行首 Home 键有相同的效果<br><code>ctrl+e</code> 光标移动到行末 End 键有相同的效果<br><code>ctrl+u</code> 剪切/删除 光标到行首、除所有在光标左侧的命令字符<br><code>crtl+k</code>剪切/删除光标后的内容 光标右侧的命令字符<br><code>ctrl+w</code> 剪切/删除光标左侧的一个“单词”word,用空格隔开的一个字符串。例如 -a 就是一个“单词<br><code>ctrl+y</code> 粘贴用 Ctrl + U， Ctrl + K 或 Ctrl + W“删除”的字符串，有点像“剪切-粘贴”  </p>
<p><code>cd</code>等同于<code>cd ~</code> 等同于<code>cd /home/username</code> change directory 直接切换到家目录<br><code>cd 路径</code>要去的那个目录的路径<br><code>cd ..</code> 要回到上一级目录（父目录）<br><code>cd ../..</code> 要回到上一级目录的上一级目录（爷目录）</p>
<p><code>du</code> disk usage “磁盘使用/占用”，文件和目录所占的空间大小，深入遍历每个目录的子目录，统计所有文件的大 默认情况下只显示目录的大小<br><code>du -h</code> 目录路径  以较高可读性的形式显示 以 Ko，Mo，Go 的形式显示文件大小<br><code>du -a</code> 目录路径  显示文件和目录的大小 汇总<br><code>du -s</code> 目录路径 summary 只显示汇总大小，当前目录的总大小<br><code>du -sh</code> 目录路径 查看目录的真实大小<br><code>free -m</code>  以mb为单位查看系统内存  兆<br><code>free</code> 用于查询内存<br><code>df -h</code> 磁盘  （以human形式）<br>负载 w top</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">w top</span><br><span class="line">load average：0.00,0.01,0.05（分别表示最近1,5,15分钟的负载情况）</span><br><span class="line">1表示满负荷负载</span><br><span class="line">标准为0.6-0.7左右</span><br><span class="line"></span><br><span class="line"> 16:08:46 up  2:28,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br></pre></td></tr></tbody></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>xargs（eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。<br>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。<br>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。<br>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。<br>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：<br><code>find /sbin -perm +700 |ls -l       #这个命令是错误的 find /sbin -perm +700 |xargs ls -l   #这样才是正确的</code><br>xargs 一般是和管道一起使用。<br>命令格式：<code>somecommand |xargs -item  command</code></p>
<p>6.查看系统进程 （查看项目or应用程序的进程）</p>
<ul>
<li><code>ps -ef|grep tomcat-probe</code><br>交互式 Bash Shell 只输出进程pid的ID号，进程名字为adb。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ps -ef|grep mysql</span></span><br><span class="line">mysql     3361     1  1 21:06 ?        00:00:01 /usr/sbin/mysqld</span><br><span class="line">root      3460  3435  0 21:08 pts/0    00:00:00 grep --color=auto mysql</span><br><span class="line">[root@localhost ~]<span class="comment"># ps -ef|grep python</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pgrep -f mysql    # 仅输出进程ID号</span></span><br><span class="line">3361</span><br><span class="line">`</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">```bash</span><br><span class="line">[root@localhost ~]<span class="comment"># ps -ef|grep mysql|awk '{print $2}'</span></span><br><span class="line">3361</span><br><span class="line">3486</span><br></pre></td></tr></tbody></table></figure>
<p>获取到pid后，可以进行后续处理。比如执行删除等操作。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk <span class="string">'{print $2}'</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要查找到 pid 之后 kill 掉该进程，还可以使用 pkill：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -f name</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep mysqld</span><br></pre></td></tr></tbody></table></figure>

<p>找出占用端口的进程</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -anp|grep ":80 " |grep LISTEN</span></span><br><span class="line">tcp     0      0 0.0.0.0:80        0.0.0.0:*      LISTEN      17785/nginx: worker</span><br></pre></td></tr></tbody></table></figure>

<h3 id="替换指定的目录及其子目录下所有文件中的adc为bcd。"><a href="#替换指定的目录及其子目录下所有文件中的adc为bcd。" class="headerlink" title="替换指定的目录及其子目录下所有文件中的adc为bcd。"></a>替换指定的目录及其子目录下所有文件中的adc为bcd。</h3><p>sed [-hnV][-e<script>][-f<script文件>][文本文件]<br>（ stream editor 简写sed ）</p>
<p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！<br>-i 选项可以直接修改文件内容，举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！<br>s ：取代，可以直接进行取代的工作，通常这个 s 的动作可以搭配正规表示法！<br>例如 1,20s/old/new/g 就是啦！<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>如果是要改变两行以上，每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。</p>
<p>方法一</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># find -type f | xargs cat</span></span><br><span class="line">adc</span><br><span class="line">adc</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># find -type f | xargs sed -i &#x27;s/adc/bcd/g&#x27; </span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># find -type f | xargs cat</span></span><br><span class="line">bcd</span><br><span class="line">bcd</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># sed -i &#x27;s/adc/bcd/g&#x27; `grep &quot;adc&quot; -rl ./`</span></span><br><span class="line"><span class="comment"># 注意：grep内容是用的反引号</span></span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">替换某个文件中的内容adb为bcd（替换指定文件的字符串）。</span><br><span class="line">```bash</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># cat hello.txt </span></span><br><span class="line">i love you</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># sed -i &quot;s/i/I/g&quot; hello.txt </span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># cat hello.txt </span></span><br><span class="line">I love you</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p>
</blockquote>
<p>软链接有点类似于Windows中的快捷方式，里面保存的是指向源文件的绝对路径，当访问它的时候就会替换成指向文件的路径。对于操作系统是通过 inode值访问硬盘的区块，对于软链接来说inode值和源文件的inode值是不一样的，但是硬链接是一样的inode值。只要有文件inode值指向这个区块，这个文件就始终不会消失。软链接文件只是维持了从软链接到源文件的指向关系，不是源文件的内容。</p>
<p>硬链接相当于创建了一个普通文件，但硬链接的inode值和源文件的inode值相同都指向同一个区块。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份源文件。</p>
<p>inode介绍：文件或目录的inode编号是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象。inode就像人的身份证。</p>
<p>crontad:定时任务<br>例如：下单操作，需要在单个小时内付完款，通过定时任务每半个小时进行一下数据释放。</p>
<ol>
<li>编辑当前用户的计数器设置，与vim操作是一样的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xiaokang@localhost ~]$ crontab -e      <span class="comment"># 编辑crontab</span></span><br><span class="line">crontab: no changes made to crontab</span><br></pre></td></tr></table></figure></li>
<li>列出该用户的计数器设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xiaokang@localhost www]$ crontab -l</span><br><span class="line">*/1 * * * * php /data/www/cron.php  &gt;&gt; /tmp/cron.log   <span class="comment"># */1表示每隔1分钟执行一次</span></span><br><span class="line"><span class="comment"># * * * * * 分别代表分 时 日 月 周</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><code>nslookup domain[dns-server]</code> 查看域名解析是否正常，在网络故障的时候用来诊断网络问题。<br>可以指定查询的类型，可以查到DNS记录的生存时间还可以指定使用那个DNS服务器进行解释。</p>
<p>如何用本地计算机查询DNS记录?</p>
<p>打开命令提示符窗口(开始–运行—输入CMD–回车)</p>
<p><code>nslookup –qt=类型 目标域名</code>(注意qt必须小写)</p>
<p>类型主要有:</p>
<p>A 地址记录(Ipv4)</p>
<p>AAAA 地址记录（Ipv6）</p>
<p>CNAME 别名记录</p>
<p>HINFO 硬件配置记录，包括CPU、操作系统信息</p>
<p>ISDN 域名对应的ISDN号码</p>
<p>MB 存放指定邮箱的服务器</p>
<p>MG 邮件组记录</p>
<p>MINFO 邮件组和邮箱的信息记录</p>
<p>MR 改名的邮箱记录</p>
<p>MX 邮件服务器记录</p>
<p>NS 名字服务器记录</p>
<p>PTR 反向记录</p>
<p>RP 负责人记录</p>
<p>SRV TCP服务器信息记录</p>
<p>TXT 域名对应的文本信息</p>
<p>比如你要查询tool.chinaz.com的A记录,那在命令符提示窗口输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt=a tool.chinaz.com</span><br></pre></td></tr></table></figure>
<p>则可以查到相应的记录</p>
<h2 id="如何使用指定DNS服务器查询"><a href="#如何使用指定DNS服务器查询" class="headerlink" title="如何使用指定DNS服务器查询?"></a>如何使用指定DNS服务器查询?</h2><p>语法为<br><code>nslookup -qt=类型 目标域名 指定的DNS服务器IP或域名</code></p>
<p>例子：<br><code>nslookup -qt=A tool.chinaz.com 8.8.8.8</code></p>
<p>返回信息说明<br>服务器：本机DNS服务器信息</p>
<p>非权威应答：Non-authoritative answer，除非实际存储DNS Server中获得域名解析回答的，都称为非权威应答。也就是从缓存中获取域名解析结果。</p>
<p>address：目标域名对应物理IP可有多个</p>
<p>aliase：目标域名<br>nslookup google.com 和 nslookup google.com 8.8.8.8</p>
<ul>
<li><p>grep，egrep 用于查询</p>
</li>
<li><p>awk，sed 用于文本操作</p>
</li>
<li><p>netstat 用于查询当前服务启动网络状态</p>
</li>
<li><p>du 用于查询文件占用大小</p>
</li>
<li><p>ps 用于查询进程状态</p>
</li>
<li><p>top 用于查询内存占用情况及进程</p>
</li>
<li><p>crontab 用于定时任务需求<br>crontab -l：list，列出指定用户的计划任务列表<br>crontab -e：edit，编辑指定用户的计划任务列表<br>以行为单位，一行则为一个计划：<br>分 时 日 月 周 需要执行的命令<br>例如：如果想要每天的0点0分执行reboot指令，则可以写成<br>0 0 * * * reboot</p>
<p>取值范围：整数<br>分：0<del>59<br>时：0</del>23<br>日：1<del>31<br>月：1</del>12<br>周：0~7，0和7表示星期天</p>
</li>
</ul>
<p>四个符号：<br><em>：表示取值范围中的每一个数字<br>-：做连续区间表达式的，要想表示1~7，则可以写成：1-7<br>/：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：</em>/10<br>,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6</p>
<p>问题1：每月1、10、22日的4:45重启network服务<br>45  4  1,10,22  *  *  service network restart</p>
<p>问题2：每周六、周日的1:10重启network服务<br>10  1  *  *  6,0   service network restart</p>
<p>问题3：每天18:00至23:00之间每隔30分钟重启network服务<br>*/30  18-23  *  *  *   service network restart</p>
<p>问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启<br>3,15  8-11  */2  *  *   reboot</p>
<p>案例：真实测试案例，每1分钟往root家目录中的RT.txt中输入当前的时间信息，为了看到效果使用追加输出<br>计划任务：*/1  *   *   *   *  ls ~&gt;&gt; /root/RT.txt</p>
<p>Crontab权限问题：本身是任何用户都可以创建自己的计划任务。</p>
<p>但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 ：<br>配置文件位于（黑名单）：<br>vim /etc/cron.deny            里面写用户名，一行一个<br>第一行yw<br>:x</p>
<p>还有一个配置文件：（白名单）<br>    /etc/cron.allow        （本身不存在，自己创建）</p>
<p>注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。</p>
<ul>
<li>gdb的基本使用 用于程序出问题，需要调整时</li>
</ul>
<p>2.查看当前系统用户数</p>
<p>who</p>
<p>统计显示 7个用户</p>
<p>3.查看当前系统版本及系统位数</p>
<p>uname -a</p>
<p>4.查看当前系统引用的JDK 是否是自己安装的配置的jdk</p>
<p>which java</p>
<p>5.查看系统端口是否被占用</p>
<p>netstat -pan|grep 8017</p>
<p>使用 netstat + grep 来查看某个端口是否在使用</p>
<p>7.查看防火墙状态及启动防火墙</p>
<p>service iptables status</p>
<p>启动的话： service iptables start</p>
<p>10.网络配置（相关命令）</p>
<p>命令：ifconfig</p>
<p>11.系统资源查看</p>
<p>命令： vmstat</p>
<p>命令 ：top</p>
<p>命令： uptime</p>
<p>12:目录命令操作<br><code>mkdir 路径``和``rmdir 路径</code>创建/删除空文件夹目录 名称或包含名称的只有一个完整路径<br><code>mkdir -p one/two/three</code> 一次性递归创建多层不存在的目录结构 批量新增目录<br>要创建的目录名有空格，加上双引号<code>touch &quot;new folder&quot;</code></p>
<p><code>cp 被复制的路径 复制到的路径（名字）可对新位置重命名</code> 复制文件或者文件夹目录 （可用于项目包的备份处理）</p>
<p><code>cp new_file one/new_file_copy</code>如果你想拷贝文件到其他目录的同时，重新命名，不要具有相同名字</p>
<p><code>man cp</code></p>
<ul>
<li><p><code>cp [OPTION]... [-T] SOURCE DEST</code> 拷贝源文件到目标文件，除了 cp 原封不动输入，还必须输入 SOURCE 和 DEST这两部分内容，分别用实际的源文件名和目标文件名代替，也可以加上一个或多个选项参数（替换 OPTION），还可以加上 -T </p>
<ul>
<li><code>cp new_file new_file_copy</code>当前目录下拷贝之前创建的 new_file 文件，第二个文件 new_file_copy 是需要创建的文件，是 new_file 的副本</li>
</ul>
</li>
<li><p><code>cp [OPTION]... SOURCE... DIRECTORY</code><br>拷贝一个或多个源文件到一个目录，除了 cp 原封不动输入，还必须输入 SOURCE 和 DIRECTORY两部分，分别用实际的源文件名和目录名代替，可以加上一个或多个选项参数（替换 OPTION）</p>
<ul>
<li><code>cp new_file one/</code> 把文件拷贝到其他文件夹目录，不加反斜杠也可以，具有相同名字</li>
</ul>
</li>
<li><p><code>cp [OPTION]... -t DIRECTORY SOURCE...</code><br>拷贝一个或多个源文件到目录，与第二种方法其实效果是一样的，只不过这里把目录名放在了前面<br>后接需要拷贝到目录的文件名（一个或多个），这里的 -t 参数是必须加的，加上一个或多个选项参数（替换 OPTION）</p>
</li>
</ul>
<p><code>cp -r 被复制的路径 复制到的路径名</code>，递归复制非空文件夹目录中的所有内容（子目录和文件），套娃，r 大写和小写作用是一样的，都表示 recursive，也就是“递归的“<br><code>cp -r one one_copy</code>当前目录下拷贝之前创建的 one 目录，拷贝之前创建的 one 目录，第二个目录 one_copy 是需要创建的文件，是 one 的副本<br><code>cp -rf 123.tar …/backup/123.tar.20181122</code></p>
<p><code>cp *.txt folder</code> ：把当前目录下所有 txt 文件拷贝到 folder 目录中<br><code>cp ha* folder</code>：把当前目录以 ha 开头的文件都拷贝到folder目录中</p>
<p>移动到的路径存在则移动，不存在则在重命名<br><code>mv -f 被移动的路径 移动到的路径</code> 移动/剪切/重命名文件或非空文件夹目录<br><code>mv *.txt one</code>：将当前目录下所有 txt 文件移动到 one 目录</p>
<p><code>rm 路径a 路径b</code> 同时删除多个文件，只要用空格隔开每个文件 rm remove 删除<br><code>rm -f 路径</code> 文件会立刻被强制删除  终端不会询问用户是否确定删除文件 f force强制<br><code>rm -f /tmp/A*</code> 删除/tmp下所有A开头的文件<br><code>r</code> recursive “递归的”<br><code>rm -rf 路径a 路径b</code> 同时删除多个删除文件夹目录，且递归删除其包含的子目录和文<br><code>rm -rf /tmp/*</code> 删除/tmp下所有文件，加上*保留/tmp<br><code>rm -f 00*</code>  删除有相同字母开头的文件 001 002<br><code>rm -i</code>对于每一个要删除的文件，终端都会询问用户是否确定删除 inform y&amp;n</p>
<p>先删除文件，才能删除目录<br>在终端中没有回收站或垃圾箱，恢复挺麻烦</p>
<p><code>*</code>通配符，表示任意的字符，通通都能匹配的符号</p>
<p>13:文件操作<br><code>cat 文件路径1 文件路径2</code> 一次性显示文件的所有内容<br>cat -n 文件路径 一次性显示文件内容和行号<br>cat 待合并的路径1 待合并的路径2 … &gt; 合并之后的路径<br>cat /proc/meminfo | grep MemTotal 查看内存总数<br>concatenate 的缩写，表示“连接/串联”</p>
<ul>
<li><code>more</code> 命令和 less 命令功能类似，more 没有 less 那么强大 不能往后翻页，只能往前，=</li>
</ul>
<p><code>less 文件路径</code> 分页输出显示文件内容<br>快捷键 按下辅助功能键查看功能（数字、回车、空格）,<br>大小写是需要区分的</p>
<ul>
<li>空格键：文件内容读取下一个终端屏幕的行数，相当于前进一个屏幕（页）。与键盘上的 PageDown（下一页）效果一样</li>
<li>回车键：文件内容读取下一行，也就是前进一行，与键盘上的向下键效果是一样的</li>
<li>d 键：前进半页（半个屏幕）</li>
<li>b 键：后退一页。与键盘上的 PageUp（上一页）效果一样</li>
<li>y 键：后退一行。与键盘上的向上键效果是一样的</li>
<li>u 键：后退半页（半个屏幕）</li>
<li>q 键：停止读取文件，中止 less 命令</li>
<li>= 号：<ul>
<li>显示你在文件中的什么位置，</li>
<li>当前页面的内容是文件中第几行到第几行，整个文件所含行数</li>
<li>所含字符数，整个文件所含字符<br><code>yum.log-20210101 lines 1-3/3 byte 104/104 (END)  (press RETURN)</code></li>
</ul>
</li>
<li>h 键：显示帮助文档。按 q 键退出帮助文档</li>
<li>/（斜杠）：进入搜索模式，在斜杠后面输入你要搜索的文字，按下回车键，把所有符合的结果都标识出来，要在搜索所得结果中跳转，可以按 n 键（跳到下一个符合项目），按 N 键（shift 键 + n。跳到上一个符合项目）。正则表达式（Regular Expression）也是可以用在搜索内容中</li>
</ul>
<p><code>head 文件路径</code> 查看一个文件的前n行，如果不指定n，则默认显示前10行<br><code>head -n 2 文件路径</code>等价于<code>head -2 文件路径</code> 查看一个文件的前n行，如果不指定n，则默认显示前10行<br>`shell </p>
<ol>
<li>[root@localhost ~]# head test1 # 查看文件头几行内容</li>
<li>hello1 world</li>
<li>hello2 world</li>
<li>hello3 world</li>
<li>hello4 world</li>
<li>[root@localhost ~]# head -1 test1 # 查看test1文件头1行内容</li>
<li>hello1 world</li>
<li>[root@localhost ~]# head -2 test1 # 查看test1文件头2行内容</li>
<li>hello2 world<br>`</li>
</ol>
<p>查看随时间一直在改变的文件，例如日志（log）文件特别有用<br><code>tail 文件路径</code> 查看一个文件的后n行，如果不指定n，则默认显示后10行<br>tail -n 文件路径 查看一个文件的后n行，如果不指定n，则默认显示后10行  </p>
<p>tail -f 文件路径 查看一个文件的动态变化，实时追踪文件的更新，<br>会检查文件是否有追加内容。如果有，就显示新增内容<br>Ctrl + c 来终止 tail -f 命令<br><code>tail -f -s 4 filepath</code>指定间隔检查的秒数，默认每过 1 秒检查一下文件是否有新内容</p>
<ul>
<li><code>[root@localhost ~]# wc test1</code></li>
</ul>
<ol start="14">
<li>4 8 52 test1 #统计文件内容信息的 行数4，字数8，字节数52<br>参数说明：<code>-l</code> 只显示行数，<code>-w</code>只显示字数，<code>-c</code>只显示Bytes数。<br><code>wc -l test1</code> # 统计文件test1的行数</li>
</ol>
<ul>
<li><code>touch 路径1  路径2</code> 创建一个或多个空白文件，<br>如果文件已存在，可以修改文件的创建时间或修改时间，<br>让电脑以为文件是在那个时候被修改或创建的<br>说我碰一下那个文件，让电脑以为我刚修改过<br>如果 touch 命令后面跟着的文件名是不存在的文件，它会新建一个<br>要创建的文件名有空格，加上双引号<code>touch &quot;new file&quot;</code></li>
</ul>
<p>13:修改文件或者目录权限<br>chmod chown chgrp 命令的使用</p>
<p>文件查找命令<br>locate命令 定位要查找包含关键字的所有文件和目录路径，查找速度极快，后接需要查找的文件名，也可以用正则表达式</p>
<p><code>locate file</code> 会查找并列出file（目录或文件名包含file）所在的所有目录路径<br><code>locate function</code><br><code>locate stats.properties</code><br>缺陷：如果是刚新建的文件locate是查不到的，因为locate不是查找硬盘，是在文件的数据库（包含文件的列表和文件的位置）中查找记录。对于刚创建的文件，没有更新进数据库（Linux 系统一般24小时自动更新一次文件数据库），因此 locate 命令就找不到其索引，自然就不会返回任何结果，只要你隔 24 小时再用 locate 查找，应该就能找到你刚创建的文件了。<br>用<code>updatedb</code>命令只能由 root 用户强制系统立即更新数据库 <code>sudo updatedb</code></p>
<p>find命令 深入查找，从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件。其常用来搜索匹配条件的文件。</p>
<p>遍历实际的硬盘的文件，与 locate 命令在文件数据库中查找文件的记录不同<br>查找文件要完全对应关键字，可以用正则匹配 功能强大</p>
<p>用文件名、创建时间等查找；最后可以对找到的文件进行操作<br><code>find 路径范围 选项 选项的值</code><br><code>find 《何处》《何物》《做什么》</code>这几个参数中，只有《何物》是必须指定的，也就是要查找什么</p>
<ul>
<li>何处：指定目录中查找，此目录的所有子目录也会被查找，只会查找完全符合《何物》的字符串表示的文件，与 locate 命令的查找所有包含关键字的文件数据库的所有记录不同<br>find 命令可以限定查找目录。比如可以只让 find 查找 /home 目录<br>默认没有给出《何处》这个参数会在当前目录及其子目录中查找</li>
<li>何物：要查找什么，只会查找完全符合《何物》的字符串表示的文件，与 locate 命令的查找所有包含关键字的文件不同。可以根据文件的名字、其大小、其最近访问时间来查找。这个参数是必须的</li>
<li>做什么：用 find 命令找到我们要的文件后，可以对每个文件做一定的操作，称为“后续处理”，默认不指定这个参数只会显示找到的文件</li>
</ul>
<h4 id="根据名字查找当前目录的文件"><a href="#根据名字查找当前目录的文件" class="headerlink" title="根据名字查找当前目录的文件"></a>根据名字查找当前目录的文件</h4><p><code>find -name &#39;new_file&#39;</code>  按照文档名称搜索，<code>-name</code> 参数指定了文件名字<code>new_file</code>用双引号括起来。不加双引号或者用单引号也是可以的，名字有空格一定要加双引号或者单引号，如果 find 命令没有结果显示，那么表示此文件不存在，</p>
<p>查找其他目录的文件，须要指定《何处》这个参数了<br><code>find /var/log -name &#39;syslog&#39;</code> 在 /var/log 目录下查找名为syslog的文件，没有权限访问的目录，会显示“Permission denied”，</p>
<p><code>find thing</code> 找到名字就是 thing 的文件，不会查找到 thing2 这样的文件<br><code>locate thing</code>会查找到比如 thing，thing1，onething 这样的文件</p>
<p><code>*</code>（星号通配符）来实现匹配多个名称，* 号是匹配0个或多个任意字符</p>
<h4 id="根据文件的最近访问时间查找"><a href="#根据文件的最近访问时间查找" class="headerlink" title="根据文件的最近访问时间查找"></a>根据文件的最近访问时间查找</h4><ul>
<li><code>-atime</code> access  time  减号表示小于</li>
<li><code>find -name &#39;syslog*&#39; -atime -7</code>查找7天内访问的所有以 syslog 这个关键字开头文件，<code>-7</code> 表示 7 天之内</li>
<li><code>find -name &#39;*syslog&#39; -atime -7</code>查找7天内访问的所有以 syslog 这个关键字结尾文件</li>
<li><code>*syslog*</code> 查找包含 syslog 这个关键字的文件 </li>
<li><code>find / -name &quot;syslog&quot;</code> 在整个硬盘里查找 </li>
</ul>
<h4 id="根据文件大小查找"><a href="#根据文件大小查找" class="headerlink" title="根据文件大小查找"></a>根据文件大小查找</h4><ul>
<li><code>-size</code> 参数，来指定查找文件的大小 加号查找大于指定大小的文件，减号查找小于指定大小的文件，如果没有加减号，则查找大小等于指定数值的文件</li>
<li><code>find /var -size +10M</code> 查找/var目录下大于 10 兆字节的文件</li>
<li><code>find /var -size +20Go</code> 查找大于 20Go 的文件</li>
<li><code>find /var -size -50k</code>  查找小于 50Ko 的文件</li>
</ul>
<h4 id="仅查找目录或文件"><a href="#仅查找目录或文件" class="headerlink" title="仅查找目录或文件"></a>仅查找目录或文件</h4><p>不用 <code>-type</code> 参数指定类型默认是查找目录和文件<br>find -type 按照文档的类型搜索</p>
<ul>
<li><code>-type f</code>：只查找文件类型</li>
<li><code>-type d</code>：只查找文件夹目录类型</li>
<li><code>find -name &#39;directory1&#39; -type d</code>查找名为directory1的目录</li>
<li><code>find -name &#39;file1&#39; -type f</code>查找名为file1的目文件</li>
</ul>
<p>文档类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@192 tmp]<span class="comment"># find .    （点表示当前目录，列出当前文件下所有文件）</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find /etc/ -name &quot;*.conf&quot;   （星号表示所有字符，列出etc目录下以点conf结尾文件）</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find . -type f   （type表示类型，f表示文件，列出当前目录所有文件）</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find . -type d  （type表示类型，d表示文件夹，列出当前目录所有文件夹）</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find . -ctime -1 （ctime表示当前时间，-1表示减一天，列出一天内修改过的文件）</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find /etc -name *.conf |wc -l</span></span><br><span class="line">[root@192 tmp]<span class="comment"># find /etc/sane.d/ -type f |wc -l 搜索/etc/sane.d/目录下所有的文件有多少个</span></span><br><span class="line"><span class="comment"># Ctrl+c  退出查看</span></span><br></pre></td></tr></table></figure>


<p>通过关键字 来查找包含关键字的文件<br><code>find ./ -type f|xargs grep “T2001774”</code><br><code>find . -name \* -type f -print |xargs grep ‘关键字’</code></p>
<p>查找文件并询问是否删除<br><code>find ./ -name ‘IceGpsAndGprsAnalyze*’ -exec rm -i &#123;&#125; ;</code></p>
<h3 id="操作查找结果-《做什么》"><a href="#操作查找结果-《做什么》" class="headerlink" title="操作查找结果 《做什么》"></a>操作查找结果 《做什么》</h3><ul>
<li><code>find -name &quot;*.jpg&quot;</code> 等价于 <code>find -name &quot;*.jpg&quot; -print</code><h4 id="格式化打印查找结果"><a href="#格式化打印查找结果" class="headerlink" title="格式化打印查找结果"></a>格式化打印查找结果</h4></li>
<li><code>-printf</code> 格式化的方式打印输出 print formatted</li>
<li><code>find -name &#39;*.txt&#39; -printf &#39;%p - %u\n&#39;</code>将查找到的文件格式化输出为<code>文件名 - 用户名</code>的形式，<code>%p</code>：文件名，<code>-</code>：就是一个短横， <code>%u</code>：文件的所有者的用户名，<code>\n</code>：用于换行</li>
</ul>
<h4 id="删除操作：xxx-delete"><a href="#删除操作：xxx-delete" class="headerlink" title="删除操作：xxx -delete"></a>删除操作：<code>xxx -delete</code></h4><ul>
<li><code>find -name &quot;*.jpg&quot; -delete</code> 删除当前目录及其子目录下所有以 .jpg 为后缀的文件，不会有确认提示</li>
</ul>
<h4 id="调用其他命令："><a href="#调用其他命令：" class="headerlink" title="调用其他命令："></a>调用其他命令：</h4><p>加上<code>-exec</code>参数之后就可以接其他命令了，对每个查找到的文件进行操作</p>
<ul>
<li><code>find one -name &quot;*.txt&quot; -exec chmod 600 &#123;&#125; \;</code> 将 one 目录下所有查找到的txt文件的访问权限都改为 600，不必用双引号括起来，<code>&#123;&#125;</code> 会用查找到的每个文件来替换，<code>\;</code> 是必须的结尾固定写法</li>
</ul>
<p>将 <code>-exec</code> 参数换成 <code>-ok</code> 参数，用法一样，<code>-ok</code> 参数会对每一个查找到的文件都做确认提示</p>
<p>命令： grep<br>| 竖线 管道符<br>过滤,grep 在文本文件中查找某个字符串，特殊，扩展<br>以管道为分界线，前面的命令有个输出，过滤，输出<br>管道前面的输出就是后面指令的输入<br><code>ls /| grep y</code> 通过管道查询出根目录下包含“y”字母的文档名称</p>
<p>grep 与 find 区别<br>grep：grep命令是一种文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。其常用来查找匹配条件的行。</p>
<ul>
<li><code>grep ‘T2001774’ ./*</code></li>
<li><code>grep -n（显示第几行） &quot;12&quot;（搜索关键字） imooc（指定的文件）</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/var目录下的所有txt文件修改权限为600</span></span><br><span class="line">find /var -name <span class="string">&#x27;*.txt&#x27;</span> -<span class="built_in">exec</span> chmod 600 &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>大括号表示刚查找到的文件，;是exec的结尾</p>
<p>将-exec参数换成-ok参数效果一样，但是会对每个文件都做确认提示！</p>
<p>15：查看环境变量</p>
<p>命令： env</p>
<p>还有 set 命令也可以</p>
<p>20：文件压缩和解压</p>
<ul>
<li><p><code>-z</code> 指定.gz格式</p>
</li>
<li><p><code>-t</code> 查看 </p>
</li>
<li><p><code>-v</code>显示详细信息</p>
</li>
<li><p><code>tar -cf imooc.tar imooc</code></p>
</li>
<li><p><code>tar -tvf imooc.tar</code> # 查看压缩文件中的内容</p>
</li>
<li><p><code>tar -cvf jpg.tar *.jpg</code> //将目录里所有jpg文件打包成tar.jpg</p>
</li>
<li><p><code>tar -czf jpg.tar.gz *.jpg</code> //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux<br>zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</p>
</li>
</ul>
<h1 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h1><ul>
<li><code>tar -xf imooc.tar</code></li>
<li><code>tar -xvf file.tar</code> //解压 tar包</li>
<li><code>tar -xzvf file.tar.gz</code> //解压tar.gz</li>
<li><code>tar -xjvf file.tar.bz2</code> //解压 tar.bz2</li>
<li><code>tar -xZvf file.tar.Z</code> //解压tar.Z</li>
<li><code>unrar e file.rar</code> //解压rar</li>
<li><code>unzip file.zip</code> //解压zip</li>
</ul>
<p>总结<br>1、<code>*.tar</code> 用 <code>tar -xvf</code> 解压<br>2、<code>*.gz</code> 用 <code>gzip -d</code>或者<code>gunzip</code> 解压<br>3、<code>.tar.gz</code>和<code>.tgz</code> 用 <code>tar -xzf</code> 解压<br>4、*.bz2 用 bzip2 -d或者用bunzip2 解压<br>5、*.tar.bz2用tar -xjf 解压<br>6、*.Z 用 uncompress 解压<br>7、*.tar.Z 用tar -xZf 解压<br>8、*.rar 用 unrar e解压<br>9、*.zip 用 unzip 解压</p>
<p>如果修改网卡的配置文件，目录层次很深，此时在浅的目录中创建一个快捷方式（软连接），方便查找<br><code>ln -s 原始文件的路径 快捷方式的路径 </code>link 文件之间创建链接、快捷方式<br>Linux 下有两种链接类型：</p>
<ul>
<li>Physical link：物理链接或硬链接</li>
<li>Symbolic link：符号链接或软连接</li>
</ul>
<p>文件在硬盘上存储时<br>每个文件三两部分：文件名，权限 和 文件内容</p>
<ul>
<li>文件名的列表是储存在硬盘的其他地方的</li>
<li>和文件内容分开存放，这样方便 Linux 管理</li>
<li>每个文件的文件内容被分配到一个标示号码，就是 inode</li>
<li>因此每个文件名都绑定到它的文件内容（用 inode ）</li>
</ul>
<p>创建硬链接</p>
<ul>
<li><p>硬链接原理：</p>
<ul>
<li>使链接的两个文件共享同样文件内容，就是同样的inode</li>
<li>一旦文件 1 和文件 2 之间有了硬链接</li>
<li>那么你修改文件1或文件2，修改的是相同的一块内容</li>
<li>只不过我们可以用两个文件名来取到文件内容</li>
</ul>
</li>
<li><p>硬链接缺陷：</p>
<ul>
<li><p>只能创建指向文件的硬链接，不能创建指向目录的</p>
</li>
<li><p>通过一些参数的修改，也可以创建指向目录的硬链接，但比较复杂</p>
</li>
<li><p><code>ln file1 file2</code>不加任何参数创建一个文件 file2，使之成为 file1 的硬链接</p>
</li>
</ul>
</li>
<li><p>file2 是新生成的硬链接，它指向 file1 的文件内容</p>
</li>
<li><p>就是说它们共享相同的文件内容，也就是拥有同一个 inode</p>
</li>
<li><p><code>ls -i</code> file1 和 file2 的 inode 是一样的</p>
</li>
<li><p>如果我们用 <code>rm file2</code> 来删除 file2，那么对 file1 没什么影响</p>
</li>
<li><p>如果我们用 rm file1 来删除 file1，对 file2 也没什么影响</p>
</li>
<li><p>对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上被删除</p>
</li>
<li><p>只有既删除 file1 又删除 file2，它们共同指向的文件内容才会消失，也就是那个 inode 才会被删去</p>
</li>
</ul>
<ul>
<li>软链接<ul>
<li>可以指向文件或目录，才真正像我们在 Windows 下的快捷方式，原理很相似，硬链接不行，<br>创建软链接需要加上 -s 参数 s 是 symbolic（符号的）的<br><code>ln -s file1 file3</code>：创建了 file1 的软链接 file<br>file3 指向的不再是 file1 的文件内容，而是指向 file1 的文件名（和硬链接不同）<br><code>ls -l</code>的结果： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# ln file1 file2</span><br><span class="line">[root@VM-0-9-centos ~]# ln -s file1 file3</span><br><span class="line">[root@VM-0-9-centos ~]# ll</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 2 root root    0 Apr 20 11:21 file1</span><br><span class="line">-rw-r--r-- 2 root root    0 Apr 20 11:21 file2</span><br><span class="line">lrwxrwxrwx 1 root root    5 Apr 20 11:23 file3 -&gt; file1</span><br><span class="line">[root@VM-0-9-centos ~]# ls -i</span><br><span class="line"> 396763 file1   396763 file2   396764 file3  1310999 test1</span><br></pre></td></tr></table></figure>
<code>file3-&gt;file1</code>，表示 file3 指向 file1<br>file3 前面的权限那里的第一个字母变成了 <code>l</code>，表示 link（链接）<br>之前硬链接的时候是没有 l 的，硬链接看起来就和普通文件类似<br>第二列的那个 1 表示拥有相同 inode 号的文件数，因为 file3 指向 file1，它们并没有指向同一块文件内容，所以它们的 inode 号不相同</li>
</ul>
</li>
<li>其实 file3 这个软链接只是 file1 的一个快捷方式<br>它指向的是 file1，所以显示的是 file1 的内容</li>
<li>file3 的 inode 和 file1 不一样，也就是文件内容不一样<br>软链接的特点</li>
<li>如果我们删除 file3，没什么大不了，file1 不会受到影响</li>
<li>如果删除 file1，file3 会变成“死链接”，因为指向的文件不见了</li>
</ul>
<p>1.添加路径到环境变量<br>CentOS下添加路径到环境变量根据权限等设置有不同的情况，一般分为以下三种：<br>（1）对当前会话生效<br>直接执行export PATH=$PATH:/usr/local/python3/bin会将路径添加到环境变量中，只不过只会对当前会话生效，当登出或注销系统时，添加的PATH就会失效，恢复为原来的配置。<br>（2）对当前用户生效<br>此时需要编辑~/.bash_profile，先执行vim ~/.bash_profile编辑文件，在文末添加export PATH=$PATH:/usr/local/python3/bin，保存退出后执行source ~/.bash_profile来使环境变量生效，这个操作对当前用户生效。<br>（3）对所有用户生效<br>此时需要编辑/etc/profile，先执行vim /etc/profile编辑文件，在文末添加export PATH=$PATH:/usr/local/python3/bin，保存退出后执行source /etc/profile来使环境变量生效，这个操作对所有用户都生效。</p>
<p>后面两种方式都可以通过<code>echo $PATH</code>来查看是否修改成功。</p>
<p>ln -s /usr/local/python3/bin/python3 /usr/bin/python</p>
</script></p><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/19/datagrip-dao-chu-dao-ru-shu-ju/" rel="prev" title="DataGrip导出导入数据">
                  <i class="fa fa-chevron-left"></i> DataGrip导出导入数据
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/20/nei-cun/" rel="next" title="内存">
                  内存 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
