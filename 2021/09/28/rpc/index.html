<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="RPC（Remote Procedure Call）远程过程调用 通俗地说就是调用远处的一个函数。远处到底有多远呢？可能是同一个文件内的不同函数，也可能是同一个机器的另一个进程的函数，还可能是远在火星好奇号上面的某个秘密方法。因为RPC涉及的函数可能非常之远，远到它们之间说着完全不同的语言，语言就成了两边的沟通障碍。而Protobuf因为支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/09/28/rpc/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="RPC（Remote Procedure Call）远程过程调用 通俗地说就是调用远处的一个函数。远处到底有多远呢？可能是同一个文件内的不同函数，也可能是同一个机器的另一个进程的函数，还可能是远在火星好奇号上面的某个秘密方法。因为RPC涉及的函数可能非常之远，远到它们之间说着完全不同的语言，语言就成了两边的沟通障碍。而Protobuf因为支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-27T16:21:41.000Z">
<meta property="article:modified_time" content="2021-09-29T04:34:09.304Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/09/28/rpc/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/09/28/rpc/","path":"2021/09/28/rpc/","title":"RPC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RPC | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81rpc%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%AD%A6http%E5%8D%8F%E8%AE%AE%E5%92%8Crestful%E5%8D%8F%E8%AE%AE%E5%90%97%EF%BC%9F"><span class="nav-text">为什么一定要rpc，不能只学http协议和restful协议吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87httpserver%E5%AE%9E%E7%8E%B0"><span class="nav-text">通过httpserver实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Exml%E7%9A%84rpc%E8%B0%83%E7%94%A8"><span class="nav-text">基于xml的rpc调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#json%E5%AE%9E%E7%8E%B0rpc%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">json实现rpc的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zerorpc%E5%AE%9E%E7%8E%B0rpc%E8%B0%83%E7%94%A8"><span class="nav-text">zerorpc实现rpc调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E8%B0%83%E7%94%A8"><span class="nav-text">一元调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94"><span class="nav-text">流式响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-text">传入多个参数</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">359</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/09/28/rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RPC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 16:21:41" itemprop="dateCreated datePublished" datetime="2021-09-27T16:21:41Z">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-29 04:34:09" itemprop="dateModified" datetime="2021-09-29T04:34:09Z">2021-09-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>RPC（Remote Procedure Call）远程过程调用</p>
<p>通俗地说就是调用远处的一个函数。远处到底有多远呢？可能是同一个文件内的不同函数，也可能是同一个机器的另一个进程的函数，还可能是远在火星好奇号上面的某个秘密方法。因为RPC涉及的函数可能非常之远，远到它们之间说着完全不同的语言，语言就成了两边的沟通障碍。而Protobuf因为支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身特性也非常方便描述服务的接口（也就是方法列表），因此非常适合作为RPC世界的接口交流语言。本章将讨论RPC的基本用法，如何针对不同场景设计自己的RPC服务，以及围绕Protobuf构造的更为庞大的RPC生态。</p>
<p>简单的理解是一个节点请求另一个节点提供的服务<br>对应rpc的是本地过程调用，函数调用是最常见的本地过程调用<br>将本地过程调用变成远程过程调用会面临各种问题</p>
<p>远程过程调用带来的新问题<br>在远程调用时，我们需要执行原本的本地函数体是在远程的服务器机器上去运行，也就是说，add是在另一个进程中执行的。这就带来了几个新问题：</p>
<ol>
<li>Call ID映射。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li>
<li>序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li>
<li>网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</li>
</ol>
<p>解决了上面三个机制，就能实现RPC了，具体过程如下：<br>client端解决的问题：</p>
<ol>
<li>将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</li>
<li>将Call ID，a和b序列化。可以直接将它们的值以二进制形式打包</li>
<li>把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</li>
<li>等待服务器返回结果</li>
<li>如果服务器调用成功，那么就将结果反序列化，并赋给total<br>server端解决的问题</li>
<li>在本地维护一个Call ID到函数指针的映射call_id_map，可以用dict完成</li>
<li>等待请求，包括多线程的并发处理能力</li>
<li>得到一个请求后，将其数据包反序列化，得到Call ID</li>
<li>通过在call_id_map中查找，得到相应的函数指针</li>
<li>将a和rb反序列化后，在本地调用add函数，得到结果</li>
<li>将结果序列化后通过网络返回给Client<br>在上面的整个流程中，估计有部分同学看到了熟悉的计算机网络的流程和web服务器的定义。<br>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。</li>
</ol>
<p>其中：<br>● Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。<br>● 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。<br>● 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</p>
<p>实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。</p>
<p>最后提一个问题： 如何将远程的这些过程写出本地函数调用的感觉来</p>
<p>RPC 和 REST 区别是什么？<br>你一定会觉得这个问题很奇怪，是的，包括我，但是你在网络上一搜，会发现类似对比的文章比比皆是，我在想可能很多初学者由于基础不牢固，才会将不相干的二者拿出来对比吧。既然是这样，那为了让你更加了解陌生的RPC，就从你熟悉得不能再熟悉的 REST 入手吧。</p>
<p>REST，是Representational State Transfer 的简写，中文描述表述性状态传递（是指某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式(XML、JSON)等信息。）</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>而RPC 呢，是 Remote Procedure Call Protocol 的简写，中文描述是远程过程调用，它可以实现客户端像调用本地服务(方法)一样调用服务器的服务(方法)。</p>
<p>而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的，按理说它和REST不是一个层面意义上的东西，不应该放在一起讨论，但是谁让REST这么流行呢，它是目前最流行的一套互联网应用程序的API设计标准，某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<p>2、使用方式不同<br>从使用上来看，HTTP 接口只关注服务提供方，对于客户端怎么调用并不关心。接口只要保证有客户端调用时，返回对应的数据就行了。而RPC则要求客户端接口保持和服务端的一致。</p>
<p>REST 是服务端把方法写好，客户端并不知道具体方法。客户端只想获取资源，所以发起HTTP请求，而服务端接收到请求后根据URI经过一系列的路由才定位到方法上面去RPC是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。</p>
<p>3、面向对象不同<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ，REST：所谓的 Representational state transfer ，是面向资源的，除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的，这个接触不多，就不多说了。</p>
<p>4、序列化协议不同<br>接口调用通常包含两个部分，序列化和通信协议。</p>
<p>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。</p>
<p>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>通过以上几点，我们知道了 REST 和 RPC 之间有很明显的差异。</p>
<p>然后第二个问题：为什么要采用RPC呢？</p>
<p>那到底为何要使用 RPC，单纯的依靠RESTful API不可以吗？为什么要搞这么多复杂的协议，渣渣表示真的学不过来了。</p>
<p>关于这一点，以下几点仅是我的个人猜想，仅供交流哈：</p>
<p>RPC 和 REST 两者的定位不同，REST 面向资源，更注重接口的规范，因为要保证通用性更强，所以对外最好通过 REST。而 RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景。RESTful API客户端与服务端之间采用的是同步机制，当发送HTTP请求时，客户端需要等待服务端的响应。当然对于这一点是可以通过一些技术来实现异步的机制的。采用RESTful API，客户端与服务端之间虽然可以独立开发，但还是存在耦合。比如，客户端在发送请求的时，必须知道服务器的地址，且必须保证服务器正常工作。而 rpc + ralbbimq中间件可以实现低耦合的分布式集群架构。说了这么多，我们该如何选择这两者呢？我总结了如下两点，供你参考：</p>
<p>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高（见下条）从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<h3 id="为什么一定要rpc，不能只学http协议和restful协议吗？"><a href="#为什么一定要rpc，不能只学http协议和restful协议吗？" class="headerlink" title="为什么一定要rpc，不能只学http协议和restful协议吗？"></a>为什么一定要rpc，不能只学http协议和restful协议吗？</h3><ol>
<li><p>rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
</li>
<li><p>自定义协议可以优化数据的传输</p>
</li>
</ol>
<p>如果我们只是开发web网站或者一些服务的使用者， 那么我们用restful看起来已经足够了，但是rpc的这种模式在大量的服务中都有，比如redis协议， rabbitmq的AMQP协议， 聊天软件的协议，也就是说我们想要开发一个redis的客户端，我们只需要用我们喜欢的语言实现redis定义的协议就行了，这对于开发服务来说非常有用，一般这种协议的价值在于我们自己开发的服务之间需要通信的时候 - 那你会问了，自己开发的组件之间协作，直接调用函数不就行了吗？ - 对了，有些人已经反映过来了 – 分布式系统，分布式系统中非常常用， 比如openstack中。 还有就是微服务！</p>
<p>所以掌握rpc开发，对于进阶和分布式开发就变得非常重要。</p>
<p>http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以后面讲解到的grpc就会使用http2.0开发</p>
<h3 id="通过httpserver实现"><a href="#通过httpserver实现" class="headerlink" title="通过httpserver实现"></a>通过httpserver实现</h3><p>rpc首先一点需要明确：一定会发起一个网络请求，一定会有个网络连接(tcp/udp)</p>
<p>把远程的函数变成一个http请求</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse, parse_qsl</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line">host = (<span class="string">''</span>, <span class="number">8003</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将url映射到对应的函数 urlconfig route call id的映射</span></span><br><span class="line"><span class="comment"># 反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">        parsed_url = urlparse(self.path)</span><br><span class="line">        qs = dict(parse_qsl(parsed_url.query))</span><br><span class="line">        a = int(qs.get(<span class="string">"a"</span>, <span class="number">0</span>))</span><br><span class="line">        b = int(qs.get(<span class="string">"b"</span>, <span class="number">0</span>))</span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(json.dumps({</span><br><span class="line">            <span class="string">"result"</span>:a+b</span><br><span class="line">        }).encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    server = HTTPServer(host, AddHandler)</span><br><span class="line">    print(<span class="string">"Starting server, listen at: %s:%s"</span> % host)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>本地调用</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>+<span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>总结说来，本地程序调用的过程大致可以分为几个步骤和阶段：<br>● 开发者开发好的程序，并进行编译，编译成机器认可的可执行文件。<br>● 运行可执行文件，调用对应的功能方法，期间会读取可执行文件中的机器指令，进行入栈，出栈赋值等操作。此时，计算机由可执行程序所在的进程控制。<br>● 调用结束，所有的内存数据出栈，程序执行结束。计算机继续由操作系统进行控制。</p>
<p>远程过程调用是在两台或者多台不同的物理机器上实现的调用，其间要跨越网络进行调用。因此，我们再想通过前文本地方法调用的形式完成功能调用，就无法实现了，因为编译器无法通过编译的可执行文件来调用远程机器上的程序方法。因此需要采用RPC的方式来实现远端服务器上的程序方法的调用。<br>RPC技术内部原理是通过两种技术的组合来实现的：<strong>本地方法调用 和 网络通信技术</strong>。<br><strong>如果想要做到不用url来确定调用方法和参数怎么办？</strong></p>
<p>改进一下client的代码</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己实现了一个demo级别的rpc封装 代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientStub</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="comment"># 1. call id</span></span><br><span class="line">        <span class="comment"># 2. 序列化和反序列化</span></span><br><span class="line">        <span class="comment"># 3. 传输协议 http</span></span><br><span class="line">        rsp = requests.get(<span class="string">f"<span class="subst">{self.url}</span>/?a=<span class="subst">{a}</span>&amp;b=<span class="subst">{b}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(rsp.text).get(<span class="string">"result"</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def add(self, a, b):</span></span><br><span class="line">    <span class="comment">#     payload = {</span></span><br><span class="line">    <span class="comment">#         "method": "add",</span></span><br><span class="line">    <span class="comment">#         "params": [a, b],</span></span><br><span class="line">    <span class="comment">#         "jsonrpc": "2.0",</span></span><br><span class="line">    <span class="comment">#         "id": 0,</span></span><br><span class="line">    <span class="comment">#     }</span></span><br><span class="line">    <span class="comment">#     response = requests.post(self.url, json=payload).json()</span></span><br><span class="line">    <span class="comment">#     print(response)</span></span><br><span class="line">    <span class="comment">#     return response["result"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这不是就是写一个web服务器 无非就是自己封装一下client</span></span><br><span class="line"><span class="comment">#不想知道过多的细节 只想像本地一样调用</span></span><br><span class="line">client = ClientStub(<span class="string">"http://127.0.0.1:8003"</span>)</span><br><span class="line">print(client.add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(client.add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(client.add(<span class="number">22</span>, <span class="number">33</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的代码我们关注几点：</p>
<ol>
<li>通信使用了json，所以json中的内容应该如何写就成为了一种协议</li>
<li>要想实现远程调用必须要要有网络连接</li>
<li>上面通过http连接，可以发现客户端和服务器端之间可以独立，实际上除了通过json以外还可以通过xml作为数据格式</li>
<li>rpc不应该和http拿来比较</li>
<li>rpc也不应该和restful拿来比较，我们完全可以把上述代码通过client和server端的封装将rpc编程基于restful来实现</li>
<li>rpc可以理解为一种调用风格，具体实现可以随意写，至于底层是走tcp协议还是http协议看需求</li>
</ol>
<p>rpc开发的四大要素<br>RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。</p>
<p><strong>客户端(Client)：</strong>服务调用发起方，也称为服务消费者。<br><strong>客户端存根(Client  Stub)：</strong>该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。<br><strong>服务端(Server)：</strong>远端的计算机机器上运行的程序，其中有客户端要调用的方法。<br><strong>服务端存根(Server Stub)：</strong>接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。</p>
<p>了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：</p>
<ul>
<li>两台物理机器在网络中要建立稳定可靠的通信连接。</li>
<li>两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。<br>图片.png</li>
</ul>
<p>RPC原理图客户端(Client)服务端(server)10客户端Stub服务端Stubsocket通信Socket通信服务提供端请求发起端</p>
<p>在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：</p>
<p>1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名；<br>2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。<br>3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。<br>4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。<br>5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。<br>6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。<br>7、服务端Stub程序<strong>将程序调用结果按照约定的协议进行序列化，</strong>并通过网络发送回客户端Stub程序。<br>8、客户端Stub程序接收到服务端Stub发送的返回数据，<strong>对数据进行反序列化操作，</strong>并将调用返回的数据传递给客户端请求发起者。<br>9、客户端请求发起者得到调用结果，整个RPC调用过程结束。</p>
<p>rpc需要使用到的术语</p>
<p>通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析：</p>
<p>1、动态代理技术： 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。<br>2、序列化和反序列化：  在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。<br><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。<br><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。<br>我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。</p>
<h3 id="基于xml的rpc调用"><a href="#基于xml的rpc调用" class="headerlink" title="基于xml的rpc调用"></a>基于xml的rpc调用</h3><p>服务端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc.server <span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"></span><br><span class="line"><span class="comment">#python中类的命名方式遵循驼峰命名法</span></span><br><span class="line"><span class="comment">#1. 没有出现url的映射</span></span><br><span class="line"><span class="comment">#2. 没有编码和解码</span></span><br><span class="line"><span class="comment">#序列化和反序列化协议是 xml 不是 json</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculater</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtract</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> abs(x-y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x/y</span><br><span class="line"></span><br><span class="line">obj = Calculater()</span><br><span class="line">server = SimpleXMLRPCServer((<span class="string">"localhost"</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="comment"># 将实例注册给rpc server</span></span><br><span class="line">server.register_instance(obj)</span><br><span class="line">print(<span class="string">"Listening on port 8088"</span>)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc <span class="keyword">import</span> client</span><br><span class="line"></span><br><span class="line"><span class="comment">#xmlrpc挺好用的 和我们调用django的服务器 django这种web框架来说一定是可以做到xmlrpc的效果 django的目的不是这种</span></span><br><span class="line"><span class="comment">#rpc强调的是本地调用效果</span></span><br><span class="line"><span class="comment">#rpc在内部调用很多</span></span><br><span class="line"></span><br><span class="line">server = client.ServerProxy(<span class="string">"http://localhost:8088"</span>)</span><br><span class="line">print(server.add(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 5</span></span><br><span class="line">print(server.multiply(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 6</span></span><br><span class="line">print(server.subtract(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后，我们通过 server_proxy 对象就可以远程调用之前的rpc server的函数了。</p>
<h3 id="json实现rpc的调用"><a href="#json实现rpc的调用" class="headerlink" title="json实现rpc的调用"></a>json实现rpc的调用</h3><p>SimpleXMLRPCServer 是基于 xml-rpc 实现的远程调用，上面我们也提到 除了 xml-rpc 之外，还有 json-rpc 协议。<br>那 python 如何实现基于 json-rpc 协议呢？答案是很多，很多web框架其自身都自己实现了json-rpc，但我们要独立这些框架之外，要寻求一种较为干净的解决方案，我们使用 jsonrpclib<br><a target="_blank" rel="noopener" href="https://github.com/tcalmant/jsonrpclib/">https://github.com/tcalmant/jsonrpclib/</a></p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jsonrpclib-pelix</span><br></pre></td></tr></tbody></table></figure>

<p>它与 Python 标准库的 SimpleXMLRPCServer 很类似（因为它的类名就叫做 SimpleJSONRPCServer ，不明真相的人真以为它们是亲兄弟）。或许可以说，jsonrpclib 就是仿照 SimpleXMLRPCServer 标准库来进行编写的。<br>它的导入与 SimpleXMLRPCServer 略有不同，因为SimpleJSONRPCServer分布在jsonrpclib库中。</p>
<p>服务端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jsonrpclib.SimpleJSONRPCServer <span class="keyword">import</span> SimpleJSONRPCServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 实例化server</span></span><br><span class="line">server = SimpleJSONRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment">#2. 将函数注册到server中</span></span><br><span class="line">server.register_function(add)</span><br><span class="line"><span class="comment">#3. 启动server</span></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>多线程<br>协程 go中 netty asyncio<br>jsonrpclib如果只是完成了这样一个简单的调用那么jsonrpclib和xmlrpcserver几乎没有优势可言<br>任何一个web服务如果不具备并发接收和处理的能力的话 那么这个server就没有用</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jsonrpclib.SimpleJSONRPCServer <span class="keyword">import</span> PooledJSONRPCServer</span><br><span class="line"><span class="keyword">from</span> jsonrpclib.threadpool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup the notification and request pools</span></span><br><span class="line">nofif_pool = ThreadPool(max_threads=<span class="number">10</span>, min_threads=<span class="number">0</span>)</span><br><span class="line">request_pool = ThreadPool(max_threads=<span class="number">50</span>, min_threads=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Don't forget to start them</span></span><br><span class="line">nofif_pool.start()</span><br><span class="line">request_pool.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup the server</span></span><br><span class="line">server = PooledJSONRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>), thread_pool=request_pool)</span><br><span class="line">server.set_notification_pool(nofif_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register methods</span></span><br><span class="line">server.register_function(add)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 超时机制 - 重试</span></span><br><span class="line"><span class="comment">#2. 限流 处于长期可用的状态 - 高可用</span></span><br><span class="line"><span class="comment">#3. 解耦</span></span><br><span class="line"><span class="comment">#4. 负载均衡 微服务 -分布式应用的一种具体的体现</span></span><br><span class="line"><span class="comment">#5. json-rpc是否满足上述的要求</span></span><br><span class="line"><span class="comment">#6. 序列化和反序列化数据压缩是否高效 json这种数据格式已经非常的简单了 1.这个序列化协议能将数据的压缩变得更小 2. 这个序列化和反序列化的速度够快</span></span><br><span class="line"><span class="comment">#json.dumps() json.loads()</span></span><br><span class="line"><span class="comment">#做架构 技术选型的时候 这些都是我们需要考虑到的点</span></span><br><span class="line"><span class="comment">#更加高效和更加全面的技术 zerorpc</span></span><br><span class="line"><span class="comment">#7. 这个rpc框架是否支持多语言 生态很好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># Stop the thread pools (let threads finish their current task)</span></span><br><span class="line">    request_pool.stop()</span><br><span class="line">    nofif_pool.stop()</span><br><span class="line">    server.set_notification_pool(<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonrpclib</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">    server = jsonrpclib.ServerProxy(<span class="string">'http://localhost:8000'</span>)</span><br><span class="line">    print(server.add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = threading.Thread(target=request)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">30</span>)  <span class="comment"># 主线程不直接退出</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="zerorpc实现rpc调用"><a href="#zerorpc实现rpc调用" class="headerlink" title="zerorpc实现rpc调用"></a>zerorpc实现rpc调用</h3><p>zerorpc 是利用 zeroMQ消息队列 + msgpack 消息序列化(二进制) 来实现类似 grpc 的功能，跨语言远程调用。<br>主要使用到 zeroMQ 的通信模式是 ROUTER–DEALER，模拟 grpc 的 &nbsp;请求-响应式 和 应答流式 RPC ：zerorpc 还支持 PUB-SUB 通信模式的远程调用。<br>zerorpc实际上会依赖msgpack-python, pyzmq, future, greenlet, gevent</p>
<p><a target="_blank" rel="noopener" href="https://github.com/0rpc/zerorpc-python">https://github.com/0rpc/zerorpc-python</a></p>
<h4 id="一元调用"><a href="#一元调用" class="headerlink" title="一元调用"></a>一元调用</h4><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloRPC</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="comment">#调用了另一个服务</span></span><br><span class="line">        <span class="comment">#流处理</span></span><br><span class="line">        <span class="comment">#本地查询了数据， 源源不断的给数据给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, %s"</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 实例化一个server</span></span><br><span class="line"><span class="comment">#2. 绑定我们的业务代码到server中</span></span><br><span class="line"><span class="comment">#3. 启动server</span></span><br><span class="line">s = zerorpc.Server(HelloRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>客户端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"ni"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"hao"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在功能体验上 client端没有太大的差异</span></span><br><span class="line"><span class="comment">#差异在性能上 服务端上</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> hello():</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line"><span class="comment">#python中的生成器和迭代器</span></span><br><span class="line">print(c.hello(<span class="string">"慕课网"</span>))</span><br></pre></td></tr></tbody></table></figure>

<h4 id="流式响应"><a href="#流式响应" class="headerlink" title="流式响应"></a>流式响应</h4><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingRPC</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">    @zerorpc.stream #@zerorpc.stream这里的函数修饰是必须的，否则会有异常，如TypeError: can’t serialize</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">streaming_range</span>(<span class="params">self, fr, to, step</span>):</span></span><br><span class="line">        <span class="keyword">return</span> range(fr, to, step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = zerorpc.Server(StreamingRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 生态 - grpc</span></span><br><span class="line"><span class="comment">#2. 语言的支持 python nodejs go</span></span><br><span class="line"><span class="comment">#3. grpc</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> c.streaming_range(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>):</span><br><span class="line">    print(item)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="传入多个参数"><a href="#传入多个参数" class="headerlink" title="传入多个参数"></a>传入多个参数</h3><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myRPC</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listinfo</span>(<span class="params">self,message</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"get info : %s"</span>%message</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getpow</span>(<span class="params">self,n,m</span>):</span></span><br><span class="line">        <span class="keyword">return</span> n**m</span><br><span class="line"></span><br><span class="line">s = zerorpc.Server(myRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>客户端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line">print(c.listinfo(<span class="string">"this is test string"</span>))</span><br><span class="line">print(c.getpow(<span class="number">2</span>,<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/22/go-de-option-mo-shi/" rel="prev" title="go的Options 模式">
                  <i class="fa fa-chevron-left"></i> go的Options 模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/" rel="next" title="Go 进程的启动过程、调度循环和GPM">
                  Go 进程的启动过程、调度循环和GPM <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
