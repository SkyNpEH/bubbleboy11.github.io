<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。  示例 1: 123输入: s &#x3D; &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。  示例 2: 123输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。  示例 3: 1234输入: s &#x3D; &quot;pwwk">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/08/07/leetocode/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。  示例 1: 123输入: s &#x3D; &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。  示例 2: 123输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。  示例 3: 1234输入: s &#x3D; &quot;pwwk">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-06T16:21:41.000Z">
<meta property="article:modified_time" content="2021-10-01T08:31:33.979Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/08/07/leetocode/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/08/07/leetocode/","path":"2021/08/07/leetocode/","title":"leetcode"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leetcode | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-text">整数反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-text">整数转罗马数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-text">罗马数字转整数</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">359</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/07/leetocode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-06 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-06T16:21:41Z">2021-08-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 08:31:33" itemprop="dateModified" datetime="2021-10-01T08:31:33Z">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ol start="3">
<li>无重复字符的最长子串<br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</li>
</ol>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = ""</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></tbody></table></figure>

<p>提示：</p>
<ul>
<li>0 &lt;= s.length &lt;= 5 * 10^4</li>
<li>s 由英文字母、数字、符号和空格组成</li>
</ul>
<p>法一 滑动窗口<br>思路和算法</p>
<p>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。</p>
<p>找出<strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。</p>
<p>以示例一中的字符串 abcabcbb 为例，<br>先从第一个字符开始，只有一个字符肯定不会重复吧。“a”满足条件，更新最大长度为1；然后走到第二个字符，“ab”也满足，更新最大长度为2。<br>走到第三个字符，“abc” 也满足，更新最大长度为 3。<br>走到第四个字符，我们发现 “a” 已经出现过了，于是我们就必须要删除之前的一些字符来继续满足无重复字符的条件，但是我们不知道前面已经出现过一次的 “a” 的 index 在哪里呀，所以我们只能一个一个找了，从当前子串的“abca”的第一个字符开始找，删除第一个字符 “a”，发现这时候只剩下一个 “a”了，我们又满足条件了，更新最大长度为3，以此类推：</p>
<figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">  v</span><br><span class="line"></span><br><span class="line">  <span class="keyword">a</span>  b  c  <span class="keyword">a</span>  b  c  b  b</span><br></pre></td></tr></tbody></table></figure>

<p>end 指针不停往前走，只要当前子串 s[start:end+1] 不满足无重复字符条件的时候，我们就让 start 指针往前走直到满足条件为止，每次满足条件我们都要更新一下最大长度，即 res。<br>这就是滑动窗口的思想，也称为sliding window，</p>
<p>对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>
<p>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；<br>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；<br>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；<br>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；<br>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；<br>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；<br>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；<br>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。</p>
<p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！<br>这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k，直到右侧出现了重复字符为止。</p>
<p>这样一来，我们就可以使用「滑动窗口」来解决这个问题了：</p>
<ul>
<li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k；</p>
</li>
<li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p>
</li>
<li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
</li>
</ul>
<p>判断重复字符<br>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，<br>但是我们不知道前面已经出现过一次的“a”的index在哪里呀，所以我们只能一个一个找了。<br>我们可以对这里做一个优化，就不需要一个个去找了。只需要用一个常用的数据结构为哈希集合、字典<br>（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set, golang 中的 map[byte]int{}）。<br>添加和移除的元素分别在右边指针和左边指针，set只充当一个记录当前左右指针之间不重复元素的功能。<br>对当前子串中的每一个字符，将其在input中的来源index记录下来即可。</p>
<p>我们先从第一个字符开始，只要碰到已经出现过的字符，我们就必须从之前出现该字符的index开始重新往后看。</p>
<p>例如‘xyzxlkjh’，当看到第二个‘x’时，我们就应该从第一个x后面的y开始重新往后看了。</p>
<p>我们将每一个已经阅读过的字符作为key，而它的值就是它在原字符串中的index。<br>如果我们现在的字符不在字典里面，我们就把它加进字典中去。<br>因此，只要end指针指向的这个字符c，在该字典中的值大于等于了当前子串首字符的index时，就说明c在当前子串中已经出现过了，<br>我们就将当前子串的首字符的index加1，即从后一位又重新开始读，此时当前子串已经满足条件了，然后我们更新res。</p>
<p>在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p>
<p>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度：O(|\Sigma|)O(∣Σ∣)，其中 \SigmaΣ 表示字符集（即字符串中可以出现的字符），|\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |\Sigma| = 128∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |\Sigma|∣Σ∣ 个，因此空间复杂度为 O(|\Sigma|)O(∣Σ∣)。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{} <span class="comment">// map[uint8]int</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> rk+<span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        <span class="comment">// rk-i+1 是当前字串从第 i 到 rk 个字符的长度</span></span><br><span class="line">        ans = max(ans, rk-i+<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> { <span class="comment">// go没有内置的max函数，但是有输入输出float的 math.Max</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y {</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>s = “abcabcbb”<br>len(s) = 8<br>rk, ans := -1, 0</p>
<p>i = 0<br>    rk + 1 = 0 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[0]] = m[“a”] == 0<br>    m[s[rk+1]] = m[s[rk+1]] + 1 = 1<br>    m[“a”] = m[“a”] + 1 = 1<br>    rk = rk + 1 = 0</p>
<pre><code>rk + 1 = 1 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[1]] = m["b"] == 0
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 1

rk + 1 = 2 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[2]] = m["c"] == 0
m["c"] = m["c"] + 1 = 1
rk = rk + 1 = 2

rk + 1 = 3 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[3]] = m["a"] = 1 != 0

ans = max(ans, rk-i+1) = max(0, 2-0+1) = 3
</code></pre>
<p>i = 1 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[0]) = delete(map[a:1 b:1 c:1], “a”)<br>    m = map[b:1 c:1]</p>
<pre><code>rk + 1 = 3 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[3]] = m["a"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["a"] = m["a"] + 1 = 1
rk = rk + 1 = 3

rk + 1 = 4 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[4]] = m["b"] == 1 != 0

ans = max(ans, rk-i+1) = max(3, 3-1+1) = 3
</code></pre>
<p>i = 2 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[1]) = delete(map[a:1 b:1 c:1], “b”)<br>    m = map[a:1 c:1]</p>
<pre><code>rk + 1 = 4 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[4]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 4

rk + 1 = 5 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[5]] = m["c"] == 1 != 0

ans = max(ans, rk-i+1) = max(3, 4-2+1) = 3
</code></pre>
<p>i = 3 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[2]) = delete(map[a:1 b:1 c:1], “c”)<br>    m = map[a:1 b:1]</p>
<pre><code>rk + 1 = 5 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[5]] = m["c"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["c"] = m["c"] + 1 = 1
rk = rk + 1 = 5

rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 5-3+1) = 3
</code></pre>
<p>i = 4 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[3]) = delete(map[a:1 b:1 c:1], “a”)<br>    m = map[b:1 c:1]</p>
<pre><code>rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 5-4+1) = 3
</code></pre>
<p>i = 5 != 0<br>    delete(m, s[i-1]) = delete(map[b:1 c:1], s[4]) = delete(map[b:1 c:1], “b”)<br>    m = map[c:1]</p>
<pre><code>rk + 1 = 6 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[6]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 6

rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 6-5+1) = 3
</code></pre>
<p>i = 6 != 0<br>    delete(m, s[i-1]) = delete(map[a:1 b:1 c:1], s[5]) = delete(map[a:1 b:1 c:1], “c”)<br>    m = map[b:1]</p>
<pre><code>rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 1 != 0
ans = max(ans, rk-i+1) = max(3, 6-6+1) = 3
</code></pre>
<p>i = 7 != 0<br>    delete(m, s[i-1]) = delete(map[b:1], s[6]) = delete(map[b:1], “b”)<br>    m = map[]</p>
<pre><code>rk + 1 = 7 &lt; 8 &amp;&amp; m[s[rk+1]] = m[abcabcbb[7]] = m["b"] == 0
m[s[rk+1]] = m[s[rk+1]] + 1 = 1
m["b"] = m["b"] + 1 = 1
rk = rk + 1 = 7

rk + 1 = 8
ans = max(ans, rk-i+1) = max(3, 7-7+1) = 3
</code></pre>
<p>return ans = 3</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Max returns the larger of x or y.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Special cases are:</span></span><br><span class="line"><span class="comment">//    Max(x, +Inf) = Max(+Inf, x) = +Inf</span></span><br><span class="line"><span class="comment">//    Max(x, NaN) = Max(NaN, x) = NaN</span></span><br><span class="line"><span class="comment">//    Max(+0, ±0) = Max(±0, +0) = +0</span></span><br><span class="line"><span class="comment">//    Max(-0, -0) = -0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> {</span><br><span class="line">    <span class="keyword">if</span> haveArchMax {</span><br><span class="line">        <span class="keyword">return</span> archMax(x, y)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法二 滑动窗口 左边界一步一步移动</p>
<p>map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</p>
<p>1、首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,<br>此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</p>
<p>2、如果当前字符 ch 包含在 map中，此时有2类情况：<br> 1）当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，<br> 那么此时更新 left 为 map.get(a)+1=0+1=1索引，也就是left移动到b，当前有效子段更新为 bca；<br>i - left = 2-0 = 2 ，所以最后 max-left 要+1，s.cahrAt(i)+1 就是 让例如abca ，</p>
<p> 2）当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，<br> 当遍历到第二个b，再添加b，发现map中包含b，<br> 而且b包含在最长有效子段中，就是1）的情况，我们更新 left = map.get(‘b’) + 1 = 2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；<br> 随后，当遍历到第二个a时，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left= map.get(‘a’) + 1 = 1，实际上，left此时应该不变，left始终为2，left移动到第二个b，子段变成 ba才对，索引下标1的 a 不一定在滑动窗口内<br> 为了处理以上2类情况，我们每次更新left，left=Math.max(left, map.get(ch)+1)= Math.max(left, map.get(s.charAt(i)) + 1) = Math.max(2, 0+1) = 2</p>
<p> 另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，<br> 因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</p>
<p>如：abcbc，我们先添加a,b,c进map，此时left=0，<br> 当遍历到第二个b，再添加b，发现map中包含b，<br> 而且b包含在最长有效子段中，就是1）的情况，我们更新 left = map.get(‘b’) + 1 = 2，此时子段更新为 cb，而且map中仍然包含c，map.get(c)=2；<br> 随后，当遍历到第二个c时，发现c包含在map中，且map.get(c)=2，如果我们像1）一样处理，就会发现 left= map.get(‘c’) + 1 = 3，实际上，left此时应该不变，left始终为2，left移动到第二个b，子段变成 bc才对，索引下标3的 c 在滑动窗口内<br> 为了处理以上2类情况，我们每次更新left，left=Math.max(left, map.get(ch)+1)= Math.max(left, map.get(s.charAt(i)) + 1) = Math.max(3, 2+1) = 3</p>
<p>右窗口是靠 i++一步步右移的，但左窗口并不是，利用哈希表的下标可以一步到位。 以 abcbab 为例， 当滑动窗口框住的是 ab 【cba】 b时，left=2; 框中 b的下标已经更新为3，当下一步 框外的b 进入for循环，判断框中是否已经有它， 发现有，窗口就应该把 b 扔出去，所以left直接跳到b后边，也就是 b的下标+1=4，直接跳了两位，一步就把左窗口固定到位,此时框住的是abcb【ab】</p>
<p>遇到重复的元素，python会删除队列前面的元素，go和java并不会删除队列前面的元素，而是更新这个元素在HashMap中存储的数组下标 i，并同时更新左区间 left 的值，我们是通过 left 和 i 来计算当前无重复子串的长度，并与之前记录的最长子串进行比较。 按你下面说的，1~n-1的字符不重复，突然最后一个字符和第n-1个字符重复的话，并不需要删除n次，我们假设n-1的元素是a，他在HashMap中存储 ：(a,n-1)，随后遍历到第n个元素，假设其也是a，此时更新哈希表：(a,n)，同时更新left，然后计算当前无重复子串长度：n-left+1，随后与原先最长子串进行比较。对其他元素并没有进行操作。</p>
<p>最后，关于哈希表的操作，我们在设计哈希表的时候，假设有N个元素，我们如果开辟M长度的地址，那么每个数组位置的查找表（链表或红黑树）元素个数为：N/M，我们在查找/删除/插入 操作元素的时候，时间复杂度是：O(log(N/M)) 或者 O(log(N/M))，然而实际设计的时候，我们会对哈希表的数组进行动态扩容缩容，使得 N/M 在一定的范围内，可以看做常数，因此哈希表各个操作的时间复杂度可以看做：O(1)。另外，HashMap当某个位置元素个数超过8的时候，会从链表转换为红黑树。对于你说的删除操作，红黑树删除操作的时间复杂度是O(log k)，此处k为红黑树元素个数，即k=N/M，满足前面所说的情况。</p>
<p>这样做可以直接省略left++的中间步骤，直接将left的坐标设置为之前出现该重复字符的下一位，直接一步到位优化了一下官方题解上那个</p>
<p>移动的是下标，这里指的是 left 指针和 i 指针，他们之间的距离即使窗口的长度，也就是我们要求的最大子串的长度，如果有重复的，就把 left 指针更新为 重复的元素的位置。而 i 指针自始至终都是一直往右移动的。<br>比如’abcdefdc’，一开始头指针指向’a’，而当尾指针指向第二个’d’时，头指针就直接指向第一个’d’后的’e’，把中间的’bcd’给忽略了。注意，敲黑板，题目要求是“找出其中不含有重复字符的 最长子串 的长度”。从’a’开始的最长不重复字串长度为6，而从’b’开始的为5，从’c’开始的为4，从’d’开始的为3。由此可见，忽略了也没影响最终结果。<br>原因很简单，有重复元素在那里，搜索’bcd’的结果必然不会大于从’a’开始搜索的结果。因此，可以略过’bcd’，直接把窗口移动到’e’处继续搜索。</p>
<p>时间复杂度：O(2n) = O(n)，最坏的情况是 left 和 right 都遍历了一遍字符串<br>空间复杂度：O(n)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 优化后的滑动窗口</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) {</span><br><span class="line">        <span class="keyword">char</span> rightChar = s.charAt(right);</span><br><span class="line">        <span class="keyword">int</span> rightCharIndex = window.getOrDefault(rightChar, <span class="number">0</span>);</span><br><span class="line">        left = Math.max(left, rightCharIndex);</span><br><span class="line">        maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        window.put(rightChar, right + <span class="number">1</span>);</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;<span class="comment">// 最长不重复子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">// 滑动窗口左下标指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++){ <span class="comment">// i 相当于滑动窗口右下标 right</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))){<span class="comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span></span><br><span class="line">                left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);       <span class="comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span></span><br><span class="line">            }        <span class="comment">//map.get('a')=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span></span><br><span class="line">            <span class="comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span></span><br><span class="line">            map.put(s.charAt(i), i);      <span class="comment">//再更新map中a映射的下标</span></span><br><span class="line">            max = Math.max(max, i-left+<span class="number">1</span>);     <span class="comment">//比较两个参数的大小</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        lookup = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        cur_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># i 相当于滑动窗口右下标</span></span><br><span class="line">            cur_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lookup:</span><br><span class="line">                <span class="comment"># 不断从左缩小窗口，直到窗口中不存在与下一个字符重复的字符，才能加入新的元素</span></span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 一步一步移，效率不高</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<p>程序变量解释<br>start 是当前无重复字符的子串首字符的 index；<br>maps 放置每一个字符的 index，如果 maps.get(s[i], -1) 大于等于 start 的话，就说明字符重复了，此时就要重置 res 和 start 的值了。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># start 指针指向的是当前子串首字符在 input 中对应的index</span></span><br><span class="line">        res, start, n = <span class="number">0</span>, <span class="number">0</span>, len(s)</span><br><span class="line">        maps = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># i 相当于滑动窗口右下标</span></span><br><span class="line">            start = max(start, maps.get(s[i], <span class="number">-1</span>) + <span class="number">1</span>) <span class="comment"># 找到当前子串新的起点</span></span><br><span class="line">            res = max(res, i - start + <span class="number">1</span>) <span class="comment"># 当前子串满足条件了，更新结果</span></span><br><span class="line">            maps[s[i]] = i <span class="comment"># 将当前字符与其在 input 中的 index 记录下来</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    res, start := <span class="number">0</span>, <span class="number">0</span> <span class="comment">// start 指针指向的是当前子串首字符在 input 中对应的index</span></span><br><span class="line">    lookup := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> s { <span class="comment">// i 相当于滑动窗口右下标</span></span><br><span class="line">        idx, ok := lookup[s[i]]</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            start = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(start), <span class="keyword">float64</span>(<span class="number">-1</span>+<span class="number">1</span>))) <span class="comment">// 找到当前子串新的起点</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            start = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(start), <span class="keyword">float64</span>(idx+<span class="number">1</span>))) <span class="comment">// 从后一位作为当前子串新的起点又重新开始读</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 第 start 到 i 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        <span class="comment">// i-start+1 是当前字串从第 i 到 rk 个字符的长度</span></span><br><span class="line">        res = <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(res), <span class="keyword">float64</span>(i-start+<span class="number">1</span>))) <span class="comment">// 当前子串满足条件了，更新结果</span></span><br><span class="line">        lookup[s[i]] = i                                      <span class="comment">// 将当前字符与其在 input 中的 index 记录下来</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>s = “abcabcbb”<br>len(s) = 8<br>start, res := 0, 0</p>
<p>i = 0<br>    lookup[s[i]] = lookup[“abcabcbb”[0]] = lookup[“a”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(0), float64(0-0+1))) = 1<br>    lookup[s[i]] = lookup[“a”] = i = 0</p>
<p>i = 1<br>    lookup[s[i]] = lookup[“abcabcbb”[2]] = lookup[“c”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(1), float64(1-0+1))) = 2<br>    lookup[s[i]] = lookup[“b”] = i = 1</p>
<p>i = 2<br>    lookup[s[i]] = lookup[“abcabcbb”[1]] = lookup[“b”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(2), float64(2-0+1))) = 3<br>    lookup[s[i]] = lookup[“c”] = i = 2</p>
<p>i = 3<br>    lookup[s[i]] = lookup[“abcabcbb”[3]] = lookup[“a”]<br>    idx = 0, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(0), float64(0+1))) = 1<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(3-1+1))) = 3<br>    lookup[s[i]] = lookup[“a”] = i = 3</p>
<p>i = 4<br>    lookup[s[i]] = lookup[“abcabcbb”[4]] = lookup[“b”]<br>    idx = 1, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(1+1))) = 2<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(4-2+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 4</p>
<p>i = 5<br>    lookup[s[i]] = lookup[“abcabcbb”[5]] = lookup[“c”]<br>    idx = 2, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(2+1))) = 3<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(5-3+1))) = 3<br>    lookup[s[i]] = lookup[“c”] = i = 5</p>
<p>i = 6<br>    lookup[s[i]] = lookup[“abcabcbb”[6]] = lookup[“b”]<br>    idx = 4, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(4+1))) = 5<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(6-5+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 6</p>
<p>i = 7<br>    lookup[s[i]] = lookup[“abcabcbb”[7]] = lookup[“b”]<br>    idx = 6, ok = true<br>    start = int(math.Max(float64(start), float64(idx+1)))<br>    start = int(math.Max(float64(1), float64(6+1))) = 7<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(3), float64(7-7+1))) = 3<br>    lookup[s[i]] = lookup[“b”] = i = 7</p>
<p>return ans = 3</p>
<p>abc 再进来一个 b 或者c </p>
<p>s = “abcbc”<br>len(s) = 5<br>start, res := 0, 0</p>
<p>i = 0<br>    lookup[s[i]] = lookup[“abcbc”[0]] = lookup[“a”]<br>    idx = 0, ok = false<br>    start = int(math.Max(float64(start), float64(-1+1)))<br>    start = int(math.Max(float64(0), float64(-1+1))) = 0<br>    res = int(math.Max(float64(res), float64(i-start+1)))<br>    res = int(math.Max(float64(0), float64(0-0+1))) = 1<br>    lookup[s[i]] = lookup[“a”] = i = 0</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<p>法三：滑动窗口的万能模板</p>
<p>对于这种求”连续…”的题，我们首先想到，”连续“ 代表的是一个范围，我们只要找到这个最大范围即可，很显然先线性数据结构中找范围用 “滑动窗口” 思想。<br>对于窗口，那么必然有“左窗棱”和“右窗棱”。</p>
<p>初始，我们让左(left)右(right)窗棱都为 0 此是窗户(ans)最小。<br>每次 “右窗棱” 向右增大时我们都判断当前字符 s[right] 是否已经存在map中，如果没有，则把当前字符加入map。<br>用字符 s[right] 表示map的key，用字符所在的下标（right）表示 map 的 value （此处有妙用）</p>
<p>在“右窗棱” 向右增加时，如果当前字符已经存在map中，说明“左窗棱”-“右窗棱” 之间存在了重复元素，此时我们该改变我们 “左窗棱” 的位置</p>
<p>如何改变左窗棱的位置？</p>
<p>应该找到重复元素第一次（最近一次更新）添加到map中的value值，然后把该value值加1，既为最新的 “左窗棱” 的位置</p>
<p>更新后的“左窗棱”不能比之前的 “左窗棱” 小<br>更新map中重复元素最新的下标</p>
<p>不管每次”左窗棱“右移还是 “右窗棱”右移，都要计算一下此时窗口的大小，和原来窗口大小比较，记录历史窗口最大的值</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        lookup = defaultdict(int)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> lookup[s[end]] &gt; <span class="number">0</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            lookup[s[end]] += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> counter &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> lookup[s[start]] &gt; <span class="number">1</span>:</span><br><span class="line">                    counter -= <span class="number">1</span></span><br><span class="line">                lookup[s[start]] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            max_len = max(max_len, end - start)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<p>滑动窗口优化<br>以上当在窗口中存在重复字符，是一个一个字符的缩小窗口<br>通过记住每个字符在字符串中的索引，当遇到重复字符的时候，就可以直接跳到重复字符的后面</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">    max_len, window = <span class="number">0</span>, {}</span><br><span class="line">    left = right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; n:</span><br><span class="line">        right_char_index = window.get(s[right], <span class="number">-1</span>)</span><br><span class="line">        left = max(left, right_char_index)</span><br><span class="line">        max_len = max(max_len, right - left + <span class="number">1</span>)</span><br><span class="line">        window[s[right]] = right + <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> {</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> left, right, window = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> right &lt; n {</span><br><span class="line">        <span class="keyword">var</span> rightChar = s[right]</span><br><span class="line">        <span class="keyword">var</span> rightCharIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := window[rightChar]; ok {</span><br><span class="line">            rightCharIndex = window[rightChar]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> rightCharIndex &gt; left {</span><br><span class="line">            left = rightCharIndex</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; maxLen {</span><br><span class="line">            maxLen = right - left + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        window[rightChar] = right + <span class="number">1</span></span><br><span class="line">        right++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    strLen := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> strLen == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    left,right,ans := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line">    <span class="keyword">for</span> right &lt; strLen{</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[s[right]]; !ok {</span><br><span class="line">            m[s[right]] = right</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> m[s[right]] + <span class="number">1</span> &gt;= left {</span><br><span class="line">                left = m[s[right]] + <span class="number">1</span></span><br><span class="line">            }</span><br><span class="line">            m[s[right]] = right</span><br><span class="line">        }</span><br><span class="line">        ans = max(right-left+<span class="number">1</span>,ans)</span><br><span class="line">        right ++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span> <span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> a &gt; b {</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>对于一个字母 x</p>
<p>start 当前找到的最长不含有重复字符的子串的开始</p>
<ul>
<li>lastOccurred[x]不存在，或者&lt;start → 无需操作</li>
<li>lastOccurred[x] &gt;= start → 更新 start = lastOccurred[x+1]</li>
<li>更新 lastOccurred[x]，更新 maxLength</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="comment">// lastOccurred := make(map[byte]int)</span></span><br><span class="line">    lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    maxLength := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for i, ch := range []byte(s) { // 不支持中文</span></span><br><span class="line">    <span class="comment">// for i, ch := range s { // 支持中文，一个中文字符算3个长度</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s) { <span class="comment">// 支持中文，一个中文字符算1个长度</span></span><br><span class="line">        <span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start {</span><br><span class="line">            start = lastI + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength {</span><br><span class="line">            maxLength = i - start + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        lastOccurred[ch] = i <span class="comment">// key唯一，如果有重复key会覆盖value</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"abcabcbb"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"bbbbb"</span>)) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"pwwkew"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">""</span>)) <span class="comment">// 0</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"b"</span>)) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"abcdef"</span>)) <span class="comment">// 6</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"这里是慕课网"</span>)) <span class="comment">// 6</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(<span class="string">"一二三二一"</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(</span><br><span class="line">        lengthOfLongestSubstring(</span><br><span class="line">            <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span>)) <span class="comment">// 8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSubstr</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    tests := []<span class="keyword">struct</span> {</span><br><span class="line">        s   <span class="keyword">string</span></span><br><span class="line">        ans <span class="keyword">int</span></span><br><span class="line">    }{</span><br><span class="line">        <span class="comment">// Normal cases</span></span><br><span class="line">        {<span class="string">"abcabcbb"</span>, <span class="number">3</span>},</span><br><span class="line">        {<span class="string">"pwwkew"</span>, <span class="number">3</span>},</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Edge cases</span></span><br><span class="line">        {<span class="string">""</span>, <span class="number">0</span>},</span><br><span class="line">        {<span class="string">"b"</span>, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"bbbbbbbbb"</span>, <span class="number">1</span>},</span><br><span class="line">        {<span class="string">"abcabcabcd"</span>, <span class="number">4</span>},</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Chinese support</span></span><br><span class="line">        {<span class="string">"这里是慕课网"</span>, <span class="number">6</span>},</span><br><span class="line">        {<span class="string">"一二三二一"</span>, <span class="number">3</span>},</span><br><span class="line">        {<span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span>, <span class="number">8</span>},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests {</span><br><span class="line">        actual := lengthOfLongestSubstring(tt.s)</span><br><span class="line">        <span class="keyword">if</span> actual != tt.ans {</span><br><span class="line">            t.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, tt.s, tt.ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">--- ide ---</span><br><span class="line">=== RUN   TestSubstr</span><br><span class="line">--- PASS: TestSubstr (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">--- 命令行 ---</span><br><span class="line">=== RUN   TestSubstr</span><br><span class="line">--- PASS: TestSubstr (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">coverage: <span class="number">52.6</span>% of statements in ../../../../learngo/...</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr    <span class="number">0.042</span>s</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BenchmarkXxx testing.B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSubstr</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">    s := <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span> <span class="comment">// 一般性能测试选择最复杂的那个用例</span></span><br><span class="line"></span><br><span class="line">    ans := <span class="number">8</span></span><br><span class="line">    <span class="comment">// 如果在这里做测试用的数据的生成，不想把这个时间加进去，可以在生成数据之后reset一下时间</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    <span class="comment">// 性能测试一般循环多次，具体不用我们定，用b.N系统自动帮我们确定多少次</span></span><br><span class="line">        actual := lengthOfLongestSubstring(s)</span><br><span class="line">        <span class="keyword">if</span> actual != ans {</span><br><span class="line">            b.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, s, ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">BenchmarkSubstr</span><br><span class="line"># <span class="number">100000000</span>次    每次操作  <span class="number">0.512</span> ns</span><br><span class="line">BenchmarkSubstr<span class="number">-8</span>            <span class="number">100000000</span>次      <span class="number">0.512</span> ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BenchmarkXxx testing.B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSubstr</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">    s := <span class="string">"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花"</span> <span class="comment">// 一般性能测试选择最复杂的那个用例</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">13</span>; i++ {</span><br><span class="line">        s = s + s</span><br><span class="line">    }</span><br><span class="line">    b.Logf(<span class="string">"len(s) = %d"</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    ans := <span class="number">8</span></span><br><span class="line">    <span class="comment">// 如果在这里做测试用的数据的生成，不想把这个时间加进去，可以在生成数据之后reset一下时间</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ {</span><br><span class="line">    <span class="comment">// 性能测试一般循环多次，具体不用我们定，用b.N系统自动帮我们确定多少次</span></span><br><span class="line">        actual := lengthOfLongestSubstring(s)</span><br><span class="line">        <span class="keyword">if</span> actual != ans {</span><br><span class="line">            b.Errorf(<span class="string">"got %d for input %s; "</span>+<span class="string">"expected %d"</span>,</span><br><span class="line">                actual, s, ans)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">BenchmarkSubstr</span><br><span class="line">nonrepeating_test.<span class="keyword">go</span>:<span class="number">40</span>: <span class="built_in">len</span>(s) = <span class="number">491520</span></span><br><span class="line">nonrepeating_test.<span class="keyword">go</span>:<span class="number">40</span>: <span class="built_in">len</span>(s) = <span class="number">491520</span></span><br><span class="line">BenchmarkSubstr<span class="number">-8</span>            <span class="number">100</span>      <span class="number">17965116</span> ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rose\go\src\learngo\lang\container\nonrepeatingsubstr&gt; go test -bench .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr</span><br><span class="line">cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz</span><br><span class="line">BenchmarkSubstr-8            200           5943632 ns/op</span><br><span class="line">--- BENCH: BenchmarkSubstr-8</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">PASS</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr     1.837s</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\rose\go\src\learngo\lang\container\nonrepeatingsubstr&gt; go test -bench . -cpuprofile cpu.out</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr</span><br><span class="line">cpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz</span><br><span class="line">BenchmarkSubstr-8            171           7770656 ns/op</span><br><span class="line">--- BENCH: BenchmarkSubstr-8</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">    nonrepeating_test.go:40: len(s) = 491520</span><br><span class="line">PASS</span><br><span class="line">ok      imooc.com/ccmouse/learngo/lang/container/nonrepeatingsubstr     2.277s</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以设立两层循环，外层循环对字符串进行整体遍历—代表子串的起始点i，内层循环从当前起始点开始往后遍历，并且将每一个当前遇到的字符存入哈希集合当中，根据哈希表的特点我们可以很快地找出哈希表中是否存在某个字符，当不存在的时候内存循环结束，同时在内层循环中我们还是需要维护一个右边界的指针r，每循环一次内层循环就加一，当内层循环结束时，就代表从外层循环选择的左边界i到内层循环维护的右边界指针r这个区间的字符串为当前起始点的无重复字符的最长子串，这时与最大值max进行比较赋值，当整个循环完成，这个max就是最大的长度。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">//存储当前最长不重复子串，用来查询下个字符是否存在</span></span><br><span class="line">    maps := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>{}</span><br><span class="line">    <span class="comment">//r是子串的右置针，这里还没有还是移动所以初始化为-1</span></span><br><span class="line">    <span class="comment">//max记录最大的子串的长度</span></span><br><span class="line">    r, max := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">//从头开始遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ {</span><br><span class="line">        <span class="comment">//当每一次外层循环结束就代表i++也就是待遍历子串的左边界加一，所以这个时候我们需要讲maps中</span></span><br><span class="line">        <span class="comment">//的最左字符删除</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">delete</span>(maps, s[i<span class="number">-1</span>])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> r &lt; <span class="built_in">len</span>(s)<span class="number">-1</span> &amp;&amp; maps[s[r+<span class="number">1</span>]] == <span class="number">0</span> {</span><br><span class="line">            maps[s[r+<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">            r++</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> max &lt; r-i+<span class="number">1</span> {</span><br><span class="line">            max = r - i + <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] = [-2147483648~2147483647]，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>将一个有符号整数进行反转，也就是说 64 这个数字再反转后会变为 46 ，个位数反转到十位数，十位数反转到个位数。如果给出的整数是负数的话，整数的符号不能变。在这道题中我们要注意以下几点：</p>
<ul>
<li>整数会有负数的情况；</li>
<li>最后一位是 0 的情况下要舍弃，例如 120 反转后为 21 。</li>
</ul>
<p>解题方案<br>思路1：时间复杂度: O(lgx) 空间复杂度: O(1)<br>翻转数字问题需要注意的就是溢出问题，为什么会存在溢出问题呢？</p>
<p>int型的数值范围是 -2147483648～2147483647 (-2^31 ~ 2^31 - 1)，<br>那么如果我们要翻转 1000000009 这个在数值范围内的数，得到 9000000001，<br>但翻转后的数就超过了范围，这个情况就是溢出，这个时候程序返回 0 即可。</p>
<p>如果输入的是负数，就递归调用原函数，参数变成 -x 即可，代码大致执行流程如下：</p>
<ul>
<li>首先判断 x 是否为负数，如果是负数先取绝对值然后递归取反，最后再将结果转换为负数即可；</li>
<li>res 为最后结果，最开始等于 0 。x % 10(例如：123 % 10 = 3) 取出最后一位数。每次得到最后一位数字，并将其作为结果中的当前最高位；</li>
<li>判断结果 res 是否溢出，如果溢出则返回 0 </li>
</ul>
<p>时刻注意特殊情况——为负数怎么办；为0怎么办；为空怎么办。<br>合理运用写完的函数，机智一点，不要碰到负数又去实现一个负数的版本，直接递归调用原函数就可以了</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>: <span class="comment"># 判断是否为负数</span></span><br><span class="line">            <span class="keyword">return</span> -self.reverse(-x) <span class="comment"># 如果是负数则取绝对值调用自身，最后将结果转为负数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x: <span class="comment"># 每次得到最后一位数字，并将其作为结果中的当前最高位</span></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 如果溢出就返回0</span></span><br></pre></td></tr></tbody></table></figure>

<p>x = 123</p>
<p>res = 0 + 3 = 3<br>x = 123 // 10 = 12</p>
<p>res = 3 * 10 + 12 % 10 = 32<br>x = 12 // 10 = 1</p>
<p>res = 32 * 10 + 1 % 10 = 321<br>x = 1 // 10 = 0</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> { <span class="comment">// 如果是负数就取反递归再取反</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> { <span class="comment">// 每次得到最后一位数字，并将其作为结果中的当前最高位</span></span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> res &lt;= <span class="number">0x7fffffff</span> { <span class="comment">// 如果溢出就返回0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p>示例 1:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="built_in">num</span> = <span class="number">9</span></span><br><span class="line">输出: <span class="string">"IX"</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: <span class="attr">L</span> = <span class="number">50</span>, <span class="attr">V</span> = <span class="number">5</span>, <span class="attr">III</span> = <span class="number">3</span>.</span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: <span class="attr">M</span> = <span class="number">1000</span>, <span class="attr">CM</span> = <span class="number">900</span>, <span class="attr">XC</span> = <span class="number">90</span>, <span class="attr">IV</span> = <span class="number">4</span>.</span><br></pre></td></tr></tbody></table></figure>

<p>详细的罗马数字计数规则如下：</p>
<ul>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3；</li>
<li>小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8；</li>
<li>小的数字，限于（I、X 和 C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4，这条规则好目前与本题无关；</li>
<li>正常使用时，连续的数字重复不得超过三次；</li>
<li>在一个数的上面画横线，表示这个数扩大 1000 倍（本题只考虑 3999 以内的数，所以用不到这条规则）；</li>
<li>从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数；反之，减去前一个数的两倍然后加上该数。</li>
</ul>
<p>我们可以将所有罗马数字的不同符号及对应整数放在字典中。但由于题目限制，正常使用时连续的数字重复不能超过三次，所以对于 400、40、4 或者是 900、90、9 这种情况我们直接单独列出来。</p>
<p>注：之所以将 900、90、9 这三种情况列出是因为罗马数字中并没有单独表示 400 的字符存在，而且不允许DCD这样的情况出现。</p>
<p>将罗马数字和对应整数以及各种特殊情况整合到字典中后，首先将字典按照对应罗马数字的对应整数值进行排序并遍历，每一项中的键 symbol 对应罗马数字符号 ，值 val 对应整数。</p>
<p>如果 num 大于 val 则进入 while 循环，并将当前的罗马数字字符 symbol 拼接到最后结果 roman 中，然后 num - val ，每执行一次 while 循环重新判断 num &gt;= val。如果不满足则跳出 while 循环，执行下一次 for 循环。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: int</span>) -&gt; str:</span></span><br><span class="line">        lookup = {</span><br><span class="line">            <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'CM'</span>: <span class="number">900</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'CD'</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'XC'</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'XL'</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'IX'</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'IV'</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        roman = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 因为dict本身是无序的，这里做了一个排序的操作，否则可能会出现IIII这种状况。</span></span><br><span class="line">        <span class="keyword">for</span> symbol, val <span class="keyword">in</span> sorted(lookup.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>])[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= val:</span><br><span class="line">                roman += symbol</span><br><span class="line">                num -= val</span><br><span class="line">        <span class="keyword">return</span> roman</span><br></pre></td></tr></tbody></table></figure>

<p>以整数 3568 为例，3568 的对应罗马数字为：MMMDLXVIII</p>
<p>第一次 for 循环 ————&gt; symbol = ‘M’ val = 1000 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘M’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘M’,num 为 2568<br>    第二次 while 循环：<br>        将 ‘M’ 拼接到 roman 中，num 减去当前 val ，此时 roman 为 ‘MM’,num 为 1568<br>    第三次 while 循环：<br>        将 ‘M’ 拼接到 roman 中，num 减去当前 val ，此时 roman 为 ‘MMM’,num 为 568                     num &gt;= val 不成立，退出 while 循环。<br>第二次 for 循环 ————&gt; symbol = ‘CM’ val = 900 , num &gt;= val不成立，不能进入 while 循环：<br>第三次 for 循环 ————&gt; symbol = ‘D’ val = 500 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘D’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘MMMD’,num 为 68<br>        num &gt;= val 不成立，退出 while 循环。<br>第四次 for 循环 ————&gt; symbol = ‘CD’ val = 400 , num &gt;= val不成立，不能进入 while 循环：<br>…………<br>第七次 for 循环 ————&gt; symbol = ‘L’ val = 50 , num &gt;= val成立，进入 while 循环：<br>    第一次 while 循环：<br>        将 ‘L’ 拼接到 roman 中， num 减去当前 val ，此时 roman 为 ‘MMMDL’,num 为 18<br>        num &gt;= val 不成立，退出 while 循环。<br>…………依次执行后得出结果为 MMMDLXVIII 。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="comment">// 初始化了一个一一对应的map，方便后面取出符号。</span></span><br><span class="line">    lookupSymbol := []<span class="keyword">string</span>{<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>}</span><br><span class="line">    lookupNum := []<span class="keyword">int</span>{<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>}</span><br><span class="line">    roman := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i, symbol := <span class="keyword">range</span> lookupSymbol {</span><br><span class="line">        val := lookupNum[i]</span><br><span class="line">        <span class="keyword">for</span> num &gt;= val {</span><br><span class="line">            roman += symbol</span><br><span class="line">            num -= val</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> roman</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "III"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "IV"</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "IX"</span></span><br><span class="line"><span class="section">输出: 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></tbody></table></figure>

<p>提示：</p>
<p>1 &lt;= s.length &lt;= 15<br>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)<br>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内<br>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。<br>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。<br>通过次数467,201提交次数739,123</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```go</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/27/go-de-tcp-he-udp/" rel="prev" title="go的tcp和udp">
                  <i class="fa fa-chevron-left"></i> go的tcp和udp
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/17/go-fan-xing/" rel="next" title="go泛型">
                  go泛型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
