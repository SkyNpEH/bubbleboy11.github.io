<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="协程都是独立运行的，他们之间没有通信。 不同的并行协程之间交流的方式有两种，一种是通过共享变量，但是不建议这么做。另一种是通过队列。Go 语言鼓励使用先入先出(FIFO)的队列的形式来交流，它单独为协程之间的队列数据交流定制了特殊的语法类型 —— channle通道，可以通过它来进行goroutine之间的通信，可以避免共享内存的坑。通道是并发安全、用来传递数据的的数据结构，它类似于内存消息队列，">
<meta property="og:type" content="article">
<meta property="og:title" content="go的channel">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/08/20/go-de-channel/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="协程都是独立运行的，他们之间没有通信。 不同的并行协程之间交流的方式有两种，一种是通过共享变量，但是不建议这么做。另一种是通过队列。Go 语言鼓励使用先入先出(FIFO)的队列的形式来交流，它单独为协程之间的队列数据交流定制了特殊的语法类型 —— channle通道，可以通过它来进行goroutine之间的通信，可以避免共享内存的坑。通道是并发安全、用来传递数据的的数据结构，它类似于内存消息队列，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T16:21:41.000Z">
<meta property="article:modified_time" content="2021-08-27T04:51:01.538Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/08/20/go-de-channel/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/08/20/go-de-channel/","path":"2021/08/20/go-de-channel/","title":"go的channel"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go的channel | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%EF%BC%88%E9%9D%9E%EF%BC%89%E7%BC%93%E5%86%B2%E5%9E%8B%E9%80%9A%E9%81%93%E3%80%8D"><span class="nav-text">无（非）缓冲型通道」</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%BC%93%E5%AD%98"><span class="nav-text">有缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87for-range%E8%8E%B7%E5%8F%96channel%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">通过for range获取channel的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD"><span class="nav-text">关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-text">无缓存空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E5%86%99%E5%AE%89%E5%85%A8"><span class="nav-text">通道写安全</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">347</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/20/go-de-channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go的channel
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-19T16:21:41Z">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-27 04:51:01" itemprop="dateModified" datetime="2021-08-27T04:51:01Z">2021-08-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>协程都是独立运行的，他们之间没有通信。</p>
<p>不同的并行协程之间交流的方式有两种，一种是通过共享变量，但是不建议这么做。<br>另一种是通过队列。Go 语言鼓励使用先入先出(FIFO)的队列的形式来交流，它单独为协程之间的队列数据交流定制了特殊的语法类型 —— channle通道，可以通过它来进行goroutine之间的通信，可以避免共享内存的坑。通道是并发安全、用来传递数据的的数据结构，它类似于内存消息队列，允许很多的协程并发对通道进行读写。接收的数据和发送的数据的顺序是一致的。</p>
<p>通过它并发核心单元就可以发送或者接收数据进行通讯(communication)</p>
<p>channel的通信保证了同步性。<br>同一时间只有一个协程可以访问数据，所以不会出现数据竞争，设计时就是这样的。</p>
<p>如果把协程比喻成小岛，那通道就是岛屿之间的交流桥梁管道，数据搭乘通道从一个协程流转到另一个协程。</p>
<p>通道是协程的输入和输出。<br>作为协程的输出，通道是一个容器，它可以容纳数据。<br>作为协程的输入，通道是一个生产者，它可以向协程提供数据。<br>通道作为容器是有限定大小的，满了就写不进去，空了就读不出来。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。<br>一个 goroutine 可以向另一 goroutine 定向发送消息。通道一般作为不同的协程交流的媒介，在同一个协程里它也是可以使用的。<br>channel 本身还需关联了一个类型，channel 可以发送数据的类型，限定进入通道的数据的类型。<br>例如: 发送 int 类型消息的 channel 写作 <code>chan int</code> 。函数也可以类型。</p>
<p>四种通道类型</p>
<p>Channel三种类型的定义。格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelType = ( <span class="string">"chan"</span> | <span class="string">"chan"</span> <span class="string">"&lt;-"</span> | <span class="string">"&lt;-"</span> <span class="string">"chan"</span> ) ElementType .</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单向通道 一次只能读写一个元素。<br>操作符是箭头 <code>&lt;-</code> 用于指定通道的方向，发送或接收。(箭头的指向就是数据的流向)</li>
</ul>
<p>把箭头 <code>&lt;-</code> 写在通道变量的右边就是写通道，<br>只发送的channel，只能向channel写数据</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan4 <span class="keyword">chan</span> &lt;-<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">chan4 := <span class="built_in">make</span>(<span class="keyword">chan</span> &lt;-<span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>把箭头写在通道变量 chan 的左边就是读通道。<br>只接收的channel，只能从channel读取数据</p>
<p>receive 操作符<br><code>&lt;- ch</code>用来从channel ch中接收数据，这个表达式会一直被block，直到有数据可以接收。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan4 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">chan4 := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//初始化</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果没有指定方向，那么是双向通道，既可以接收数据，也可以发送数据。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只可以用来发送 float64 类型的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只可以用来接收 int 类型的数据</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">msg &lt;- <span class="number">1</span></span><br><span class="line">msg &lt;- <span class="number">1</span></span><br><span class="line">data := &lt;-msg <span class="comment">// invalid operation: &lt;-msg (receive from send-only type chan&lt;- int)</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">msg &lt;- <span class="number">1</span> <span class="comment">// invalid operation: msg &lt;- 1 (send to receive-only type &lt;-chan int)</span></span><br></pre></td></tr></tbody></table></figure>


<p><code>&lt;-</code>总是优先和最左边的类型结合。(The <code>&lt;-</code> operator associates with the leftmost chan possible)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="keyword">int</span>    <span class="comment">// 等价 chan&lt;- (chan int)</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 chan&lt;- (&lt;-chan int)</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 等价 &lt;-chan (&lt;-chan int)</span></span><br><span class="line"><span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>总结：make 初始化三种类型: slice, map和channel<br>像 map 和 slice 数据类型一样, channel必须先创建再使用:</li>
<li>channel是引用类型，和其他引用类型一样，channel 的空值为 <code>nil</code> ，使用 <code>==</code> 可以对类型相同的 channel 进行比较，只有指向相同对象或同为 nil 时，才返回 true。</li>
</ul>
<p>操作    值为 nil 的 channel    被关闭的 channel    正常的 channel<br>close    panic                 panic             成功关闭<br>c&lt;-    永远阻塞                 panic            阻塞或成功发送<br>&lt;-c    永远阻塞                 永远不阻塞         阻塞或成功接收</p>
<p>关闭一个未初始化(nil) 的 channel 或者重复关闭同一个channel均会产生 panic</p>
<ul>
<li>必须通过make初始化的，否则会出现永久阻塞的现象。</li>
</ul>
<p><code>make</code>的第一个参数需要是关键字chan，之后跟着允许限定通道可以容纳交换的数据类型</p>
<p><code>make</code>初始化Channel的第二个参数指定缓存的大小、容量：<code>ch := make(chan int, 100)</code>。</p>
<p>容量(capacity)代表Channel容纳的最多的元素的数量，</p>
<h3 id="无（非）缓冲型通道」"><a href="#无（非）缓冲型通道」" class="headerlink" title="无（非）缓冲型通道」"></a>无（非）缓冲型通道」</h3><p>没有设置容量，或者容量设置为0，</p>
<p>缺省情况下，不管是存消息还是取消息，都会挂起当前goroutine，发送和接收会一直阻塞着，除非另外一端已经准备好。只有sender和receiver都准备好了后它们的通讯(communication)才会发生。<br>发送端发送数据写操作会阻塞直到有其它协程接收方来从当前通道中读取当前通道接收数据。<br>无缓冲区的channel永远不会存数据，只负责数据的流通。</p>
<p>总是处于既满又空的状态。<br>这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p>
<p>通道空了，读操作就会阻塞，协程也会进入睡眠，直到有其它协程写通道装进了数据才会被唤醒。如果有多个协程的读操作阻塞了，一个写操作也只会唤醒一个协程。</p>
<p>从无缓冲channel取数据，必须要有数据流进来才可以，否则当前协程阻塞<br>数据流入无缓冲channel，如果没有其他goroutine来拿走这个数据，那么当前协程阻塞<br>注意：<br>同步的channel不能只在一个协程中发送和接收，因为会被永远阻塞，数据不能到接收方那里。</p>
<h3 id="有缓存"><a href="#有缓存" class="headerlink" title="有缓存"></a>有缓存</h3><p>有可能不发生阻塞，发送方则会阻塞直到发送的值被拷贝到缓冲区内；并且缓存未满，则send会被执行不会阻塞；<br>如果缓冲区已满。接收方在有值可以接收之前会一直阻塞。<br>send写操作就会阻塞，协程就会进入休眠，直到有其它协程某个接收方读通道挪出了空间，协程才会被唤醒。如果有多个协程的写操作都阻塞了，一个读操作只会唤醒一个协程。</p>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>在 Go 语言里不存在无界通道，每个通道都是有限定最大容量的，缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendStmt = Channel <span class="string">"&lt;-"</span> Expression .</span><br><span class="line">Channel = Expression .</span><br></pre></td></tr></tbody></table></figure>

<p>通道作为容器，它可以像切片一样，使用 <code>cap()</code> 和 <code>len()</code> 全局函数获得通道的容量和当前内部的元素个数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch); i++ {</span><br><span class="line">        ch &lt;- i <span class="comment">// 写通道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(ch) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">var</span> value <span class="keyword">int</span> = &lt;-ch <span class="comment">// 读通道</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>在通讯(communication)开始前channel和expression必须先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { c &lt;- <span class="number">3</span> + <span class="number">4</span> }()</span><br><span class="line">i := &lt;-c</span><br><span class="line">fmt.Println(i) <span class="comment">// 7</span></span><br></pre></td></tr></tbody></table></figure>

<p>send被执行前(proceed)通讯(communication)一直被阻塞着。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 申明</span></span><br><span class="line"><span class="keyword">if</span> msg != <span class="literal">nil</span> {</span><br><span class="line">    fmt.Println(<span class="string">"not nil"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 初始化不带缓冲区的整型通道</span></span><br><span class="line">msg &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg // fatal error: all goroutines are asleep - deadlock! 没有缓冲的channel 在没有启动一个接收者之前，放数据到msg中的时候会阻塞的，阻塞之前会获取一把锁，这把锁是要等到数据被接收之后释放，但是没有接收者就没法释放锁</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">msg1 &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg</span></span><br><span class="line">msg1 &lt;- <span class="number">2</span> <span class="comment">// 发送值 2 到通道 msg fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 取数据: 将箭头右边的值放到左边</span></span><br><span class="line">        data := &lt;- msg <span class="comment">//  从通道 msg 接收数据，并将数据赋值给 data</span></span><br><span class="line">        fmt.Println(data) <span class="comment">// </span></span><br><span class="line">    }()</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送值 1 到通道 msg</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line"><span class="keyword">var</span> msg1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 初始化 缓冲区大小为1的整型通道</span></span><br><span class="line">msg1 &lt;- <span class="number">1</span> <span class="comment">// 1 放入 msg 这个 channel 中</span></span><br><span class="line">data1 := &lt;- msg1 <span class="comment">// 将箭头右边的值放到左边，从 msg 这个 channel 取数据放到 data</span></span><br><span class="line">fmt.Println(data1) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-msg1) <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// 初始化  缓冲区大小为2</span></span><br><span class="line"><span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line"><span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"><span class="comment">// 获取这两个数据</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">var</span> value = rand.Intn(<span class="number">100</span>)</span><br><span class="line">        ch &lt;- value</span><br><span class="line">        fmt.Printf(<span class="string">"send %d\n"</span>, value)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        value := &lt;-ch</span><br><span class="line">        fmt.Printf(<span class="string">"recv %d\n"</span>, value)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 子协程循环读</span></span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    <span class="comment">// 主协程循环写</span></span><br><span class="line">    send(ch)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">send <span class="number">81</span></span><br><span class="line">send <span class="number">87</span></span><br><span class="line">recv <span class="number">81</span></span><br><span class="line">recv <span class="number">87</span></span><br><span class="line">send <span class="number">47</span></span><br><span class="line">recv <span class="number">47</span></span><br><span class="line">send <span class="number">59</span></span><br><span class="line">recv <span class="number">59</span></span><br><span class="line">send <span class="number">81</span></span><br><span class="line">recv <span class="number">81</span></span><br><span class="line">send <span class="number">18</span></span><br><span class="line">recv <span class="number">18</span></span><br></pre></td></tr></tbody></table></figure>

<p>没有缓冲 但channel中有数据 写就会被阻塞，但消费了 还能在写入</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> production(dataCh)</span><br><span class="line">    <span class="keyword">go</span> consume(dataCh)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">production</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ {</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> data := &lt;-ch:</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">=== RUN   TestService</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">997</span></span><br><span class="line"><span class="number">998</span></span><br><span class="line"><span class="number">999</span></span><br><span class="line">--- PASS: TestService (<span class="number">3.00</span>s)</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ichan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> {</span><br><span class="line">    str = <span class="string">"hello world"</span></span><br><span class="line">    ichan &lt;- <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    &lt;-ichan  <span class="comment">//这里有值，下面才会运行</span></span><br><span class="line">    fmt.Println(str) <span class="comment">// hello world</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 阻塞主进程，防止未处理完的子协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> chan1 { <span class="comment">// 如果data的缓冲区为空，这个协程会一直阻塞，除非被channel被close</span></span><br><span class="line">            fmt.Println(d)</span><br><span class="line">        }</span><br><span class="line">        quit &lt;- <span class="literal">true</span></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    chan1 &lt;- <span class="number">1</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    chan1 &lt;- <span class="number">4</span></span><br><span class="line">    chan1 &lt;- <span class="number">5</span></span><br><span class="line">    <span class="built_in">close</span>(chan1) <span class="comment">// 用完需要关闭，否则goroutine会被死锁，因为上面用range，它是不等到信道关闭是不会结束读取的</span></span><br><span class="line">    &lt;-quit       <span class="comment">// 解除阻塞</span></span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    msg &lt;- <span class="number">2</span> <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg) <span class="comment">// 通过启动协程消费channel</span></span><br><span class="line">    <span class="comment">// Wait() 阻塞等待所有的写通道协程结束</span></span><br><span class="line">    <span class="comment">// 待计数值变成零，Wait() 才会返回</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>{</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// 计数值减一</span></span><br><span class="line">    data := &lt;- queue</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>{</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    data := &lt;- queue</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>happens-before 特性</p>
<p>无缓冲时，接收 happens-before 发送<br>任何情况下，发送 happens-before 接收<br>close happens-before 接收</p>
<h3 id="通过for-range获取channel的数据"><a href="#通过for-range获取channel的数据" class="headerlink" title="通过for range获取channel的数据"></a>通过for range获取channel的数据</h3><p>除了可以遍历数组、切片、字典，还可以遍历通道，取代箭头操作符。<br>当通道空了，循环会暂停阻塞，<br>当通道关闭时，阻塞停止，循环也跟着结束了。<br>当循环结束时，我们就知道通道已经关闭了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">    }()</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span> {</span><br><span class="line">            c &lt;- i</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"Finished"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">Finished</span><br></pre></td></tr></tbody></table></figure>

<p><code>range c</code>遍历读取到的迭代值为Channel中发送的值，它会一直迭代直到channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在 <code>for …… range</code> 那一行</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span> 为什么会打印<span class="number">2</span>，因为<span class="number">2</span>发送的msg，执行<span class="keyword">for</span>循环的第二轮，打印完<span class="number">2</span>关闭</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!执行<span class="keyword">for</span>循环的第三轮，从空的通道循环</span><br></pre></td></tr></tbody></table></figure>

<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>内建的close方法关闭Channel。<br>通道如果没有显式关闭，当它不再被程序使用的时候，会自动关闭被垃圾回收掉。<br>不过优雅的程序应该将通道看成资源，显式关闭每个不再使用的资源是一种良好的习惯。<br>你可以在多个goroutine从/往 一个channel 中 receive/send 数据，不必考虑额外的同步措施。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg) <span class="comment">// 让for循环正常结束，不报错</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>channel关闭后sender的receiver操作。</p>
<p>往一个已经被close关闭的channel中继续发送写数据会导致 <code>panic: send on closed channel</code>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    time.Sleep(time.Hour)</span><br><span class="line">}()</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">c &lt;- <span class="number">3</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></tbody></table></figure>

<p>已经关闭的channel能够继续接收读取已发送的数据不会被阻塞、不会产生 panic，且能读出 channel 中还未被读取的消息，直到已发送的数据接收读取完为止后，再读取立即返回元素类型的零值(zero value)。</p>
<p>并且会返回 false ，据此可判断 channel 是否关闭<br>如果通道里的元素是整型的，读操作是不能通过返回值来确定通道是否关闭的。<br>关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 2</span></span><br><span class="line">value := &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 3</span></span><br><span class="line">value = &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 4</span></span><br><span class="line">value = &lt;-ch</span><br><span class="line">fmt.Println(value) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">--</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>

<p>通道关闭，依然可以读取数据，<br>通过<code>range</code>读取，channel关闭后for循环直到数据读取完为止，自动跳出不报错：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> queue {</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">// 睡眠1秒钟后，2发送给msg，通道关闭，依然可以读取数据，直到数据读取完为止</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">--</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></tbody></table></figure>

<p>channel的 receive支持 multi-valued assignment</p>
<p>用一个额外的返回参数来检查channel是否关闭。判断值是零值还是正常读取的值<br>如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;-ch</span><br><span class="line">x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok = &lt;-ch</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">i, ok := &lt;-c</span><br><span class="line">fmt.Printf(<span class="string">"%d, %t"</span>, i, ok) <span class="comment">// 0, false</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        fmt.Println(data, ok)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="无缓存空间"><a href="#无缓存空间" class="headerlink" title="无缓存空间"></a>无缓存空间</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> chan1 {</span><br><span class="line">            fmt.Println(d)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    chan1 &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    chan1 &lt;- <span class="number">2</span></span><br><span class="line">    chan1 &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(chan1)</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 无缓存</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock! 不关闭通道consume遍历空通道阻塞</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span> <span class="comment">// 发送要放在接收协程跑起来后面，因为无缓存发送后会阻塞等待接收</span></span><br><span class="line">    <span class="built_in">close</span>(msg) <span class="comment">// </span></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>如官方的例子中通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</span><br><span class="line">        sum += v</span><br><span class="line">    }</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c 把 sum 发送到通道 c</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    s := []<span class="keyword">int</span>{<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>}</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c 从通道 c 中接收 一直处于阻塞状态，直至计算结果发送到channel中。</span></span><br><span class="line">    fmt.Println(x, y, x+y) <span class="comment">// -5 17 12</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>channel可以用在goroutine之间的同步。<br>下面的例子中main goroutine通过done channel等待worker完成任务。<br>worker做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 通知任务已完成</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    <span class="comment">// 等待任务完成</span></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="通道写安全"><a href="#通道写安全" class="headerlink" title="通道写安全"></a>通道写安全</h4><p>上面提到向一个已经关闭的通道执行写操作会抛出异常，这意味着我们在写通道时一定要确保通道没有被关闭。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        i++</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    value := &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">    value = &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    send(ch)</span><br><span class="line">}</span><br><span class="line">---------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">panic</span>: send on closed channel</span><br></pre></td></tr></tbody></table></figure>

<p>那如何确保呢？Go 语言并不存在一个内置函数可以判断出通道是否已经被关闭。即使存在这样一个函数，当你判断时通道没有关闭，并不意味着当你往通道里写数据时它就一定没有被关闭，并发环境下，它是可能被其它协程随时关闭的。</p>
<p>确保通道写安全的最好方式是由负责写通道的协程自己来关闭通道，读通道的协程不要去关闭通道。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> send(ch)</span><br><span class="line">    recv(ch)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个方法确实可以解决单写多读的场景，可要是遇上了多写单读的场合该怎么办呢？任意一个读写通道的协程都不可以随意关闭通道，否则会导致其它写通道协程抛出异常。这时候就必须让其它不相干的协程来干这件事，这个协程需要等待所有的写通道协程都结束运行后才能关闭通道。那其它协程要如何才能知道所有的写通道已经结束运行了呢？这个就需要使用到内置 <code>sync</code> 包提供的 <code>WaitGroup</code> 对象，它使用计数来等待指定事件完成。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// 计数值减一</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">4</span> {</span><br><span class="line">        i++</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> wg = <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="number">2</span>)       <span class="comment">// 增加计数值</span></span><br><span class="line">    <span class="keyword">go</span> send(ch, wg) <span class="comment">// 写</span></span><br><span class="line">    <span class="keyword">go</span> send(ch, wg) <span class="comment">// 写</span></span><br><span class="line">    <span class="keyword">go</span> recv(ch)</span><br><span class="line">    <span class="comment">// Wait() 阻塞等待所有的写通道协程结束</span></span><br><span class="line">    <span class="comment">// 待计数值变成零，Wait() 才会返回</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg)</span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"等待返回值"</span>)</span><br><span class="line">    fmt.Println(&lt;-msg)</span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        queue &lt;- <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line">等待返回值</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> consume(msg) <span class="comment">// 双向的通道可以转换为单向的通道</span></span><br><span class="line">    msg &lt;- <span class="number">1</span></span><br><span class="line">    <span class="built_in">close</span>(msg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(queue &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        data, ok := &lt;-queue</span><br><span class="line">        <span class="keyword">if</span> !ok {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/18/go-ce-shi/" rel="prev" title="go测试">
                  <i class="fa fa-chevron-left"></i> go测试
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/20/go-de-goroutine/" rel="next" title="go测试">
                  go测试 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
