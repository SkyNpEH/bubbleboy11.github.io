<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="go的协程本质是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程，但并不是一个东西 场景一：不允许后面的逻辑，必需要等前面的完成才能执行场景二：批量操作相同的信息，批量发送信息 Goroutine Thread内存占⽤ 2KB -&gt; 1GB 从 8k 开始，服务端程序上限很多是 8M(⽤ulimit -a 可看)，调⽤多会 stack overflowCo">
<meta property="og:type" content="article">
<meta property="og:title" content="go的goroutine">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/08/20/go-de-goroutine/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="go的协程本质是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程，但并不是一个东西 场景一：不允许后面的逻辑，必需要等前面的完成才能执行场景二：批量操作相同的信息，批量发送信息 Goroutine Thread内存占⽤ 2KB -&gt; 1GB 从 8k 开始，服务端程序上限很多是 8M(⽤ulimit -a 可看)，调⽤多会 stack overflowCo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T16:21:41.000Z">
<meta property="article:modified_time" content="2021-10-14T12:53:48.178Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/08/20/go-de-goroutine/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/08/20/go-de-goroutine/","path":"2021/08/20/go-de-goroutine/","title":"go的goroutine"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go的goroutine | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA"><span class="nav-text">子协程异常退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-text">协程死循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-text">协程的本质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="nav-text">设置线程数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-Pool"><span class="nav-text">sync.Pool</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">363</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/08/20/go-de-goroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go的goroutine
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-08-19T16:21:41Z">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-14 12:53:48" itemprop="dateModified" datetime="2021-10-14T12:53:48Z">2021-10-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>go的协程本质是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程，但并不是一个东西</p>
<p>场景一：<br>不允许后面的逻辑，必需要等前面的完成才能执行<br>场景二：<br>批量操作相同的信息，批量发送信息</p>
<p>Goroutine Thread<br>内存占⽤ 2KB -&gt; 1GB 从 8k 开始，服务端程序上限很多是 8M(⽤ulimit -a 可看)，调⽤多会 stack overflow<br>Context switch ⼏⼗ NS 级 1-2 us<br>由谁管理 Go runtime 操作系统<br>通信⽅式 CSP/传统共享内存 传统共享内存<br>ID 有，⽤户⽆法访问 有<br>抢占 1.13 以前需主动让出 1.14 开始可由信号中断  | 内核抢占</p>
<p>简介<br>因为并发程序要考虑很多的细节，以保证对共享变量的正确访问，使得并发编程在很多情况下变得很复杂。<br>但是Go语言在开发并发时，是比较简洁的。它通过channel来传递数据。数据竞争这个问题在golang的设计上就进行了规避了。</p>
<blockquote>
<p>Don’t communicate by sharing memory; share memory by communicating.<br>不要通过共享内存来通信；通过通信来实现共享内存</p>
</blockquote>
<p>Go语言用2种手段来实现并发程序，goroutine和channel，其支持顺序通信进程（communication sequential processes），简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中，值会在不同的运行实例（goroutine）中传递。</p>
<p>在并发系统中，对goroutine的切换时机和运行结果就没有唯一的保证性。<br>在go语言中，我们采用channel来进行goroutine之间的通信，能更容易的保证结果的一致性<br>多个协程可以在一个或多个线程上运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -race xx.go</span><br></pre></td></tr></tbody></table></figure>

<p>查看运行是否有数据访问冲突</p>
<p>每一个线程 下面都有一个 Go自己实现的协程处理器<br>然后下面就是协程队列<br>Processor就会依次运行协程</p>
<p>go会监听这个队列如果一个时间段这个队列数量还是没有发生变化,golang就会吧当前的goroutine放到当前队列的队尾</p>
<p>当某一个协程被系统中断,processor就会吧这个协程,放到其他空闲的线程上</p>
<p>初学者可以完全将协程理解为线程，但是用起来比线程更加简单，占用的资源也更少。<br>通常在一个进程里启动上万个线程就已经不堪重负，但是 Go 语言允许你启动百万协程也可以轻松应付。</p>
<p>A goroutine is a lightweight thread managed by the Go runtime.<br>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>在Go语言中，每一个并发的执行单元就叫做goroutine。<br>每个goroutine都对应一个非常简单的模型：它是一个并发的执行函数，并且在多个并发的goroutine间，资源是共享的。goroutine非常轻量，创建的开销很少。</p>
<p>goroutine 语法格式：在函数前加上一个关键字：<code>go</code>。Go 语言就能送给调试器运行启动一个新的协程，函数调用将成为这个协程的入口。<br>不需要在定义时区分是否是异步函数，python才需要<br>调度器在合适的点进行切的</p>
<p>go routine 可能的切换点</p>
<ul>
<li>I/0, select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用（有时）</li>
<li><code>runtime.Gosched()</code></li>
<li>只是参考，不能保证切换，不能保证在其他地方不切换<br>go语言调度器开的线程数一般不会超过机器的CPU核数</li>
</ul>
<p>值得注意的是这里的 go 关键字语法和前面的 defer 关键字语法是一样的，它后面跟了一个匿名函数，然后还要带上一对<code>()</code>，表示对匿名函数的调用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></tbody></table></figure>

<p>starts a new goroutine running 开启一个新的 goroutine:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></tbody></table></figure>

<p>The evaluation of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code> happens in the current goroutine and the execution of <code>f</code> happens in the new goroutine.<br>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。<br>Goroutines run in the same address space, so access to shared memory must be synchronized. 同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<p>The <code>sync</code> package provides useful primitives, although you won’t need them much in Go as there are other primitives. (See the next slide.)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="comment">// 等待十秒输出</span></span><br><span class="line">fmt.Println(<span class="string">"I am here"</span>) <span class="comment">// I am here</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">}()</span><br><span class="line"><span class="comment">// 这里直接输出，不会等待十秒</span></span><br><span class="line">fmt.Println(<span class="string">"I am here"</span>) <span class="comment">// I am here</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">    say(<span class="string">"hello"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"In main"</span>)</span><br><span class="line">    <span class="keyword">go</span> longSleep()</span><br><span class="line">    <span class="keyword">go</span> shortSleep()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"sleep "</span>)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * <span class="number">1e9</span>)<span class="comment">//ns，符号 1e9 表示 1 乘 10 的 9 次方，e=指数</span></span><br><span class="line">    fmt.Println(<span class="string">"the end of main"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longSleep</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"longSleep begin"</span>)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"longSleep end"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortSleep</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"shortSleep begin"</span>)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"shortSleep end"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">In main</span><br><span class="line">sleep</span><br><span class="line">longSleep begin</span><br><span class="line">shortSleep begin</span><br><span class="line">shortSleep end</span><br><span class="line">longSleep end</span><br><span class="line">the end of main</span><br></pre></td></tr></tbody></table></figure>

<p>main() ，longSleep() 和 shortSleep() 这3个函数都是独立的处理单元按顺序启动，然后开始并行运行。为了模拟<br>运算时间的损耗，我们使用了sleep()函数，这个函数可以按照指定时间来暂停函数或协程执行。</p>
<p>如果我们不在main()函数中sleep()较长的时间，那么main() 函数结束时，其他协程运行的程序也会结束。main()程序退出，它不会等待任何其他非main协程的结束。<br>协程是独立的处理单元，一旦陆续启动一些协程，就无法确定他们是什么时候正在开始运行的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGoroutine</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1999</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"run in child goroutine"</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"run in grand child goroutine"</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">                fmt.Println(<span class="string">"run in grand grand child goroutine"</span>)</span><br><span class="line">            }()</span><br><span class="line">        }()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine will quit"</span>)</span><br><span class="line">}</span><br><span class="line">-------</span><br><span class="line">run in main goroutine</span><br><span class="line">run in child goroutine</span><br><span class="line">run in grand child goroutine</span><br><span class="line">run in grand grand child goroutine</span><br><span class="line">main goroutine will quit</span><br></pre></td></tr></tbody></table></figure>

<p>main 函数运行在主协程(main goroutine)里面，上面的例子中我们在主协程里面启动了一个子协程，子协程又启动了一个孙子协程，孙子协程又启动了一个曾孙子协程。这些协程之间似乎形成了父子、子孙、关系，但是实际上协程之间并不存在这么多的层级关系，在 Go 语言里只有一个主协程，其它都是它的子协程，子协程之间是平行关系。</p>
<p>上面的代码中主协程睡眠了 1s，等待子协程们执行完毕。如果将睡眠的这行代码去掉，将会看不到子协程运行的痕迹</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="built_in">run</span> <span class="keyword">in</span> main goroutine</span><br><span class="line">main goroutine will quit</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为主协程运行结束，其它协程就会立即消亡，不管它们是否已经开始运行</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span>{</span><br><span class="line">    fmt.Println(<span class="string">"p"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">}</span><br><span class="line">没有打印输出 因为主协程运行结束，其它协程来不及执行完就会立即消亡，不管它们是否已经开始运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span>{</span><br><span class="line">    fmt.Println(<span class="string">"p"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">main</span><br><span class="line">没有打印输出p，主死从随，因为主协程运行结束，其它协程就会立即消亡，不管它们是否已经开始运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">p ，主协程挂起<span class="number">1</span>秒钟，从的协程立刻执行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">q</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        fmt.Println(<span class="string">"dead circle"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> q()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>) <span class="comment">// 如果不加这个 因为go开了协程 mian函数本身也是一个协程，如果main退出整个函数就退出了，程序中断</span></span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">dead circle</span><br><span class="line">... 一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            fmt.Println(<span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">... 一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">                time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">只有打印了这几个，一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line">...</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i) <span class="comment">// 闭包，用到了匿名函数外另一个协程的变量</span></span><br><span class="line">                <span class="comment">// 主死从随</span></span><br><span class="line">                time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line">...</span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">91</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">92</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">一秒钟后程序停止</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">...</span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">79</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">                time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">69</span></span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">96</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">84</span></span><br><span class="line">这样就没有重复，不按顺序是协程谁先调度谁后调度是系统内部，不是先启动就先运行</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">10000</span> == <span class="number">0</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"%d goroutine started\n"</span>, i) <span class="comment">// IO操作里面切换，有等待的过程</span></span><br><span class="line">    }</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码将会无休止地创建协程，每个协程都在睡眠，为了确保它们都是活的，协程会 1s 钟醒过来一次。在我的个人电脑上，这个程序创建了千万个协程还没有到上限，观察内存发现占用还不到 1G，这意味着每个协程的内存占用还不到 100 字节。</p>
<p>go的协程和 python的协程-网上有些人可能喜欢拿web框架来做性能对比<br>go的 gin begoo-flask/ django 性能对比 这个不科学的 uwsgi 协程<br>go的 gin begoo-flask/ django + gevent性能对比<br>tornado sanic fastapi/ asyncio 协程库我们就不再使用python的线程来对比<br>只要大家懂了任何一门语言的协程，其他语言的协程都很好理解 GMP<br>大家都开启100W个协程<br>使用的简单性- go 启动一个协程</p>
<p><code>WaitGroup</code> 实现等待某个协程或协程组结束完成的同步操作。父线程调用 <code>Add</code> 方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用 <code>Done</code> 方法 goroutine 内完成任务-1。同时，主线程里可以调用 <code>Wait</code> 方法阻塞至所有线程结束、计数归零。但在使用时要注意:<br>Add的数量和Done的调用数量必须相等。<br>另外，就是WaitGroup结构一旦定义就不能复制的原因。<br> WaitGroup在需要等待多个任务结束再返回的业务来说还是很有用的，但现实中用的更多的可能是，先等待一个协程组，若所有协程组都正确完成，则一直等到所有协程组结束；若其中有一个协程发生错误，则告诉协程组的其他协程，全部停止运行（本次任务失败）以免浪费系统资源。<br>该场景WaitGroup是无法实现的，那么该场景该如何实现呢，就需要用到通知机制，其实也可以用channel来实现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup{}</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        res += val</span><br><span class="line">        wg.Done() <span class="comment">// goroutine 内完成任务-1</span></span><br><span class="line">    }(i)</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(res) <span class="comment">// 45</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup{}</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">int</span>)</span></span> {</span><br><span class="line">        res += val</span><br><span class="line">        wg.Done()</span><br><span class="line">    }(i)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把这个注释掉你会发现，什么结果你都可能拿到</span></span><br><span class="line"><span class="comment">// wg.Wait()</span></span><br><span class="line">fmt.Println(res) <span class="comment">// 1 或者 15</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<p>如何解决主的goroutine在子协程结束后自动结束，主协程不用睡眠</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动1个协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 运行完减一个</span></span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span>  {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">5</span>) <span class="comment">// 启动5个协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> f(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">这<span class="number">5</span>个数的顺序随机</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        total = total + <span class="number">1</span></span><br><span class="line">        <span class="comment">//1. 从 total 取出值</span></span><br><span class="line">        <span class="comment">//2. 将 total+1</span></span><br><span class="line">        <span class="comment">//3. 将 total+1 的计算结果放入到total中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// 100000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>并发会产生的问题 -竞争</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        total = total - <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> sub()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// -36827</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 按理说： 最后的结果应该是0</span></span><br><span class="line"><span class="comment">2. 实际的情况：</span></span><br><span class="line"><span class="comment">  1. 不是0</span></span><br><span class="line"><span class="comment">  2. 每次的运行结果还不一样 54779、-29729</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">=== RUN   TestCounter</span><br><span class="line">time:  <span class="number">2071910</span></span><br><span class="line">--- PASS: TestCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">28</span>: <span class="number">4398</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    nowTime := time.Now().UnixNano()</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">    tTime := time.Now().UnixNano()</span><br><span class="line">    fmt.Println(<span class="string">"time: "</span>, (tTime - nowTime))</span><br><span class="line">}</span><br><span class="line">=== RUN   TestCounter</span><br><span class="line">time:  <span class="number">2071910</span></span><br><span class="line">--- PASS: TestCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">28</span>: <span class="number">4334</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutCounter</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">    nowTime := time.Now().UnixNano()</span><br><span class="line">    <span class="keyword">var</span> nut sync.Mutex</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ {</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            nut.Lock()</span><br><span class="line">            <span class="keyword">defer</span> nut.Unlock()</span><br><span class="line">            counter++</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    t.Log(counter)</span><br><span class="line">    tTime := time.Now().UnixNano()</span><br><span class="line">    fmt.Println(<span class="string">"time: "</span>, (tTime - nowTime))</span><br><span class="line">}</span><br><span class="line">=== RUN   TestMutCounter</span><br><span class="line">time:  <span class="number">2151931</span></span><br><span class="line">--- PASS: TestMutCounter (<span class="number">0.00</span>s)</span><br><span class="line">    share_test.<span class="keyword">go</span>:<span class="number">48</span>: <span class="number">5000</span></span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>

<p>互斥写锁 <code>Mutex</code> 同步协程 同步数据 解决并发问题</p>
<p>能不用锁就别用锁 - 性能</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mutex</span><span class="params">()</span></span> {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">    <span class="comment">// 你的代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        lock.Lock() <span class="comment">// 先把门锁上</span></span><br><span class="line">        total = total + <span class="number">1</span></span><br><span class="line">        <span class="comment">//1. 从 total 取出值</span></span><br><span class="line">        <span class="comment">//2. 将 total+1</span></span><br><span class="line">        <span class="comment">//3. 将 total+1 的计算结果放入到total中</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 放开锁，直接加defer 会报错？</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++ {</span><br><span class="line">        lock.Lock() <span class="comment">// 先把门锁上</span></span><br><span class="line">        total = total - <span class="number">1</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 放开锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> sub()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total) <span class="comment">// 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>绝大多数的web系统来说 都是读多写少<br>有1w个人同时读数据库 A读的时候 B能读吗？ 为什么要加锁呢 一定要加锁 写和读上面加同一把锁<br>并发严重下降， B读了一个数据 不会对C读数据产生影响吗？ 一定是写和读之间造成的<br>读写锁 <code>RWLock</code> 尽量用，读之间不会产生影响，写和读之间才会产生影响<br>• 尽量用 defer 来释放锁，防止panic没有释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RwMutex</span><span class="params">()</span></span>  {</span><br><span class="line">    <span class="comment">// 加读锁</span></span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以加写锁</span></span><br><span class="line">    rwLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    fmt.Println(<span class="string">"开始读取数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">    fmt.Println(<span class="string">"读取成功"</span>)</span><br><span class="line">    rwLock.RUnlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">-</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">等了<span class="number">10</span>秒钟再打印下面的</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">fatal error: all goroutines are asleep - deadlock! 因为<span class="number">6</span>个协程实际上只有<span class="number">5</span>个</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.RLock()</span><br><span class="line">    fmt.Println(<span class="string">"开始读取数据"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"读取成功"</span>)</span><br><span class="line">    rwLock.RUnlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.Lock() <span class="comment">// 没有wLock</span></span><br><span class="line">    fmt.Println(<span class="string">"开始修改数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"修改成功"</span>)</span><br><span class="line">    rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> write()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">等了<span class="number">10</span>秒钟再打印下面的</span><br><span class="line">修改成功</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    rwLock.Lock() <span class="comment">// 没有wLock</span></span><br><span class="line">    fmt.Println(<span class="string">"开始修改数据"</span>)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"修改成功"</span>)</span><br><span class="line">    rwLock.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> write()</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">开始读取数据</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">读取成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br><span class="line">开始修改数据</span><br><span class="line">修改成功</span><br></pre></td></tr></tbody></table></figure>

<p>锁不可重入：lock 之后，即便是同一个线程(goroutine)，也无法再次加锁（写递归函数要小心）</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可重入例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Failed1</span><span class="params">()</span></span>  {</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句会死锁</span></span><br><span class="line">    <span class="comment">// 但是如果你只有一个goroutine，那么这一个会导致程序崩溃</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>• 锁不可升级：加了读锁之后，如果试图加写锁，锁不升级</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可升级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Failed2</span><span class="params">()</span></span>  {</span><br><span class="line">    rwMutex.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwMutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句会死锁</span></span><br><span class="line">    <span class="comment">// 但是如果你只有一个goroutine，那么这一个会导致程序崩溃</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="子协程异常退出"><a href="#子协程异常退出" class="headerlink" title="子协程异常退出"></a>子协程异常退出</h4><p>在使用子协程时一定要特别注意保护好每个子协程，确保它们正常安全的运行。因为子协程的异常退出会将异常传播到主协程，直接会导致主协程也跟着挂掉，然后整个程序就崩溃了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"run in child goroutine"</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"run in grand child goroutine"</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">                fmt.Println(<span class="string">"run in grand grand child goroutine"</span>)</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"wtf"</span>)</span><br><span class="line">            }()</span><br><span class="line">        }()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine will quit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">run in main goroutine</span><br><span class="line">run in child goroutine</span><br><span class="line">run in grand child goroutine</span><br><span class="line">run in grand grand child goroutine</span><br><span class="line"><span class="built_in">panic</span>: wtf</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">34</span> [running]:</span><br><span class="line">main.main.func1<span class="number">.1</span><span class="number">.1</span>()</span><br><span class="line">    /Users/qianwp/<span class="keyword">go</span>/src/github.com/pyloque/practice/main.<span class="keyword">go</span>:<span class="number">14</span> +<span class="number">0x79</span></span><br><span class="line">created by main.main.func1<span class="number">.1</span></span><br><span class="line">    /Users/qianwp/<span class="keyword">go</span>/src/github.com/pyloque/practice/main.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0x75</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们看到主协程最后一句打印语句没能运行就挂掉了，主协程在异常退出时会打印堆栈信息。从堆栈信息中可以了解到是哪行代码引发了程序崩溃。</p>
<p>为了保护子协程的安全，通常我们会在协程的入口函数开头增加 <code>recover()</code> 语句来恢复协程内部发生的异常，阻断它传播到主协程导致程序崩溃。<code>recover</code> 语句必须写在 <code>defer</code> 语句里面。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="comment">// log error</span></span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="协程死循环"><a href="#协程死循环" class="headerlink" title="协程死循环"></a>协程死循环</h4><p>前面我们通过 <code>recover()</code> 函数可以防止个别协程的崩溃波及整体进程。但是如果有个别协程死循环了会导致其它协程饥饿得到不运行么？下面我们来做一个实验</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    fmt.Println(<span class="string">"run in main goroutine"</span>)</span><br><span class="line">    n := <span class="number">7</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            fmt.Println(<span class="string">"dead loop goroutine start"</span>)</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">            } <span class="comment">// 死循环</span></span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"main goroutine running"</span>)</span><br><span class="line">    }</span><br><span class="line">---</span><br><span class="line">run in main goroutine</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">dead loop goroutine start</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">main goroutine running</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>通过调整上面代码中的变量 n 的值可以发现一个有趣的现象，当 n 值大于 7 时，主协程将没有机会得到运行，而如果 n 值为 7、2、1，主协程依然可以每秒输出一次。要解释这个现象就必须深入了解协程的运行原理 cpu逻辑核心数量  我选8也能打印主协程？</p>
<h4 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h4><p>一个进程内部可以运行多个线程，而每个线程又可以运行很多协程。<br>线程要负责对协程进行调度，保证每个协程都有机会得到执行。<br>当一个协程睡眠时，它要将线程的运行权让给其它的协程来运行，而不能持续霸占这个线程。<br>同一个线程内部最多只会有一个协程正在运行。</p>
<p>线程的调度是由操作系统负责的，调度算法运行在内核态，而协程的调用是由 Go 语言的运行时负责的，调度算法运行在用户态。</p>
<p>协程可以简化为三个状态，运行态、就绪态和休眠态。<br>同一个线程中最多只会存在一个处于运行态的协程，<br>就绪态的协程是指那些具备了运行能力但是还没有得到运行机会的协程，它们随时会被调度到运行态，<br>休眠态的协程还不具备运行能力，它们是在等待某些条件的发生，比如 IO 操作的完成、睡眠时间的结束等。</p>
<p>操作系统对线程的调度是抢占式的，也就是说单个线程的死循环不会影响其它线程的执行，每个线程的连续运行受到时间片的限制。</p>
<p>Go 语言运行时对协程的调度并不是抢占式的。如果单个协程通过死循环霸占了线程的执行权，那这个线程就没有机会去运行其它协程了，你可以说这个线程假死了。不过一个进程内部往往有多个线程，假死了一个线程没事，全部假死了才会导致整个进程卡死。</p>
<p>每个线程都会包含多个就绪态的协程形成了一个就绪队列，如果这个线程因为某个别协程死循环导致假死，那这个队列上所有的就绪态协程是不是就没有机会得到运行了呢？Go 语言运行时调度器采用了 work-stealing 算法，当某个线程空闲时，也就是该线程上所有的协程都在休眠（或者一个协程都没有），它就会去其它线程的就绪队列上去偷一些协程来运行。也就是说这些线程会主动找活干，在正常情况下，运行时会尽量平均分配工作任务。</p>
<h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><p>默认情况下，Go 运行时会将线程数会被设置为机器 CPU 逻辑核心数。同时它内置的 <code>runtime</code> 包提供了 <code>GOMAXPROCS(n int)</code> 函数允许我们动态调整线程数，注意这个函数名字是全大写，Go 语言的设计者就是这么任性，该函数会返回修改前的线程数，如果参数 n &lt;=0 ，就不会产生修改效果，等价于读操作。线程数不是协程数，改的越大，越能承受更多的死循环</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 读取默认的线程数</span></span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">// 设置线程数为 10</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 读取当前的线程数</span></span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">0</span>)) <span class="comment">// 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获取当前的协程数量可以使用 runtime 包提供的 <code>NumGoroutine()</code> 方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(runtime.NumGoroutine()) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(runtime.NumGoroutine()) <span class="comment">// 11</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">// [10694344 6434193 10546265 8131522 8812068 8852472 10570023 0 0 3704848]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">                runtime.Gosched() <span class="comment">// 手动交出控制权，别的也有机会运行，总有机会又调度给自己</span></span><br><span class="line">            }</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">//[8696348 8301481 9040898 1115475 0 7329666 5930928 10650591 0 9584546]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                a[i]++            <span class="comment">// 中间没有机会进行协程之间的切换，会被一个协程抢掉，这个协程不主动交出控制权的话，它就始终在这个协程里面</span></span><br><span class="line">                runtime.Gosched() <span class="comment">// 手动交出控制权，别的也有机会运行，总有机会又调度给自己</span></span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    <span class="comment">//panic: runtime error: index out of range [10] with length 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(*a)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    *a++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    fmt.Println(a) <span class="comment">// 1 协程来不及运行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(*a)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    *a++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 2</span></span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"><span class="keyword">go</span> run -race <span class="number">3.</span><span class="keyword">go</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE竞争</span><br><span class="line">Read at <span class="number">0x00c0000ac078</span> by main goroutine:</span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/rose/<span class="keyword">go</span>/src/learngo/lang/channel/<span class="number">3</span>/<span class="number">3.</span><span class="keyword">go</span>:<span class="number">24</span> +<span class="number">0xee</span></span><br><span class="line"></span><br><span class="line">Previous write at <span class="number">0x00c0000ac078</span> by goroutine <span class="number">7</span>:</span><br><span class="line">  main.(*atomicInt).increment()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">struct</span> {</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span>{</span><br><span class="line">    a.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> a.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> a.value</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    a.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> a.lock.Unlock() <span class="comment">//defer的正确用法</span></span><br><span class="line">    a.value++</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a.get()) <span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要在一段代码端同步，那就变成一个匿名函数就好了，出这块代码区释放，代码区对a.value进行保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *atomicInt)</span> <span class="title">increment</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.lock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> a.lock.Unlock() <span class="comment">//defer的只控制这个匿名函数体</span></span><br><span class="line">        <span class="comment">//............</span></span><br><span class="line">        a.value++</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a atomicInt</span><br><span class="line">    a.increment()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        a.increment()</span><br><span class="line">    }()</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    fmt.Println(a.get()) <span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p><code>sync.Map</code>并发安全 map<br>• key 和 value 类型都是<code>interface{}</code>。意味着你要搞各种类型断言</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := sync.Map{}</span><br><span class="line">m.Store(<span class="string">"cat"</span>, <span class="string">"Tom"</span>)</span><br><span class="line">m.Store(<span class="string">"mouse"</span>, <span class="string">"Jerry"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里重新读取出来的，就是</span></span><br><span class="line">val, ok := m.Load(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(val.(<span class="keyword">string</span>))) <span class="comment">// 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>sync.Once</code>：只执行一次，一般用来解决一些初始化的需求</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法，不管调用几次，只会输出一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintOnce</span><span class="params">()</span></span> {</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"只输出一次"</span>)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    PrintOnce()</span><br><span class="line">    PrintOnce()</span><br><span class="line">    PrintOnce()</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line">只输出一次</span><br></pre></td></tr></tbody></table></figure>

<h4 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a><code>sync.Pool</code></h4><ol>
<li>优先从自己的缓存里面返回数据；</li>
<li>如果不够了，就创建一个新的，使用传入的New 回调；</li>
<li>在 GC 的时候，sync.Pool 会被清空</li>
</ol>
<p>sync.Pool 的缺陷：</p>
<ol>
<li>没有超时机制</li>
<li>无法限制内存使用量</li>
<li>GC 全部清掉<br>sync.Pool是可以在多协程的情况下使用的，但是在访问共享池时，会有锁的开销。 -协程安全，会有锁的开销</li>
</ol>
<p>sync.Pool 的一般使用步骤（以user为例）</p>
<ol>
<li>定义 user 结构体</li>
<li>为 user 加上 Reset 方法。该方法用于重置对象，<br>接收器是指针；</li>
<li>定义一个 sync.Pool</li>
<li>调用 Get 方法</li>
<li>使用defer 保证放回去 pool</li>
<li>重置 user</li>
<li>执行业务逻辑</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般来说，复用对象都要求我们取出来之后，</span></span><br><span class="line"><span class="comment">// 重置里面的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Reset</span><span class="params">(name <span class="keyword">string</span>, email <span class="keyword">string</span>)</span></span>  {</span><br><span class="line">    u.Email = email</span><br><span class="line">    u.Name = name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    pool := sync.Pool{</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>{}{</span><br><span class="line">            <span class="keyword">return</span> &amp;user{}</span><br><span class="line">    }}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get 返回的是 interface{}，所以需要类型断言</span></span><br><span class="line">    u := pool.Get().(*user)</span><br><span class="line">    <span class="comment">// defer 还回去</span></span><br><span class="line">    <span class="keyword">defer</span> pool.Put(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 紧接着重置 u 这个对象</span></span><br><span class="line">    u.Reset(<span class="string">"Tom"</span>, <span class="string">"my_email@qq.com"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下边就是使用 u 来完成你的业务逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/20/go-de-channel/" rel="prev" title="go的channel">
                  <i class="fa fa-chevron-left"></i> go的channel
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/23/go-de-atornic/" rel="next" title="go的atomic">
                  go的atomic <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
