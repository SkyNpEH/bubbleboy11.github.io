<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，数组的赋值呢是直接拷贝整个数组。 结构体的拷贝 值类型结构体之间可以相互赋值，它在本质上是一次浅拷贝操作，拷贝了结构体内部的所有字段。结构体指针之间也可以相互赋值，它在本质上也是一次浅拷贝操作，不过它拷贝的仅仅是指针地址值，结构体的内容是共享的。 123456789101112131415161718192">
<meta property="og:type" content="article">
<meta property="og:title" content="go结构体的参数传递和方法">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/07/07/go-jie-gou-ti-de-can-shu-chuan-di-he-fang-fa/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="变量赋值本质上是一次内存浅拷贝，切片的赋值是拷贝了切片头，字符串的赋值是拷贝了字符串的头部，数组的赋值呢是直接拷贝整个数组。 结构体的拷贝 值类型结构体之间可以相互赋值，它在本质上是一次浅拷贝操作，拷贝了结构体内部的所有字段。结构体指针之间也可以相互赋值，它在本质上也是一次浅拷贝操作，不过它拷贝的仅仅是指针地址值，结构体的内容是共享的。 123456789101112131415161718192">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-06T16:21:41.000Z">
<meta property="article:modified_time" content="2021-08-08T13:01:16.153Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/07/07/go-jie-gou-ti-de-can-shu-chuan-di-he-fang-fa/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/07/07/go-jie-gou-ti-de-can-shu-chuan-di-he-fang-fa/","path":"2021/07/07/go-jie-gou-ti-de-can-shu-chuan-di-he-fang-fa/","title":"go结构体的参数传递和方法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go结构体的参数传递和方法 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8B%B7%E8%B4%9D-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">结构体的拷贝 值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">函数和方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"><span class="nav-text">结构体方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95"><span class="nav-text">结构体指针方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%96%B9%E6%B3%95"><span class="nav-text">非结构体类型上方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">封装的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E9%A6%96%E5%AD%97%E6%AF%8D%E5%B0%8F%E5%86%99"><span class="nav-text">外部包中的结构体首字母小写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8C%85%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E9%A6%96%E5%AD%97%E6%AF%8D%E5%B0%8F%E5%86%99"><span class="nav-text">外部包中的结构体字段首字母小写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receiver%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%B8%BAnil%E7%9A%84"><span class="nav-text">Receiver是可以为nil的</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">342</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/07/go-jie-gou-ti-de-can-shu-chuan-di-he-fang-fa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go结构体的参数传递和方法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-06 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-06T16:21:41Z">2021-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-08 13:01:16" itemprop="dateModified" datetime="2021-08-08T13:01:16Z">2021-08-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>变量赋值本质上是一次内存浅拷贝，<br>切片的赋值是拷贝了切片头，<br>字符串的赋值是拷贝了字符串的头部，<br>数组的赋值呢是直接拷贝整个数组。</p>
<h2 id="结构体的拷贝-值类型"><a href="#结构体的拷贝-值类型" class="headerlink" title="结构体的拷贝 值类型"></a>结构体的拷贝 值类型</h2><p>结构体之间可以相互赋值，它在本质上是一次浅拷贝操作，拷贝了结构体内部的所有字段。<br>结构体指针之间也可以相互赋值，它在本质上也是一次浅拷贝操作，不过它拷贝的仅仅是指针地址值，结构体的内容是共享的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//var c9 Course = Course{"scrapy", 110, "https://www.imooc.com"}</span></span><br><span class="line">    c9 := Course{<span class="string">"scrapy"</span>, <span class="number">110</span>, <span class="string">"https://www.imooc.com"</span>}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var c10 Course = c9</span></span><br><span class="line">    c10 := c9</span><br><span class="line">    fmt.Println(c9)  <span class="comment">// {scrapy 110 https://www.imooc.com}</span></span><br><span class="line">    fmt.Println(c10) <span class="comment">// {scrapy 110 https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c9) <span class="comment">// {Name:scrapy Price:110 Url:https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c10) <span class="comment">// {Name:scrapy Price:110 Url:https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"c9 = %p,c10 = %p\n"</span>, &amp;c9, &amp;c10)</span><br><span class="line">    <span class="comment">//c9 = 0xc000100280,c10 = 0xc0001002d0</span></span><br><span class="line"></span><br><span class="line">    c9.Price = <span class="number">200</span></span><br><span class="line">    fmt.Println(c9)  <span class="comment">// {scrapy 200 https://www.imooc.com}</span></span><br><span class="line">    fmt.Println(c10) <span class="comment">// {scrapy 110 https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c9) <span class="comment">// {Name:scrapy Price:200 Url:https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c10) <span class="comment">// {Name:scrapy Price:110 Url:https://www.imooc.com}</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//var c9 *Course = &amp;Course{"scrapy", 110, "https://www.imooc.com"}</span></span><br><span class="line">    c9 := &amp;Course{<span class="string">"scrapy"</span>, <span class="number">110</span>, <span class="string">"https://www.imooc.com"</span>}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var c10 *Course = c9</span></span><br><span class="line">    c10 := c9</span><br><span class="line">    fmt.Println(c9)          <span class="comment">// &amp;{scrapy 110 https://www.imooc.com}</span></span><br><span class="line">    fmt.Println(c10)         <span class="comment">// &amp;{scrapy 110 https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c9)  <span class="comment">// &amp;{Name:scrapy Price:110 Url:https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c10) <span class="comment">// &amp;{Name:scrapy Price:110 Url:https://www.imooc.com}</span></span><br><span class="line">    c9.Price = <span class="number">200</span></span><br><span class="line">    fmt.Println(c9)          <span class="comment">// &amp;{scrapy 200 https://www.imooc.com}</span></span><br><span class="line">    fmt.Println(c10)         <span class="comment">// &amp;{scrapy 200 https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c9)  <span class="comment">// &amp;{Name:scrapy Price:200 Url:https://www.imooc.com}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c10) <span class="comment">// &amp;{Name:scrapy Price:200 Url:https://www.imooc.com}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 语言中同时有函数和方法。<br>方法有哪些作用呢 给用户定义的类型添加新的行为</p>
<p>结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：<br>声明时，在关键字func 和函数名之间增加了一个参数，这个参数被称作接收者，将函数与接收者的类型绑在一起。<br>如果一个函数有接收者，这个作用在接收者（receiver）上的一个函数就被称为方法。</p>
<p>接收者是某种类型的变量<br>接受者可以是命名类型或者结构体类型的一个值或者是一个任何其他允许类型的指针。<br>但是接收者不能是一个指针类型</p>
<p>指针方法和值方法都可以在指针或非指针上被调用，<br>Go 语言里有两种类型的接收者：值接收者，指针接收者<br>接收者是值类型的时候，调用者可以是值类型，也可以是引用类型<br>接收者是一个指针类型，调用者可以是值类型，也可以指针类型<br>接收者类型可以是（几乎）任何类型，结构体类型、函数类型、int、bool、string 或数组的别名类型。</p>
<p>接收者不能是一个接口类型的变量，因为接口是一类事物的抽象定义，而方法是某个具体事物的实现，如果这样做会引发一个编译错误：invalid receiver type…。</p>
<p>一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p>
<p>所有给定类型 T（或 *T）上的所有方法的集合叫做该类型 T（或 *T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *denseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *sparseMatrix)</span> <span class="title">Add</span><span class="params">(b Matrix)</span> <span class="title">Matrix</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>别名类型不能有它原始类型上已经定义过的方法。</p>
<p>定义方法的一般格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> {</span><br><span class="line">    ... <span class="comment">/* 方法体*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在方法名之前，<code>func</code> 关键字之后的括号中指定 receiver。</p>
<p>如果 <code>recv</code> 是 receiver 的实例，<code>recv</code> 方法的接收者对应的变量名，就像是面向对象语言中的 <code>this</code> 或 <code>self</code> <code>me</code>，但是 Go 中并没有 self 和 this 这样的关键字来指代当前的对象。<br>通常我们都使用单个字母来表示。</p>
<p>GO推荐的标准命名<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-names">https://github.com/golang/go/wiki/CodeReviewComments#receiver-names</a></p>
<blockquote>
<p>The name of a method’s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as “c” or “cl” for “Client”). Don’t use generic names such as “me”, “this” or “self”, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver “c” in one method, don’t call it “cl” in another.</p>
</blockquote>
<p>方法接受者名称应反映其身份， 并且不要使用me, this, self这些面向对象语言的典型标志符。在JetBrains系类的开发工具中（IntelliJ、Goland）如果方法接收者名字是self me this类似的词，IDE会提示Receiver has generic name信息</p>
<p>在go中方法接受者其实就是方法的另一个参数。</p>
<p>Method1 是它的方法名，那么方法调用遵循传统的 <code>object.name</code> 选择器符号：recv.Method1()。</p>
<p>如果 <code>recv</code> 一个指针，Go 会自动解引用。方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。</p>
<p>如果方法不需要使用 <code>recv</code> 的值，可以用 <code>_</code> 替换它，比如：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>receiver_type</code> 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。</p>
<h3 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h3><p>无论是方法还是函数都可以把他作为一个普通的函数来调用<br>函数将变量作为参数：<code>Function1(recv)</code>  <code>函数名（参数列表）</code><br>方法在变量上被调用：<code>recv.Method1()</code> <code>调用者.方法名（参数）</code></p>
<p>不要忘记 <code>Method1</code> 后边的括号 <code>()</code>，否则会引发编译器错误：<code>method recv.Method1 is not an expression, must be called</code></p>
<p>接收者必须有一个显式的名字，这个名字必须在方法中被使用。</p>
<p>在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。</p>
<p>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</p>
<p>Go的方法只是语法糖而已，本质还是第一个参数是接收者receiver普通函数<br>在 Go 中为实体增加方法，理解成前面的参是第一个形参，然后用这个参在给这个 func 增加限定作用域会更好理解。</p>
<p>比如给对象加方法，其他语言都是在 class 的 block 内写func，而 Go 是在 struct 的 block 块外加 func，是没有 this 或者 self 的语境的，更像是给一个实体额外挂上一个 func。</p>
<p>值接受者vs指针接受者</p>
<ul>
<li>要改变内容必须使用指针接受者</li>
<li>结构过大考虑指针接受者</li>
<li>一致性：如有指针接收者，最好都是指针接收者</li>
<li>值接收者是 go语言特有</li>
<li>值/指针接收者均可接收值/指针</li>
</ul>
<h3 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h3><p>定义一个结构体类型和该类型的一个方法</p>
<p>Go 语言不是面向对象的语言，它里面不存在类的概念，结构体正是类的替代品。<br>类可以附加很多成员方法，结构体也可以。</p>
<p>Go 语言不喜欢类型的隐式转换，所以需要将整形显示转换成浮点型，不是很好看，不过这就是 Go 语言的基本规则，显式的代码可能不够简洁，但是易于理解。</p>
<p>Go 语言的方法名称也分首字母大小写，它的权限规则和字段一样，</p>
<ul>
<li>首字母大写就是公开方法，</li>
<li>首字母小写就是内部方法，只能归属于同一个包的代码才可以访问内部方法。</li>
</ul>
<p>结构体的参数传递</p>
<p>函数调用时参数传递结构体变量<br>值传递涉及到结构体字段的浅拷贝，<br>指针传递会共享结构体内容，只会拷贝指针地址，规则上和赋值是等价的。</p>
<p>接收者有两种形式 1. 值传递 2. 指针传递 如果你想改结构体的值 如果结构体的数据很大</p>
<p>通过值传递，在函数里面修改结构体的状态不会影响到原有结构体的状态，函数内部的逻辑并没有产生任何效果。通过指针传递就不一样。</p>
<p>结构体的值类型和指针类型访问内部字段和方法在形式上是一样的。这点不同于 C++ 语言，在 C++ 语言里，值访问使用句点 . 操作符，而指针访问需要使用箭头 -&gt; 操作符。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TwoInts <span class="keyword">struct</span> {</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    two1 := <span class="built_in">new</span>(TwoInts)</span><br><span class="line">    two1.a = <span class="number">12</span></span><br><span class="line">    two1.b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"The sum is: %d\n"</span>, two1.AddThem()) <span class="comment">// The sum is: 22</span></span><br><span class="line">    fmt.Printf(<span class="string">"Add them to the param: %d\n"</span>, two1.AddToParam(<span class="number">20</span>)) <span class="comment">// Add them to the param: 42</span></span><br><span class="line"></span><br><span class="line">    two2 := TwoInts{<span class="number">3</span>, <span class="number">4</span>}</span><br><span class="line">    fmt.Printf(<span class="string">"The sum is: %d\n"</span>, two2.AddThem()) <span class="comment">// The sum is: 7</span></span><br><span class="line">    fmt.Printf(<span class="string">"The sum is: %d\n"</span>, (&amp;two2).AddThem()) <span class="comment">// The sum is: 7</span></span><br><span class="line">    <span class="comment">// fmt.Printf("The sum is: %d\n", (*two2).AddThem()) // invalid indirect of two2 (type TwoInts)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddThem</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tn *TwoInts)</span> <span class="title">AddToParam</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> tn.a + tn.b + param</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接收者类型是 *TwoInts 的方法 AddThem()，它能在类型 TwoInts 的值上被调用，这是自动间接发生的。</p>
<p>因此 <code>two2.AddThem</code> 可以替代 <code>(&amp;two2).AddThem()</code>。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">printCourseInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 课程价格: %d, 课程的地址:%s\n"</span>, c.Name, c.Price, c.Url)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">setPrice</span><span class="params">(price <span class="keyword">int</span>)</span></span> { <span class="comment">// c相当于python的self，也可以写成self</span></span><br><span class="line">    c.Price = price</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setPrice1</span><span class="params">(c Course)</span></span> { <span class="comment">// c相当于python的self，也可以写成self</span></span><br><span class="line">    c.Price = <span class="number">800</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Course)</span> <span class="title">setPricePoint</span><span class="params">(price <span class="keyword">int</span>)</span></span> { <span class="comment">// c相当于python的self，也可以写成self</span></span><br><span class="line">    c.Price = price <span class="comment">// 等同于(*c).Price = price</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setPricePoint1</span><span class="params">(c *Course)</span></span> { <span class="comment">// c相当于python的self，也可以写成self</span></span><br><span class="line">    c.Price = <span class="number">800</span> <span class="comment">// 等同于(*c).Price = 800</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//结构体方法， 达到了封装数据和封装方法的效果</span></span><br><span class="line">    c11 := Course{<span class="string">"scrapy"</span>, <span class="number">110</span>, <span class="string">"https://www.imooc.com"</span>}</span><br><span class="line">    c11.printCourseInfo()       <span class="comment">// 课程名:scrapy, 课程价格: 200, 课程的地址:https://www.imooc.com</span></span><br><span class="line">    Course.printCourseInfo(c11) <span class="comment">// 课程名:scrapy, 课程价格: 200, 课程的地址:https://www.imooc.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体是值传递，不改变原来的值</span></span><br><span class="line">    c11.setPrice(<span class="number">200</span>)</span><br><span class="line">    <span class="comment">//Course.setPrice(c11, 200)</span></span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">// 110</span></span><br><span class="line">    fmt.Println(c11)       <span class="comment">// {scrapy 110 https://www.imooc.com}</span></span><br><span class="line"></span><br><span class="line">    setPrice1(c11)</span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">// 110</span></span><br><span class="line">    fmt.Println(c11)       <span class="comment">// {scrapy 110 https://www.imooc.com}</span></span><br><span class="line"></span><br><span class="line">    (&amp;c11).setPrice(<span class="number">300</span>)   <span class="comment">//修改c10的price? 为什么呢？ 语法糖 函数参数的传递是怎么传递的？</span></span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">// 110</span></span><br><span class="line"></span><br><span class="line">    c11.setPricePoint(<span class="number">200</span>)</span><br><span class="line">    <span class="comment">//Course.setPricePoint(c11, 200)</span></span><br><span class="line">    fmt.Println(c11.Price)    <span class="comment">// 200</span></span><br><span class="line">    (&amp;c11).setPricePoint(<span class="number">300</span>) <span class="comment">//修改c10的price? 为什么呢？ 语法糖 函数参数的传递是怎么传递的？</span></span><br><span class="line">    fmt.Println(c11.Price)    <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">    (&amp;c11).setPricePoint(<span class="number">400</span>) <span class="comment">//修改c10的price? 为什么呢？ 语法糖 函数参数的传递是怎么传递的？</span></span><br><span class="line">    <span class="comment">// 结构体是值传递</span></span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">// 400</span></span><br><span class="line"></span><br><span class="line">    setPricePoint1(&amp;c11)</span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">// 800</span></span><br><span class="line">    fmt.Println(c11)       <span class="comment">// {scrapy 800 https://www.imooc.com}</span></span><br><span class="line"></span><br><span class="line">    setPricePoint1(*c11)</span><br><span class="line">    fmt.Println(c11.Price) <span class="comment">//</span></span><br><span class="line">    fmt.Println(c11)       <span class="comment">//</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> {</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> { <span class="comment">// 面积</span></span><br><span class="line">    <span class="comment">// c.Radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">    <span class="keyword">return</span> math.Pi * <span class="keyword">float64</span>(c.Radius) * <span class="keyword">float64</span>(c.Radius)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">Circumference</span><span class="params">()</span> <span class="title">float64</span></span> { <span class="comment">// 周长</span></span><br><span class="line">    <span class="comment">// c.Radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * <span class="keyword">float64</span>(c.Radius)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// var c1 Circle</span></span><br><span class="line">    <span class="comment">// c1.Radius = 10.00</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = Circle {Radius: <span class="number">50</span>}</span><br><span class="line">    fmt.Println(c.Area(), c.Circumference())</span><br><span class="line">    <span class="comment">// 7853.981633974483 314.1592653589793</span></span><br><span class="line">    <span class="comment">// 指针变量调用方法形式上是一样的</span></span><br><span class="line">    <span class="keyword">var</span> pc = &amp;c</span><br><span class="line">    fmt.Println(pc.Area(), pc.Circumference())</span><br><span class="line">    <span class="comment">// 7853.981633974483 314.1592653589793</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="结构体指针方法"><a href="#结构体指针方法" class="headerlink" title="结构体指针方法"></a>结构体指针方法</h3><p>鉴于性能的原因，<code>recv</code> 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。</p>
<p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。</p>
<p>结构体指针方法和值方法在调用时形式上是没有区别的，只不过一个可以改变结构体内部状态、类型的属性，而另一个不会。指针方法使用结构体值变量可以调用，值方法使用结构体指针变量也可以调用。<br>通过指针访问内部的字段需要 2 次内存读取操作，第一步是取得指针地址，第二部是读取地址的内容，它比值访问要慢。但是在方法调用时，指针传递可以避免结构体的拷贝操作，结构体比较大时，这种性能的差距就会比较明显。</p>
<p>如果使用上面的方法形式给 Circle 增加一个扩大半径的方法，你会发现半径扩大不了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">expand</span><span class="params">()</span></span> {</span><br><span class="line">  c.Radius *= <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为上面的方法和前面的 expandByValue 函数是等价的，只不过是把函数的第一个参数挪了位置而已，参数传递时会复制了一份结构体内容，起不到扩大半径的效果。这时候就必须要使用结构体的指针方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span> <span class="title">expand</span><span class="params">()</span></span> {</span><br><span class="line">  c.Radius *= <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一些特殊的结构体它不允许被复制，比如结构体内部包含有锁时，这时就必须使用它的指针形式来定义方法，否则会发生一些莫名其妙的问题。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  {</span><br><span class="line">   <span class="keyword">var</span> c Circle</span><br><span class="line">   fmt.Println(c.radius)</span><br><span class="line">   c.radius = <span class="number">10.00</span></span><br><span class="line">   fmt.Println(c.getArea())</span><br><span class="line">   c.changeRadius(<span class="number">20</span>)</span><br><span class="line">   fmt.Println(c.radius)</span><br><span class="line">   change(&amp;c, <span class="number">30</span>)</span><br><span class="line">   fmt.Println(c.radius)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span>  {</span><br><span class="line">   <span class="keyword">return</span> c.radius * c.radius</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 注意如果想要更改成功c的值，这里需要传指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span> <span class="title">changeRadius</span><span class="params">(radius <span class="keyword">float64</span>)</span></span>  {</span><br><span class="line">   c.radius = radius</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作将不生效</span></span><br><span class="line"><span class="comment">//func (c Circle) changeRadius(radius float64)  {</span></span><br><span class="line"><span class="comment">//   c.radius = radius</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">// 引用类型要想改变值需要传指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(c *Circle, radius <span class="keyword">float64</span>)</span></span>  {</span><br><span class="line">   c.radius = radius</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> miniaction <span class="keyword">struct</span> {</span><br><span class="line">    name   <span class="keyword">string</span> <span class="comment">// 接口名称 热销商品，某一个分类下的商品列表</span></span><br><span class="line">    router <span class="keyword">string</span> <span class="comment">// 路由地址 https://api.imooc.com/hotproduct</span></span><br><span class="line">    action <span class="keyword">string</span> <span class="comment">// 路由对应的方法名 func hotproduct() {}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构体增加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mini miniaction)</span> <span class="title">getMiniInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"mini.name=%s,mini.router=%s,mini.action=%s\n"</span>, mini.name, mini.router, mini.action)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构体增加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *miniaction)</span> <span class="title">miniInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"mini.name=%s,mini.router=%s,mini.action=%s\n"</span>, this.name, this.router, this.action)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    mini1 := miniaction{</span><br><span class="line">        name:   <span class="string">"获取商品列表"</span>,</span><br><span class="line">        router: <span class="string">"productList"</span>,</span><br><span class="line">        action: <span class="string">"productList()"</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mini2 := &amp;miniaction{</span><br><span class="line">        name:   <span class="string">"获取分类下的商品列表"</span>,</span><br><span class="line">        router: <span class="string">"productListByCategory"</span>,</span><br><span class="line">        action: <span class="string">"productListByCategory()"</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收者有两种，一种是值类型，一种是指针类型</span></span><br><span class="line">    <span class="comment">//接收者是值类型的时候，调用者可以是值类型，也可以是引用类型</span></span><br><span class="line">    mini1.getMiniInfo()</span><br><span class="line">    <span class="comment">//mini.name=获取商品列表,mini.router=productList,mini.action=productList()</span></span><br><span class="line"></span><br><span class="line">    mini2.getMiniInfo()</span><br><span class="line">    <span class="comment">//mini.name=获取分类下的商品列表,mini.router=productListByCategory,mini.action=productListByCategory()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收者是一个指针类型，调用者可以是值类型，也可以指针类型</span></span><br><span class="line">    mini2.miniInfo()</span><br><span class="line">    <span class="comment">//mini.name=获取分类下的商品列表,mini.router=productListByCategory,mini.action=productListByCategory()</span></span><br><span class="line">    (*mini2).miniInfo()</span><br><span class="line">    <span class="comment">//mini.name=获取分类下的商品列表,mini.router=productListByCategory,mini.action=productListByCategory()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(&amp;mini2).miniInfo() // calling method miniInfo with receiver &amp;mini2 (type **miniaction) requires explicit dereference</span></span><br><span class="line"></span><br><span class="line">    mini1.miniInfo()</span><br><span class="line">    <span class="comment">//mini.name=获取商品列表,mini.router=productList,mini.action=productList()</span></span><br></pre></td></tr></tbody></table></figure>

<p>接收者类型是 *miniaction 的方法 miniInfo()，它能在类型 miniaction 的值上被调用，这是自动间接发生的。</p>
<p>定义的方法只能通过指定的类型来调用，不能像函数一样来调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miniInfo() <span class="comment">// undefined: miniInfo</span></span><br></pre></td></tr></tbody></table></figure>

<p>自定义类型也可以做为方法的接收者</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> float <span class="keyword">float32</span> <span class="comment">// 自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义类型定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(radius float)</span> <span class="title">getCircleAround</span><span class="params">()</span> <span class="title">float</span></span> {</span><br><span class="line">    <span class="keyword">return</span> radius * <span class="number">3.14</span> * <span class="number">2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个自定义的类型并调用方法</span></span><br><span class="line">    <span class="keyword">var</span> radius float = <span class="number">2</span></span><br><span class="line">    fmt.Println(radius.getCircleAround()) <span class="comment">// 12.56</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面的例子：<br><code>change()</code> 接受一个指向 B 的指针，并改变它内部的成员；<br><code>write()</code> 接受通过拷贝接受 B 的值并只输出 B 的内容。<br>注意 Go 为我们做了探测工作，我们自己并没有指出是否在指针上调用方法，Go 替我们做了这些事情。b1 是值而 b2 是指针，方法都支持运行了。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> {</span><br><span class="line">    thing <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">change</span><span class="params">()</span></span> { b.thing = <span class="number">1</span> }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span> <span class="title">write</span><span class="params">()</span> <span class="title">string</span></span> { <span class="keyword">return</span> fmt.Sprint(b) }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> b1 B <span class="comment">// b1是值</span></span><br><span class="line">    b1.change()</span><br><span class="line">    fmt.Println(b1.write()) <span class="comment">// {1}</span></span><br><span class="line"></span><br><span class="line">    b2 := <span class="built_in">new</span>(B) <span class="comment">// b2是指针</span></span><br><span class="line">    b2.change()</span><br><span class="line">    fmt.Println(b2.write()) <span class="comment">// {1}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>试着在 <code>write()</code> 中改变接收者 b 的值：将会看到它可以正常编译，但是开始的 b 没有被改变。</p>
<p>我们知道方法将指针作为接收者不是必须的，如下面的例子，我们只是需要 <code>Point3</code> 的值来做计算：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point3 <span class="keyword">struct</span> { x, y, z <span class="keyword">float64</span> }</span><br><span class="line"><span class="comment">// A method on Point3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point3)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> {</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(p.x*p.x + p.y*p.y + p.z*p.z)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样做稍微有点昂贵，因为 Point3 是作为值传递给方法的，因此传递的是它的拷贝，这在 Go 中合法的。也可以在指向这个类型的指针上调用此方法（会自动解引用）。</p>
<p>假设 p3 定义为一个指针：p3 := &amp;Point{ 3, 4, 5}。</p>
<p>可以使用 p3.Abs() 来替代 (*p3).Abs()。</p>
<p>在值和指针上调用方法：</p>
<p>可以有连接到类型的方法，也可以有连接到类型指针的方法。</p>
<p>但是这没关系：对于类型 T，如果在 *T 上存在方法 Meth()，并且 t 是这个类型的变量，那么 <code>t.Meth()</code> 会被自动转换为 <code>(&amp;t).Meth()</code>。</p>
<p>如下面程序所示，类型 List 在值上有一个方法 Len()，在指针上有一个方法 Append()，但是可以看到两个方法都可以在两种类型的变量上被调用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> List []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l List)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>        { <span class="keyword">return</span> <span class="built_in">len</span>(l) }</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Append</span><span class="params">(val <span class="keyword">int</span>)</span></span> { *l = <span class="built_in">append</span>(*l, val) }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">var</span> lst List</span><br><span class="line">    lst.Append(<span class="number">1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%v (len: %d)"</span>, lst, lst.Len()) <span class="comment">// [1] (len: 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    plst := <span class="built_in">new</span>(List)</span><br><span class="line">    plst.Append(<span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%v (len: %d)"</span>, plst, plst.Len()) <span class="comment">// &amp;[2] (len: 1)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="非结构体类型上方法"><a href="#非结构体类型上方法" class="headerlink" title="非结构体类型上方法"></a>非结构体类型上方法</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片类型</span></span><br><span class="line"><span class="keyword">type</span> intArr []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr intArr)</span> <span class="title">swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    list := intArr{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    fmt.Println(<span class="string">"原始数据："</span>, list)</span><br><span class="line">    list.swap(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="string">"处理后的数据:"</span>, list)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">原始数据： [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">处理后的数据: [<span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="keyword">type</span> intArr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr intArr)</span> <span class="title">swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    list := intArr{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    fmt.Println(<span class="string">"原始数据："</span>, list)</span><br><span class="line">    list.swap(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="string">"处理后的数据:"</span>, list)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">原始数据： [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">处理后的数据: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>为类型绑定方法的时候，所有的接收者 (receiver) 都是采用的值类型的方式。<br>切片是引用数组的内存地址，所以改变后值也改变，而数组这种值类型会拷贝一个新的数组，所以不会影响原数组。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntVector []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v IntVector)</span> <span class="title">Sum</span><span class="params">()</span> <span class="params">(s <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> v {</span><br><span class="line">        s += x</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(IntVector{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}.Sum()) <span class="comment">// 输出是6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *list.List)</span> <span class="title">Iter</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    lst := <span class="built_in">new</span>(list.List)</span><br><span class="line">    <span class="keyword">for</span> _= <span class="keyword">range</span> lst.Iter() {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// lst.Iter undefined (type *list.List has no field or method Iter)</span></span><br></pre></td></tr></tbody></table></figure>

<p>类型和作用在它上面定义的方法必须在同一个包里定义，这就是为什么不能在 int、float 或类似这些的类型上定义方法。<br>试图在 int 类型上定义方法会得到一个编译错误：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m <span class="keyword">int</span>)</span> <span class="title">toString</span><span class="params">()</span></span> {</span><br><span class="line">}</span><br><span class="line"><span class="comment">// cannot define new methods on non-local type int</span></span><br></pre></td></tr></tbody></table></figure>

<p>内置的int类型不能加方法，</p>
<p>类型在其他的，或是非本地的包里定义，在它上面定义方法都会得到和上面同样的错误。</p>
<p>但是有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型，然后再为别名类型定义方法。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myInt)</span> <span class="title">toString</span><span class="params">()</span></span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// T ...</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Println ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Println</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"value: %v"</span>, t)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    t := T(<span class="number">1</span>) <span class="comment">// 除了{}还可以()</span></span><br><span class="line">    t.Println()</span><br><span class="line">    T.Println(t) <span class="comment">// receiver作为函数的第一个参数，这个时候发生值拷贝，</span></span><br><span class="line">    <span class="comment">// 所以方法内部的t变量只是真实t变量的一个拷贝，这和this的含义是不相符的</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">value: <span class="number">1</span></span><br><span class="line">value: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>比如想在 time.Time 上定义如下方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t time.Time)</span> <span class="title">first3Chars</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> time.LocalTime().String()[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myTime <span class="keyword">struct</span> {</span><br><span class="line">    time.Time <span class="comment">//anonymous field</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t myTime)</span> <span class="title">first3Chars</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> t.Time.String()[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    m := myTime{time.Now()}</span><br><span class="line">    <span class="comment">// 调用匿名Time上的String方法</span></span><br><span class="line">    fmt.Println(<span class="string">"Full time now:"</span>, m.String())</span><br><span class="line">    <span class="comment">// 调用myTime.first3Chars</span></span><br><span class="line">    fmt.Println(<span class="string">"First 3 chars:"</span>, m.first3Chars())</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">Full time now: Mon Oct <span class="number">24</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">54</span> Romance Daylight Time <span class="number">2011</span></span><br><span class="line">First <span class="number">3</span> chars: Mon</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test ...</span></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> {</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetA ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Test)</span> <span class="title">SetA</span><span class="params">(a <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    t.A = a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetA1 ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">SetA1</span><span class="params">(a <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    t.A = a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    t := Test{</span><br><span class="line">        A: <span class="number">3</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"demo1:"</span>)</span><br><span class="line">    fmt.Println(t.A)</span><br><span class="line">    t.SetA(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(t.A)</span><br><span class="line">    t1 := Test{</span><br><span class="line">        A: <span class="number">4</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"demo2:"</span>)</span><br><span class="line">    fmt.Println(t1.A)</span><br><span class="line">    (&amp;t1).SetA1(<span class="number">6</span>)</span><br><span class="line">    fmt.Println(t1.A)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">demo1:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">demo2:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>当receiver不是指针时调用SetA其值根本没有改变。</p>
<p>因为Go中都是值传递，所以你如果对SetA的receiver的名称命名为this, self等，它就已经失去了本身的意义——“调用一个对象的方法就是向该对象传递一条消息”。而且对象本身的属性也并不一定会发生改变。</p>
<h3 id="封装的使用"><a href="#封装的使用" class="headerlink" title="封装的使用"></a>封装的使用</h3><h4 id="外部包中的结构体首字母小写"><a href="#外部包中的结构体首字母小写" class="headerlink" title="外部包中的结构体首字母小写"></a>外部包中的结构体首字母小写</h4><p>通过引入外部包小写字母开头的私有的结构体来实现封装，引入了工厂方法来实现</p>
<p>定义一个model包，新建userinfo.go文件，这里我们将结构体userInfo首字母小写</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> {</span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line">    Age       <span class="keyword">int</span></span><br><span class="line">    Height    <span class="keyword">float32</span></span><br><span class="line">    Eduschool <span class="keyword">string</span></span><br><span class="line">    Hobby     []<span class="keyword">string</span></span><br><span class="line">    MoreInfo  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中执行如下代码即会报错</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="comment">//"../model"</span></span><br><span class="line">    <span class="string">"learninggo/model"</span></span><br><span class="line">)</span><br><span class="line">    boge := model.userInfo{</span><br><span class="line">        Name:      <span class="string">"波哥"</span>,</span><br><span class="line">        Age:       <span class="number">18</span>,</span><br><span class="line">        Height:    <span class="number">181</span>,</span><br><span class="line">        Eduschool: <span class="string">"北京邮电大学"</span>,</span><br><span class="line">        Hobby:     []<span class="keyword">string</span>{<span class="string">"coding"</span>, <span class="string">"运动"</span>},</span><br><span class="line">        MoreInfo:  <span class="literal">nil</span>,</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//cannot refer to unexported name model.userInfo</span></span><br></pre></td></tr></tbody></table></figure>

<p>那如果外部包想访问这个结构体，如何来操作，这里就需要引入软件编程设计模式中的工厂模式了，工厂就如同现实中的工厂用于生产产品，在软件工程当中，工厂模式就是用于生成对象。这里建立工厂函数NewUserInfo，习惯以New开头</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式：生成对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserInfo</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>, height <span class="keyword">float32</span>, eduschool <span class="keyword">string</span>, hobby []<span class="keyword">string</span>, moreinfo <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span> *<span class="title">userInfo</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;userInfo{</span><br><span class="line">        Name:      name,</span><br><span class="line">        Age:       age,</span><br><span class="line">        Height:    height,</span><br><span class="line">        Eduschool: eduschool,</span><br><span class="line">        Hobby:     hobby,</span><br><span class="line">        MoreInfo:  moreinfo,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中执行如下代码正确</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boge := model.NewUserInfo(<span class="string">"波哥"</span>, <span class="number">18</span>, <span class="number">181</span>, <span class="string">"北京邮电大学"</span>, []<span class="keyword">string</span>{<span class="string">"coding"</span>, <span class="string">"运动"</span>}, <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">"boge的信息=%v\n"</span>, boge)</span><br><span class="line"><span class="comment">//boge的信息=&amp;{波哥 18 181 北京邮电大学 [coding 运动] map[]}</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="外部包中的结构体字段首字母小写"><a href="#外部包中的结构体字段首字母小写" class="headerlink" title="外部包中的结构体字段首字母小写"></a>外部包中的结构体字段首字母小写</h4><p>字段首字母小写它是非导出的，即外部的包方法无法访问调用。<br>如果包中的结构体中某些变量，我们不希望外部实体直接访问，也就是说对外部的包来说他是一个私有的， 可是我们又想获取或者设置对应的数据，如何操作？<br>前面我们讲解方法接收者时有讲解过，我们可以从面向对象语言特性中得到启发，也就是面向对象中提供的 getter 和 setter 方法。<br>对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名，这样就形成了对我们数据的保护，称为对数据的封装。</p>
<p>通过引入外部包结构体中小写字母开头的私有字段来实现封装，我们引入gettter和setter 方法。</p>
<p>工作中的应用<br>比如产品的价格，我们不希望外部数据直接进行修改，因为这些数据很重要，但是我们可以提供一个接口告知使用者，你想修改我商品的价格，可以，但是必须按我的规定来，比如商品的价格必须在某个范围之内，这些是在接口中事先封装好的，不在这个范围，则拒绝修改。</p>
<p>go语言不支持面向对象，没有构造函数的说法，如果要想达到这个封装的效果 那么就一定要解决 1. 变量的封装 2. 方法的封装</p>
<p>引入前面包的知识，定义一个 model包，新建product.go文件，<br>类型 Product 被明确的导出了，结构体Product中的两个字段首字母小写的字段没有被导出。<br>例如在 main.go 中 p.productName 就是错误的。<br>该如何在另一个程序中修改或者只是读取一个 Product 的名字呢？</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> {</span><br><span class="line">    productName  <span class="keyword">string</span></span><br><span class="line">    productPrice <span class="keyword">float32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter setter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">SetProductName</span><span class="params">(newProductName <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    p.productName = newProductName</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">GetProductName</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> p.productName</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中执行如下代码正确</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"../model"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    product := &amp;model.Product{}</span><br><span class="line">    product.SetProductName(<span class="string">"波哥go语言体系课"</span>)</span><br><span class="line">    fmt.Println(product.GetProductName()) <span class="comment">// 波哥go语言体系课</span></span><br><span class="line"></span><br><span class="line">    p := <span class="built_in">new</span>(model.Product)</span><br><span class="line">    <span class="comment">// p.productName = "Go入门"  // undefined (cannot refer to unexported field or method productName)</span></span><br><span class="line">    p.SetProductName(<span class="string">"Go入门"</span>)</span><br><span class="line">    fmt.Println(p.GetProductName()) <span class="comment">// Go入门</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Receiver是可以为nil的"><a href="#Receiver是可以为nil的" class="headerlink" title="Receiver是可以为nil的"></a>Receiver是可以为nil的</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> {</span><br><span class="line">    v <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(a == <span class="literal">nil</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">testV</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(a.v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a *A</span><br><span class="line">    a.test()</span><br><span class="line">    a.testV()</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal <span class="number">0xc0000005</span> code=<span class="number">0x0</span> addr=<span class="number">0x0</span> pc=<span class="number">0xf7a6f</span>]</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.(*A).testV(...)</span><br></pre></td></tr></tbody></table></figure>

<p>a.test()能够正常输出，只有在处理变量结构体内部变量v才报出panic！！！Receiver是方法的第一个参数，所以仅仅作为参数传递时即使是nil也能够正常调用函数，而在真正使用的地方报出panic。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> {</span><br><span class="line">    Value       <span class="keyword">int</span></span><br><span class="line">    Left, Right *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFunc</span><span class="params">(node Node)</span></span> {</span><br><span class="line">    <span class="comment">//fmt.Print(node.Value, " ")</span></span><br><span class="line">    fmt.Println(node.Value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给结构定义方法</span></span><br><span class="line"><span class="comment">// (node treeNode):接受者 这个参数也是传值</span></span><br><span class="line"><span class="comment">// 和普通函数没有区别</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node Node)</span> <span class="title">PrintMethod</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//fmt.Print(node.Value, " ")</span></span><br><span class="line">    fmt.Println(node.Value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// node是传值，所以修改是没有作用的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node Node)</span> <span class="title">SetValue</span><span class="params">(value <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    node.Value = value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针才可以改变结构内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">SetValuePtr</span><span class="params">(value <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> {</span><br><span class="line">        fmt.Println(<span class="string">"Setting Value to nil "</span> +</span><br><span class="line">            <span class="string">"node. Ignored."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    node.Value = value <span class="comment">// 等同于(*node).Value = value</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;Node{Value: value} <span class="comment">// 返回函数体里面建立一个局部变量的地址</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span> <span class="title">traverse</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.Left.traverse()</span><br><span class="line">    node.PrintMethod()</span><br><span class="line">    node.Right.traverse()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> root Node</span><br><span class="line">    fmt.Println(root) <span class="comment">// {0 &lt;nil&gt; &lt;nil&gt;}</span></span><br><span class="line">    root = Node{Value: <span class="number">3</span>}</span><br><span class="line">    root.Left = &amp;Node{}</span><br><span class="line">    root.Right = &amp;Node{<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>}</span><br><span class="line">    root.Right.Left = <span class="built_in">new</span>(Node)</span><br><span class="line"></span><br><span class="line">    nodes := []Node{</span><br><span class="line">        {Value: <span class="number">3</span>},</span><br><span class="line">        {},</span><br><span class="line">        {<span class="number">6</span>, <span class="literal">nil</span>, &amp;root},</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(nodes) <span class="comment">// [{3 &lt;nil&gt; &lt;nil&gt;} {0 &lt;nil&gt; &lt;nil&gt;} {6 &lt;nil&gt; 0xc00000c080}]</span></span><br><span class="line"></span><br><span class="line">    PrintFunc(root)    <span class="comment">// 3</span></span><br><span class="line">    root.PrintMethod() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    root.Left.Right = CreateNode(<span class="number">2</span>)</span><br><span class="line">    root.SetValue(<span class="number">5</span>)</span><br><span class="line">    fmt.Println(root) <span class="comment">// {3 0xc0000040a8 0xc0000040c0}</span></span><br><span class="line"></span><br><span class="line">    root.SetValuePtr(<span class="number">6</span>)</span><br><span class="line">    fmt.Println(root) <span class="comment">// {6 0xc0000040a8 0xc0000040c0}</span></span><br><span class="line"></span><br><span class="line">    root.PrintMethod() <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    Ptr := &amp;root</span><br><span class="line">    Ptr.PrintMethod() <span class="comment">// 6</span></span><br><span class="line">    Ptr.SetValuePtr(<span class="number">8</span>)</span><br><span class="line">    Ptr.PrintMethod() <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(root) <span class="comment">// {8 0xc0000040a8 0xc0000040c0}</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nil指针可以调用方法 但是会报错，</span></span><br><span class="line">    <span class="keyword">var</span> pRoot *Node</span><br><span class="line">    pRoot.SetValuePtr(<span class="number">1</span>) <span class="comment">// Setting Value to nil node. Ignored.</span></span><br><span class="line">    pRoot = &amp;root</span><br><span class="line">    pRoot.SetValuePtr(<span class="number">2</span>)</span><br><span class="line">    pRoot.PrintMethod() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      2</span></span><br><span class="line"><span class="comment">//   /   \</span></span><br><span class="line"><span class="comment">// 0      5</span></span><br><span class="line"><span class="comment">//  \    /</span></span><br><span class="line"><span class="comment">//   2  0</span></span><br><span class="line"></span><br><span class="line">    root.traverse()</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"imooc.com/ccmouse/learngo/lang/tree"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合扩展类型</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> {</span><br><span class="line">    node *tree.Node <span class="comment">// 包含原有要扩展的类型，然后在他的基础上，扩展自己想要的功能</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.node == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// myTreeNode{myNode.node.Left}.postOrder() // Cannot call a pointer method on 'myTreeNode{myNode.node.Left}'</span></span><br><span class="line"></span><br><span class="line">    left := myTreeNode{myNode.node.Left}</span><br><span class="line">    right := myTreeNode{myNode.node.Right}</span><br><span class="line"></span><br><span class="line">    left.postOrder()</span><br><span class="line">    right.postOrder()</span><br><span class="line">    myNode.node.PrintMethod()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> root tree.Node</span><br><span class="line"></span><br><span class="line">    root = tree.Node{Value: <span class="number">3</span>}</span><br><span class="line">    root.Left = &amp;tree.Node{}</span><br><span class="line">    root.Right = &amp;tree.Node{<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>}</span><br><span class="line">    root.Right.Left = <span class="built_in">new</span>(tree.Node)</span><br><span class="line">    root.Left.Right = tree.CreateNode(<span class="number">2</span>)</span><br><span class="line">    root.Right.Left.SetValuePtr(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Print(<span class="string">"In-order traversal: "</span>)</span><br><span class="line">    root.Traverse()</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    fmt.Print(<span class="string">"My own post-order traversal: "</span>)</span><br><span class="line">    myRoot := myTreeNode{&amp;root}</span><br><span class="line">    myRoot.postOrder()</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    nodeCount := <span class="number">0</span></span><br><span class="line">    root.TraverseFunc(<span class="function"><span class="keyword">func</span><span class="params">(node *tree.Node)</span></span> {</span><br><span class="line">        nodeCount++</span><br><span class="line">    })</span><br><span class="line">    fmt.Println(<span class="string">"Node count:"</span>, nodeCount) <span class="comment">// Node count: 5</span></span><br><span class="line"></span><br><span class="line">    c := root.TraverseWithChannel()</span><br><span class="line">    maxNodeValue := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node := <span class="keyword">range</span> c {</span><br><span class="line">        <span class="keyword">if</span> node.Value &gt; maxNodeValue {</span><br><span class="line">            maxNodeValue = node.Value</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"Max node value:"</span>, maxNodeValue) <span class="comment">// Max node value: 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"imooc.com/ccmouse/learngo/lang/tree"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内嵌 实质上是省略成员名 将成员变量从包中带过来(包括方法和成员变量)</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> {</span><br><span class="line">    *tree.Node <span class="comment">// Embedding</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.Node == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left := myTreeNode{myNode.Node.Left} 类型的最后一个点的后面是他的名字</span></span><br><span class="line">    left := myTreeNode{myNode.Left} <span class="comment">// 也可以直接省略</span></span><br><span class="line">    right := myTreeNode{myNode.Right}</span><br><span class="line"></span><br><span class="line">    left.postOrder()</span><br><span class="line">    right.postOrder()</span><br><span class="line">    myNode.PrintMethod()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//var root tree.Node</span></span><br><span class="line">    <span class="comment">//root = tree.Node{Value: 3}</span></span><br><span class="line"></span><br><span class="line">    root := myTreeNode{&amp;tree.Node{Value: <span class="number">3</span>}}</span><br><span class="line">    root.Left = &amp;tree.Node{}</span><br><span class="line">    root.Right = &amp;tree.Node{<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>}</span><br><span class="line">    root.Right.Left = <span class="built_in">new</span>(tree.Node)</span><br><span class="line">    root.Left.Right = tree.CreateNode(<span class="number">2</span>)</span><br><span class="line">    root.Right.Left.SetValue(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Print(<span class="string">"In-order traversal: "</span>)</span><br><span class="line">    root.Traverse()</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    fmt.Print(<span class="string">"My own post-order traversal: "</span>)</span><br><span class="line">    <span class="comment">//myRoot := myTreeNode{&amp;root}</span></span><br><span class="line">    <span class="comment">//myRoot.postOrder()</span></span><br><span class="line">    root.postOrder()</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//var baseRoot *tree.Node</span></span><br><span class="line">    <span class="comment">// 把子类的指针赋值给一个基类父类的指针，java可以go不可以，go语言要通过接口而不是类的继承实现</span></span><br><span class="line">    <span class="comment">//baseRoot := &amp;root // cannot use &amp;root (type *myTreeNode) as type *tree.Node in assignment</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用别名扩展类型</span></span><br><span class="line"><span class="comment">// A FIFO queue.</span></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pushes the element into the queue.</span></span><br><span class="line"><span class="comment">//         e.g. q.Push(123)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pops element from head.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    head := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if the queue is empty or not.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"imooc.com/ccmouse/learngo/lang/queue"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    q := queue.Queue{<span class="number">1</span>}</span><br><span class="line"></span><br><span class="line">    q.Push(<span class="number">2</span>)</span><br><span class="line">    q.Push(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(q.Pop())     <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(q.Pop())     <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(q.IsEmpty()) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(q.Pop())     <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(q.IsEmpty()) <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/07/go-jie-gou-ti-de-shi-li-hua-he-new-han-shu/" rel="prev" title="go结构体的实例化和new函数">
                  <i class="fa fa-chevron-left"></i> go结构体的实例化和new函数
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/07/go-de-type/" rel="next" title="go的type">
                  go的type <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
