<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。概念的地位和java中接口的地位是不一样Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。 Go 语言的接口是隐式的，只要结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的所有方法一样，那么这个结构体就自动实现了这个接口，就可以使用这个接口变量来指向这个结构体">
<meta property="og:type" content="article">
<meta property="og:title" content="go接口">
<meta property="og:url" content="https://bubbleboy11.github.io/2021/07/08/go-jie-kou/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。概念的地位和java中接口的地位是不一样Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。 Go 语言的接口是隐式的，只要结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的所有方法一样，那么这个结构体就自动实现了这个接口，就可以使用这个接口变量来指向这个结构体">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-07-07T16:21:41.000Z">
<meta property="article:modified_time" content="2021-07-19T01:34:18.709Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2021/07/08/go-jie-kou/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2021/07/08/go-jie-kou/","path":"2021/07/08/go-jie-kou/","title":"go接口"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>go接口 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%A4%9A%E6%80%81"><span class="nav-text">用接口来模拟多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%AE%A9%E7%B1%BB%E5%9E%8B%E5%8E%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">定义接口与类型，让类型去实现接口中的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-text">自定义类型也可以实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-text">空接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-text">接口变量的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-text">接口的组合继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-text">接口变量的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F"><span class="nav-text">指向指针的接口变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%AD%E8%A8%80"><span class="nav-text">接口断言</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">339</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-kou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go接口
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-19 01:34:18" itemprop="dateModified" datetime="2021-07-19T01:34:18Z">2021-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。概念的地位和java中接口的地位是不一样<br>Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。</p>
<p>Go 语言的接口是隐式的，只要结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的所有方法一样，那么这个结构体就自动实现了这个接口，就可以使用这个接口变量来指向这个结构体对象变量</p>
<p>go语言的接口实际上就是python中的协议 - 鸭子类型<br>是一种抽象类型，不能实例化<br>struct是具象，具象能实例化</p>
<p>python语言本身设计上是采用了完全的基于鸭子类型 - 协议 影响了python语法的，例如 for len()</p>
<p>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</p>
<h2 id="用接口来模拟多态"><a href="#用接口来模拟多态" class="headerlink" title="用接口来模拟多态"></a>用接口来模拟多态</h2><p>多态 声明类型的时候你申明的类型是一种兼容类型， 但是实际赋值的时候是另一种类型</p>
<p>定义接口时，方法不能实现<br>一个类型如果实现了接口中的所有方法，我们就说这种类型实现接口，类型不仅仅结构体，也可以是内置类型<br>接口是一种特殊的容器，它可以容纳多种不同的对象，只要这些对象都同样实现了接口定义的方法。如果我们将容纳的对象替换成另一个对象，<br>在go语言当中多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。</p>
<p>使用这种方式模拟多态本质上是<br>结构体组合 属性变量（Name）和 接口变量（Fruitable）来做到的，<br>属性变量是对象的数据，<br>而接口变量是对象的功能，<br>将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<p>自定义类型可以实现多个接口</p>
<p>对已有的类型添加功能，扩充系统类型或别人的类型<br>类型和接口是松耦合的，</p>
<p>其实在python中不需要多态 python是动态语言</p>
<p>组合<br>定义别名<br>使用内嵌来扩展已有类型</p>
<h3 id="定义接口与类型，让类型去实现接口中的方法"><a href="#定义接口与类型，让类型去实现接口中的方法" class="headerlink" title="定义接口与类型，让类型去实现接口中的方法"></a>定义接口与类型，让类型去实现接口中的方法</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> 接口名 <span class="keyword">interface</span> {</span><br><span class="line">        方法名<span class="number">1</span>（参数列表）（返回值）</span><br><span class="line">        方法名<span class="number">2</span>（参数列表）（返回值）</span><br><span class="line">        方法名<span class="number">3</span>（参数列表）（返回值）</span><br><span class="line">        。。。</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 通过自定义类型来实现接口中的所有方法</span></span><br><span class="line"><span class="comment">//定义类型</span></span><br><span class="line">    <span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">type</span> TT <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//方法接收者</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名1<span class="params">()</span>（返回值）</span>{}</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名2<span class="params">()</span>（返回值）</span>{}</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名3<span class="params">()</span>（返回值）</span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中定义一个结构体一个接口pay，增加两个方法topay()，info()</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pay <span class="keyword">interface</span> {</span><br><span class="line">    topay()</span><br><span class="line">    info()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个结构体payment</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> payment <span class="keyword">struct</span> {</span><br><span class="line">    paymentmethod <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>让这个结构体去实现接口pay中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">topay</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"topay:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"info:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义payment类型的变量_payment，就可以通过这个变量去调用接口中的方法了，因为结构体payment实现了接口中所有的方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_payment := &amp;payment{paymentmethod: <span class="string">"alipay"</span>}</span><br><span class="line">_payment.info() <span class="comment">// info: alipay</span></span><br><span class="line">_payment.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>一个变量实现了接口当中所有方法，接口变量就可以指向这个变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _pay pay</span><br><span class="line">_pay = _payment</span><br><span class="line">_pay.info() <span class="comment">// info: alipay</span></span><br><span class="line">_pay.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们一般不这样使用，后面我们会讲解他的使用场景</p>
<h3 id="自定义类型也可以实现接口"><a href="#自定义类型也可以实现接口" class="headerlink" title="自定义类型也可以实现接口"></a>自定义类型也可以实现接口</h3><p>在main.go文件中,定义两个接口<br>写操作接口write</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> {</span><br><span class="line">    echo()</span><br><span class="line">    out()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> read <span class="keyword">interface</span> {</span><br><span class="line">    scan()</span><br><span class="line">    input()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基于内置类型创建自定义类型</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readwrite <span class="keyword">string</span></span><br></pre></td></tr></tbody></table></figure>

<p>自定义的类型readwrite实现上面定义的两个接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">scan</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:scan()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">input</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:input()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go文件中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _readwrite readwrite</span><br><span class="line">_readwrite.echo() <span class="comment">// readwrite:echo()</span></span><br></pre></td></tr></tbody></table></figure>


<p>多重继承可以通过实现多个接口实现，所有的方法都要实现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多重继承格式</span></span><br><span class="line"><span class="keyword">type</span> InterfaceAA <span class="keyword">interface</span> {</span><br><span class="line">    InterfaceA</span><br><span class="line">    InterfaceB</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>综合案例<br>为了巩固面向对象知识点，通过结合面向对象三大特征，综合的对面向对象的知识进行进阶</p>
<p>企业项目中经常涉及到与日志存储的业务，比如针对web项目的日志存储</p>
<p>比如磁盘IO操作的日志:磁盘进行数据拷贝读取一般会有读写日志,记录读取到的位置，即当前数据在磁盘的哪个碰头哪个扇区上</p>
<p>比如网络请求的日志:去访问某个网站一般会有请求日志的记录，用于分析来访客户，刻画出用户的区域，访问兴趣爱好（网购时的一个典型例子,用户浏览记录写cookie）</p>
<p>这里我们模拟一个网络读写日志与磁盘读写日志的例子</p>
<p>定义公共日志结构体Log，做为父类,并为其增加方法writeLog()，传递一个write接口类型的变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> {</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">    addtime <span class="keyword">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">writeLog</span><span class="params">(_write write)</span></span> {</span><br><span class="line">    fmt.Println(l.name + <span class="string">"---"</span> + l.content)</span><br><span class="line">    _write.echo()</span><br><span class="line">    _write.out()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义网络读写结构体与磁盘读写结构体，继承自父类Log</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NetLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IOLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义自定义类型，iowrite与netwrite，分别实现write接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iowrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netwrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:out()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类引用指向子类对象</span></span><br><span class="line"><span class="comment">//一个变量实现了接口当中所有方法，接口就可以指向这个变量</span></span><br><span class="line">log := &amp;Log{</span><br><span class="line">    name:    <span class="string">"微信小程序支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _iowrite *iowrite</span><br><span class="line"><span class="keyword">var</span> _netwrite *netwrite</span><br><span class="line"><span class="comment">//writeLog的参数是一个write类型，我们这里的iowrite实现了write接口中的所有方法，所以可以传递iowrite</span></span><br><span class="line"><span class="comment">//相当于write （指向）-&gt; iowrite</span></span><br><span class="line">log.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeLog的参数是一个write类型，我们这里的netwrite实现了write接口中的所有方法，所以可以传递netwrite</span></span><br><span class="line"><span class="comment">//相当于write （指向）-&gt; netwrite</span></span><br><span class="line">log.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<p>调用者多态的一面</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">netlog := &amp;NetLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序网络支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序网络支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">//writeLog的调用者是Log,我们的NetLog继承自Log，所以可直接调用</span></span><br><span class="line">netlog.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序网络支付日志---微信小程序网络支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br><span class="line"></span><br><span class="line">filelog := &amp;IOLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序文件支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序文件支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">//writeLog的调用者是Log,我们的IOLog继承自Log，所以可直接调用</span></span><br><span class="line">filelog.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序文件支付日志---微信小程序文件支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>如果一个接口里面没有定义任何方法，那么它就是空接口，任意结构体都隐式地实现了空接口。</p>
<p>Go 语言为了避免用户重复定义很多空接口，它自己内置了一个，这个空接口的名字特别奇怪，叫 interface{} ，初学者会非常不习惯。之所以这个类型名带上了大括号，那是在告诉用户括号里什么也没有。我始终认为这种名字很古怪，它让代码看起来有点丑陋。</p>
<p>空接口里面没有方法，所以它也不具有任何能力，其作用相当于 Java和python中 的 Object 类型，可以容纳任意对象，它是一个万能容器。比如一个字典的 key 是字符串，但是希望 value 可以容纳任意类型的对象，这时候就可以使用空接口类型 interface{}。<br>可以把任何类型都赋值给空接口变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">    url   <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> {</span><br><span class="line">    printInfo() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">printInfo</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"课程信息"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="comment">// 判断是不是int类型，是返回ture，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := x.(<span class="keyword">int</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是不是string类型</span></span><br><span class="line">    <span class="keyword">if</span> s, ok := x.(<span class="keyword">string</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, s)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//fmt.Printf("%v\n", i)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print1</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%v(本来值)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>{} <span class="comment">// 空接口</span></span><br><span class="line">    <span class="comment">// 参数传递</span></span><br><span class="line">    i = Course{}</span><br><span class="line">    fmt.Println(i) <span class="comment">// { 0 }</span></span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// 10(整数)</span></span><br><span class="line">    i = <span class="string">"bobby"</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// bobby(字符串)</span></span><br><span class="line">    i = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>}</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// [django scrapy](本来值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空接口可以作为map的值,value可以是任何类型，而不是固定的指定类型</span></span><br><span class="line">    <span class="keyword">var</span> teacherInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">    teacherInfo[<span class="string">"name"</span>] = <span class="string">"bobby"</span></span><br><span class="line">    teacherInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">    teacherInfo[<span class="string">"weight"</span>] = <span class="number">75.2</span></span><br><span class="line">    teacherInfo[<span class="string">"courses"</span>] = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>, <span class="string">"sanic"</span>}</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, teacherInfo) <span class="comment">// map[age:18 courses:[django scrapy sanic] name:bobby weight:75.2]</span></span><br><span class="line">    <span class="comment">//类型断言0-, 接口引入了</span></span><br><span class="line">    <span class="comment">// 接口有一个默认的规范  接口的名称一般以 er 结尾</span></span><br><span class="line">    c := &amp;Course{}</span><br><span class="line">    c.printInfo()</span><br><span class="line">    c1 := Course{}</span><br><span class="line">    c1.printInfo()</span><br><span class="line">    <span class="comment">//var c Printer = Course{}  // 实现了方法可以实例化</span></span><br><span class="line">    <span class="comment">//c.printInfo()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">"address"</span>: <span class="string">"Beijing Tongzhou"</span>,</span><br><span class="line">    <span class="string">"married"</span>: <span class="literal">true</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(user) <span class="comment">// map[age:30 address:Beijing Tongzhou married:true]</span></span><br><span class="line"><span class="comment">// 类型转换语法来了</span></span><br><span class="line"><span class="keyword">var</span> age = user[<span class="string">"age"</span>].(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> address = user[<span class="string">"address"</span>].(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> married = user[<span class="string">"married"</span>].(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(age, address, married) <span class="comment">// 30 Beijing Tongzhou true</span></span><br></pre></td></tr></tbody></table></figure>

<p>user 字典变量的类型是 map[string]interface{}，从这个字典中直接读取得到的 value 类型是 interface{}，需要通过类型转换才能得到期望的变量。</p>
<h2 id="接口变量的本质"><a href="#接口变量的本质" class="headerlink" title="接口变量的本质"></a>接口变量的本质</h2><p>在使用接口时，我们要将接口看成一个特殊的容器，这个容器只能容纳一个对象，只有实现了这个接口类型的对象才可以放进去。</p>
<p>接口变量作为变量来说它也是需要占据内存空间的，通过翻阅 Go 语言的源码可以发现，接口变量也是由结构体来定义的，<br>这个结构体包含两个指针字段，一个字段指向被容纳的对象内存，另一个字段指向一个特殊的结构体 itab，<br>这个特殊的结构体包含了接口的类型信息和被容纳对象的数据类型信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface structure</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> {</span><br><span class="line">  tab *itab  <span class="comment">// 类型指针</span></span><br><span class="line">  data unsafe.Pointer  <span class="comment">// 数据指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> {</span><br><span class="line">  inter *interfacetype <span class="comment">// 接口类型信息</span></span><br><span class="line">  _type *_type <span class="comment">// 数据类型信息</span></span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>既然接口变量只包含两个指针字段，那么它的内存占用应该是 2 个机器字，下面我们来编写代码验证一下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>{}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">int</span> {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(arr))</span><br><span class="line">    s = arr</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></tbody></table></figure>

<p>数组的内存占用是 10 个机器字，但是这丝毫不会影响到接口变量的内存占用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口是一个协议</span></span><br><span class="line"><span class="comment">// 程序员 - 只要你能够 1. 写代码 2. 解决bug 其实就是一组方法的集合</span></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> {</span><br><span class="line">    Coding() <span class="keyword">string</span> <span class="comment">//方法只是申明</span></span><br><span class="line">    Debug() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计师 - 只要你能够 1. 设计</span></span><br><span class="line"><span class="keyword">type</span> Designer <span class="keyword">interface</span> {</span><br><span class="line">    Design() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manger <span class="keyword">interface</span> {</span><br><span class="line">    Programmer <span class="comment">// 接口继承</span></span><br><span class="line">    Designer <span class="comment">// 接口继承</span></span><br><span class="line">    Manage() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java里面一种类型只要继承一个接口 才行 如果你继承了这个接口的话 那么这个接口里面的所有方法你必须要全部实现</span></span><br><span class="line"><span class="keyword">type</span> UIDesigner <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d UIDesigner)</span> <span class="title">Design</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会ui设计"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会ui设计"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于Pythoner这个结构体来说 你实现任何方法都可以，但是你只要不全部实现Coding Debug的话 那你Pythoner就不是一个Programmer类型</span></span><br><span class="line"><span class="comment">// Pythoner本身自己就是一个类型 那我何必在意我是不是Programmer</span></span><br><span class="line"><span class="keyword">type</span> Pythoner <span class="keyword">struct</span> {</span><br><span class="line">    UIDesigner         <span class="comment">// 匿名内嵌接口变量，会python也会设计</span></span><br><span class="line">    lib       []<span class="keyword">string</span> <span class="comment">// 属性变量</span></span><br><span class="line">    framework []<span class="keyword">string</span></span><br><span class="line">    years     <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// go开发者既能开发又能调式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"go开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"go开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会go的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会go的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// python开发者既能开发又能调式还会管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"python开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"python开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会python的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会python的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Manage</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"不好意思，管理我也懂"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"不好意思，管理我也懂"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (p Pythoner) Design() string {</span></span><br><span class="line"><span class="comment">//    fmt.Println("我是一个python开发者，但是我会ui设计")</span></span><br><span class="line"><span class="comment">//    return "我是一个python开发者，但是我会ui设计"</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlePy</span><span class="params">(p Programmer)</span></span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 新的语言出来了, 接口帮我们完成了go语言的多态</span></span><br><span class="line">    <span class="keyword">var</span> pro Programmer = Pythoner{}</span><br><span class="line">    pro.Coding() <span class="comment">// python开发者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pro3 Programmer</span><br><span class="line">    <span class="keyword">var</span> py3 = Pythoner{}</span><br><span class="line">    pro3 = py3</span><br><span class="line">    pro3.Coding() <span class="comment">// python开发者</span></span><br><span class="line">    pro3.Debug()  <span class="comment">// 我会python的debug</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pros []Programmer</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Pythoner{})</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Gopher{})</span><br><span class="line"></span><br><span class="line">    p := Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, p)</span><br><span class="line">    <span class="keyword">var</span> pro1 Programmer = Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, pro1)</span><br><span class="line">    <span class="keyword">var</span> pro2 Programmer = Gopher{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, pro2) <span class="comment">// main.Gopher</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m Manger = Pythoner{}</span><br><span class="line">    m.Design() <span class="comment">// 我会ui设计</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">    eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Fruitable  <span class="comment">// 匿名内嵌接口变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">want</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"I like "</span>)</span><br><span class="line">    f.eat() <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apple)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating apple"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Banana)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating banana"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> f1 = Fruit{<span class="string">"Apple"</span>, Apple{}}</span><br><span class="line">    <span class="keyword">var</span> f2 = Fruit{<span class="string">"Banana"</span>, Banana{}}</span><br><span class="line">    f1.want()</span><br><span class="line">    f2.want()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">I like eating apple</span><br><span class="line">I like eating banana</span><br></pre></td></tr></tbody></table></figure>

<p>使用这种方式模拟多态本质上是通过组合属性变量（Name）和接口变量（Fruitable）来做到的，属性变量是对象的数据，而接口变量是对象的功能，将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<h2 id="接口的组合继承"><a href="#接口的组合继承" class="headerlink" title="接口的组合继承"></a>接口的组合继承</h2><p>go语言中并不支持继承<br>接口的定义也支持组合继承，比如我们可以将两个接口定义合并为一个接口如下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Smellable <span class="keyword">interface</span> {</span><br><span class="line">  smell()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eatable <span class="keyword">interface</span> {</span><br><span class="line">  eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">  Smellable</span><br><span class="line">  Eatable</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时 Fruitable 接口就自动包含了 smell() 和 eat() 两个方法，它和下面的定义是等价的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">  smell()</span><br><span class="line">  eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="接口变量的赋值"><a href="#接口变量的赋值" class="headerlink" title="接口变量的赋值"></a>接口变量的赋值</h2><p>接口变量的赋值浅拷贝</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span> {}</span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line">    a = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rx = a.(Rect)</span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Println(rx)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">{<span class="number">50</span> <span class="number">50</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的输出结果中可以推断出结构体的内存发生了复制，这个复制可能是因为赋值（a = r）也可能是因为类型转换（rx = a.(Rect)），也可能是两者都进行了内存复制。那能不能判断出究竟在接口变量赋值时有没有发生内存复制呢？不好意思，就目前来说我们学到的知识点还办不到。到后面的高级阶段我们将会使用 unsafe 包来洞悉其中的更多细节。不过我可以提前告诉你们答案是什么，那就是两者都会发生数据内存的复制 —— 浅拷贝。</p>
<h2 id="指向指针的接口变量"><a href="#指向指针的接口变量" class="headerlink" title="指向指针的接口变量"></a>指向指针的接口变量</h2><p>如果将上面的例子改成指针，将接口变量指向结构体指针，那结果就不一样了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span> {}</span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line">    a = &amp;r <span class="comment">// 指向了结构体指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rx = a.(*Rect) <span class="comment">// 转换成指针类型</span></span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Println(rx)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">&amp;{<span class="number">100</span> <span class="number">100</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>从输出结果中可以看出指针变量 rx 指向的内存和变量 r 的内存是同一份。因为在类型转换的过程中只发生了指针变量的内存复制，而指针变量指向的内存是共享的。</p>
<h2 id="接口断言"><a href="#接口断言" class="headerlink" title="接口断言"></a>接口断言</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AliOss <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LocalFile <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> AliOss:</span><br><span class="line">        <span class="comment">//此处要做一些特殊的处理，我设置阿里云的权限问题</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    <span class="keyword">case</span> LocalFile:</span><br><span class="line">        <span class="comment">//检查路径的权限</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/08/go-jie-gou-ti-biao-qian/" rel="prev" title="go结构体标签">
                  <i class="fa fa-chevron-left"></i> go结构体标签
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/12/grpc/" rel="next" title="grpc">
                  grpc <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
