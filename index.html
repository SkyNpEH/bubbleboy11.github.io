<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:type" content="website">
<meta property="og:title" content="外心人D的博客">
<meta property="og:url" content="https://bubbleboy11.github.io/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">339</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/go-de-http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/go-de-http/" class="post-title-link" itemprop="url">go的http</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-25 03:12:41" itemprop="dateModified" datetime="2021-07-25T03:12:41Z">2021-07-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Web是基于http协议的一个服务，<br>Go语言里面提供了一个完善的net/http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。<br>同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<h4 id="web工作方式的几个概念"><a href="#web工作方式的几个概念" class="headerlink" title="web工作方式的几个概念"></a>web工作方式的几个概念</h4><p>Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息</p>
<p>Response：服务器需要反馈给客户端的信息</p>
<p>Conn：用户的每次请求链接</p>
<p>Handler：处理请求和生成返回信息的处理逻辑</p>
<h4 id="分析http包运行机制"><a href="#分析http包运行机制" class="headerlink" title="分析http包运行机制"></a>分析http包运行机制</h4><ol>
<li><p>创建Listen Socket, 监听指定的端口, 等待客户端请求到来。</p>
</li>
<li><p>Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。</p>
</li>
<li><p>处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。</p>
</li>
</ol>
<p>编写一个Web服务器很简单，只要调用http包的两个函数就可以了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// HandleFunc将一个普通的函数ServeHTTP包装成Handle</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, ServeHTTP) <span class="comment">//设置访问的路由</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/1.png" alt="description"></p>
<p>Go的http有两个核心功能：Conn、ServeMux</p>
<p>HandlerFunc注册一个处理器事件和绑定路由</p>
<h4 id="Conn的goroutine"><a href="#Conn的goroutine" class="headerlink" title="Conn的goroutine"></a>Conn的goroutine</h4><p>与我们一般编写的http服务器不同, Go为了实现高并发和高性能, 使用了goroutines来处理Conn的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是Go高效的保证。</p>
<p>Go在等待客户端请求里面是这样写的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们可以看到客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，这样保证了每个请求的独立性。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> {</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="ServeMux的定义"><a href="#ServeMux的定义" class="headerlink" title="ServeMux的定义"></a>ServeMux的定义</h4><p>我们前面小节讲述conn.server的时候，其实内部是调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。那么这个路由器是怎么实现的呢？</p>
<p>ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。</p>
<p>它的结构如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux also takes care of sanitizing the URL request path and the Host</span></span><br><span class="line"><span class="comment">// header, stripping the port number and redirecting any request containing . or</span></span><br><span class="line"><span class="comment">// .. elements or repeated slashes to an equivalent, cleaner URL.</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> {</span><br><span class="line">    mu    sync.RWMutex <span class="comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">    m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">    hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames 是否在任意的规则中带有host信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> {</span><br><span class="line">    h       Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">    pattern <span class="keyword">string</span> <span class="comment">// 匹配字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// Handle 注册HTTP处理器 handler 和对应的模式 pattern。</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="comment">// 如果该模式已经注册有一个处理器，Handle会panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> {</span><br><span class="line">    mux.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern == <span class="string">""</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> _, exist := mux.m[pattern]; exist {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mux.m == <span class="literal">nil</span> {</span><br><span class="line">        mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">    }</span><br><span class="line">    e := muxEntry{h: handler, pattern: pattern}</span><br><span class="line">    mux.m[pattern] = e</span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> {</span><br><span class="line">        mux.es = appendSorted(mux.es, e)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> {</span><br><span class="line">        mux.hosts = <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Handler的定义"><a href="#Handler的定义" class="headerlink" title="Handler的定义"></a>Handler的定义</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn't log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> {</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Handler是一个接口，但是下面的sayhelloName函数并没有实现ServeHTTP这个接口，为什么能添加呢？原来在http包里面还定义了一个类型HandlerFunc,我们定义的函数sayhelloName就是这个HandlerFunc调用之后的结果，这个类型默认就实现了ServeHTTP这个接口，即我们调用了HandlerFunc(f)，强制类型转换f成为HandlerFunc类型，这样f就拥有了ServeHTTP方法。</p>
<p>路由器里面存储好了相应的路由规则之后，那么具体的请求又是怎么分发的呢？请看下面的代码，默认的路由器实现了ServeHTTP</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="comment">// ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> {</span><br><span class="line">        <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) {</span><br><span class="line">            w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">        }</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如上所示路由器接收到请求之后，如果是*那么关闭链接，不然调用mux.Handler(r)返回对应设置路由的处理Handler，然后执行h.ServeHTTP(w, r)<br>也就是调用对应路由的handler的ServerHTTP接口，<br>那么mux.Handler(r)怎么处理的呢？</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler returns the handler to use for the given request,</span></span><br><span class="line"><span class="comment">// consulting r.Method, r.Host, and r.URL.Path. It always returns</span></span><br><span class="line"><span class="comment">// a non-nil handler. If the path is not in its canonical form, the</span></span><br><span class="line"><span class="comment">// handler will be an internally-generated handler that redirects</span></span><br><span class="line"><span class="comment">// to the canonical path. If the host contains a port, it is ignored</span></span><br><span class="line"><span class="comment">// when matching handlers.</span></span><br><span class="line"><span class="comment">// Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The path and host are used unchanged for CONNECT requests.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handler also returns the registered pattern that matches the</span></span><br><span class="line"><span class="comment">// request or, in the case of internally-generated redirects,</span></span><br><span class="line"><span class="comment">// the pattern that will match after following the redirect.</span></span><br><span class="line"><span class="comment">// Handler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there is no registered handler that applies to the request,</span></span><br><span class="line"><span class="comment">// Handler returns a ``page not found'' handler and an empty pattern.</span></span><br><span class="line"><span class="comment">// 如果没有已注册模式可以应用于该请求，本方法将返回一个内建的"404 page not found"处理器和一个空字符串模式。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> {</span><br><span class="line">        <span class="comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line">        <span class="comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line">        <span class="comment">// but the path canonicalization does not.</span></span><br><span class="line">        <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All other requests have any port stripped and path cleaned</span></span><br><span class="line">    <span class="comment">// before passing to mux.handler.</span></span><br><span class="line">    host := stripHostPort(r.Host)</span><br><span class="line">    path := cleanPath(r.URL.Path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line">    <span class="comment">// redirect for /tree/.</span></span><br><span class="line">    <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path != r.URL.Path {</span><br><span class="line">        _, pattern = mux.handler(host, path)</span><br><span class="line">        url := *r.URL</span><br><span class="line">        url.Path = path</span><br><span class="line">        <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler is the main implementation of Handler.</span></span><br><span class="line"><span class="comment">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts {</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> {</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> {</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="comment">// HandleFunc注册一个处理器函数handler和对应的模式pattern。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> {</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">    }</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers. If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span> // 基于现有的函数自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Go其实支持外部实现的路由器 ListenAndServe的第二个参数就是用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了Handler接口就可以，我们可以在自己实现的路由器的ServeHTTP里面实现自定义路由功能。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> {</span><br><span class="line">    server := &amp;Server{Addr: addr, Handler: handler}</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Server defines parameters for running an HTTP server.</span></span><br><span class="line"><span class="comment">// The zero value for Server is a valid configuration.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Addr optionally specifies the TCP address for the server to listen on,</span></span><br><span class="line">    <span class="comment">// in the form "host:port". If empty, ":http" (port 80) is used.</span></span><br><span class="line">    <span class="comment">// The service names are defined in RFC 6335 and assigned by IANA.</span></span><br><span class="line">    <span class="comment">// See net.Dial for details of the address format.</span></span><br><span class="line">    Addr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }</span><br></pre></td></tr></tbody></table></figure>

<p>Go 提供了一系列用于创建 Web 服务器的标准库，而且通过 Go 创建一个服务器的 步骤非常简单，只要通过 net/http 包调用 ListenAndServe 函数并传入网络地址以及负责处理请求的处理器( handler )作为参数就可以了。</p>
<p>如果网络地址参数为空字符串，那么服务器默认使用 80 端口进行网络连接；<br>如果处理器参数为 nil，那么服务器将使用默认的多路复用器 DefaultServeMux，</p>
<p>我们也可以通过调用 NewServeMux 函数创建一个多路复用器。<br>多路复用器接收到用户的请求之后根据请求的 URL 来判断使用哪个处理器来处理请求，找到后就会重定向到对应的处理器来处理请求</p>
<h4 id="使用默认的多路复用器（DefaultServeMux）"><a href="#使用默认的多路复用器（DefaultServeMux）" class="headerlink" title="使用默认的多路复用器（DefaultServeMux）"></a>使用默认的多路复用器（DefaultServeMux）</h4><p>使用实现ServerHTTP的类型来自定义的处理器处理请求</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// HandleFunc将一个普通的函数ServeHTTP包装成Handle</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefineServeMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsm *DefineServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 创建自定义的多路复用处理器defineServerMux</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过自定义类型启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//http.HandleFunc("/", ServeHTTP)</span></span><br><span class="line">    defineServeMux := DefineServeMux{}</span><br><span class="line">    http.Handle(<span class="string">"/defineServerMux"</span>, &amp;defineServeMux)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/2.png" alt="description"></p>
<p>使用自己创建的多路复用器</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefineServeMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsm *DefineServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 创建自定义的多路复用处理器defineServerMux</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过自定义类型启动一个http服务"</span>)</span><br><span class="line">    <span class="keyword">if</span> r.URL.Path == <span class="string">"/"</span> {</span><br><span class="line">        sayhelloName(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello myroute!"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, ServeHTTP)</span><br><span class="line">    defineServeMux := DefineServeMux{}</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, &amp;defineServeMux)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/3.png" alt="description"></p>
<h2 id="web请求与响应解析"><a href="#web请求与响应解析" class="headerlink" title="web请求与响应解析"></a>web请求与响应解析</h2><p>Go 语言的 net/http 包提供了一系列用于表示 HTTP 报文的结构，我们可以使用它处理请求和发送相应，<br>其中 Request 结构代表了客户端发送的请求报文<br>Request结构体中的字段可以获取请求报文中的信息.</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Request represents an HTTP request received by a server</span></span><br><span class="line"><span class="comment">// or to be sent by a client.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The field semantics differ slightly between client and server</span></span><br><span class="line"><span class="comment">// usage. In addition to the notes on the fields below, see the</span></span><br><span class="line"><span class="comment">// documentation for Request.Write and RoundTripper.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Method specifies the HTTP method (GET, POST, PUT, etc.).</span></span><br><span class="line">    <span class="comment">// Method指定HTTP方法（GET、POST、PUT等）。</span></span><br><span class="line">    <span class="comment">// For client requests, an empty string means GET.</span></span><br><span class="line">    <span class="comment">// 对客户端，""代表GET。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Go's HTTP client does not support sending a request with</span></span><br><span class="line">    <span class="comment">// the CONNECT method. See the documentation on Transport for</span></span><br><span class="line">    <span class="comment">// details.</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL specifies either the URI being requested (for server</span></span><br><span class="line">    <span class="comment">// requests) or the URL to access (for client requests).</span></span><br><span class="line">    <span class="comment">// URL在服务端表示被请求的URI，在客户端表示要访问的URL。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the URL is parsed from the URI</span></span><br><span class="line">    <span class="comment">// supplied on the Request-Line as stored in RequestURI.  For</span></span><br><span class="line">    <span class="comment">// most requests, fields other than Path and RawQuery will be</span></span><br><span class="line">    <span class="comment">// empty. (See RFC 7230, Section 5.3)</span></span><br><span class="line">    <span class="comment">// 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，</span></span><br><span class="line">    <span class="comment">// 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。</span></span><br><span class="line">    <span class="comment">// （参见RFC 7230, Section 5.3）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, the URL's Host specifies the server to</span></span><br><span class="line">    <span class="comment">// connect to, while the Request's Host field optionally</span></span><br><span class="line">    <span class="comment">// specifies the Host header value to send in the HTTP</span></span><br><span class="line">    <span class="comment">// request.</span></span><br><span class="line">    <span class="comment">// 在客户端，URL的Host字段指定了要连接的服务器，</span></span><br><span class="line">    <span class="comment">// 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。</span></span><br><span class="line">    URL *url.URL</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The protocol version for incoming server requests.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, these fields are ignored. The HTTP</span></span><br><span class="line">    <span class="comment">// client code always uses either HTTP/1.1 or HTTP/2.</span></span><br><span class="line">    <span class="comment">// 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1</span></span><br><span class="line">    <span class="comment">// See the docs on Transport for details.</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Header contains the request header fields either received</span></span><br><span class="line">    <span class="comment">// by the server or to be sent by the client.</span></span><br><span class="line">    <span class="comment">// Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If a server received a request with header lines,</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    Host: example.com</span></span><br><span class="line">    <span class="comment">//    accept-encoding: gzip, deflate</span></span><br><span class="line">    <span class="comment">//    Accept-Language: en-us</span></span><br><span class="line">    <span class="comment">//    fOO: Bar</span></span><br><span class="line">    <span class="comment">//    foo: two</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// then // 则：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    Header = map[string][]string{</span></span><br><span class="line">    <span class="comment">//        "Accept-Encoding": {"gzip, deflate"},</span></span><br><span class="line">    <span class="comment">//        "Accept-Language": {"en-us"},</span></span><br><span class="line">    <span class="comment">//        "Foo": {"Bar", "two"},</span></span><br><span class="line">    <span class="comment">//    }</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For incoming requests, the Host header is promoted to the</span></span><br><span class="line">    <span class="comment">// Request.Host field and removed from the Header map.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// HTTP defines that header names are case-insensitive. The</span></span><br><span class="line">    <span class="comment">// request parser implements this by using CanonicalHeaderKey,</span></span><br><span class="line">    <span class="comment">// making the first character and any characters following a</span></span><br><span class="line">    <span class="comment">// hyphen uppercase and the rest lowercase.</span></span><br><span class="line">    <span class="comment">// HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, certain headers such as Content-Length</span></span><br><span class="line">    <span class="comment">// and Connection are automatically written when needed and</span></span><br><span class="line">    <span class="comment">// values in Header may be ignored. See the documentation</span></span><br><span class="line">    <span class="comment">// for the Request.Write method.</span></span><br><span class="line">    <span class="comment">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。</span></span><br><span class="line">    Header Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Body is the request's body.</span></span><br><span class="line">    <span class="comment">// Body是请求的主体。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, a nil body means the request has no</span></span><br><span class="line">    <span class="comment">// body, such as a GET request. The HTTP Client's Transport</span></span><br><span class="line">    <span class="comment">// is responsible for calling the Close method.</span></span><br><span class="line">    <span class="comment">// 在客户端，如果Body是nil表示该请求没有主体买入GET请求。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段会负责调用Body的Close方法。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the Request Body is always non-nil</span></span><br><span class="line">    <span class="comment">// but will return EOF immediately when no body is present.</span></span><br><span class="line">    <span class="comment">// The Server will close the request body. The ServeHTTP</span></span><br><span class="line">    <span class="comment">// Handler does not need to.</span></span><br><span class="line">    <span class="comment">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。</span></span><br><span class="line">    <span class="comment">// Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Body must allow Read to be called concurrently with Close.</span></span><br><span class="line">    <span class="comment">// In particular, calling Close should unblock a Read waiting</span></span><br><span class="line">    <span class="comment">// for input.</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetBody defines an optional func to return a new copy of</span></span><br><span class="line">    <span class="comment">// Body. It is used for client requests when a redirect requires</span></span><br><span class="line">    <span class="comment">// reading the body more than once. Use of GetBody still</span></span><br><span class="line">    <span class="comment">// requires setting Body.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, it is unused.</span></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContentLength records the length of the associated content.</span></span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度。</span></span><br><span class="line">    <span class="comment">// The value -1 indicates that the length is unknown.</span></span><br><span class="line">    <span class="comment">// 如果为-1，表示长度未知</span></span><br><span class="line">    <span class="comment">// Values &gt;= 0 indicate that the given number of bytes may</span></span><br><span class="line">    <span class="comment">// be read from Body.</span></span><br><span class="line">    <span class="comment">// 如果&gt;=0，表示可以从Body字段读取ContentLength字节数据。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, a value of 0 with a non-nil Body is</span></span><br><span class="line">    <span class="comment">// also treated as unknown.</span></span><br><span class="line">    <span class="comment">// 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TransferEncoding lists the transfer encodings from outermost to</span></span><br><span class="line">    <span class="comment">// innermost. An empty list denotes the "identity" encoding.</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    <span class="comment">// TransferEncoding can usually be ignored; chunked encoding is</span></span><br><span class="line">    <span class="comment">// automatically added and removed as necessary when sending and</span></span><br><span class="line">    <span class="comment">// receiving requests.</span></span><br><span class="line">    <span class="comment">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除"chunked"传输编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close indicates whether to close the connection after</span></span><br><span class="line">    <span class="comment">// replying to this request (for servers) or after sending this</span></span><br><span class="line">    <span class="comment">// request and reading its response (for clients).</span></span><br><span class="line">    <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求和读取响应后关闭连接。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the HTTP server handles this automatically</span></span><br><span class="line">    <span class="comment">// and this field is not needed by Handlers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, setting this field prevents re-use of</span></span><br><span class="line">    <span class="comment">// TCP connections between requests to the same hosts, as if</span></span><br><span class="line">    <span class="comment">// Transport.DisableKeepAlives were set.</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For server requests, Host specifies the host on which the</span></span><br><span class="line">    <span class="comment">// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this</span></span><br><span class="line">    <span class="comment">// is either the value of the "Host" header or the host name</span></span><br><span class="line">    <span class="comment">// given in the URL itself. For HTTP/2, it is the value of the</span></span><br><span class="line">    <span class="comment">// ":authority" pseudo-header field.</span></span><br><span class="line">    <span class="comment">// It may be of the form "host:port". For international domain</span></span><br><span class="line">    <span class="comment">// names, Host may be in Punycode or Unicode form. Use</span></span><br><span class="line">    <span class="comment">// golang.org/x/net/idna to convert it to either format if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="comment">// To prevent DNS rebinding attacks, server Handlers should</span></span><br><span class="line">    <span class="comment">// validate that the Host header has a value for which the</span></span><br><span class="line">    <span class="comment">// Handler considers itself authoritative. The included</span></span><br><span class="line">    <span class="comment">// ServeMux supports patterns registered to particular host</span></span><br><span class="line">    <span class="comment">// names and thus protects its registered Handlers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, Host optionally overrides the Host</span></span><br><span class="line">    <span class="comment">// header to send. If empty, the Request.Write method uses</span></span><br><span class="line">    <span class="comment">// the value of URL.Host. Host may contain an international</span></span><br><span class="line">    <span class="comment">// domain name.</span></span><br><span class="line">    <span class="comment">// 在服务端，Host指定URL会在其上寻找资源的主机。</span></span><br><span class="line">    <span class="comment">// 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。</span></span><br><span class="line">    <span class="comment">// Host的格式可以是"host:port"。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 在客户端，请求的Host字段（可选地）用来重写请求的Host头。</span></span><br><span class="line">    <span class="comment">// 如过该字段为""，Request.Write方法会使用URL字段的Host。</span></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form contains the parsed form data, including both the URL</span></span><br><span class="line">    <span class="comment">// field's query parameters and the PATCH, POST, or PUT form data.</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PostForm contains the parsed form data from PATCH, POST</span></span><br><span class="line">    <span class="comment">// or PUT body parameters.</span></span><br><span class="line">    <span class="comment">// PostForm是解析好的PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores PostForm and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    PostForm url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MultipartForm is the parsed multipart form, including file uploads.</span></span><br><span class="line">    <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseMultipartForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseMultipartForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores MultipartForm and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    MultipartForm *multipart.Form <span class="comment">// multipart 包下 Form 结构的指针类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trailer specifies additional headers that are sent after the request body.</span></span><br><span class="line">    <span class="comment">// Trailer指定了会在请求主体之后发送的额外的头域。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, the Trailer map initially contains only the</span></span><br><span class="line">    <span class="comment">// trailer keys, with nil values. (The client declares which trailers it</span></span><br><span class="line">    <span class="comment">// will later send.)  While the handler is reading from Body, it must</span></span><br><span class="line">    <span class="comment">// not reference Trailer. After reading from Body returns EOF, Trailer</span></span><br><span class="line">    <span class="comment">// can be read again and will contain non-nil values, if they were sent</span></span><br><span class="line">    <span class="comment">// by the client.</span></span><br><span class="line">    <span class="comment">// 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。</span></span><br><span class="line">    <span class="comment">// （客户端会声明哪些trailer会发送）</span></span><br><span class="line">    <span class="comment">// 在处理器从Body读取时，不能使用本字段。</span></span><br><span class="line">    <span class="comment">// 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。</span></span><br><span class="line">    <span class="comment">// （如果客户端发送了这些键值对），此时才可以访问本字段。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For client requests, Trailer must be initialized to a map containing</span></span><br><span class="line">    <span class="comment">// the trailer keys to later send. The values may be nil or their final</span></span><br><span class="line">    <span class="comment">// values. The ContentLength must be 0 or -1, to send a chunked request.</span></span><br><span class="line">    <span class="comment">// After the HTTP request is sent the map values can be updated while</span></span><br><span class="line">    <span class="comment">// the request body is read. Once the body returns EOF, the caller must</span></span><br><span class="line">    <span class="comment">// not mutate Trailer.</span></span><br><span class="line">    <span class="comment">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）</span></span><br><span class="line">    <span class="comment">// ContentLength字段必须是0或-1，以启用"chunked"传输编码发送请求。</span></span><br><span class="line">    <span class="comment">// 在开始发送请求后，Trailer可以在读取请求主体期间被修改，</span></span><br><span class="line">    <span class="comment">// 一旦请求主体返回EOF，调用者就不可再修改Trailer。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Few HTTP clients, servers, or proxies support HTTP trailers.</span></span><br><span class="line">    <span class="comment">// 很少有HTTP客户端、服务端或代理支持HTTP trailer。</span></span><br><span class="line">    Trailer Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RemoteAddr allows HTTP servers and other software to record</span></span><br><span class="line">    <span class="comment">// the network address that sent the request, usually for</span></span><br><span class="line">    <span class="comment">// logging. This field is not filled in by ReadRequest and</span></span><br><span class="line">    <span class="comment">// has no defined format. The HTTP server in this package</span></span><br><span class="line">    <span class="comment">// sets RemoteAddr to an "IP:port" address before invoking a</span></span><br><span class="line">    <span class="comment">// handler.</span></span><br><span class="line">    <span class="comment">// This field is ignored by the HTTP client.</span></span><br><span class="line">    <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。</span></span><br><span class="line">    <span class="comment">// 本字段不是ReadRequest函数填写的，也没有定义格式。</span></span><br><span class="line">    <span class="comment">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为"IP:port"格式的地址。</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的RemoteAddr字段。</span></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestURI is the unmodified request-target of the</span></span><br><span class="line">    <span class="comment">// Request-Line (RFC 7230, Section 3.1.1) as sent by the client</span></span><br><span class="line">    <span class="comment">// to a server. Usually the URL field should be used instead.</span></span><br><span class="line">    <span class="comment">// It is an error to set this field in an HTTP client request.</span></span><br><span class="line">    <span class="comment">// RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI</span></span><br><span class="line">    <span class="comment">// （参见RFC 2616, Section 5.1）</span></span><br><span class="line">    <span class="comment">// 一般应使用URI字段，在客户端设置请求的本字段会导致错误。</span></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS allows HTTP servers and other software to record</span></span><br><span class="line">    <span class="comment">// information about the TLS connection on which the request</span></span><br><span class="line">    <span class="comment">// was received. This field is not filled in by ReadRequest.</span></span><br><span class="line">    <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息</span></span><br><span class="line">    <span class="comment">// 本字段不是ReadRequest函数填写的。</span></span><br><span class="line">    <span class="comment">// The HTTP server in this package sets the field for</span></span><br><span class="line">    <span class="comment">// TLS-enabled connections before invoking a handler;</span></span><br><span class="line">    <span class="comment">// otherwise it leaves the field nil.</span></span><br><span class="line">    <span class="comment">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。</span></span><br><span class="line">    <span class="comment">// This field is ignored by the HTTP client.</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的TLS字段。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cancel is an optional channel whose closure indicates that the client</span></span><br><span class="line">    <span class="comment">// request should be regarded as canceled. Not all implementations of</span></span><br><span class="line">    <span class="comment">// RoundTripper may support Cancel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For server requests, this field is not applicable.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Deprecated: Set the Request's context with NewRequestWithContext</span></span><br><span class="line">    <span class="comment">// instead. If a Request's Cancel field and context are both</span></span><br><span class="line">    <span class="comment">// set, it is undefined whether Cancel is respected.</span></span><br><span class="line">    Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Response is the redirect response which caused this request</span></span><br><span class="line">    <span class="comment">// to be created. This field is only populated during client</span></span><br><span class="line">    <span class="comment">// redirects.</span></span><br><span class="line">    Response *Response</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctx is either the client or server context. It should only</span></span><br><span class="line">    <span class="comment">// be modified via copying the whole Request using WithContext.</span></span><br><span class="line">    <span class="comment">// It is unexported to prevent people from using Context wrong</span></span><br><span class="line">    <span class="comment">// and mutating the contexts held by callers of the same request.</span></span><br><span class="line">    ctx context.Context</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获取请求 URL</p>
<p>Request 结构中的 URL 字段用于表示请求行中包含的 URL，改字段是一个指向 url.URL 结构的指针</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A URL represents a parsed URL (technically, a URI reference).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The general form represented is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [scheme:][//[userinfo@]host][/]path[?query][#fragment]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// URLs that do not start with a slash after the scheme are interpreted as:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    scheme:opaque[?query][#fragment]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.</span></span><br><span class="line"><span class="comment">// A consequence is that it is impossible to tell which slashes in the Path were</span></span><br><span class="line"><span class="comment">// slashes in the raw URL and which were %2f. This distinction is rarely important,</span></span><br><span class="line"><span class="comment">// but when it is, the code should use RawPath, an optional field which only gets</span></span><br><span class="line"><span class="comment">// set if the default encoding is different from Path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// URL's String method uses the EscapedPath method to obtain the path. See the</span></span><br><span class="line"><span class="comment">// EscapedPath method for more details.</span></span><br><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> {</span><br><span class="line">    Scheme      <span class="keyword">string</span></span><br><span class="line">    Opaque      <span class="keyword">string</span>    <span class="comment">// encoded opaque data 编码后的不透明数据</span></span><br><span class="line">    User        *Userinfo <span class="comment">// username and password information</span></span><br><span class="line">    Host        <span class="keyword">string</span>    <span class="comment">// host or host:port</span></span><br><span class="line">    Path        <span class="keyword">string</span>    <span class="comment">// path (relative paths may omit leading slash) 获取请求的 URL</span></span><br><span class="line">    RawPath     <span class="keyword">string</span>    <span class="comment">// encoded path hint (see EscapedPath method)</span></span><br><span class="line">    ForceQuery  <span class="keyword">bool</span>      <span class="comment">// append a query ('?') even if RawQuery is empty</span></span><br><span class="line">    RawQuery    <span class="keyword">string</span>    <span class="comment">// encoded query values, without '?' 编码后的查询字符串，获取请求的 URL 后面?后面的查询字符串，没有'?' </span></span><br><span class="line">    Fragment    <span class="keyword">string</span>    <span class="comment">// fragment for references, without '#'引用的片段（文档位置），没有'#'</span></span><br><span class="line">    RawFragment <span class="keyword">string</span>    <span class="comment">// encoded fragment hint (see EscapedFragment method)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Path 字段</p>
<p> 例如：<a target="_blank" rel="noopener" href="http://luboke.com/hello?username=%E5%85%A8%E6%A0%88%E7%BC%96%E7%A8%8B&amp;password=123456">http://luboke.com/hello?username=全栈编程&amp;password=123456</a><br> 通过 r.URL.Path 只能得到 /hello</p>
<p>RawQuery 字段</p>
<p> 例如：<a target="_blank" rel="noopener" href="http://luboke.com/hello?username=%E5%85%A8%E6%A0%88%E7%BC%96%E7%A8%8B&amp;password=123456">http://luboke.com/hello?username=全栈编程&amp;password=123456</a></p>
<p> 通过 r.URL.RawQuery 得到的是 username=全栈编程&amp;password=123456</p>
<p>获取请求头中的信息<br>通过 Request 结果中的 Header 字段用来获取请求头中的所有信息，Header 字段 的类型是 Header 类型，而 Header 类型是一个 map[string][]string，string 类型的 key， string 切片类型的值。下面是 Header 类型及它的方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Header represents the key-value pairs in an HTTP header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The keys should be in canonical form, as returned by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key. If</span></span><br><span class="line"><span class="comment">// there are no values associated with the key, Get returns "".</span></span><br><span class="line"><span class="comment">// Get返回键对应的第一个值，如果键不存在会返回""。</span></span><br><span class="line"><span class="comment">// It is case insensitive; textproto.CanonicalMIMEHeaderKey is</span></span><br><span class="line"><span class="comment">// used to canonicalize the provided key. To use non-canonical keys,</span></span><br><span class="line"><span class="comment">// access the map directly.</span></span><br><span class="line"><span class="comment">// 如要获取该键对应的值切片，请直接用规范格式的键访问map。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> textproto.MIMEHeader(h).Get(key)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the header entries associated with key to the</span></span><br><span class="line"><span class="comment">// single element value. It replaces any existing values</span></span><br><span class="line"><span class="comment">// associated with key. The key is case insensitive; it is</span></span><br><span class="line"><span class="comment">// canonicalized by textproto.CanonicalMIMEHeaderKey.</span></span><br><span class="line"><span class="comment">// To use non-canonical keys, assign to the map directly.</span></span><br><span class="line"><span class="comment">// Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the key, value pair to the header.</span></span><br><span class="line"><span class="comment">// It appends to any existing values associated with key.</span></span><br><span class="line"><span class="comment">// The key is case insensitive; it is canonicalized by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="comment">// Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del deletes the values associated with key.Del删除键值对。</span></span><br><span class="line"><span class="comment">// The key is case insensitive; it is canonicalized by</span></span><br><span class="line"><span class="comment">// CanonicalHeaderKey.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span></span> {</span><br><span class="line">    textproto.MIMEHeader(h).Del(key)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write writes a header in wire format.Write以有线格式将头域写入w。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">return</span> h.write(w, <span class="literal">nil</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteSubset writes a header in wire format.</span></span><br><span class="line"><span class="comment">// If exclude is not nil, keys where exclude[key] == true are not written.</span></span><br><span class="line"><span class="comment">// Keys are not canonicalized before checking the exclude map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">WriteSubset</span><span class="params">(w io.Writer, exclude <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">return</span> h.writeSubset(w, exclude, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="获取请求头中的某个具体属性的值"><a href="#获取请求头中的某个具体属性的值" class="headerlink" title="获取请求头中的某个具体属性的值"></a>获取请求头中的某个具体属性的值</h4><p>假如需要获取 Accept-Encoding 的值</p>
<p>方式一：r.Header[“Accept-Encoding”]<br>i. 得到的是一个字符串切片<br>ii. 结果<br>[gzip, deflate, br]</p>
<p>方式二：r.Header.Get(“Accept-Encoding”)<br>i. 得到的是字符串形式的值，多个值使用逗号分隔<br>ii. 结果<br>gzip, deflate, br</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP 这里是继承，所以不能改名字ServeHttp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// http:127.0.0.1:8080/?query=bobobo&amp;name=go#fragment</span></span><br><span class="line">    fmt.Fprintln(w, r.URL.RawQuery)</span><br><span class="line">    fmt.Fprintln(w, r.URL.Host)</span><br><span class="line">    fmt.Fprintln(w, r.URL.Path)</span><br><span class="line"></span><br><span class="line">    rawQuery := r.URL.RawQuery</span><br><span class="line">    val, _ := url.ParseQuery(rawQuery)</span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取url当中key为name的值"</span>, val)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取url当中key为name的值"</span>, val.Get(<span class="string">"name"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"通过HandleFunc启动一个http服务"</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"######"</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中的所有信息有："</span>, r.Header)</span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> r.Header {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s:%s\n"</span>, key, r.Header[key])</span><br><span class="line">    }</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"获取Accept-Language的值"</span>, r.Header[<span class="string">"Accept-Language"</span>])</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中Accept-Encoding的信息是："</span>, r.Header[<span class="string">"Accept-Encoding"</span>])</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"请求头中Accept-Encoding的属性值是："</span>, r.Header.Get(<span class="string">"Accept-Encoding"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/geturl"</span>, ServeHTTP)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/4.png" alt="description"></p>
<p>把空格编码成%20，也就是%+2位十六进制数</p>
<p><img src="./go%E7%9A%84http/5.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseQuery parses the URL-encoded query string and returns</span></span><br><span class="line"><span class="comment">// a map listing the values specified for each key.</span></span><br><span class="line"><span class="comment">// ParseQuery always returns a non-nil map containing all the</span></span><br><span class="line"><span class="comment">// valid query parameters found; err describes the first decoding error</span></span><br><span class="line"><span class="comment">// encountered, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Query is expected to be a list of key=value settings separated by</span></span><br><span class="line"><span class="comment">// ampersands or semicolons. A setting without an equals sign is</span></span><br><span class="line"><span class="comment">// interpreted as a key set to an empty value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseQuery</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(Values, error)</span></span> {</span><br><span class="line">    m := <span class="built_in">make</span>(Values)</span><br><span class="line">    err := parseQuery(m, query)</span><br><span class="line">    <span class="keyword">return</span> m, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get gets the first value associated with the given key.</span></span><br><span class="line"><span class="comment">// If there are no values associated with the key, Get returns</span></span><br><span class="line"><span class="comment">// the empty string. To access multiple values, use the map</span></span><br><span class="line"><span class="comment">// directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Values)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    vs := v[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vs) == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>http包建立Web服务器</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form {</span><br><span class="line">        fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">    }</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello 全栈编程@luboke.com !"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这个代码，我们build之后，然后执行web.exe,这个时候其实已经在9090端口监听http链接请求了。</p>
<p>在浏览器输入<a target="_blank" rel="noopener" href="http://localhost:9090/">http://localhost:9090</a></p>
<p><img src="./go%E7%9A%84http/6.png" alt="description"><br><img src="./go%E7%9A%84http/7.png" alt="description"></p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map<span class="comment">[]</span></span><br><span class="line">path /</span><br><span class="line">scheme </span><br><span class="line"><span class="comment">[]</span></span><br><span class="line">map<span class="comment">[]</span></span><br><span class="line">path /favicon.ico</span><br><span class="line">scheme </span><br><span class="line"><span class="comment">[]</span></span><br></pre></td></tr></tbody></table></figure>


<p>换一个地址试试：<a target="_blank" rel="noopener" href="http://localhost:9090/?url_long=111&amp;url_long=222">http://localhost:9090/?url_long=111&amp;url_long=222</a></p>
<p>在服务器端输出的信息如下：</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">map[url_long</span>:<span class="string">[111 222]]</span></span><br><span class="line"><span class="attr">path</span> <span class="string">/</span></span><br><span class="line"><span class="attr">scheme</span> <span class="string"></span></span><br><span class="line"><span class="meta">[111</span> <span class="string">222]</span></span><br><span class="line"><span class="attr">key</span>: <span class="string">url_long</span></span><br><span class="line"><span class="attr">val</span>: <span class="string">111222</span></span><br><span class="line"><span class="attr">map[]</span></span><br><span class="line"><span class="attr">path</span> <span class="string">/favicon.ico</span></span><br><span class="line"><span class="attr">scheme</span> <span class="string"></span></span><br><span class="line"><span class="attr">[]</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="获取请求体中的信息"><a href="#获取请求体中的信息" class="headerlink" title="获取请求体中的信息"></a>获取请求体中的信息</h4><p>请求和响应的主体都是有 Request 结构中的 Body 字段表示，这个字段的类型是 io.ReadCloser 接口，该接口包含了 Reader 接口和 Closer 接口，<br>Reader 接口拥有 Read 方法，<br>Closer 接口拥有 Close 方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadCloser is the interface that groups the basic Read and Close methods.</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> {</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="comment">// Reader接口用于包装基本的读取方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read reads up to len(p) bytes into p.</span></span><br><span class="line"><span class="comment">// Read方法读取len(p)字节数据写入p。</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered.</span></span><br><span class="line"><span class="comment">// 它返回写入的字节数和遇到的任何错误。</span></span><br><span class="line"><span class="comment">// Even if Read returns n &lt; len(p), it may use all of p as scratch space during the call.</span></span><br><span class="line"><span class="comment">// 即使Read方法返回值 n &lt; len(p)，本方法在被调用时仍可能使用p的全部长度作为暂存空间。</span></span><br><span class="line"><span class="comment">// If some data is available but not len(p) bytes, Read conventionally</span></span><br><span class="line"><span class="comment">// returns what is available instead of waiting for more.</span></span><br><span class="line"><span class="comment">// 如果有部分可用数据，但不够len(p)字节，Read按惯例会返回可以读取到的数据，而不是等待更多数据。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When Read encounters an error or end-of-file condition after</span></span><br><span class="line"><span class="comment">// successfully reading n &gt; 0 bytes, it returns the number of</span></span><br><span class="line"><span class="comment">// bytes read. It may return the (non-nil) error from the same call</span></span><br><span class="line"><span class="comment">// or return the error (and n == 0) from a subsequent call.</span></span><br><span class="line"><span class="comment">// An instance of this general case is that a Reader returning</span></span><br><span class="line"><span class="comment">// a non-zero number of bytes at the end of the input stream may</span></span><br><span class="line"><span class="comment">// return either err == EOF or err == nil. The next Read should</span></span><br><span class="line"><span class="comment">// return 0, EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers should always process the n &gt; 0 bytes returned before</span></span><br><span class="line"><span class="comment">// considering the error err. Doing so correctly handles I/O errors</span></span><br><span class="line"><span class="comment">// that happen after reading some bytes and also both of the</span></span><br><span class="line"><span class="comment">// allowed EOF behaviors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations of Read are discouraged from returning a</span></span><br><span class="line"><span class="comment">// zero byte count with a nil error, except when len(p) == 0.</span></span><br><span class="line"><span class="comment">// Callers should treat a return of 0 and nil as indicating that</span></span><br><span class="line"><span class="comment">// nothing happened; in particular it does not indicate EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> {</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="comment">// Writer接口用于包装基本的写入方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line"><span class="comment">// Write方法len(p) 字节数据从p写入底层的数据流。</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line"><span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line"><span class="comment">// 它会返回写入的字节数(0 &lt;= n &lt;= len(p))和遇到的任何导致写入提取结束的错误。</span></span><br><span class="line"><span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line"><span class="comment">// Write必须返回非nil的错误，如果它返回的 n &lt; len(p)。</span></span><br><span class="line"><span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line"><span class="comment">// Write不能修改切片p中的数据，即使临时修改也不行。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> {</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closer is the interface that wraps the basic Close method.</span></span><br><span class="line"><span class="comment">// Closer接口用于包装基本的关闭方法。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The behavior of Close after the first call is undefined.</span></span><br><span class="line"><span class="comment">// 在第一次调用之后再次被调用时，Close方法的的行为是未定义的。</span></span><br><span class="line"><span class="comment">// Specific implementations may document their own behavior.</span></span><br><span class="line"><span class="comment">// 某些实现可能会说明他们自己的行为。</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHTTPBody</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="built_in">len</span> := r.ContentLength</span><br><span class="line">    body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>)</span><br><span class="line">    r.Body.Read(body)</span><br><span class="line">    fmt.Fprintln(w, body, <span class="keyword">string</span>(body))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/getbody"</span>, GetHTTPBody)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -id <span class="string">"action=search&amp;book=the way to go"</span> localhost:8080/getbody</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 22 Jul 2021 03:41:53 GMT</span><br><span class="line">Content-Length: 151</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line"></span><br><span class="line">[97 99 116 105 111 110 61 115 101 97 114 99 104 38 98 111 111 107 61 116 104 101 32 119 97 121 32 116 111 32 103 111]</span><br><span class="line">action=search&amp;book=the way to go</span><br></pre></td></tr></tbody></table></figure>

<p>由于 GET 请求没有请求体，所以我们需要在 HTML 页面中创建一个 form 表单，通过指定 method=”post”来发送一个 POST 请求</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;form action="http://localhost:8080/getBody4" method="POST"&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4?username=胡歌&amp;pwd=huge"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">"波哥"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密 码 ： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">value</span>=<span class="string">"666666"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/8.png" alt="description"><br><img src="./go%E7%9A%84http/9.png" alt="description"></p>
<p>通过 net/http 库中的 Request 结构的字段以及方法获取请求 URL 后面 的请求参数以及 form 表单中提交的请求参数</p>
<p>可以通过Request结构体的 Form 和 PostForm 字段获取请求参数</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Form contains the parsed form data, including both the URL</span></span><br><span class="line">    <span class="comment">// field's query parameters and the PATCH, POST, or PUT form data.</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和PATCH或POST或PUT的表单数据。</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// 本字段只有在调用ParseForm后才有效。</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line">    <span class="comment">// 在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values maps a string key to a list of values.</span></span><br><span class="line"><span class="comment">// Values将建映射到值的列表。</span></span><br><span class="line"><span class="comment">// It is typically used for query parameters and form values.</span></span><br><span class="line"><span class="comment">// 它一般用于查询的参数和表单的属性。</span></span><br><span class="line"><span class="comment">// Unlike in the http.Header map, the keys in a Values map</span></span><br><span class="line"><span class="comment">// are case-sensitive.</span></span><br><span class="line"><span class="comment">// 不同于http.Header这个字典类型，Values的键是大小写敏感的。</span></span><br><span class="line"><span class="keyword">type</span> Values <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseForm populates r.Form and r.PostForm.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For all requests, ParseForm parses the raw query from the URL and updates r.Form.</span></span><br><span class="line"><span class="comment">// ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For POST, PUT, and PATCH requests, it also reads the request body, parses it</span></span><br><span class="line"><span class="comment">// as a form and puts the results into both r.PostForm and r.Form.</span></span><br><span class="line"><span class="comment">//对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。</span></span><br><span class="line"><span class="comment">// Request body parameters take precedence over URL query string values in r.Form.</span></span><br><span class="line"><span class="comment">//解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request Body's size has not already been limited by MaxBytesReader,</span></span><br><span class="line"><span class="comment">// the size is capped at 10MB.</span></span><br><span class="line"><span class="comment">// 如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For other HTTP methods, or when the Content-Type is not</span></span><br><span class="line"><span class="comment">// application/x-www-form-urlencoded, the request Body is not read, and</span></span><br><span class="line"><span class="comment">// r.PostForm is initialized to a non-nil, empty value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ParseMultipartForm calls ParseForm automatically.</span></span><br><span class="line"><span class="comment">// ParseMultipartForm会自动调用ParseForm。</span></span><br><span class="line"><span class="comment">// ParseForm is idempotent.</span></span><br><span class="line"><span class="comment">// 重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseForm</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">"POST"</span> || r.Method == <span class="string">"PUT"</span> || r.Method == <span class="string">"PATCH"</span> {</span><br><span class="line">            r.PostForm, err = parsePostForm(r)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">            r.PostForm = <span class="built_in">make</span>(url.Values)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.PostForm) &gt; <span class="number">0</span> {</span><br><span class="line">            r.Form = <span class="built_in">make</span>(url.Values)</span><br><span class="line">            copyValues(r.Form, r.PostForm)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">var</span> newValues url.Values</span><br><span class="line">        <span class="keyword">if</span> r.URL != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">var</span> e error</span><br><span class="line">            newValues, e = url.ParseQuery(r.URL.RawQuery)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">                err = e</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> newValues == <span class="literal">nil</span> {</span><br><span class="line">            newValues = <span class="built_in">make</span>(url.Values)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">            r.Form = newValues</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            copyValues(r.Form, newValues)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果没有调用ParseForm方法，下面无法获取表单的数据<br>如果form表单的action属性的URL地址中也有与form表单参数名相同的请求参数，<br>那么参数值都可以得到，并且form表单中的参数值在ULR的参数值的前面</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormAndPostForm</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 解析url传递的参数，对于POST则解析响应包的主体（request body）</span></span><br><span class="line">    r.ParseForm()</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.PostForm --&gt;"</span>, r.PostForm)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.Form --&gt;"</span>, r.Form)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/getBody4"</span>, FormAndPostForm)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/10.png" alt="description"></p>
<p>点击提交跳转到指定url<br><img src="./go%E7%9A%84http/11.png" alt="description"></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/12.png" alt="description"></p>
<p>如果对 form 表单做一些修改，在 action 属性的 URL 后面也添加相同的请求参 数</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/getBody4"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/13.png" alt="description"></p>
<p>表单中的请求参数 username 和 URL 中的请求参数 username 都获取到了，而且表单中的请求参数的值排在 URL 请求参 数值的前面</p>
<p>如果此时我们只想获取表单中的请求参数该怎么办呢？那就需要使 用 Request 结构中的 PostForm 字段</p>
<p>Request本身也提供了FormValue()函数来获取用户提交的参数。如r.Form[“username”]也可写成r.FormValue(“username”)。</p>
<p>r.Form里面包含了所有请求的参数，比如URL中query-string、POST的数据、PUT的数据，所以当你在URL中的query-string字段和POST冲突时，会保存成一个slice，里面存储了多个值，Go官方文档中说在接下来的版本里面将会把POST、GET这些数据分离开来。</p>
<p>FormValue方法和PostFormValue方法直接获取请求参数，获取请求参数之前会自动调用ParseForm方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FormValue returns the first value for the named component of the query.</span></span><br><span class="line"><span class="comment">// FormValue返回key为键查询r.Form字段得到结果[]string切片的同名参数中第一个值。</span></span><br><span class="line"><span class="comment">// POST and PUT body parameters take precedence over URL query string values.</span></span><br><span class="line"><span class="comment">// POST和PUT主体中的同名参数优先于URL查询字符串。</span></span><br><span class="line"><span class="comment">// FormValue calls ParseMultipartForm and ParseForm if necessary and ignores</span></span><br><span class="line"><span class="comment">// any errors returned by these functions.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 该方法调用之前 会自动调用 ParseMultipartForm 和 ParseForm 方法对表单进行解析</span></span><br><span class="line"><span class="comment">// If key is not present, FormValue returns the empty string.</span></span><br><span class="line"><span class="comment">// 若参数不存在则返回空字符串。</span></span><br><span class="line"><span class="comment">// To access multiple values of the same key, call ParseForm and</span></span><br><span class="line"><span class="comment">// then inspect Request.Form directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> vs := r.Form[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostFormValue returns the first value for the named component of the POST,</span></span><br><span class="line"><span class="comment">// PATCH, or PUT request body. URL query parameters are ignored.</span></span><br><span class="line"><span class="comment">// PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。</span></span><br><span class="line"><span class="comment">// PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores</span></span><br><span class="line"><span class="comment">// any errors returned by these functions.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 该方法调用之前会自动调用 ParseMultipartForm 和 ParseForm 方法对表单进行解析</span></span><br><span class="line"><span class="comment">// If key is not present, PostFormValue returns the empty string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">PostFormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> vs := r.PostForm[key]; <span class="built_in">len</span>(vs) &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> vs[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/formpostvalue"</span>, FormPostValue)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/formpostvalue"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/16.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/formpostvalue"</span>, FormPostValue)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/17.png" alt="description"></p>
<p>要使表单能够上传文件，首先第一步就是要添加form的enctype属性，enctype属性有如下三种情况:</p>
<p><code>application/x-www-form-urlencoded</code> 表示在发送前编码所有字符（默认）<br><code>multipart/form-data</code> 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。<br><code>text/plain</code> 空格转换为 “+” 加号，但不对特殊字符编码。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/formpostvalue"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line">    f, _, err := r.FormFile(<span class="string">"photo"</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">        dataFromFile, err := ioutil.ReadAll(f)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">            fmt.Fprintf(w, <span class="string">"%s\n"</span>, <span class="keyword">string</span>(dataFromFile))</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            fmt.Fprintf(w, <span class="string">"ioutil.ReadAll(f):%s\n"</span>, err.Error())</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/18.png" alt="description"><br><img src="./go%E7%9A%84http/19.png" alt="description"></p>
<p>但是 PostForm 字段只支持 application/x-www-form-urlencoded 编码，如果 form 表单的 enctype 属性值为 multipart/form-data，那么使用 PostForm 字段 无法获取表单中的数据，<br>为了取得 multipart/form-data 编码的表单数据，我们需要用到 Request 结构的 ParseMultipartForm 方法和 MultipartForm 字段</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParseMultipartForm parses a request body as multipart/form-data.</span></span><br><span class="line"><span class="comment">// ParseMultipartForm将请求的主体作为multipart/form-data解析。</span></span><br><span class="line"><span class="comment">// The whole request body is parsed and up to a total of maxMemory bytes of</span></span><br><span class="line"><span class="comment">// its file parts are stored in memory, with the remainder stored on</span></span><br><span class="line"><span class="comment">// disk in temporary files.</span></span><br><span class="line"><span class="comment">// 请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。</span></span><br><span class="line"><span class="comment">// ParseMultipartForm calls ParseForm if necessary.</span></span><br><span class="line"><span class="comment">// 如果必要，ParseMultipartForm会自行调用ParseForm。</span></span><br><span class="line"><span class="comment">// After one call to ParseMultipartForm, subsequent calls have no effect.</span></span><br><span class="line"><span class="comment">// 重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">ParseMultipartForm</span><span class="params">(maxMemory <span class="keyword">int64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == multipartByReader {</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"http: multipart handled by MultipartReader"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.Form == <span class="literal">nil</span> {</span><br><span class="line">        err := r.ParseForm()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mr, err := r.multipartReader(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    f, err := mr.ReadForm(maxMemory)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r.PostForm == <span class="literal">nil</span> {</span><br><span class="line">        r.PostForm = <span class="built_in">make</span>(url.Values)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> f.Value {</span><br><span class="line">        r.Form[k] = <span class="built_in">append</span>(r.Form[k], v...)</span><br><span class="line">        <span class="comment">// r.PostForm should also be populated. See Issue 9305.</span></span><br><span class="line">        r.PostForm[k] = <span class="built_in">append</span>(r.PostForm[k], v...)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r.MultipartForm = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileHeader describes a file part of a multipart request.</span></span><br><span class="line"><span class="comment">// FileHeader描述一个multipart请求的（一个）文件记录的信息。</span></span><br><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> {</span><br><span class="line">    Filename <span class="keyword">string</span></span><br><span class="line">    Header   textproto.MIMEHeader</span><br><span class="line">    Size     <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields 内含隐藏或非导出字段</span></span><br><span class="line">    content []<span class="keyword">byte</span></span><br><span class="line">    tmpfile <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open opens and returns the FileHeader's associated File.</span></span><br><span class="line"><span class="comment">// Open方法打开并返回其关联的文件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fh *FileHeader)</span> <span class="title">Open</span><span class="params">()</span> <span class="params">(File, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> b := fh.content; b != <span class="literal">nil</span> {</span><br><span class="line">        r := io.NewSectionReader(bytes.NewReader(b), <span class="number">0</span>, <span class="keyword">int64</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">        <span class="keyword">return</span> sectionReadCloser{r}, <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> os.Open(fh.tmpfile)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiPartForm</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 解析表单</span></span><br><span class="line">    r.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    fileHeader := r.MultipartForm.File[<span class="string">"photo"</span>][<span class="number">0</span>]</span><br><span class="line">    f, err := fileHeader.Open()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintln(w, <span class="string">"fileHeader.Open() --&gt;"</span>, err.Error())</span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//dataFromFile, err := ioutil.ReadAll(f)</span></span><br><span class="line">        <span class="comment">//if err != nil {</span></span><br><span class="line">        <span class="comment">//    fmt.Fprintf(w, "%s\n", dataFromFile)</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//// 获取请求参数</span></span><br><span class="line">        <span class="comment">//fmt.Fprintln(w, "r.MultipartForm --&gt;", r.MultipartForm)</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        dataFromFile, err := ioutil.ReadAll(f)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">            <span class="comment">// 浏览器能打开的则直接显示，比如txt</span></span><br><span class="line">            <span class="comment">// 浏览器无法打开的则下载</span></span><br><span class="line">            fmt.Fprintf(w, <span class="string">"%s\n"</span>, <span class="keyword">string</span>(dataFromFile))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"r.MultipartForm --&gt;"</span>, r.MultipartForm)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/multipartform"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/15.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取被上传的文件，但是只能处理上传一个文件的情况。</span></span><br><span class="line"><span class="comment">// FormFile returns the first file for the provided form key.</span></span><br><span class="line"><span class="comment">// FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。</span></span><br><span class="line"><span class="comment">// FormFile calls ParseMultipartForm and ParseForm if necessary.</span></span><br><span class="line"><span class="comment">// 如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。</span></span><br><span class="line"><span class="comment">// 查询失败会返回ErrMissingFile错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">FormFile</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(multipart.File, *multipart.FileHeader, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == multipartByReader {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"http: multipart handled by MultipartReader"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == <span class="literal">nil</span> {</span><br><span class="line">        err := r.ParseMultipartForm(defaultMaxMemory)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm != <span class="literal">nil</span> &amp;&amp; r.MultipartForm.File != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> fhs := r.MultipartForm.File[key]; <span class="built_in">len</span>(fhs) &gt; <span class="number">0</span> {</span><br><span class="line">            f, err := fhs[<span class="number">0</span>].Open()</span><br><span class="line">            <span class="keyword">return</span> f, fhs[<span class="number">0</span>], err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, ErrMissingFile</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenFile is the generalized open call; most users will use Open</span></span><br><span class="line"><span class="comment">// or Create instead. It opens the named file with specified flag</span></span><br><span class="line"><span class="comment">// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag</span></span><br><span class="line"><span class="comment">// is passed, it is created with mode perm (before umask). If successful,</span></span><br><span class="line"><span class="comment">// methods on the returned File can be used for I/O.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> {</span><br><span class="line">    testlog.Open(name)</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A FileMode represents a file's mode and permission bits.</span></span><br><span class="line"><span class="comment">// The bits have the same definition on all systems, so that</span></span><br><span class="line"><span class="comment">// information about files can be moved from one system</span></span><br><span class="line"><span class="comment">// to another portably. Not all bits apply to all systems.</span></span><br><span class="line"><span class="comment">// The only required bit is ModeDir for directories.</span></span><br><span class="line"><span class="keyword">type</span> FileMode = fs.FileMode</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormPostValue</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"FormValue"</span>, r.FormValue(<span class="string">"username"</span>), r.FormValue(<span class="string">"password"</span>), r.FormValue(<span class="string">"website"</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Fprintln(w, <span class="string">"PostFormValue"</span>, r.PostFormValue(<span class="string">"username"</span>), r.PostFormValue(<span class="string">"password"</span>), r.PostFormValue(<span class="string">"website"</span>))</span><br><span class="line"></span><br><span class="line">    f, fh, err := r.FormFile(<span class="string">"photo"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将文件上传到某个文件夹下面，要有名称</span></span><br><span class="line">    <span class="comment">// 0666 当前文件的所属组有读写权限</span></span><br><span class="line">    _file, err := os.OpenFile(<span class="string">"./"</span>+fh.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"os.OpenFile:%s\n"</span>, err.Error())</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> _file.Close()</span><br><span class="line">    <span class="comment">// 将获取的文件拷贝到指定的文件夹下面</span></span><br><span class="line">    copybyte, err := io.Copy(_file, f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"io.Copy:%s\n"</span>, err.Error())</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Copy byte:%d\n"</span>, copybyte)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/20.png" alt="description"></p>
<p>上传文件主要三步处理：</p>
<p>表单中增加enctype=”multipart/form-data”<br>服务端处理文件上传我们需要调用r.ParseMultipartForm，把上传的文件存储在内存和临时文件中<br>里面的参数表示maxMemory最大字节，调用ParseMultipartForm之后，上传的文件存储在maxMemory大小的内存里面，如果文件大小超过了maxMemory，那么剩下的部分将存储在系统的临时文件中。</p>
<p>使用r.FormFile获取文件句柄，然后对文件进行存储等处理。实例中使用了io.Copy来存储文件。</p>
<p>获取其他非文件字段信息的时候就不需要调用r.ParseForm，因为在需要的时候Go自动会去调用。而且ParseMultipartForm调用一次之后，后面再次调用不会再有效果。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy copies from src to dst until either EOF is reached</span></span><br><span class="line"><span class="comment">// on src or an error occurs. It returns the number of bytes</span></span><br><span class="line"><span class="comment">// copied and the first error encountered while copying, if any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A successful Copy returns err == nil, not err == EOF.</span></span><br><span class="line"><span class="comment">// Because Copy is defined to read from src until EOF, it does</span></span><br><span class="line"><span class="comment">// not treat an EOF from Read as an error to be reported.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If src implements the WriterTo interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling src.WriteTo(dst).</span></span><br><span class="line"><span class="comment">// Otherwise, if dst implements the ReaderFrom interface,</span></span><br><span class="line"><span class="comment">// the copy is implemented by calling dst.ReadFrom(src).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>通过 Server 结构对服务器进行更详细的配置<br>Server结构体也定义了实现http的相关方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyDefinitionMux <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyDefinitionMux)</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello 我是波哥,go语言体系课@luboke.com!"</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyDefinitionMux)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"测试通过 Server 结构详细配置服务器"</span>)</span><br><span class="line">    <span class="comment">//h.sayhelloName(w,r)</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    myDefinitionMux := MyDefinitionMux{}</span><br><span class="line">    <span class="comment">//对net/http包中 Server 结构体设置</span></span><br><span class="line">    server := http.Server{</span><br><span class="line">        Addr: <span class="string">":8080"</span>,</span><br><span class="line">        <span class="comment">//自定义handle</span></span><br><span class="line">        Handler:     &amp;myDefinitionMux,</span><br><span class="line">        ReadTimeout: <span class="number">2</span> * time.Second,</span><br><span class="line">    }</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A ResponseWriter interface is used by an HTTP handler to</span></span><br><span class="line"><span class="comment">// construct an HTTP response.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A ResponseWriter may not be used after the Handler.ServeHTTP method</span></span><br><span class="line"><span class="comment">// has returned.</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">// Header returns the header map that will be sent by</span></span><br><span class="line">    <span class="comment">// WriteHeader. The Header map also is the mechanism with which</span></span><br><span class="line">    <span class="comment">// Handlers can set HTTP trailers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Changing the header map after a call to WriteHeader (or</span></span><br><span class="line">    <span class="comment">// Write) has no effect unless the modified headers are</span></span><br><span class="line">    <span class="comment">// trailers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// There are two ways to set Trailers. The preferred way is to</span></span><br><span class="line">    <span class="comment">// predeclare in the headers which trailers you will later</span></span><br><span class="line">    <span class="comment">// send by setting the "Trailer" header to the names of the</span></span><br><span class="line">    <span class="comment">// trailer keys which will come later. In this case, those</span></span><br><span class="line">    <span class="comment">// keys of the Header map are treated as if they were</span></span><br><span class="line">    <span class="comment">// trailers. See the example. The second way, for trailer</span></span><br><span class="line">    <span class="comment">// keys not known to the Handler until after the first Write,</span></span><br><span class="line">    <span class="comment">// is to prefix the Header map keys with the TrailerPrefix</span></span><br><span class="line">    <span class="comment">// constant value. See TrailerPrefix.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To suppress automatic response headers (such as "Date"), set</span></span><br><span class="line">    <span class="comment">// their value to nil.</span></span><br><span class="line">    Header() Header</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write writes the data to the connection as part of an HTTP reply.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If WriteHeader has not yet been called, Write calls</span></span><br><span class="line">    <span class="comment">// WriteHeader(http.StatusOK) before writing the data. If the Header</span></span><br><span class="line">    <span class="comment">// does not contain a Content-Type line, Write adds a Content-Type set</span></span><br><span class="line">    <span class="comment">// to the result of passing the initial 512 bytes of written data to</span></span><br><span class="line">    <span class="comment">// DetectContentType. Additionally, if the total size of all written</span></span><br><span class="line">    <span class="comment">// data is under a few KB and there are no Flush calls, the</span></span><br><span class="line">    <span class="comment">// Content-Length header is added automatically.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Depending on the HTTP protocol version and the client, calling</span></span><br><span class="line">    <span class="comment">// Write or WriteHeader may prevent future reads on the</span></span><br><span class="line">    <span class="comment">// Request.Body. For HTTP/1.x requests, handlers should read any</span></span><br><span class="line">    <span class="comment">// needed request body data before writing the response. Once the</span></span><br><span class="line">    <span class="comment">// headers have been flushed (due to either an explicit Flusher.Flush</span></span><br><span class="line">    <span class="comment">// call or writing enough data to trigger a flush), the request body</span></span><br><span class="line">    <span class="comment">// may be unavailable. For HTTP/2 requests, the Go HTTP server permits</span></span><br><span class="line">    <span class="comment">// handlers to continue to read the request body while concurrently</span></span><br><span class="line">    <span class="comment">// writing the response. However, such behavior may not be supported</span></span><br><span class="line">    <span class="comment">// by all HTTP/2 clients. Handlers should read before writing if</span></span><br><span class="line">    <span class="comment">// possible to maximize compatibility.</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteHeader sends an HTTP response header with the provided</span></span><br><span class="line">    <span class="comment">// status code.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If WriteHeader is not called explicitly, the first call to Write</span></span><br><span class="line">    <span class="comment">// will trigger an implicit WriteHeader(http.StatusOK).</span></span><br><span class="line">    <span class="comment">// Thus explicit calls to WriteHeader are mainly used to</span></span><br><span class="line">    <span class="comment">// send error codes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The provided code must be a valid HTTP 1xx-5xx status code.</span></span><br><span class="line">    <span class="comment">// Only one header may be written. Go does not currently</span></span><br><span class="line">    <span class="comment">// support sending user-defined 1xx informational headers,</span></span><br><span class="line">    <span class="comment">// with the exception of 100-continue response header that the</span></span><br><span class="line">    <span class="comment">// Server sends automatically when the Request.Body is read.</span></span><br><span class="line">    WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResponseData</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">    <span class="comment">//w.Write([]byte("向客户端响应字符串"))</span></span><br><span class="line">    <span class="comment">//    html := `</span></span><br><span class="line">    <span class="comment">//&lt;!DOCTYPE html&gt;</span></span><br><span class="line">    <span class="comment">//&lt;html lang="en"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;head&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;title&gt;Title&lt;/title&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/head&gt;</span></span><br><span class="line">    <span class="comment">//&lt;body&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/getBody4" method="POST"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/getBody4?username=胡歌&amp;pwd=huge" method="POST"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/multipartform" method="POST" enctype="multipart/form-data"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//&lt;form action="http://localhost:8080/formpostvalue" method="POST" enctype="multipart/form-data"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--&lt;form action="http://localhost:8080/formpostvalue" method="POST" enctype="application/x-www-form-urlencoded"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//    用户名： &lt;input type="text" name="username"</span></span><br><span class="line">    <span class="comment">//                value="波哥"&gt;&lt;br/&gt;</span></span><br><span class="line">    <span class="comment">//    密 码 ： &lt;input type="password" name="password"</span></span><br><span class="line">    <span class="comment">//                 value="666666"&gt;&lt;br/&gt;</span></span><br><span class="line">    <span class="comment">//    文件：&lt;input type="file" name="photo"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;!--    文件：&lt;input type="file" name="photo" /&gt;&lt;br/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">//    &lt;input type="submit"&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/form&gt;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&lt;/body&gt;</span></span><br><span class="line">    <span class="comment">//&lt;/html&gt;</span></span><br><span class="line">    <span class="comment">//`</span></span><br><span class="line">    <span class="comment">//w.Write([]byte(html))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">        ID       <span class="keyword">int</span></span><br><span class="line">        Username <span class="keyword">string</span></span><br><span class="line">        Password <span class="keyword">string</span></span><br><span class="line">    }</span><br><span class="line">    user := &amp;User{</span><br><span class="line">        ID:       <span class="number">1</span>,</span><br><span class="line">        Username: <span class="string">"boge"</span>,</span><br><span class="line">        Password: <span class="string">"123456"</span>,</span><br><span class="line">    }</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">    _json, _ := json.Marshal(user)</span><br><span class="line">    w.Write(_json)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    http.HandleFunc(<span class="string">"/responsedata"</span>, ResponseData)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="./go%E7%9A%84http/21.png" alt="description"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/20/go-bao-guan-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/go-bao-guan-li/" class="post-title-link" itemprop="url">go包管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-19 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-19T16:21:41Z">2021-07-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-15 15:22:21" itemprop="dateModified" datetime="2021-07-15T15:22:21Z">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>包管理 1.12之前 go的没有包管理 python java maven go modules</p>
<p>包package：工程项目当中根据不同工作模块建立的不同的文件夹</p>
<p>Go 语言的源码复用建立在包（package）基础之上。<br>Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。</p>
<p>所有与包相关的操作，必须依赖于工作目录（GOPATH）。</p>
<p>任何源代码文件必须属于某个包，<br>一个文件夹目录下的同级文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</p>
<p>源码文件的第一行非注释有效代码必须是 <code>package pacakgeName</code> 语句，指明这个文件属于哪个包</p>
<p>包的习惯用法：</p>
<p>Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。<br>◆ 完整包名组成:引入路径+包名 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。</p>
<p>包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在GOPATH/src/a/b/ 下定义一个包 c。在包 c 的源码中只需声明为package c，而不是声明为package a/b/c，但是在导入 c 包时，需要带上路径，例如import “a/b/c”。</p>
<p>◆ 源代码中的包名称</p>
<ul>
<li>包名一般是小写的，使用一个简短且有意义的名称。</li>
<li>包名一般要和所在的目录文件夹同名，也可以不同，包名中不能包含- 等特殊符号。包与文件夹一一对应</li>
<li>同一个文件夹包下，所有源文件中的package包名是必须一致一样</li>
</ul>
<p>◆ 代码引用时使用包名,而非文件夹名称<br>◆ 源代码导入的是文件夹路径名称 - 非包名 - 非文件名</p>
<p>Go 语言的入口 main() 函数所在的包（package）叫 main，main()只能在main包中使用。main 包想要引用别的代码，必须同样以包的方式进行引用<br>包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。</p>
<p>包AA-&gt;println()<br>包BB-&gt;println()<br>内置built-&gt;println()</p>
<p>.py文件要引用其他的函数或变量，通过文件名称就属于一个包了</p>
<h3 id="可见性-访问控制"><a href="#可见性-访问控制" class="headerlink" title="可见性 访问控制"></a>可见性 访问控制</h3><p>命令一般使用CamelCase，不用 _</p>
<p>一个包中的变量或函数或者结构体结构体定义的 名称 以及内部变量属性的大小写：</p>
<ul>
<li>首字母大写是公开变量或函数，相当于类成员变量的 Public 类别。对于另一个包可见可引用 可以被导出，可以被其他包访问</li>
<li>首字母小写是内部变量或函数，相当于类成员变量的 Private 类别。内部变量只有属于同一个 package（目录）的代码才能直接访问，对于另一个包不可见，不可以被导出，不可以被其他包访问</li>
</ul>
<p>同一个包中，不允许定义相同的变量和函数</p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包目录的路径"</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<p>不要认为是包名，也不可以直接import一个包中的函数或变量</p>
<p>import 导入语句通常放在源码文件开头包声明语句的下面；<br>导入的包名需要使用双引号包裹起来；<br>包名是从 <code>GOPATH/src/</code> 后开始计算的，使用 <code>/</code> 进行路径分隔。</p>
<p>包的导入有两种写法，分别是单行导入和多行导入<br>go引用不是通过文件名而是通过package声明的包名，</p>
<h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包 1 的路径"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包 2 的路径"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"包 1 的路径"</span></span><br><span class="line">    <span class="string">"包 2 的路径"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包的导入路径"><a href="#包的导入路径" class="headerlink" title="包的导入路径"></a>包的导入路径</h2><p>包的引用路径有两种写法，分别是全路径导入和相对路径导入。</p>
<h3 id="全路径导入"><a href="#全路径导入" class="headerlink" title="全路径导入"></a>全路径导入</h3><p>包的绝对路径就是 <code>GOROOT/src/</code>或 <code>GOPATH/src/</code> 后面包的存放路径，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"lab/test"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql/driver"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面代码的含义如下：<br>test 包是自定义的包，其源码位于<code>GOPATH/src/lab/test</code> 目录下；<br>driver 包的源码位于<code>GOROOT/src/database/sql/driver</code> 目录下；<br>sql 包的源码位于<code>GOROOT/src/database/sql</code> 目录下。</p>
<h3 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h3><p>相对路径只能用于导入<code>GOPATH</code> 下的包，标准包的导入只能使用全路径导入。</p>
<p>例如包 a 的所在路径是GOPATH/src/lab/a，包 b 的所在路径为GOPATH/src/lab/b，<br>如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对路径导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../a"</span></span><br></pre></td></tr></tbody></table></figure>

<p>当然了，也可以使用上面的全路径导入，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全路径导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"lab/a"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="包的引用格式"><a href="#包的引用格式" class="headerlink" title="包的引用格式"></a>包的引用格式</h3><h4 id="标准引用格式"><a href="#标准引用格式" class="headerlink" title="标准引用格式"></a>标准引用格式</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="省略引用格式"><a href="#省略引用格式" class="headerlink" title="省略引用格式"></a>省略引用格式</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<p>包名前加点<code>.</code> 相当于把fmt包直接合并到当前程序中，在使用fmt包内的方法是可以不用加前缀<code>fmt.</code>，直接引用。</p>
<h4 id="自定义别名引用格式-给包取别名"><a href="#自定义别名引用格式-给包取别名" class="headerlink" title="自定义别名引用格式 给包取别名"></a>自定义别名引用格式 给包取别名</h4><p>在导入包的时候，我们还可以为导入的包设置别名，如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中 F 就是 fmt 包的别名，使用时我们可以使用<code>F.</code>来代替标准引用格式的<code>fmt.</code>来作为前缀使用 fmt 包中的方法。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> F <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    F.Println(<span class="string">"C语言中文网"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当add1和add2都有同名的Add函数，给包取别名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    int_add <span class="string">"lang/add1"</span></span><br><span class="line">    float_add <span class="string">"lang/add2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   fmt.Println(int_add.Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">   fmt.Println(float_add.Add(<span class="number">1.0</span>, <span class="number">2.0</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="为结构体定义的方法必须在一个包内"><a href="#为结构体定义的方法必须在一个包内" class="headerlink" title="为结构体定义的方法必须在一个包内"></a>为结构体定义的方法必须在一个包内</h3><p>GO的面向对象使用结构体来做的，对一个结构体可以定义很多方法。</p>
<p>因为需要封装的原因，所以一个结构体中的方法必须在一个包内定义。也就是说，如果结构体定义在了包A中，那么它对应的方法也必须都定义在包A中，不可以在别的包中定义，这样就破坏了封装的概念。但是可以是不同的文件，即可以在同一个包中的不同源文件中定义结构体的方法。</p>
<h3 id="匿名引用格式"><a href="#匿名引用格式" class="headerlink" title="匿名引用格式"></a>匿名引用格式</h3><p>导包<code>_</code>的作用是:当导入一个包的时候，该包的init和其他函数都会被导入，go语言编译器会自动调用，init函数自动执行，不需要显示调用<br>在定义的时候不能有任何的参数与返回值<br>匿名引用导入包使用也不会报错<br>引用某个包时,如果只是希望执行包初始化的init函数,而不使用包内部的数据时,可以使用匿名引用格，也会和其他包一样编译到可执行文件中</p>
<ul>
<li><p>一般用于初始化工具，比如连接数据库</p>
</li>
<li><p>一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。</p>
</li>
<li><p>包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。</p>
</li>
<li><p>包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。</p>
</li>
</ul>
<p>在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。</p>
<p>Go语言包的初始化有如下特点：<br>包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。<br>Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。</p>
<p>-当前包引入其他包，优先调用其他包的全局变量，init()函数（如果其他包也调用 了init()函数，则继续向上调用），再调用本包的init()函数</p>
<p>单个包的初始化过程执行顺序:初始化常量–》全局变量-》init()-&gt;main)()</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">   fmt.Println(<span class="string">"init初始化"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="本地包的使用"><a href="#本地包的使用" class="headerlink" title="本地包的使用"></a>本地包的使用</h3><p>action/productActino.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> action</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//public</span></span><br><span class="line"><span class="keyword">var</span> Product <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//private</span></span><br><span class="line"><span class="keyword">var</span> product <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductList</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"action-&gt;ProductList()"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productList</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"action-&gt;productList()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>practice_package/main.go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="comment">//"function"</span></span><br><span class="line">    <span class="string">"learninggo/action"</span></span><br><span class="line">    <span class="string">"learninggo/model"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//function.Println("hello 波哥")</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(action.Product) <span class="comment">// 0</span></span><br><span class="line">    action.ProductList() <span class="comment">// action-&gt;ProductList()</span></span><br><span class="line">    <span class="comment">//action.productList()</span></span><br><span class="line"></span><br><span class="line">    bobo := model.UserInfo{</span><br><span class="line">        Name:      <span class="string">"波哥"</span>,</span><br><span class="line">        Age:       <span class="number">18</span>,</span><br><span class="line">        Height:    <span class="number">182.32</span>,</span><br><span class="line">        Eduschool: <span class="string">"北京邮电大学"</span>,</span><br><span class="line">        Hobby:     []<span class="keyword">string</span>{<span class="string">"coding"</span>, <span class="string">"旅行"</span>, <span class="string">"读书"</span>, <span class="string">"运动"</span>},</span><br><span class="line">        MoreInfo: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">            <span class="string">"work"</span>: <span class="string">"百度"</span>,</span><br><span class="line">            <span class="string">"duty"</span>: <span class="string">"产品狗"</span>,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println(bobo.MoreInfo[<span class="string">"work"</span>]) <span class="comment">// 百度</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/19/gin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/19/gin/" class="post-title-link" itemprop="url">gin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-18 17:46:44" itemprop="dateCreated datePublished" datetime="2021-07-18T17:46:44Z">2021-07-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-10 11:32:17" itemprop="dateModified" datetime="2021-07-10T11:32:17Z">2021-07-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/16/go-bi-bao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/16/go-bi-bao/" class="post-title-link" itemprop="url">go闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-15 16:21:41 / 修改时间：15:19:15" itemprop="dateCreated datePublished" datetime="2021-07-15T16:21:41Z">2021-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<p>闭包</p>
<p>是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：<br><strong>函数 + 引用环境 = 闭包</strong></p>
<p>同一个函数与不同引用环境组合，可以形成不同的实例</p>
<p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，<br>函数是编译期静态的概念，而闭包是运行期动态的概念。</p>
<p>首先他是一个函数，是函数与函数外部数据的引用（在函数体内部引用到了函数体外部的数据）</p>
<h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span> <span class="comment">// 准备一个字符串</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">// 创建一个匿名函数</span></span><br><span class="line">    <span class="comment">// 在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包，匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"hello dude"</span></span><br><span class="line">}</span><br><span class="line">foo() <span class="comment">// 调用匿名函数，执行闭包，此时 str 发生修改</span></span><br><span class="line">fmt.Println(str) <span class="comment">// hello dude</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h4><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p>
<p>累加器的实现：<br>创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。</span></span><br><span class="line"><span class="comment">// 提供一个值, 每次调用函数会指定对值进行累加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="comment">// 返回一个闭包函数，每次返回会创建一个新的函数实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        <span class="comment">// 对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</span></span><br><span class="line">        value++</span><br><span class="line">        <span class="comment">// 将修改后的值通过闭包的返回值返回一个累加值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建一个累加器，初始值为1，返回的 accumulator 是类型为 func()int 的函数变量。</span></span><br><span class="line">    accumulator := Accumulate(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator) <span class="comment">// 0xc000006018</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个累加器，初始值为1，返回的 accumulator 是类型为 func()int 的函数变量。</span></span><br><span class="line">    accumulator1 := Accumulate(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 调用 accumulator() 时，代码 return func() int 开始执行匿名函数逻辑，直到 return value 返回。累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator1()) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(accumulator1()) <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator1) <span class="comment">// 0xc000006028</span></span><br><span class="line">    <span class="comment">// 创建一个累加器, 初始值为10</span></span><br><span class="line">    accumulator2 := Accumulate(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator2()) <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;accumulator2) <span class="comment">//0xc000006038</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对比输出的日志发现 accumulator 与 accumulator1 与 accumulator2 输出的函数地址不同，因此它们是不同的闭包实例。</p>
<p>每调用一次 accumulator 都会自动对引用的变量进行累加。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber()) <span class="comment">// 1</span></span><br><span class="line">   fmt.Println(nextNumber()) <span class="comment">// 2</span></span><br><span class="line">   fmt.Println(nextNumber()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()</span><br><span class="line">   fmt.Println(nextNumber1()) <span class="comment">// 1</span></span><br><span class="line">   fmt.Println(nextNumber1()) <span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以一个例子来定义一个闭包，该闭包函数每调用一次，让值加1</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clousure</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int64</span>)</span> <span class="title">int64</span></span> {</span><br><span class="line">    <span class="keyword">var</span> step <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(_step <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> {</span><br><span class="line">        step += _step</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    func2 := clousure()</span><br><span class="line">    fmt.Println(func2(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(func2(<span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(func2(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分析执行结果<br>闭包函数每次调用，均保留上次的执行结果，并参与下一次调用时候的运算</p>
<p>同一个包中，函数不支持重载即不能有相同的函数名</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/15/go-zuo-yong-yu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/15/go-zuo-yong-yu/" class="post-title-link" itemprop="url">go作用域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-14 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-14T16:21:41Z">2021-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-15 10:22:23" itemprop="dateModified" datetime="2021-07-15T10:22:23Z">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。</p>
<p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。<br>作用域（Scope）为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。权限的概念，可见性就是变量可以在哪个范围以内使用。有些变量可以在所有代码文件中使用，有些变量只能在当前的文件中使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。</p>
<p>Go 语言中变量可以在三个地方声明：</p>
<h3 id="局部变量-（Local-Variable）"><a href="#局部变量-（Local-Variable）" class="headerlink" title="局部变量 （Local Variable）"></a>局部变量 （Local Variable）</h3><p>函数体内定义的变量，作用域只在函数体内有效，在函数外部是不可知的。<br>函数的参数和返回值变量也是局部变量。<br>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量定义的内存空间就会被释放。销毁。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明局部变量 */</span></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化参数 */</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"结果： a = %d, b = %d and c = %d\n"</span>, a, b, c)</span><br><span class="line"><span class="comment">// 结果： a = 10, b = 20 and c = 30</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外定义声明的变量，全局变量只需要在一个源文件中定义声明后，就可以在整个程序所有源文件中使用，<br>可以在整个包甚至外部包（被导出后）不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。<br>在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">    <span class="comment">/* 初始化参数 */</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    g = a + b</span><br><span class="line">    fmt.Printf(<span class="string">"结果： a = %d, b = %d and g = %d\n"</span>, a, b, g)</span><br><span class="line">    <span class="comment">// 结果： a = 10, b = 20 and g = 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> g <span class="keyword">int</span> = <span class="number">30</span></span><br><span class="line">    fmt.Printf(<span class="string">"结果： g = %d\n"</span>, g) <span class="comment">// 结果： g = 30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量<br>会作为函数体内的局部变量。<br>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。<br>如果与全局变量同名它们会优先使用。</p>
<p>形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p>
<h4 id="函数值传递"><a href="#函数值传递" class="headerlink" title="函数值传递"></a>函数值传递</h4><p>指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">/* main 函数中声明局部变量 */</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"main()函数中 a = %d\n"</span>, a)</span><br><span class="line">    <span class="comment">// main()函数中 a = 10</span></span><br><span class="line">    c = sum(a, b)</span><br><span class="line">    <span class="comment">// sum() 函数中 a = 10</span></span><br><span class="line">    <span class="comment">// sum() 函数中 b = 20</span></span><br><span class="line">    fmt.Printf(<span class="string">"main()函数中 c = %d\n"</span>, c)</span><br><span class="line">    <span class="comment">// main()函数中 c = 30</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义-两数相加 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"sum() 函数中 a = %d\n"</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">"sum() 函数中 b = %d\n"</span>, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testScope</span><span class="params">(args <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    args = <span class="number">100</span></span><br><span class="line">    fmt.Println(args)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args <span class="keyword">int</span></span><br><span class="line">    testScope(args) <span class="comment">// 100</span></span><br><span class="line">    fmt.Println(args) <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(params ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> params {</span><br><span class="line">        sum += v</span><br><span class="line">    }</span><br><span class="line">    params[<span class="number">0</span>] = <span class="number">9</span> <span class="comment">// 值传递不影响</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数引用传递"><a href="#函数引用传递" class="headerlink" title="函数引用传递"></a>函数引用传递</h4><p>在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>引用传递指针参数传递到函数内，</p>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>在程序运行期间变量有效存在的时间间隔。</p>
<p>变量的生命周期与变量的作用域有着不可分割的联系：</p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">        blackIndex, <span class="comment">// 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span></span><br><span class="line">    )               <span class="comment">// 小括号另起一行缩进，和大括号的风格保存一致</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，在每次循环的开始会创建临时变量 t，然后在每次循环迭代中创建临时变量 x 和 y。临时变量 x、y 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/14/go-di-gui-han-shu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/14/go-di-gui-han-shu/" class="post-title-link" itemprop="url">go递归函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-13 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-13T16:21:41Z">2021-07-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-15 02:48:35" itemprop="dateModified" datetime="2021-07-15T02:48:35Z">2021-07-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>递归函数指的是在运行的过程中函数内部调用函数自身的函数，<br>从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，</p>
<p>递归函数 在一个循环体当中执行，必须有一个条件可以在满足某个条件时终止当前的循环，否则为死循环</p>
<p>构成递归需要具备以下条件：</p>
<ul>
<li>一个问题可以被拆分成多个子问题；</li>
<li>拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；</li>
<li>不能无限制的调用本身，子问题需要有退出递归状态的条件。<br>注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> {</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   recursion()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>位置     值<br>1        1<br>2        1<br>3        2<br>4        3<br>..    ..<br>n    func(n-1) + func(n-2)</p>
<p>传递一个位置，返回当前位置的值</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf(<span class="string">"fibonacci(%d) is: %d\n"</span>, i, result)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> {</span><br><span class="line">        res = <span class="number">1</span> <span class="comment">// res = n</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        res = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> {</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">fibonacci(<span class="number">1</span>) is: <span class="number">1</span></span><br><span class="line">fibonacci(<span class="number">2</span>) is: <span class="number">1</span></span><br><span class="line">fibonacci(<span class="number">3</span>) is: <span class="number">2</span></span><br><span class="line">fibonacci(<span class="number">4</span>) is: <span class="number">3</span></span><br><span class="line">fibonacci(<span class="number">5</span>) is: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a>数字阶乘</h3><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作n!</p>
<p>例如，n!=1×2×3×…×n，阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p>
<p>使用递归函数计算给定数的阶乘，示例代码如下所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">uint64</span>)</span> <span class="params">(result <span class="keyword">uint64</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> {</span><br><span class="line">        result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d 的阶乘是 %d\n"</span>, i, Factorial(<span class="keyword">uint64</span>(i)))</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">10</span> 的阶乘是 <span class="number">3628800</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多个函数组成递归"><a href="#多个函数组成递归" class="headerlink" title="多个函数组成递归"></a>多个函数组成递归</h3><p>Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%d is even: is %t\n"</span>, <span class="number">16</span>, even(<span class="number">16</span>)) <span class="comment">// 16 is even: is true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d is odd: is %t\n"</span>, <span class="number">17</span>, odd(<span class="number">17</span>))</span><br><span class="line">    <span class="comment">// 17 is odd: is true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d is odd: is %t\n"</span>, <span class="number">18</span>, odd(<span class="number">18</span>))</span><br><span class="line">    <span class="comment">// 18 is odd: is false</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">even</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> odd(RevSign(nr) - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">odd</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr == <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> even(RevSign(nr) - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RevSign</span><span class="params">(nr <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">if</span> nr &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">return</span> -nr</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nr</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line"><span class="number">16</span> is even: is <span class="literal">true</span></span><br><span class="line"><span class="number">17</span> is odd: is <span class="literal">true</span></span><br><span class="line"><span class="number">18</span> is odd: is <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/12/grpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/grpc/" class="post-title-link" itemprop="url">grpc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-11 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-11T16:21:41Z">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-09 13:17:33" itemprop="dateModified" datetime="2021-07-09T13:17:33Z">2021-07-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>go语言的包以及编码规范 </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-kou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-jie-kou/" class="post-title-link" itemprop="url">go接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-19 02:37:59" itemprop="dateModified" datetime="2021-07-19T02:37:59Z">2021-07-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。概念的地位和java中接口的地位是不一样<br>Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。</p>
<p>Go 语言的接口是隐式的，只要结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的所有方法一样，那么这个结构体就自动实现了这个接口，就可以使用这个接口变量来指向这个结构体对象变量</p>
<p>go语言的接口实际上就是python中的协议 - 鸭子类型<br>是一种抽象类型，不能实例化<br>struct是具象，具象能实例化</p>
<p>python语言本身设计上是采用了完全的基于鸭子类型 - 协议 影响了python语法的，例如 for len()</p>
<p>单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。</p>
<h2 id="用接口来模拟多态"><a href="#用接口来模拟多态" class="headerlink" title="用接口来模拟多态"></a>用接口来模拟多态</h2><p>定义接口时，方法不能实现<br>一个类型如果实现了接口中的所有方法，我们就说这种类型实现接口，类型不仅仅结构体，也可以是内置类型<br>这个类型的实例可以赋给它所实现的任意接口类型的变量，接口变量就可以指向这个变量</p>
<p>多态 声明类型的时候你申明的类型是一种兼容类型， 但是实际赋值的时候是另一种类型</p>
<p>接口是一种特殊的容器，它可以容纳多种不同的对象，只要这些对象都同样实现了接口定义的方法。如果我们将容纳的对象替换成另一个对象，</p>
<p>使用这种方式模拟多态本质上是<br>结构体组合 属性变量（Name）和 接口变量（Fruitable）来做到的，<br>属性变量是对象的数据，<br>而接口变量是对象的功能，<br>将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<p>自定义类型可以实现多个接口</p>
<p>对已有的类型添加功能，扩充系统类型或别人的类型<br>类型和接口是松耦合的，</p>
<p>其实在python中不需要多态 python是动态语言</p>
<p>组合<br>定义别名<br>使用内嵌来扩展已有类型</p>
<h3 id="定义接口与类型，让类型去实现接口中的方法"><a href="#定义接口与类型，让类型去实现接口中的方法" class="headerlink" title="定义接口与类型，让类型去实现接口中的方法"></a>定义接口与类型，让类型去实现接口中的方法</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> {</span><br><span class="line">    方法名<span class="number">1</span>（参数列表）（返回值）</span><br><span class="line">    方法名<span class="number">2</span>（参数列表）（返回值）</span><br><span class="line">    方法名<span class="number">3</span>（参数列表）（返回值）</span><br><span class="line">    。。。</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 通过自定义类型来实现接口中的所有方法</span></span><br><span class="line"><span class="comment">//定义类型</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> TT <span class="keyword">string</span></span><br><span class="line"><span class="comment">//方法接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名1<span class="params">()</span>（返回值）</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名2<span class="params">()</span>（返回值）</span>{}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span>方法名3<span class="params">()</span>（返回值）</span>{}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中定义一个接口pay，增加两个方法topay()，info()</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pay <span class="keyword">interface</span> {</span><br><span class="line">    topay()</span><br><span class="line">    info()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义一个结构体payment</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> payment <span class="keyword">struct</span> {</span><br><span class="line">    paymentmethod <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>让这个结构体去实现接口pay中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">topay</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"topay:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *payment)</span> <span class="title">info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"info:"</span>, p.paymentmethod)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义结构体 payment类型的变量_payment，就可以通过这个变量去调用接口中的方法了，因为结构体payment实现了接口中所有的方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_payment := &amp;payment{paymentmethod: <span class="string">"alipay"</span>}</span><br><span class="line">_payment.info() <span class="comment">// info: alipay</span></span><br><span class="line">_payment.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>一个变量实现了接口当中所有方法，接口变量就可以指向这个变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _pay pay</span><br><span class="line">_pay = _payment</span><br><span class="line">_pay.info() <span class="comment">// info: alipay</span></span><br><span class="line">_pay.topay() <span class="comment">// topay: alipay</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们一般不这样使用，后面我们会讲解他的使用场景</p>
<h3 id="自定义类型（非结构体）也可以实现接口"><a href="#自定义类型（非结构体）也可以实现接口" class="headerlink" title="自定义类型（非结构体）也可以实现接口"></a>自定义类型（非结构体）也可以实现接口</h3><p>在main.go文件中,定义两个接口<br>写操作接口write</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> {</span><br><span class="line">    echo()</span><br><span class="line">    out()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> read <span class="keyword">interface</span> {</span><br><span class="line">    scan()</span><br><span class="line">    input()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基于内置类型创建自定义类型</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readwrite <span class="keyword">string</span></span><br></pre></td></tr></tbody></table></figure>

<p>自定义的类型readwrite实现上面定义的两个接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">scan</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:scan()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *readwrite)</span> <span class="title">input</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"readwrite:input()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go文件中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _readwrite readwrite</span><br><span class="line">_readwrite.echo() <span class="comment">// readwrite:echo()</span></span><br></pre></td></tr></tbody></table></figure>


<p>多重继承可以通过实现多个接口实现，所有的方法都要实现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多重继承格式</span></span><br><span class="line"><span class="keyword">type</span> InterfaceAA <span class="keyword">interface</span> {</span><br><span class="line">    InterfaceA</span><br><span class="line">    InterfaceB</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>综合案例</p>
<p>企业项目中经常涉及到与日志存储的业务，比如针对web项目的日志存储</p>
<p>比如磁盘IO操作的日志:磁盘进行数据拷贝读取一般会有读写日志,记录读取到的位置，即当前数据在磁盘的哪个碰头哪个扇区上</p>
<p>比如网络请求的日志:去访问某个网站一般会有请求日志的记录，用于分析来访客户，刻画出用户的区域，访问兴趣爱好（网购时的一个典型例子,用户浏览记录写cookie）</p>
<p>这里我们模拟一个网络读写日志与磁盘读写日志的例子</p>
<p>定义公共日志结构体Log，做为父类,并为其增加方法writeLog()，传递一个write接口类型的变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> {</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">    addtime <span class="keyword">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Log)</span> <span class="title">writeLog</span><span class="params">(_write write)</span></span> {</span><br><span class="line">    fmt.Println(l.name + <span class="string">"---"</span> + l.content)</span><br><span class="line">    _write.echo()</span><br><span class="line">    _write.out()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义网络读写结构体与磁盘读写结构体，继承自父类Log</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NetLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IOLog <span class="keyword">struct</span> {</span><br><span class="line">    Log</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义自定义类型，iowrite与netwrite，分别实现write接口中的所有方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iowrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *iowrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"iowrite:out()"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netwrite <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">echo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:echo()"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *netwrite)</span> <span class="title">out</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"netwrite:out()"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>父类引用指向子类对象<br>一个变量实现了接口当中所有方法，接口就可以指向这个变量<br>main.go文件中</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">log := &amp;Log{</span><br><span class="line">    name:    <span class="string">"微信小程序支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _iowrite *iowrite</span><br><span class="line"><span class="keyword">var</span> _netwrite *netwrite</span><br><span class="line"><span class="comment">//writeLog的参数是一个write类型，我们这里的iowrite实现了write接口中的所有方法，所以可以传递iowrite</span></span><br><span class="line"><span class="comment">//相当于write （指向）-&gt; iowrite</span></span><br><span class="line">log.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeLog的参数是一个write类型，我们这里的netwrite实现了write接口中的所有方法，所以可以传递netwrite</span></span><br><span class="line"><span class="comment">//相当于write （指向）-&gt; netwrite</span></span><br><span class="line">log.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序支付日志---微信小程序支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<p>调用者多态的一面</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">netlog := &amp;NetLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序网络支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序网络支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">//writeLog的调用者是Log,我们的NetLog继承自Log，所以可直接调用</span></span><br><span class="line">netlog.writeLog(_netwrite)</span><br><span class="line"><span class="comment">// 微信小程序网络支付日志---微信小程序网络支付日志内容</span></span><br><span class="line"><span class="comment">// netwrite:echo()</span></span><br><span class="line"><span class="comment">// netwrite:out()</span></span><br><span class="line"></span><br><span class="line">filelog := &amp;IOLog{Log{</span><br><span class="line">    name:    <span class="string">"微信小程序文件支付日志"</span>,</span><br><span class="line">    content: <span class="string">"微信小程序文件支付日志内容"</span>,</span><br><span class="line">    addtime: <span class="number">0</span>,</span><br><span class="line">}}</span><br><span class="line"><span class="comment">//writeLog的调用者是Log,我们的IOLog继承自Log，所以可直接调用</span></span><br><span class="line">filelog.writeLog(_iowrite)</span><br><span class="line"><span class="comment">// 微信小程序文件支付日志---微信小程序文件支付日志内容</span></span><br><span class="line"><span class="comment">// iowrite:echo()</span></span><br><span class="line"><span class="comment">// iowrite:out()</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>如果一个接口里面没有定义任何方法，那么它就是空接口，任意结构体都隐式地实现了空接口。</p>
<p>Go 语言为了避免用户重复定义很多空接口，它自己内置了一个，这个空接口的名字特别奇怪，叫 interface{} ，初学者会非常不习惯。之所以这个类型名带上了大括号，那是在告诉用户括号里什么也没有。我始终认为这种名字很古怪，它让代码看起来有点丑陋。</p>
<p>空接口里面没有方法，所以它也不具有任何能力，其作用相当于 Java和python中 的 Object 类型，可以容纳任意对象，它是一个万能容器。比如一个字典的 key 是字符串，但是希望 value 可以容纳任意类型的对象，这时候就可以使用空接口类型 interface{}。<br>可以把任何类型都赋值给空接口变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    price <span class="keyword">int</span></span><br><span class="line">    url   <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> {</span><br><span class="line">    printInfo() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">printInfo</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"课程信息"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="comment">// 判断是不是int类型，是返回ture，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := x.(<span class="keyword">int</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是不是string类型</span></span><br><span class="line">    <span class="keyword">if</span> s, ok := x.(<span class="keyword">string</span>); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, s)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//fmt.Printf("%v\n", i)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print1</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s(字符串)\n"</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%d(整数)\n"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%v(本来值)\n"</span>, v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>{} <span class="comment">// 空接口</span></span><br><span class="line">    <span class="comment">// 参数传递</span></span><br><span class="line">    i = Course{}</span><br><span class="line">    fmt.Println(i) <span class="comment">// { 0 }</span></span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// 10(整数)</span></span><br><span class="line">    i = <span class="string">"bobby"</span></span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// bobby(字符串)</span></span><br><span class="line">    i = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>}</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// [django scrapy](本来值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空接口可以作为map的值,value可以是任何类型，而不是固定的指定类型</span></span><br><span class="line">    <span class="keyword">var</span> teacherInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">    teacherInfo[<span class="string">"name"</span>] = <span class="string">"bobby"</span></span><br><span class="line">    teacherInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">    teacherInfo[<span class="string">"weight"</span>] = <span class="number">75.2</span></span><br><span class="line">    teacherInfo[<span class="string">"courses"</span>] = []<span class="keyword">string</span>{<span class="string">"django"</span>, <span class="string">"scrapy"</span>, <span class="string">"sanic"</span>}</span><br><span class="line">    fmt.Printf(<span class="string">"%v"</span>, teacherInfo) <span class="comment">// map[age:18 courses:[django scrapy sanic] name:bobby weight:75.2]</span></span><br><span class="line">    <span class="comment">//类型断言0-, 接口引入了</span></span><br><span class="line">    <span class="comment">// 接口有一个默认的规范  接口的名称一般以 er 结尾</span></span><br><span class="line">    c := &amp;Course{}</span><br><span class="line">    c.printInfo()</span><br><span class="line">    c1 := Course{}</span><br><span class="line">    c1.printInfo()</span><br><span class="line">    <span class="comment">//var c Printer = Course{}  // 实现了方法可以实例化</span></span><br><span class="line">    <span class="comment">//c.printInfo()</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">"address"</span>: <span class="string">"Beijing Tongzhou"</span>,</span><br><span class="line">    <span class="string">"married"</span>: <span class="literal">true</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(user) <span class="comment">// map[age:30 address:Beijing Tongzhou married:true]</span></span><br><span class="line"><span class="comment">// 类型转换语法来了</span></span><br><span class="line"><span class="keyword">var</span> age = user[<span class="string">"age"</span>].(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> address = user[<span class="string">"address"</span>].(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> married = user[<span class="string">"married"</span>].(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Println(age, address, married) <span class="comment">// 30 Beijing Tongzhou true</span></span><br></pre></td></tr></tbody></table></figure>

<p>user 字典变量的类型是 map[string]interface{}，从这个字典中直接读取得到的 value 类型是 interface{}，需要通过类型转换才能得到期望的变量。</p>
<h2 id="接口变量的本质"><a href="#接口变量的本质" class="headerlink" title="接口变量的本质"></a>接口变量的本质</h2><p>在使用接口时，我们要将接口看成一个特殊的容器，这个容器只能容纳一个对象，只有实现了这个接口类型的对象才可以放进去。</p>
<p>接口变量作为变量来说它也是需要占据内存空间的，通过翻阅 Go 语言的源码可以发现，接口变量也是由结构体来定义的，<br>这个结构体包含两个指针字段，一个字段指向被容纳的对象内存，另一个字段指向一个特殊的结构体 itab，<br>这个特殊的结构体包含了接口的类型信息和被容纳对象的数据类型信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface structure</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> {</span><br><span class="line">  tab *itab  <span class="comment">// 类型指针</span></span><br><span class="line">  data unsafe.Pointer  <span class="comment">// 数据指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> {</span><br><span class="line">  inter *interfacetype <span class="comment">// 接口类型信息</span></span><br><span class="line">  _type *_type <span class="comment">// 数据类型信息</span></span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>既然接口变量只包含两个指针字段，那么它的内存占用应该是 2 个机器字，下面我们来编写代码验证一下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>{}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">int</span> {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>}</span><br><span class="line">    fmt.Println(unsafe.Sizeof(arr))</span><br><span class="line">    s = arr</span><br><span class="line">    fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></tbody></table></figure>

<p>数组的内存占用是 10 个机器字，但是这丝毫不会影响到接口变量的内存占用。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口是一个协议</span></span><br><span class="line"><span class="comment">// 程序员 - 只要你能够 1. 写代码 2. 解决bug 其实就是一组方法的集合</span></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> {</span><br><span class="line">    Coding() <span class="keyword">string</span> <span class="comment">//方法只是申明</span></span><br><span class="line">    Debug() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计师 - 只要你能够 1. 设计</span></span><br><span class="line"><span class="keyword">type</span> Designer <span class="keyword">interface</span> {</span><br><span class="line">    Design() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manger <span class="keyword">interface</span> {</span><br><span class="line">    Programmer <span class="comment">// 接口继承</span></span><br><span class="line">    Designer <span class="comment">// 接口继承</span></span><br><span class="line">    Manage() <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// java里面一种类型只要继承一个接口 才行 如果你继承了这个接口的话 那么这个接口里面的所有方法你必须要全部实现</span></span><br><span class="line"><span class="keyword">type</span> UIDesigner <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d UIDesigner)</span> <span class="title">Design</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会ui设计"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会ui设计"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于Pythoner这个结构体来说 你实现任何方法都可以，但是你只要不全部实现Coding Debug的话 那你Pythoner就不是一个Programmer类型</span></span><br><span class="line"><span class="comment">// Pythoner本身自己就是一个类型 那我何必在意我是不是Programmer</span></span><br><span class="line"><span class="keyword">type</span> Pythoner <span class="keyword">struct</span> {</span><br><span class="line">    UIDesigner         <span class="comment">// 匿名内嵌接口变量，会python也会设计</span></span><br><span class="line">    lib       []<span class="keyword">string</span> <span class="comment">// 属性变量</span></span><br><span class="line">    framework []<span class="keyword">string</span></span><br><span class="line">    years     <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// go开发者既能开发又能调式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"go开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"go开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会go的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会go的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// python开发者既能开发又能调式还会管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Coding</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"python开发者"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"python开发者"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Debug</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"我会python的debug"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我会python的debug"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pythoner)</span> <span class="title">Manage</span><span class="params">()</span> <span class="title">string</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    fmt.Println(<span class="string">"不好意思，管理我也懂"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"不好意思，管理我也懂"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//func (p Pythoner) Design() string {</span></span><br><span class="line"><span class="comment">//    fmt.Println("我是一个python开发者，但是我会ui设计")</span></span><br><span class="line"><span class="comment">//    return "我是一个python开发者，但是我会ui设计"</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlePy</span><span class="params">(p Programmer)</span></span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 新的语言出来了, 接口帮我们完成了go语言的多态</span></span><br><span class="line">    <span class="keyword">var</span> pro Programmer = Pythoner{}</span><br><span class="line">    pro.Coding() <span class="comment">// python开发者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pro3 Programmer</span><br><span class="line">    <span class="keyword">var</span> py3 = Pythoner{}</span><br><span class="line">    pro3 = py3</span><br><span class="line">    pro3.Coding() <span class="comment">// python开发者</span></span><br><span class="line">    pro3.Debug()  <span class="comment">// 我会python的debug</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pros []Programmer</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Pythoner{})</span><br><span class="line">    pros = <span class="built_in">append</span>(pros, Gopher{})</span><br><span class="line"></span><br><span class="line">    p := Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, p)</span><br><span class="line">    <span class="keyword">var</span> pro1 Programmer = Pythoner{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, pro1)</span><br><span class="line">    <span class="keyword">var</span> pro2 Programmer = Gopher{}</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, pro2) <span class="comment">// main.Gopher</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m Manger = Pythoner{}</span><br><span class="line">    m.Design() <span class="comment">// 我会ui设计</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">    eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Fruitable  <span class="comment">// 匿名内嵌接口变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">want</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"I like "</span>)</span><br><span class="line">    f.eat() <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apple)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating apple"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Banana)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eating banana"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> f1 = Fruit{<span class="string">"Apple"</span>, Apple{}}</span><br><span class="line">    <span class="keyword">var</span> f2 = Fruit{<span class="string">"Banana"</span>, Banana{}}</span><br><span class="line">    f1.want()</span><br><span class="line">    f2.want()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">I like eating apple</span><br><span class="line">I like eating banana</span><br></pre></td></tr></tbody></table></figure>

<p>使用这种方式模拟多态本质上是通过组合属性变量（Name）和接口变量（Fruitable）来做到的，属性变量是对象的数据，而接口变量是对象的功能，将它们组合到一块就形成了一个完整的多态性的结构体。</p>
<h2 id="接口的组合继承"><a href="#接口的组合继承" class="headerlink" title="接口的组合继承"></a>接口的组合继承</h2><p>go语言中并不支持继承<br>接口的定义也支持组合继承，比如我们可以将两个接口定义合并为一个接口如下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Smellable <span class="keyword">interface</span> {</span><br><span class="line">  smell()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eatable <span class="keyword">interface</span> {</span><br><span class="line">  eat()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">  Smellable</span><br><span class="line">  Eatable</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时 Fruitable 接口就自动包含了 smell() 和 eat() 两个方法，它和下面的定义是等价的。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruitable <span class="keyword">interface</span> {</span><br><span class="line">  smell()</span><br><span class="line">  eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="接口变量的赋值"><a href="#接口变量的赋值" class="headerlink" title="接口变量的赋值"></a>接口变量的赋值</h2><p>接口变量的赋值浅拷贝</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span> {}</span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line">    a = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rx = a.(Rect)</span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Println(rx)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">{<span class="number">50</span> <span class="number">50</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的输出结果中可以推断出结构体的内存发生了复制，这个复制可能是因为赋值（a = r）也可能是因为类型转换（rx = a.(Rect)），也可能是两者都进行了内存复制。那能不能判断出究竟在接口变量赋值时有没有发生内存复制呢？不好意思，就目前来说我们学到的知识点还办不到。到后面的高级阶段我们将会使用 unsafe 包来洞悉其中的更多细节。不过我可以提前告诉你们答案是什么，那就是两者都会发生数据内存的复制 —— 浅拷贝。</p>
<h2 id="指向指针的接口变量"><a href="#指向指针的接口变量" class="headerlink" title="指向指针的接口变量"></a>指向指针的接口变量</h2><p>如果将上面的例子改成指针，将接口变量指向结构体指针，那结果就不一样了</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> {</span><br><span class="line">    Width <span class="keyword">int</span></span><br><span class="line">    Height <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span> {}</span><br><span class="line">    <span class="keyword">var</span> r = Rect{<span class="number">50</span>, <span class="number">50</span>}</span><br><span class="line">    a = &amp;r <span class="comment">// 指向了结构体指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rx = a.(*Rect) <span class="comment">// 转换成指针类型</span></span><br><span class="line">    r.Width = <span class="number">100</span></span><br><span class="line">    r.Height = <span class="number">100</span></span><br><span class="line">    fmt.Println(rx)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">&amp;{<span class="number">100</span> <span class="number">100</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>从输出结果中可以看出指针变量 rx 指向的内存和变量 r 的内存是同一份。因为在类型转换的过程中只发生了指针变量的内存复制，而指针变量指向的内存是共享的。</p>
<h2 id="接口断言"><a href="#接口断言" class="headerlink" title="接口断言"></a>接口断言</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AliOss <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LocalFile <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">store</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> AliOss:</span><br><span class="line">        <span class="comment">//此处要做一些特殊的处理，我设置阿里云的权限问题</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    <span class="keyword">case</span> LocalFile:</span><br><span class="line">        <span class="comment">//检查路径的权限</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-gou-ti-biao-qian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-jie-gou-ti-biao-qian/" class="post-title-link" itemprop="url">go结构体标签</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-07 16:21:41 / 修改时间：14:41:13" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>结构体的字段除了名字和类型外，还可以有一个可选的标签（tag）：<br>它是一个附属于字段的字符串，可以是文档或其他的重要标记。<br>比如在我们解析json或生成json文件时，常用到encoding/json包，它提供一些默认标签，例如：</p>
<ul>
<li><code>omitempty</code>标签可以在序列化的时候忽略0值或者空值。</li>
<li><code>-</code>标签的作用是不进行序列化，其效果和和直接将结构体中的字段写成小写的效果一样。</li>
</ul>
<p>能表述的信息是有限的<br>string是映射成mysql中char类型还是varchar类型还是text类型， 即使能够说明 但是额外的信息 max_length<br>没有标签会采用默认字段的名称作为key</p>
<p>在序列化和反序列化的时候，也支持类型转化等操作。如</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> {</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span>   <span class="string">`json:"age,string"`</span></span><br><span class="line">    <span class="comment">// 这样生成的json对象中，age就为字符串</span></span><br><span class="line">    Sex  <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> {</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Age    <span class="keyword">int</span> <span class="string">`json:"age,omitempty"`</span></span><br><span class="line">    Weight <span class="keyword">int</span></span><br><span class="line">    height <span class="keyword">int</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    info := Info{</span><br><span class="line">       Name:   <span class="string">"bobby"</span>,</span><br><span class="line">       Gender: <span class="string">"男"</span>,</span><br><span class="line">    }</span><br><span class="line">    re, _ := json.Marshal(info)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(re)) <span class="comment">// {"Name":"bobby","Weight":0,"Gender":"男"}</span></span><br><span class="line">    <span class="comment">// 小写的height和有标签的age都没有打印，因为没有序列化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info1 <span class="keyword">struct</span> {</span><br><span class="line">    Name   <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// 字段转换成指定的name ，也就是转换成小写</span></span><br><span class="line">    Age    <span class="keyword">int</span>    <span class="string">`json:"age,omitempty"`</span></span><br><span class="line">    Gender <span class="keyword">string</span> <span class="string">`json:"-"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    info1 := Info1{</span><br><span class="line">        Name:   <span class="string">"bobby"</span>,</span><br><span class="line">        Gender: <span class="string">"男"</span>,</span><br><span class="line">    }</span><br><span class="line">    re1, _ := json.Marshal(info1)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(re1)) <span class="comment">// {"name":"bobby"} N变n</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>设置自定义的标签，以及如何像官方包一样，可以通过标签，对字段进行自定义处理。<br>要实现这些，我们要用到reflect包。通过反射包去识别这些tag 把结构体的关键信息提取到变量中，java的 spring 底层都是反射<br>具体的应用绝大部分情况之下我们是不需要使用到反射的 实际开发的项目中会用到的</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info2 <span class="keyword">struct</span> { <span class="comment">// 能表述的信息是有限的</span></span><br><span class="line">    Name   <span class="keyword">string</span> <span class="string">`orm:"name, max_length=17, min_length=5"`</span></span><br><span class="line">    Age    <span class="keyword">int</span>    <span class="string">`orm:"age, min=18, max=70"`</span></span><br><span class="line">    Gender <span class="keyword">string</span> <span class="string">`orm:"gender, required"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    info2 := Info2{</span><br><span class="line">        Name:   <span class="string">"bobby"</span>,</span><br><span class="line">        Gender: <span class="string">"男"</span>,</span><br><span class="line">    }</span><br><span class="line">    re2, _ := json.Marshal(info2)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(re2)) <span class="comment">// {"Name":"bobby","Age":0,"Gender":"男"}</span></span><br><span class="line">    <span class="comment">// 通过反射包去识别这些tag 把结构体的关键信息提取到变量中，获取变量的动态类型</span></span><br><span class="line">    t := reflect.TypeOf(info2)</span><br><span class="line">    fmt.Println(<span class="string">"Type:"</span>, t.Name()) <span class="comment">// Type: Info2 是struct的类型而不是Name类型</span></span><br><span class="line">    fmt.Println(<span class="string">"Kind:"</span>, t.Kind()) <span class="comment">// Kind: struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">        field := t.Field(i) <span class="comment">//获取结构体的每一个字段</span></span><br><span class="line">        tag := field.Tag.Get(<span class="string">"orm"</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%d. %v (%v), tag: '%v'\n"</span>, i+<span class="number">1</span>, field.Name, field.Type.Name(), tag)</span><br><span class="line">        <span class="comment">//1. Name (string), tag: 'name, max_length=17, min_length=5'</span></span><br><span class="line">        <span class="comment">//2. Age (int), tag: 'age, min=18, max=70'</span></span><br><span class="line">        <span class="comment">//3. Gender (string), tag: 'gender, required'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/07/08/go-jie-gou-ti-tong-guo-nei-qian-jie-gou-ti-shi-xian-ji-cheng-de-xiao-guo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/go-jie-gou-ti-tong-guo-nei-qian-jie-gou-ti-shi-xian-ji-cheng-de-xiao-guo/" class="post-title-link" itemprop="url">go结构体通过内嵌结构体实现继承的效果</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 16:21:41" itemprop="dateCreated datePublished" datetime="2021-07-07T16:21:41Z">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-17 15:50:17" itemprop="dateModified" datetime="2021-07-17T15:50:17Z">2021-07-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>结构体作为一种变量它可以放进另外一个结构体作为另一个结构体字段的类型<br>这种内嵌结构体的形式在 Go 语言里称之为「组合」。</p>
<p>在go语言当中继承：主要是通过类型组合的方式来实现：<br>内嵌一个（或多个）包含想要的行为（字段和方法）的类型；<br>多重继承可以通过内嵌多个类型实现</p>
<p>一个结构体中嵌套另一个结构体，那外面的结构体将直接继承内嵌结构体类型所有字段和方法，这种做法其实就是 语法糖</p>
<h2 id="内嵌有名结构体"><a href="#内嵌有名结构体" class="headerlink" title="内嵌有名结构体"></a>内嵌有名结构体</h2><p>在嵌套结构体时有指定结构体变量名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> {</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Age   <span class="keyword">int</span></span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Teacher)</span> <span class="title">teacherInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"姓名:%s, 年龄:%d, 职称:%s\n"</span>, t.Name, t.Age, t.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> {</span><br><span class="line">    Teacher Teacher <span class="comment">// 如果讲师的信息比较多怎么办 将另一个结构体的变量放进来</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course)</span> <span class="title">courseInfo</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">courseInfo1</span><span class="params">(c Course)</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Teacher)</span> <span class="title">show</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(t.Name, t.Age, t.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    t := Teacher{</span><br><span class="line">        Name:  <span class="string">"bobby"</span>,</span><br><span class="line">        Age:   <span class="number">18</span>,</span><br><span class="line">        Title: <span class="string">"程序员"</span>,</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// var c Course = Course {</span></span><br><span class="line">    c := Course{</span><br><span class="line">        Teacher: t,</span><br><span class="line">        Price:   <span class="number">100</span>,</span><br><span class="line">        Url:     <span class="string">""</span>,</span><br><span class="line">        Name:    <span class="string">"django"</span>,</span><br><span class="line">    }</span><br><span class="line">    c.courseInfo() <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line">    courseInfo1(c) <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)                                                   <span class="comment">// {Teacher:{Name:bobby Age:18 Title:程序员} Name:django Price:100 Url:}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c.Teacher)                                           <span class="comment">// {Name:bobby Age:18 Title:程序员}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c.Teacher.Name, c.Teacher.Age, c.Teacher.Title) <span class="comment">// bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    c.Teacher.show() <span class="comment">// bobby 18 程序员</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userinfo <span class="keyword">struct</span> {</span><br><span class="line">    name      <span class="keyword">string</span></span><br><span class="line">    age       <span class="keyword">int</span></span><br><span class="line">    height    <span class="keyword">float32</span></span><br><span class="line">    eduschool <span class="keyword">string</span></span><br><span class="line">    hobby     []<span class="keyword">string</span></span><br><span class="line">    moreinfo  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台管理系统中，权限问题，这里涉及了角色，超级管理员，管理员，普通用户</span></span><br><span class="line"><span class="keyword">type</span> role <span class="keyword">struct</span> {</span><br><span class="line">    user          userinfo</span><br><span class="line">    authorization Integer <span class="comment">// 1=超级管理员，2=管理员，3=普通用户</span></span><br><span class="line">}</span><br><span class="line">    superadmin := role{</span><br><span class="line">        user: userinfo{</span><br><span class="line">            name:      <span class="string">"超级管理员"</span>,</span><br><span class="line">            age:       <span class="number">0</span>,</span><br><span class="line">            height:    <span class="number">0</span>,</span><br><span class="line">            eduschool: <span class="string">""</span>,</span><br><span class="line">            hobby:     <span class="literal">nil</span>,</span><br><span class="line">            moreinfo:  <span class="literal">nil</span>,</span><br><span class="line">        },</span><br><span class="line">        authorization: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">    admin := role{</span><br><span class="line">        user: userinfo{</span><br><span class="line">            name:      <span class="string">"管理员"</span>,</span><br><span class="line">            age:       <span class="number">0</span>,</span><br><span class="line">            height:    <span class="number">0</span>,</span><br><span class="line">            eduschool: <span class="string">""</span>,</span><br><span class="line">            hobby:     <span class="literal">nil</span>,</span><br><span class="line">            moreinfo:  <span class="literal">nil</span>,</span><br><span class="line">        },</span><br><span class="line">        authorization: <span class="number">2</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(superadmin, admin)</span><br><span class="line">    <span class="comment">//{{超级管理员 0 0  [] map[]} 1} {{管理员 0 0  [] map[]} 2}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="匿名内嵌结构体"><a href="#匿名内嵌结构体" class="headerlink" title="匿名内嵌结构体"></a>匿名内嵌结构体</h2><p>在嵌套结构体时没有指定结构体变量名</p>
<p>结构体继承访问流程<br>1.先判断字段是否属于子结构体，如果有就访问<br>2.如果没有，继续去找他继承的父结构体，如果有就访问<br>3.如果没有继续去找这个结构体的所继承的结构体，如果有就访问，没有就报错</p>
<p>如果嵌入结构的字段和外部结构或一个结构中继承了多个结构体的字段相同，<br>想要访问或修改嵌入结构的字段值需要必须指定加上外部结构中声明的嵌入结构体变量名或者匿名结构体名</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Course1 <span class="keyword">struct</span> {</span><br><span class="line">    Teacher <span class="comment">// 匿名内嵌结构体：不写参数名称</span></span><br><span class="line">    Name    <span class="keyword">string</span>  <span class="comment">// 属性变量</span></span><br><span class="line">    Price   <span class="keyword">int</span></span><br><span class="line">    Url     <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Course1)</span> <span class="title">courseInfo2</span><span class="params">()</span></span> { <span class="comment">// 外结构体会自动继承匿名内嵌变量的方法</span></span><br><span class="line">    <span class="comment">// c.Teacher.Name的Teacher可以省略，但是Course struct也有Name，重名的字段会取外嵌的字段，所以不省略Teacher</span></span><br><span class="line">    <span class="comment">// c.Teacher.Age, c.Teacher.Title的Teacher都可以省略</span></span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Age, c.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">courseInfo3</span><span class="params">(c Course1)</span></span> {</span><br><span class="line">    <span class="comment">// c.Teacher.Name的Teacher可以省略，但是Course struct也有Name，重名的字段会取外嵌的字段，所以不省略Teacher</span></span><br><span class="line">    <span class="comment">// c.Teacher.Age, c.Teacher.Title的Teacher都可以省略</span></span><br><span class="line">    fmt.Printf(<span class="string">"课程名:%s, 价格:%d, 讲师信息：%s %d %s\n"</span>, c.Name, c.Price, c.Teacher.Name, c.Age, c.Title)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    c1 := Course1{</span><br><span class="line">        Teacher: t,</span><br><span class="line">        Price:   <span class="number">100</span>,</span><br><span class="line">        Url:     <span class="string">""</span>,</span><br><span class="line">        Name:    <span class="string">"django"</span>,</span><br><span class="line">    }</span><br><span class="line">    c1.courseInfo2() <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line">    courseInfo3(c1)  <span class="comment">// 课程名:django, 价格:100, 讲师信息：bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c1)                                                     <span class="comment">// {Teacher:{Name:bobby Age:18 Title:程序员} Name:django Price:100 Url:}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c1.Teacher)                                             <span class="comment">// {Name:bobby Age:18 Title:程序员}</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c1.Teacher.Name, c1.Teacher.Age, c1.Teacher.Title) <span class="comment">// bobby 18 程序员</span></span><br><span class="line">    <span class="comment">// 继承了字段</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d %s\n"</span>, c1.Teacher.Name, c1.Age, c1.Title)                 <span class="comment">// bobby 18 程序员</span></span><br><span class="line"></span><br><span class="line">    c1.Teacher.show() <span class="comment">// bobby 18 程序员</span></span><br><span class="line">    <span class="comment">// 继承了方法</span></span><br><span class="line">    c1.show()         <span class="comment">// bobby 18 程序员</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继承仅仅是形式上的语法糖，<code>c.show()</code> 被转换成二进制代码后和 <code>c.Teacher.show()</code> 是等价的，<code>c.Age</code> 和 <code>c.Teacher.Age</code> 也是等价的。</p>
<p>支付是一个企业项目变现的重要手段，做为企业应用必不可少的功能，支付系统包括微信支付，支付宝，银联，银行卡京东等等，在开发中如何避免重复代码来实现类似的支付功能？由此引出继承<br>你的系统支持各种类型的支付 每一种支付类型都有统一的接口<br>我们通过封装一个公共的支付结构体，把它做为父类，同时实现4个不同支付平台的结构体，把这4个不同支付平台的结构体做为子类，来实现继承的功能</p>
<p>定一个协议 1. 创建订单 2. 支付 3. 查询支付状态 4. 退款<br>支付发起了<br>你现在有一个缓存 - 这个地方你一开始使用的缓存是redis 但是后期你考虑到可能使用其他的缓存技术 - 本地 memcache<br>如果后期接入一种新的支付 或者取消已有的支付</p>
<p>定义一个model包，新建payment.go文件</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付</span></span><br><span class="line"><span class="comment">// 支付宝</span></span><br><span class="line"><span class="comment">// 银联</span></span><br><span class="line"><span class="comment">// 银行卡</span></span><br><span class="line"><span class="keyword">type</span> PaymentArgs <span class="keyword">struct</span> {</span><br><span class="line">    AppID       <span class="keyword">string</span></span><br><span class="line">    MchID       <span class="keyword">string</span></span><br><span class="line">    Key         <span class="keyword">string</span></span><br><span class="line">    CallbackUrl <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在model包，新建Alipay.go文件，这里我们让结构体Alipay 继承 PaymentArgs<br>同一个结构体继承了多个不同的结构体</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Alipay <span class="keyword">struct</span> {</span><br><span class="line">    PaymentArgs               <span class="comment">//匿名结构体，自动拥有PaymentArgs的信息</span></span><br><span class="line">    PaymentOther PaymentOther <span class="comment">//有名结构体</span></span><br><span class="line">    AlipayOpenID <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.go文件中这样来实现结构体变量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alipay := &amp;model.Alipay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"alipay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"alipaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"alipayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/alipay"</span>,</span><br><span class="line">    },</span><br><span class="line">    AlipayOpenID: <span class="string">"alipayopenid"</span>,</span><br><span class="line">}</span><br><span class="line">wechatpay := &amp;model.WechatPay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"wechatpay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"wechatpaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"wechatpayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/wechatpay"</span>,</span><br><span class="line">    },</span><br><span class="line">    WechatOpenID: <span class="string">"wechatpayopenid"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中，如下的访问</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(alipay.PaymentArgs.AppID) <span class="comment">// alipay123</span></span><br><span class="line">fmt.Println(wechatpay.WechatOpenID)   <span class="comment">// wechatpayopenid</span></span><br><span class="line"></span><br><span class="line">alipay.PaymentOther.AppID = <span class="string">"ailpay_paymentother"</span></span><br><span class="line">fmt.Println(alipay.PaymentOther.AppID) <span class="comment">// ailpay_paymentother</span></span><br><span class="line">fmt.Println(alipay.AppID)              <span class="comment">// alipay123 默认继承第一个结构体的字段</span></span><br><span class="line">fmt.Println(alipay.PaymentArgs.AppID)  <span class="comment">// alipay123</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法的继承与重载"><a href="#方法的继承与重载" class="headerlink" title="方法的继承与重载"></a>方法的继承与重载</h4><p>为payment.go文件中PaymentArgs结构体增加方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PaymentArgs)</span> <span class="title">Info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"Info = %v\n"</span>, p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们定义的Alipay结构体与WechatPay结构体自动就继承了PaymentArgs的方法<br>我们在main.go中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paymentArgs := model.PaymentArgs{</span><br><span class="line">    AppID:       <span class="string">"superAppid"</span>,</span><br><span class="line">    MchID:       <span class="string">"superMchid"</span>,</span><br><span class="line">    Key:         <span class="string">"superKey"</span>,</span><br><span class="line">    CallbackUrl: <span class="string">"https://api.imooc.com/super"</span>,</span><br><span class="line">}</span><br><span class="line">paymentArgs.Info()</span><br><span class="line"><span class="comment">//Info = &amp;{superAppid superMchid superKey https://api.imooc.com/super}</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样的我们可以对继承的方法进行重定义<br>在我们的Alipay.go中为Alipay结构体增加重写了Info()方法，</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alipay)</span> <span class="title">Info</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"alipay = %v\n"</span>, a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在main.go中调用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alipay := &amp;model.Alipay{</span><br><span class="line">    PaymentArgs: model.PaymentArgs{</span><br><span class="line">        AppID:       <span class="string">"alipay123"</span>,</span><br><span class="line">        MchID:       <span class="string">"alipaymchid"</span>,</span><br><span class="line">        Key:         <span class="string">"alipayfjkadsfjkasfjas"</span>,</span><br><span class="line">        CallbackUrl: <span class="string">"https://api.imooc.com/alipay"</span>,</span><br><span class="line">    },</span><br><span class="line">    AlipayOpenID: <span class="string">"alipayopenid"</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载info方法</span></span><br><span class="line">alipay.Info()</span><br><span class="line"><span class="comment">//alipay = &amp;{{alipay123 alipaymchid alipayfjkadsfjkasfjas</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WeChatnPay <span class="keyword">struct</span> {</span><br><span class="line">    PaymentArgs</span><br><span class="line">    WeChatOpenID <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b Bank</span><br><span class="line"><span class="keyword">var</span> a AliPay</span><br><span class="line"><span class="keyword">var</span> w WeChat</span><br></pre></td></tr></tbody></table></figure>

<h4 id="一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问"><a href="#一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问" class="headerlink" title="一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问"></a>一个内置类型可以做为结构体的匿名字段，这种方式只能在本包访问</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringStruct <span class="keyword">struct</span> {</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line">    ss := StringStruct{<span class="string">"hello"</span>}</span><br><span class="line">    fmt.Println(ss.<span class="keyword">string</span>) <span class="comment">// hello</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Go-语言的结构体没有多态性"><a href="#Go-语言的结构体没有多态性" class="headerlink" title="Go 语言的结构体没有多态性"></a>Go 语言的结构体没有多态性</h2><p>Go 语言不是面向对象语言在于它的结构体不支持多态，它不能算是一个严格的面向对象语言。</p>
<p>但是go语言支持鸭子类型</p>
<p>下面的例子呈现了 Java 类的多态性。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat fruit"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enjoy</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"smell first"</span>);</span><br><span class="line">    eat();</span><br><span class="line">    System.out.println(<span class="string">"clean finally"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat apple"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"eat banana"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">    Banana banana = <span class="keyword">new</span> Banana();</span><br><span class="line">    apple.enjoy();</span><br><span class="line">    banana.enjoy();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">smell first</span><br><span class="line">eat apple</span><br><span class="line">clean <span class="keyword">finally</span></span><br><span class="line">smell first</span><br><span class="line">eat banana</span><br><span class="line">clean <span class="keyword">finally</span></span><br></pre></td></tr></tbody></table></figure>

<p>父类 Fruit 定义的 enjoy 方法调用了子类实现的 eat 方法，子类的方法可以对父类定义的方法进行覆盖，父类的 eat 方法被隐藏起来了。</p>
<p>多态的定义格式与实现方式<br>结构体与自定义类型都可以实现接口中的方法<br>接口的多重继承实现方式</p>
<p>Go 语言的结构体明确不支持这种形式的多态，外结构体的方法不能覆盖内部结构体的方法。</p>
<p>比如我们用 Go 语言来改写上面的水果例子观察一下输出结果。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat fruit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fruit)</span> <span class="title">enjoy</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"smell first"</span>)</span><br><span class="line">    f.eat()</span><br><span class="line">    fmt.Println(<span class="string">"clean finally"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span> {</span><br><span class="line">    Fruit</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apple)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat apple"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Banana <span class="keyword">struct</span> {</span><br><span class="line">    Fruit</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Banana)</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"eat banana"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> apple = Apple {}</span><br><span class="line">    <span class="keyword">var</span> banana = Banana {}</span><br><span class="line">    apple.enjoy()</span><br><span class="line">    banana.enjoy()</span><br><span class="line">}</span><br><span class="line">----------</span><br><span class="line">smell first</span><br><span class="line">eat fruit</span><br><span class="line">clean finally</span><br><span class="line">smell first</span><br><span class="line">eat fruit</span><br><span class="line">clean finally</span><br></pre></td></tr></tbody></table></figure>

<p>enjoy 方法调用的 eat 方法还是 Fruit 自己的 eat 方法，它没能被外面的结构体方法覆盖掉。这意味着面向对象的代码习惯不能直接用到 Go 语言里了，我们需要转变思维。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
