<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:type" content="website">
<meta property="og:title" content="外心人D的博客">
<meta property="og:url" content="https://bubbleboy11.github.io/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="本博客大多内容为慕课和网上博客，并非原创">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">363</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/18/protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/18/protobuf/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-18 03:45:29 / 修改时间：03:48:23" itemprop="dateCreated datePublished" datetime="2021-10-18T03:45:29Z">2021-10-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://colobu.com/2015/01/07/Protobuf-language-guide/">https://colobu.com/2015/01/07/Protobuf-language-guide/</a></p>
<p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/10/go-la-ji-hui-shou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/10/go-la-ji-hui-shou/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-10 04:15:07" itemprop="dateCreated datePublished" datetime="2021-10-10T04:15:07Z">2021-10-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-14 13:54:59" itemprop="dateModified" datetime="2021-10-14T13:54:59Z">2021-10-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第2章-Go内部机制"><a href="#第2章-Go内部机制" class="headerlink" title="第2章 Go内部机制"></a>第2章 Go内部机制</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是释放掉那些不再使用的内存空间的过程.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/10/go-la-ji-hui-shou/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/07/windows-sheng-cheng-xiang-mu-mu-lu-jie-gou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/07/windows-sheng-cheng-xiang-mu-mu-lu-jie-gou/" class="post-title-link" itemprop="url">Windows生成项目目录结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-06 16:21:41 / 修改时间：04:29:39" itemprop="dateCreated datePublished" datetime="2021-10-06T16:21:41Z">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在需要生成项目结构的目录下，Shift+空白处鼠标点击右键–&gt;在此处打开powershell窗口；</p>
<p><code>tree</code>生成文件夹目录结构</p>
<figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">F:</span>.</span><br><span class="line">├─test1</span><br><span class="line">├─test2</span><br><span class="line">└─test3</span><br></pre></td></tr></tbody></table></figure>

<p><code>tree /f</code> 生成包含文件的目录结构</p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">F</span><span class="selector-pseudo">:.</span></span><br><span class="line">├─<span class="selector-tag">test1</span></span><br><span class="line">│ <span class="selector-tag">text1</span><span class="selector-class">.txt</span></span><br><span class="line">│ <span class="selector-tag">text2</span><span class="selector-class">.txt</span></span><br><span class="line">│</span><br><span class="line">├─<span class="selector-tag">test2</span></span><br><span class="line">└─<span class="selector-tag">test3</span></span><br></pre></td></tr></tbody></table></figure>

<p>在powershell窗口输入 <code>tree /f &gt;project.txt</code> 然后回车即可生成项目目录结构（<code>project.txt</code>为指定生成的项目结构文件）</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/05/grpc-de-go-de-rpc-ru-men/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/05/grpc-de-go-de-rpc-ru-men/" class="post-title-link" itemprop="url">grpc的go的rpc入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-04 16:21:41" itemprop="dateCreated datePublished" datetime="2021-10-04T16:21:41Z">2021-10-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 10:29:04" itemprop="dateModified" datetime="2021-10-19T10:29:04Z">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html</a></p>
<h3 id="RPC版”Hello-World”"><a href="#RPC版”Hello-World”" class="headerlink" title="RPC版”Hello, World”"></a>RPC版”Hello, World”</h3><p>Go语言的RPC包的路径为net/rpc，也就是放在了net包目录下面。因此我们可以猜测该RPC包是建立在net包基础之上的。在第一章“Hello, World”革命一节最后，我们基于http实现了一个打印例子。下面我们尝试基于rpc实现一个类似的例子。</p>
<p>我们先构造一个HelloService类型，其中的Hello方法用于实现打印功能</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    *reply = <span class="string">"hello "</span>+ request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中Hello方法必须满足<strong>Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法</strong>。</p>
<p>然后就可以将HelloService类型的对象注册为一个RPC服务：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">    <span class="comment">// rpc.RegisterName("HelloService", &amp;HelloService{})</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>) <span class="comment">// 省略127.0.0.1</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("监听端口失败")</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"Accept error:"</span>, err) <span class="comment">// 当一个新的连接进来的时候</span></span><br><span class="line">        <span class="comment">// panic("建立链接失败")</span></span><br><span class="line">    }</span><br><span class="line">    rpc.ServeConn(conn)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>rpc.Register</code>函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在“HelloService”服务空间之下。然后我们建立一个唯一的TCP链接，并且通过<code>rpc.ServeConn</code>函数在该TCP链接上为对方提供RPC服务。</p>
<p>下面是客户端请求HelloService服务的代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先是通过<code>rpc.Dial</code>拨号RPC服务，然后通过<code>client.Call</code>调用具体的RPC方法。在调用<code>client.Call</code>时，第一个参数是用点号链接的RPC服务名字和方法名字，第二和第三个参数分别我们定义RPC方法的两个参数。</p>
<p>先运行服务端，再运行客户端，执行结果</p>
<figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">hello:</span>hello</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更安全的RPC接口"><a href="#更安全的RPC接口" class="headerlink" title="更安全的RPC接口"></a>更安全的RPC接口</h3><p>在涉及RPC的应用中，作为开发人员一般至少有三种角色：首先是服务端实现RPC方法的开发人员，其次是客户端调用RPC方法的人员，最后也是最重要的是制定服务端和客户端RPC接口规范的设计人员。在前面的例子中我们为了简化将以上几种角色的工作全部放到了一起，虽然看似实现简单，但是不利于后期的维护和工作的切割。</p>
<p>新建handler/handler.go文件内容如下： 为什么要新建一个文件？ - 解耦</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hanlder</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决 serviceName 统一和名称冲突的问题</span></span><br><span class="line"><span class="comment">//   a. server端和client端如何统一serviceName</span></span><br><span class="line"><span class="comment">//   b. 多个server的包中serviceName同名的问题</span></span><br><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">"handler/HelloService"</span></span><br><span class="line"><span class="comment">// const HelloServiceName = "path/to/pkg.HelloService"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续屏蔽 HelloServiceName 和 Hello 函数名称</span></span><br><span class="line"><span class="comment">// 关心的是 NewHelloService 这个结构体中的方法而不是名字</span></span><br><span class="line"><span class="keyword">type</span> NewHelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *NewHelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果要重构 HelloService 服务，第一步需要明确服务的名字和接口：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server_proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServicer <span class="keyword">interface</span> {</span><br><span class="line">    Hello(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果做到解耦 - 我们关系的是函数 鸭子类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(srv HelloServicer)</span> <span class="title">error</span></span> { <span class="comment">// 用接口不用导入结构体，增强解耦</span></span><br><span class="line">    <span class="keyword">return</span> rpc.RegisterName(hanlder.HelloServiceName, srv)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将RPC服务的接口规范分为三个部分：首先是服务的名字，然后是服务要实现的详细方法列表，最后是注册该类型服务的函数。为了避免名字冲突，我们在RPC服务的名字中增加了包路径前缀（这个是RPC服务抽象的包路径，并非完全等价Go语言的包路径）。RegisterHelloService注册服务时，编译器会要求传入的对象满足HelloServiceInterface接口。</p>
<p>在定义了RPC服务接口规范之后，客户端就可以根据规范编写RPC调用的代码了：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 1. 建立连接</span></span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(hanlder.HelloServiceName+<span class="string">".Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中唯一的变化是client.Call的第一个参数用<code>HelloServiceName+".Hello"</code>代替了<code>"HelloService.Hello"</code>。然而通过client.Call函数调用RPC方法依然比较繁琐，同时参数的类型依然无法得到编译器提供的安全保障。</p>
<p>为了简化客户端用户调用RPC函数，我们在可以在接口规范部分增加对客户端的简单包装：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client_proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServiceStub <span class="keyword">struct</span> {</span><br><span class="line">    *rpc.Client</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在go语言中没有类、对象 就意味着没有初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHelloServiceClient</span><span class="params">(protcol, address <span class="keyword">string</span>)</span> <span class="title">HelloServiceStub</span></span> {</span><br><span class="line">    conn, err := rpc.Dial(protcol, address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        <span class="comment">// panic("connect error!")</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> HelloServiceStub{Client: conn}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HelloServiceStub)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    err := c.Call(hanlder.HelloServiceName+<span class="string">".Hello"</span>, request, reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们在接口规范中针对客户端新增加了HelloServiceClient类型，该类型也必须满足HelloServiceInterface接口，这样客户端用户就可以直接通过接口对应的方法调用RPC函数。同时提供了一个DialHelloService方法，直接拨号HelloService服务。</p>
<p>基于新的客户端接口，我们可以简化客户端用户的代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/client_proxy"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 封装后，像本地调用函数一样</span></span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    client, err := client_proxy.NewHelloServiceClient(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 只想写业务逻辑 不想关注每个函数的名称</span></span><br><span class="line">    <span class="comment">// 客户端部分</span></span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err := client.Hello(<span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在客户端用户不用再担心RPC方法名字或参数类型不匹配等低级错误的发生。</p>
<p>最后是基于RPC接口规范编写真实的服务端代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/hanlder"</span></span><br><span class="line">    <span class="string">"OldPackageTest/new_helloworld/server_proxy"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    server_proxy.RegisterHelloService(&amp;hanlder.NewHelloService{})</span><br><span class="line">    <span class="comment">// server_proxy.RegisterHelloService(new(hanlder.NewHelloService))</span></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept() <span class="comment">//当一个新的连接进来的时候</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在新的RPC服务端实现中，我们用RegisterHelloService函数来注册函数，这样不仅可以避免命名服务名称的工作，同时也保证了传入的服务对象满足了RPC接口的定义。最后我们新的服务改为支持多个TCP链接，然后为每个TCP链接提供RPC服务。</p>
<h3 id="跨语言的RPC"><a href="#跨语言的RPC" class="headerlink" title="跨语言的RPC"></a>跨语言的RPC</h3><p>标准库的RPC默认采用Go语言特有的gob编码，因此从其它语言调用Go语言实现的RPC服务将比较困难。在互联网的微服务时代，每个RPC以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代RPC的一个首要条件。得益于RPC的框架设计，Go语言的RPC其实也是很容易实现跨语言支持的。</p>
<p>Go语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的<code>io.ReadWriteCloser</code>接口之上的，我们可以将RPC架设在不同的通讯协议之上。这里我们将尝试通过官方自带的<code>net/rpc/jsonrpc</code>扩展实现一个跨语言的RPC。</p>
<p>首先是基于json编码重新实现RPC服务：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2. 注册处理逻辑 handler</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, &amp;HelloService{})</span><br><span class="line">    <span class="comment">// rpc.RegisterName("HelloService", new(HelloService))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动服务</span></span><br><span class="line">    <span class="keyword">for</span> { <span class="comment">// 死循环，运行完不退出</span></span><br><span class="line">        conn, err := listener.Accept() <span class="comment">//当一个新的连接进来的时候，</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) <span class="comment">// 并发</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码中最大的变化是用<code>rpc.ServeCodec</code>函数替代了<code>rpc.ServeConn</code>函数，传入的参数是针对服务端的json编解码器。</p>
<p>然后是实现json版本的客户端：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 建立连接</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">        <span class="comment">// panic("连接失败")</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span> <span class="comment">//string有默认值</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, <span class="string">"hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">        <span class="comment">// panic("调用失败")</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先手工调用net.Dial函数建立TCP链接，然后基于该链接建立针对客户端的json编解码器。</p>
<p>在确保客户端可以正常调用RPC服务的方法之后，我们用一个普通的TCP服务代替Go语言版本的RPC服务，这样可以查看客户端调用时发送的数据格式。比如通过nc命令<code>nc -l 1234</code>在同样的端口启动一个TCP服务。然后再次执行一次RPC调用将会发现nc输出了以下的信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"method"</span>:<span class="string">"HelloService.Hello"</span>,<span class="attr">"params"</span>:[<span class="string">"hello"</span>],<span class="attr">"id"</span>:<span class="number">0</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个json编码的数据，其中method部分对应要调用的rpc服务和方法组合成的名字，params部分的第一个元素为参数，id是由调用端维护的一个唯一的调用编号。</p>
<p>请求的json数据对象在内部对应两个结构体：客户端是clientRequest，服务端是serverRequest。<br>clientRequest和serverRequest结构体的内容基本是一致的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientRequest <span class="keyword">struct</span> {</span><br><span class="line">    Method <span class="keyword">string</span>         <span class="string">`json:"method"`</span></span><br><span class="line">    Params [<span class="number">1</span>]<span class="keyword">interface</span>{} <span class="string">`json:"params"`</span></span><br><span class="line">    Id     <span class="keyword">uint64</span>         <span class="string">`json:"id"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverRequest <span class="keyword">struct</span> {</span><br><span class="line">    Method <span class="keyword">string</span>           <span class="string">`json:"method"`</span></span><br><span class="line">    Params *json.RawMessage <span class="string">`json:"params"`</span></span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:"id"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在获取到RPC调用对应的json数据后，我们可以通过直接向架设了RPC服务的TCP服务器发送json数据模拟RPC方法调用：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">'{"method":"HelloService.Hello","params":["hello"],"id":1}'</span> | nc localhost 1234</span></span><br></pre></td></tr></tbody></table></figure>

<p>返回的结果也是一个json格式的数据：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"result"</span>:<span class="string">"hello:hello"</span>,<span class="attr">"error"</span>:<span class="literal">null</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>其中id对应输入的id参数，result为返回的结果，error部分在出问题时表示错误信息。对于顺序调用来说，id不是必须的。但是Go语言的RPC框架支持异步调用，当返回结果的顺序和调用的顺序不一致时，可以通过id来识别对应的调用。</p>
<p>返回的json数据也是对应内部的两个结构体：客户端是clientResponse，服务端是serverResponse。两个结构体的内容同样也是类似的：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientResponse <span class="keyword">struct</span> {</span><br><span class="line">    Id     <span class="keyword">uint64</span>           <span class="string">`json:"id"`</span></span><br><span class="line">    Result *json.RawMessage <span class="string">`json:"result"`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>{}      <span class="string">`json:"error"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverResponse <span class="keyword">struct</span> {</span><br><span class="line">    Id     *json.RawMessage <span class="string">`json:"id"`</span></span><br><span class="line">    Result <span class="keyword">interface</span>{}      <span class="string">`json:"result"`</span></span><br><span class="line">    Error  <span class="keyword">interface</span>{}      <span class="string">`json:"error"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此无论采用何种语言，只要遵循同样的json结构，以同样的流程就可以和Go语言编写的RPC服务进行通信。这样我们就实现了跨语言的RPC。</p>
<p>python客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONClient</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        self.socket = socket.create_connection(addr)</span><br><span class="line">        self.id_counter = itertools.count()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, name, *params</span>):</span></span><br><span class="line">        request = dict(id=next(self.id_counter),</span><br><span class="line">                    params=list(params),</span><br><span class="line">                    method=name)</span><br><span class="line">        self.socket.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This must loop if resp is bigger than 4K</span></span><br><span class="line">        response = self.socket.recv(<span class="number">4096</span>)</span><br><span class="line">        response = json.loads(response.decode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.get(<span class="string">'id'</span>) != request.get(<span class="string">'id'</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"expected id=%s, received id=%s: %s"</span></span><br><span class="line">                            %(request.get(<span class="string">'id'</span>), response.get(<span class="string">'id'</span>),</span><br><span class="line">                              response.get(<span class="string">'error'</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.get(<span class="string">'error'</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(response.get(<span class="string">'error'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.get(<span class="string">'result'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">    self._socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rpc = JSONClient((<span class="string">"localhost"</span>, <span class="number">1234</span>))</span><br><span class="line">    args = <span class="string">"hello"</span></span><br><span class="line">    print(rpc.call(<span class="string">"HelloService.Hello"</span>, args))</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go_json_rpc_client</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">request = {</span><br><span class="line">    <span class="string">"id"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"params"</span>:[<span class="string">"bobby"</span>],</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"HelloService.Hello"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">client = socket.create_connection((<span class="string">"localhost"</span>, <span class="number">1234</span>))</span><br><span class="line">client.sendall(json.dumps(request).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取服务器返回的数据</span></span><br><span class="line">This must loop <span class="keyword">if</span> resp <span class="keyword">is</span> bigger than <span class="number">4</span>K</span><br><span class="line">rsp = client.recv(<span class="number">1024</span>)</span><br><span class="line">rsp = client.recv(<span class="number">4096</span>)</span><br><span class="line">rsp = json.loads(rsp.decode())</span><br><span class="line"></span><br><span class="line">print(rsp)  <span class="comment"># {'id': 0, 'result': 'hello, bobby', 'error': None}</span></span><br><span class="line">print(rsp[<span class="string">"result"</span>])  <span class="comment"># hello, bobby</span></span><br><span class="line">client.close() <span class="comment">#关闭这个链接</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request = {</span><br><span class="line">    <span class="string">"id"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"params"</span>:[<span class="string">"bobby"</span>],</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"HelloService.Hello"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">rsp = requests.post(<span class="string">"http://localhost:1234/jsonrpc"</span>, json=request)</span><br><span class="line">print(rsp.text)  <span class="comment"># {"id":0,"result":"hello, bobby","error":null}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Http上的RPC"><a href="#Http上的RPC" class="headerlink" title="Http上的RPC"></a>Http上的RPC</h3><p>替换rpc的传输协议为http</p>
<p>Go语言内在的RPC框架已经支持在Http协议上提供RPC服务。但是框架的http服务同样采用了内置的gob协议，并且没有提供采用其它协议的接口，因此从其它语言依然无法访问的。在前面的例子中，我们已经实现了在TCP协议之上运行jsonrpc服务，并且通过nc命令行工具成功实现了RPC方法调用。现在我们尝试在http协议上提供jsonrpc服务。</p>
<p>新的RPC服务其实是一个类似REST规范的接口，接收请求并采用相应处理流程：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">//返回值是通过修改reply的值</span></span><br><span class="line">    *reply = <span class="string">"hello, "</span> + request</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1. 实例化一个server</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, &amp;HelloService{})</span><br><span class="line">    http.HandleFunc(<span class="string">"/jsonrpc"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">        <span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> {</span><br><span class="line">            io.Writer</span><br><span class="line">            io.ReadCloser</span><br><span class="line">        }{</span><br><span class="line">            ReadCloser: r.Body,</span><br><span class="line">            Writer:     w,</span><br><span class="line">        }</span><br><span class="line">        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    })</span><br><span class="line">    http.ListenAndServe(<span class="string">":1234"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RPC的服务架设在“/jsonrpc”路径，在处理函数中基于http.ResponseWriter和http.Request类型的参数构造一个io.ReadWriteCloser类型的conn通道。然后基于conn构建针对服务端的json编码解码器。最后通过rpc.ServeRequest函数为每次请求处理一次RPC方法调用。</p>
<p>模拟一次RPC调用的过程就是向该链接发送一个json字符串：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:1234/jsonrpc -X POST \</span></span><br><span class="line">    --data '{"method":"HelloService.Hello","params":["hello"],"id":0}'</span><br></pre></td></tr></tbody></table></figure>

<p>返回的结果依然是json字符串：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"id"</span>:<span class="number">0</span>,<span class="attr">"result"</span>:<span class="string">"hello:hello"</span>,<span class="attr">"error"</span>:<span class="literal">null</span>}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就可以很方便地从不同语言中访问RPC服务了。</p>
<p>option go_package 设置 package 名称 和生成的文件路径<br><code>".;proto"</code> 生成在当前路径，<br><code>"coolcar/auth/api/gen/v1;authpb"</code><br><code>coolcar/auth/api/gen/v1;</code> 定义生成的go文件存放 package 目录路径，<br><code>authpb</code>：表示生成的go文件包的名字</p>
<p>proto文件名称为：trip.proto<br>两者名字前缀最好要一致。</p>
<p>option java_package</p>
<p>这个选项我们在 Python 中是不需要的，但是在 Go 里面是需要的（如果没有的话也不会报错，但是会抛警告，然后生成的文件的包名就是 proto 文件的名字）。当时我们是通过这个选项指定的包名，但其实这个选项的设置是比较灵活的，我们还可以自己指定生成文件的目录。</p>
<p><code>option go_package = "../../common/stream/proto/v1";</code></p>
<p>如果改成上面这种方式的话，那么会把生成的文件放在执行命令的目录下的 common/stream/protobuf/v1 中，并且包名是 v1。如果目录不存在的话，会自动创建。并且这个选项对 Python 是无任何影响的，所以一个针对于 Go 的 proto 文件，拿给 Python 也是完全可以使用的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax = "proto3";</span><br><span class="line">package coolcar;</span><br><span class="line">option go_package = "coolcar/proto/gen/go;trippb";</span><br><span class="line"></span><br><span class="line">message Trip {</span><br><span class="line">  string start = 1;</span><br><span class="line">  string end = 2;</span><br><span class="line">  int64 duration_sec = 3;</span><br><span class="line">  int64 fee_cent = 4;</span><br><span class="line">  TripStatus status = 8;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> car/proto</span><br><span class="line">protoc -I . <span class="params">--go_out=paths=source_relative</span><span class="function">:gen</span>/go trip.proto</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trip <span class="keyword">struct</span> {</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    Start         <span class="keyword">string</span>      <span class="string">`protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`</span></span><br><span class="line">    End           <span class="keyword">string</span>      <span class="string">`protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`</span></span><br><span class="line">    DurationSec   <span class="keyword">int64</span>       <span class="string">`protobuf:"varint,3,opt,name=duration_sec,json=durationSec,proto3" json:"duration_sec,omitempty"`</span></span><br><span class="line">    FeeCent       <span class="keyword">int64</span>       <span class="string">`protobuf:"varint,4,opt,name=fee_cent,json=feeCent,proto3" json:"fee_cent,omitempty"`</span></span><br><span class="line">    Status        TripStatus  <span class="string">`protobuf:"varint,8,opt,name=status,proto3,enum=coolcar.TripStatus" json:"status,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果message中的数据类型是int64，那么在转成json时会变成字符串，这是因为int64的长度过大<br>，如果使用int32那么转成json时，数据类型则会是数字类型。<br>字段名 duration_sec ，生成go代码时会使用驼峰规则</p>
<p>import trippb “coolcar/proto/gen/go”</p>
<p>与proto中的定义对应起来：option go_package=”coolcar/proto/gen/go;trippb”;</p>
<p>包名称为:trippb</p>
<p>包路径为：coolcar/proto/gen/go</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    trippb <span class="string">"OldPackageTest/car/proto/gen/go"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1、模拟微服务和微服务之间通过gRPC传递二进制流来互相通信</span></span><br><span class="line">    trip := trippb.Trip{</span><br><span class="line">        Start:       <span class="string">"abc"</span>,</span><br><span class="line">        End:         <span class="string">"def"</span>,</span><br><span class="line">        DurationSec: <span class="number">3600</span>,</span><br><span class="line">        FeeCent:     <span class="number">10000</span>,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(&amp;trip)</span><br><span class="line">    <span class="comment">//start:"abc"  end:"def"  duration_sec:3600  fee_cent:10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据转换为二进制bianma数据，并打印出来（模拟向客户端发送数据）</span></span><br><span class="line">    b, err := proto.Marshal(&amp;trip)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, b)</span><br><span class="line">    <span class="comment">//0A03616263120364656618901C20904E</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将二进制数据解码回来（模拟从客户端接收数据并解析成可以使用的数据格式）</span></span><br><span class="line">    <span class="keyword">var</span> trip2 trippb.Trip</span><br><span class="line">    err = proto.Unmarshal(b, &amp;trip2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(&amp;trip2)</span><br><span class="line">    <span class="comment">//start:"abc"  end:"def"  duration_sec:3600  fee_cent:10000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、模拟发送json数据给小程序端，因为pg.go 中结构体有json标签</span></span><br><span class="line">    c, err := json.Marshal(&amp;trip2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, c)</span><br><span class="line">    <span class="comment">//{"start":"abc","end":"def","duration_sec":3600,"fee_cent":10000}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>protobuf的基本类型和默认值 (15:41)<br>当proto文件不同步的时候容易出现的问题 (12:28)</p>
<p>proto文件中引入其他的proto文件 (10:20)</p>
<p>比如我们要定义多个服务，这些服务都有一个相同的方法，比如：调用 Ping，返回字符串 Pong，那么我们可以把这些公共的写在一个单独的文件中，然后去导入它。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 common.proto</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 我们调用 Ping 是不需要传递参数的，但是 proto 文件要求我们必须定义</span><br><span class="line">// 所以我们定义一个空的消息体即可，就叫 Empty</span><br><span class="line">message Empty {}</span><br><span class="line"></span><br><span class="line">message Pong {</span><br><span class="line">  string result = 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们在其它的 proto 文件（hello.proto）导入它：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"common.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/empty.proto"</span>;  <span class="comment">// 导入内置的 proto 文件</span></span><br><span class="line">option go_package = <span class="string">".;yoyoyo"</span>;  <span class="comment">// 对 Python 无影响</span></span><br><span class="line"></span><br><span class="line">message HelloRequest {</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">message HelloResponse {</span><br><span class="line">  <span class="built_in">string</span> message = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">service Hello {</span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloResponse)</span> </span>{}</span><br><span class="line">  <span class="function">rpc <span class="title">Ping</span><span class="params">(google.protobuf.Empty)</span> <span class="title">returns</span> <span class="params">(Pong)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 注意到 google.protobuf.Empty 是我们从内置的 proto 文件中导入的，Pong 我们定义在 common.proto 文件中</span></span><br><span class="line"><span class="comment">// 但是我们将它们所在的文件都 import 进来了，所以可以直接使用</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"./;proto"</span>;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Pong</span></span>{</span><br><span class="line">  <span class="built_in">string</span> id = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="嵌套的message对象-复合类型"><a href="#嵌套的message对象-复合类型" class="headerlink" title="嵌套的message对象 复合类型"></a>嵌套的message对象 复合类型</h4><p>建立三个message，同时包含复合类型（Location）和枚举类型（TripStatus）以及repeated重复类型<br>proto中的double类型转换为golang的float64,枚举类型转换为int32</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = "proto3";</span><br><span class="line">package coolcar;</span><br><span class="line">option go_package = "coolcar/proto/gen/go;trippb";</span><br><span class="line"></span><br><span class="line">message Location {</span><br><span class="line">  double latitude = 1;</span><br><span class="line">  double longitude = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">enum TripStatus {</span><br><span class="line">  TS_NOT_SPECIFIED = 0;</span><br><span class="line">  NOT_STARTED = 1;</span><br><span class="line">  IN_PROGRESS = 2;</span><br><span class="line">  FINISHED = 3;</span><br><span class="line">  PAID = 4;</span><br><span class="line">}</span><br><span class="line">message Trip {</span><br><span class="line">  string start = 1;</span><br><span class="line">  string end = 2;</span><br><span class="line">  Location start_pos = 5;</span><br><span class="line">  Location end_pos = 6;</span><br><span class="line">  repeated Location path_locations = 7;</span><br><span class="line">  int64 duration_sec = 3;</span><br><span class="line">  int64 fee_cent = 4;</span><br><span class="line">  TripStatus status = 8;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>v2版本和v1命令不一样</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd car/proto</span><br><span class="line">protoc -I . --go_out=paths=source_relative:gen/go trip.proto</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trip <span class="keyword">struct</span> {</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    Start         <span class="keyword">string</span>      <span class="string">`protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`</span></span><br><span class="line">    End           <span class="keyword">string</span>      <span class="string">`protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`</span></span><br><span class="line">    StartPos      *Location   <span class="string">`protobuf:"bytes,5,opt,name=start_pos,json=startPos,proto3" json:"start_pos,omitempty"`</span></span><br><span class="line">    EndPos        *Location   <span class="string">`protobuf:"bytes,6,opt,name=end_pos,json=endPos,proto3" json:"end_pos,omitempty"`</span></span><br><span class="line">    PathLocations []*Location <span class="string">`protobuf:"bytes,7,rep,name=path_locations,json=pathLocations,proto3" json:"path_locations,omitempty"`</span></span><br><span class="line">    DurationSec   <span class="keyword">int64</span>       <span class="string">`protobuf:"varint,3,opt,name=duration_sec,json=durationSec,proto3" json:"duration_sec,omitempty"`</span></span><br><span class="line">    FeeCent       <span class="keyword">int64</span>       <span class="string">`protobuf:"varint,4,opt,name=fee_cent,json=feeCent,proto3" json:"fee_cent,omitempty"`</span></span><br><span class="line">    Status        TripStatus  <span class="string">`protobuf:"varint,8,opt,name=status,proto3,enum=coolcar.TripStatus" json:"status,omitempty"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> {</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    Latitude  <span class="keyword">float64</span> <span class="string">`protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`</span></span><br><span class="line">    Longitude <span class="keyword">float64</span> <span class="string">`protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TripStatus <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    TripStatus_TS_NOT_SPECIFIED TripStatus = <span class="number">0</span></span><br><span class="line">    TripStatus_NOT_STARTED      TripStatus = <span class="number">1</span></span><br><span class="line">    TripStatus_IN_PROGRESS      TripStatus = <span class="number">2</span></span><br><span class="line">    TripStatus_FINISHED         TripStatus = <span class="number">3</span></span><br><span class="line">    TripStatus_PAID             TripStatus = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum value maps for TripStatus.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    TripStatus_name = <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">string</span>{</span><br><span class="line">        <span class="number">0</span>: <span class="string">"TS_NOT_SPECIFIED"</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">"NOT_STARTED"</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">"IN_PROGRESS"</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">"FINISHED"</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">"PAID"</span>,</span><br><span class="line">    }</span><br><span class="line">    TripStatus_value = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int32</span>{</span><br><span class="line">        <span class="string">"TS_NOT_SPECIFIED"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"NOT_STARTED"</span>:      <span class="number">1</span>,</span><br><span class="line">        <span class="string">"IN_PROGRESS"</span>:      <span class="number">2</span>,</span><br><span class="line">        <span class="string">"FINISHED"</span>:         <span class="number">3</span>,</span><br><span class="line">        <span class="string">"PAID"</span>:             <span class="number">4</span>,</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>复合类型为指针类型，repeated类型转换为指针切片。复合类型编译成go之后的数据类型是一个切片</p>
<p>不是字段的值是1，编号一定要相同，第一个字段是xx，第二个字段是xx，通过编号映射而不是变量名称和定义顺序</p>
<h4 id="protobuf中的-enum-枚举类型"><a href="#protobuf中的-enum-枚举类型" class="headerlink" title="protobuf中的 enum 枚举类型"></a>protobuf中的 enum 枚举类型</h4><p>字段都大写，枚举类型编译成go代码之后就变成了几个常量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    trippb <span class="string">"OldPackageTest/car/proto/gen/go"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1、模拟微服务和微服务之间通过gRPC传递二进制流来互相通信</span></span><br><span class="line">    trip := trippb.Trip{</span><br><span class="line">        Start:       <span class="string">"abc"</span>,</span><br><span class="line">        End:         <span class="string">"def"</span>,</span><br><span class="line">        DurationSec: <span class="number">3600</span>,</span><br><span class="line">        FeeCent:     <span class="number">10000</span>,</span><br><span class="line"></span><br><span class="line">        StartPos:&amp;trippb.Location{ <span class="comment">//必须为取地址</span></span><br><span class="line">            Latitude:<span class="number">30</span>,</span><br><span class="line">            Longitude:<span class="number">120</span>,</span><br><span class="line">        },</span><br><span class="line">        EndPos:&amp;trippb.Location{</span><br><span class="line">            Latitude:<span class="number">35</span>,</span><br><span class="line">            Longitude:<span class="number">115</span>,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        PathLocations:[]*trippb.Location{ <span class="comment">//指针切片</span></span><br><span class="line">            {</span><br><span class="line">                Latitude:<span class="number">31</span>,</span><br><span class="line">                Longitude:<span class="number">119</span>,</span><br><span class="line">            },</span><br><span class="line">            {</span><br><span class="line">                Latitude:<span class="number">32</span>,</span><br><span class="line">                Longitude:<span class="number">118</span>,</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">        Status:trippb.TripStatus_IN_PROGRESS, <span class="comment">// 枚举对应常量</span></span><br><span class="line">    }</span><br><span class="line">    fmt.Println(&amp;trip)</span><br><span class="line">    <span class="comment">//start:"abc" end:"def" start_pos:{latitude:30 longitude:120} end_pos:{latitude:35 longitude:115} path_locations:{latitude:31 longitude:119} path_locations:{latitude:32 longitude:118} duration_sec:3600 fee_cent:10000 status:IN_PROGRESS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据转换为二进制bianma数据，并打印出来（模拟向客户端发送数据）</span></span><br><span class="line">    b, err := proto.Marshal(&amp;trip)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, b)</span><br><span class="line">    <span class="comment">//0A03616263120364656618901C20904E2A12090000000000003E40110000000000005E403212090000000000804140110000000000C05C403A12090000000000003F40110000000000C05D403A12090000000000004040110000000000805D404002</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将二进制数据解码回来（模拟从客户端接收数据并解析成可以使用的数据格式）</span></span><br><span class="line">    <span class="keyword">var</span> trip2 trippb.Trip</span><br><span class="line">    err = proto.Unmarshal(b, &amp;trip2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(&amp;trip2)</span><br><span class="line">    <span class="comment">// start:"abc" end:"def" start_pos:{latitude:30 longitude:120} end_pos:{latitude:35 longitude:115} path_locations:{latitude:31 longitude:119} path_locations:{latitude:32 longitude:118} duration_sec:3600 fee_cent:10000 status:IN_PROGRESS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、模拟发送json数据给小程序端，因为pg.go 中结构体有json标签</span></span><br><span class="line">    c, err := json.Marshal(&amp;trip2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"start"</span>: <span class="string">"abc"</span>,</span><br><span class="line">  <span class="attr">"end"</span>: <span class="string">"def"</span>,</span><br><span class="line">  <span class="attr">"start_pos"</span>: {</span><br><span class="line">    <span class="attr">"latitude"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"longitude"</span>: <span class="number">120</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"end_pos"</span>: {</span><br><span class="line">    <span class="attr">"latitude"</span>: <span class="number">35</span>,</span><br><span class="line">    <span class="attr">"longitude"</span>: <span class="number">115</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"path_locations"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"latitude"</span>: <span class="number">31</span>,</span><br><span class="line">      <span class="attr">"longitude"</span>: <span class="number">119</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">"latitude"</span>: <span class="number">32</span>,</span><br><span class="line">      <span class="attr">"longitude"</span>: <span class="number">118</span></span><br><span class="line">    }</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"duration_sec"</span>: <span class="number">3600</span>,</span><br><span class="line">  <span class="attr">"fee_cent"</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span></span>{</span><br><span class="line">    MALE = <span class="number">0</span>;</span><br><span class="line">    FEMALE = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>{</span><br><span class="line">    Gender g = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsp, _ := client.SayHello(context.Background(), &amp;proto_bak.HelloRequest{</span><br><span class="line">    G:    proto_bak.Gender_MALE,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="protobuf中的-map-枚举类型"><a href="#protobuf中的-map-枚举类型" class="headerlink" title="protobuf中的 map 枚举类型"></a>protobuf中的 map 枚举类型</h4><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>{</span><br><span class="line">    map&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mp = <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rsp, _ := client.SayHello(context.Background(), &amp;proto_bak.HelloRequest{</span><br><span class="line">    Mp: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{</span><br><span class="line">        <span class="string">"name"</span>:    <span class="string">"bobby"</span>,</span><br><span class="line">        <span class="string">"company"</span>: <span class="string">"慕课网"</span>,</span><br><span class="line">    },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="protobuf内置的timestamp类型"><a href="#protobuf内置的timestamp类型" class="headerlink" title="protobuf内置的timestamp类型"></a>protobuf内置的timestamp类型</h4><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>{</span><br><span class="line">    google.protobuf.Timestamp addTime = <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsp, _ := client.SayHello(context.Background(), &amp;proto_bak.HelloRequest{</span><br><span class="line">    AddTime: timestamppb.New(time.Now()),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h4><p>ProtoBuf的所有字段都是可选的，每个字段都可以选择不填，不填的话他的值就是零（0/false/“”）</p>
<p>因为所有字段都是可选则，所以一个字段的值填零（数据类型的默认值，如int64的默认值0）和不填，结果是一样的。就是pb 文件的 json 标签的 <code>emitempty</code></p>
<p>所以使用proto定义一个bool类型的字段时要特别小心，有很大的风险</p>
<h3 id="定义一个服务，同时用命令生成go代码"><a href="#定义一个服务，同时用命令生成go代码" class="headerlink" title="定义一个服务，同时用命令生成go代码"></a>定义一个服务，同时用命令生成go代码</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message GetTripRequest {</span><br><span class="line">  string id = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">message GetTripResponse{</span><br><span class="line">  string id = 1;</span><br><span class="line">  Trip   trip = 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义服务</span><br><span class="line">service TripService {</span><br><span class="line">  //定义服务接口GetTrip，接收参数为 GetTripRequest，返回为GetTripResponse</span><br><span class="line">  rpc GetTrip (GetTripRequest) returns (GetTripResponse);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code">https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code</a></p>
<p>Regenerate gRPC code<br>Before you can use the new service method, you need to recompile the updated .proto file.</p>
<p>While still in the <code>examples/helloworld</code> directory, run the following command:</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc <span class="attribute">--go_out</span>=. <span class="attribute">--go_opt</span>=paths=source_relative \</span><br><span class="line">    <span class="attribute">--go-grpc_out</span>=. <span class="attribute">--go-grpc_opt</span>=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></tbody></table></figure>

<p>This will regenerate the <code>helloworld/helloworld.pb.go</code> and <code>helloworld/helloworld_grpc.pb.go</code> files, which contain:</p>
<ul>
<li>Code for populating, serializing, and retrieving <code>HelloRequest</code> and <code>HelloReply</code> message types.</li>
<li>Generated client and server code.</li>
</ul>
<p>在<code>server/proto/</code>目录下执行命令改成:&nbsp;</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative trip.proto</span><br><span class="line"></span><br><span class="line">protoc --go_out=paths=source_relative:gen/go --go-grpc_out=. --go-grpc_opt=paths=source_relative trip.proto​</span><br><span class="line"></span><br><span class="line">指定路径</span><br><span class="line">protoc --go_out=./gen/go --go_opt=paths=source_relative --go-grpc_out=./gen/go --go-grpc_opt=paths=source_relative trip.proto</span><br></pre></td></tr></tbody></table></figure>

<p>pb描述和rpc方法之前旧版生成是在一个文件中，新版本命令分别生成了2个文件pb和方法已经分离<br><code>protoc --go_out=. --go_opt=paths=source_relative .\proto\trip.proto</code>生成了message对应的的trip.pb.go文件，示例如下</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TripStatus <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  TripStatus_IS_NOT_SPECIFIED TripStatus = <span class="number">0</span></span><br><span class="line">  TripStatus_NOT_START        TripStatus = <span class="number">1</span></span><br><span class="line">  TripStatus_IN_PROGRESS      TripStatus = <span class="number">2</span></span><br><span class="line">  TripStatus_FINISHED         TripStatus = <span class="number">3</span></span><br><span class="line">  TripStatus_PAID             TripStatus = <span class="number">4</span></span><br><span class="line">  TripStatus_OVER             TripStatus = <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Enum value maps for TripStatus.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  TripStatus_name = <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">string</span>{</span><br><span class="line">    <span class="number">0</span>: <span class="string">"IS_NOT_SPECIFIED"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"NOT_STARTED"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">"IN_PROGRESS"</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">"FINISHED"</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">"PAID"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"OVER"</span>,</span><br><span class="line">  }</span><br><span class="line">  TripStatus_value = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int32</span>{</span><br><span class="line">    <span class="string">"IS_NOT_SPECIFIED"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"NOT_STARTED"</span>:        <span class="number">1</span>,</span><br><span class="line">    <span class="string">"IN_PROGRESS"</span>:      <span class="number">2</span>,</span><br><span class="line">    <span class="string">"FINISHED"</span>:         <span class="number">3</span>,</span><br><span class="line">    <span class="string">"PAID"</span>:             <span class="number">4</span>,</span><br><span class="line">    <span class="string">"OVER"</span>:             <span class="number">5</span>,</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> {</span><br><span class="line">    state         protoimpl.MessageState</span><br><span class="line">    sizeCache     protoimpl.SizeCache</span><br><span class="line">    unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">    Latitude  <span class="keyword">float64</span> <span class="string">`protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`</span></span><br><span class="line">    Longitude <span class="keyword">float64</span> <span class="string">`protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>protoc --go-grpc_out=. --go-grpc_opt=paths=source_relative .\proto\trip.proto</code>生成了service对应的trip_grpc.pb.go文件，<br>里面分别定义了TripServiceServer和TripServiceClient两个interface，分别对应服务端和客户端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TripServiceClient is the client API for TripService service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> TripServiceClient <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">//定义服务接口GetTrip，接收参数为 GetTripRequest，返回为GetTripResponse</span></span><br><span class="line">    GetTrip(ctx context.Context, in *GetTripRequest, opts ...grpc.CallOption) (*GetTripResponse, error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TripServiceServer is the server API for TripService service.</span></span><br><span class="line"><span class="comment">// All implementations must embed UnimplementedTripServiceServer</span></span><br><span class="line"><span class="comment">// for forward compatibility</span></span><br><span class="line"><span class="keyword">type</span> TripServiceServer <span class="keyword">interface</span> {</span><br><span class="line">    <span class="comment">//定义服务接口GetTrip，接收参数为 GetTripRequest，返回为GetTripResponse</span></span><br><span class="line">    GetTrip(context.Context, *GetTripRequest) (*GetTripResponse, error)</span><br><span class="line">    mustEmbedUnimplementedTripServiceServer()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>旧版</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I . --go_out=plugins=grpc,paths=source_relative:gen/go trip.proto</span><br></pre></td></tr></tbody></table></figure>

<p><code>need method: GetTrip(context.Context, *GetTripRequest) (*Trip, error)</code></p>
<p><code>have method: GetTrip(c context.Context, req *trippb.GetTripRequest) (*trippb.GetTripResponse, error)</code></p>
<p>也就是说，GetTrip在proto里定义的是返回Trip，而我们在代码里返回的是GetTripResponse。<br>这边的确我在设计的时候就有反复，两种做法都是可以的，最终我的做法是返回Trip。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    trippb <span class="string">"OldPackageTest/car/proto/gen/go"</span></span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="comment">//trippb "coolcar/proto/gen/go"</span></span><br><span class="line">    <span class="comment">//trip "OldPackageTest/car/tripservice"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span>{</span><br><span class="line">    <span class="comment">// 把 trippb.UnimplementedTripServiceServer 结构体组合(继承)到自己定义的结构体中</span></span><br><span class="line">    trippb.UnimplementedTripServiceServer <span class="comment">// 实现了 trippb.TripServiceServer 接口</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现GetTrip接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Server)</span> <span class="title">GetTrip</span><span class="params">(c context.Context, req *trippb.GetTripRequest)</span> <span class="params">(*trippb.GetTripResponse, error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;trippb.GetTripResponse{</span><br><span class="line">        Id: req.Id,</span><br><span class="line">        Trip: &amp;trippb.Trip{</span><br><span class="line">            Start:       <span class="string">"abc"</span>,</span><br><span class="line">            End:         <span class="string">"def"</span>,</span><br><span class="line">            DurationSec: <span class="number">3600</span>,</span><br><span class="line">            FeeCent:     <span class="number">10000</span>,</span><br><span class="line">            StartPos: &amp;trippb.Location{</span><br><span class="line">                Latitude:  <span class="number">30</span>,</span><br><span class="line">                Longitude: <span class="number">120</span>,</span><br><span class="line">            },</span><br><span class="line">            EndPos: &amp;trippb.Location{</span><br><span class="line">                Latitude:  <span class="number">35</span>,</span><br><span class="line">                Longitude: <span class="number">120</span>,</span><br><span class="line">            },</span><br><span class="line">            PathLocations: []*trippb.Location{</span><br><span class="line">                {</span><br><span class="line">                    Latitude:  <span class="number">35</span>,</span><br><span class="line">                    Longitude: <span class="number">120</span>,</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    Latitude:  <span class="number">35</span>,</span><br><span class="line">                    Longitude: <span class="number">120</span>,</span><br><span class="line">                },</span><br><span class="line">            },</span><br><span class="line">            Status: trippb.TripStatus_IN_PROGRESS,</span><br><span class="line">        },</span><br><span class="line">    }, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//该代码只是用来判断服务是否都实现</span></span><br><span class="line"><span class="keyword">var</span> _ tripPb.TripServiceServer = &amp;Server{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err) <span class="comment">// 输出完程序就退出</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    trippb.RegisterTripServiceServer(s, &amp;Server{})</span><br><span class="line">    log.Fatal(s.Serve(lis))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>客户端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    trippb <span class="string">"OldPackageTest/car/proto/gen/go"</span></span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    conn, err := grpc.Dial(<span class="string">"localhost:8081"</span>, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"cannot connect server: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tsClient := trippb.NewTripServiceClient(conn)</span><br><span class="line">    r, err := tsClient.GetTrip(context.Background(), &amp;trippb.GetTripRequest{</span><br><span class="line">        Id: <span class="string">"trip456,hello"</span>,</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"cannot call GetTrip: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">}</span><br><span class="line">---</span><br><span class="line">id:<span class="string">"trip456,hello"</span> trip:{start:<span class="string">"abc"</span> end:<span class="string">"def"</span> start_pos:{latitude:<span class="number">30</span> longitude:<span class="number">120</span>} end_pos:{latitude:<span class="number">35</span> longitude:<span class="number">120</span>} path_locations:{latitude:<span class="number">35</span> longitude:<span class="number">120</span>} path_locations:{latitude:<span class="number">35</span> longitude:<span class="number">120</span>} duration_sec:<span class="number">3600</span> fee_cent:<span class="number">10000</span> status:IN_PROGRESS}</span><br></pre></td></tr></tbody></table></figure>

<p>client发送了一个值为<code>trip456,hello</code>的id个服务端，服务器原样返回给客户端了</p>
<h3 id="grpcgateway"><a href="#grpcgateway" class="headerlink" title="grpcgateway"></a>grpcgateway</h3><p>使用 http/json 来访问grpc<br>用GRPC Gateway暴露REST接口</p>
<p>/protp/trip.yaml</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">google.api.Service</span></span><br><span class="line"><span class="attr">config_version:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">selector:</span> <span class="string">coolcar.TripService.GetTrip</span> <span class="comment"># proto 文件 package.service.func</span></span><br><span class="line">      <span class="attr">get:</span> <span class="string">/trip/{id}</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xxx/proto</span><br><span class="line">protoc --go_out=plugins=grpc,paths=source_relative:gen/go trip.proto</span><br><span class="line">protoc --grpc-gateway_out=paths=source_relative,grpc_api_configuration=trip.yaml:gen/go trip.proto</span><br></pre></td></tr></tbody></table></figure>

<p>会在gen/go中多一个trip.pb.gw.go文件</p>
<p>服务端</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    trippb <span class="string">"OldPackageTest/car/proto/gen/go"</span></span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trippb "coolcar/proto/gen/go"</span></span><br><span class="line">    <span class="comment">//trip "OldPackageTest/car/tripservice"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span>{</span><br><span class="line">    <span class="comment">// 把 trippb.UnimplementedTripServiceServer 结构体组合(继承)到自己定义的结构体中</span></span><br><span class="line">    trippb.UnimplementedTripServiceServer <span class="comment">// 实现了 trippb.TripServiceServer 接口</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Server)</span> <span class="title">GetTrip</span><span class="params">(c context.Context, req *trippb.GetTripRequest)</span> <span class="params">(*trippb.GetTripResponse, error)</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;trippb.GetTripResponse{</span><br><span class="line">        Id: req.Id,</span><br><span class="line">        Trip: &amp;trippb.Trip{</span><br><span class="line">            Start:       <span class="string">"abc"</span>,</span><br><span class="line">            End:         <span class="string">"def"</span>,</span><br><span class="line">            DurationSec: <span class="number">3600</span>,</span><br><span class="line">            FeeCent:     <span class="number">10000</span>,</span><br><span class="line">            StartPos: &amp;trippb.Location{</span><br><span class="line">                Latitude:  <span class="number">30</span>,</span><br><span class="line">                Longitude: <span class="number">120</span>,</span><br><span class="line">            },</span><br><span class="line">            EndPos: &amp;trippb.Location{</span><br><span class="line">                Latitude:  <span class="number">35</span>,</span><br><span class="line">                Longitude: <span class="number">120</span>,</span><br><span class="line">            },</span><br><span class="line">            PathLocations: []*trippb.Location{</span><br><span class="line">                {</span><br><span class="line">                    Latitude:  <span class="number">35</span>,</span><br><span class="line">                    Longitude: <span class="number">120</span>,</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    Latitude:  <span class="number">35</span>,</span><br><span class="line">                    Longitude: <span class="number">120</span>,</span><br><span class="line">                },</span><br><span class="line">            },</span><br><span class="line">            Status: trippb.TripStatus_IN_PROGRESS,</span><br><span class="line">        },</span><br><span class="line">    }, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    log.SetFlags(log.Lshortfile)</span><br><span class="line">    fmt.Println(<span class="string">"service is runing"</span>)</span><br><span class="line">    <span class="keyword">go</span> startGRPCGateway()</span><br><span class="line"></span><br><span class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err) <span class="comment">// 输出完程序就退出</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    trippb.RegisterTripServiceServer(s, &amp;Server{})</span><br><span class="line">    log.Fatal(s.Serve(lis))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startGRPCGateway</span><span class="params">()</span></span> {</span><br><span class="line">    c := context.Background()</span><br><span class="line">    c, cancel := context.WithCancel(c)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    mux := runtime.NewServeMux()</span><br><span class="line">    err := trippb.RegisterTripServiceHandlerFromEndpoint(</span><br><span class="line">        c,</span><br><span class="line">        mux,</span><br><span class="line">        <span class="string">"localhost:8081"</span>,</span><br><span class="line">        []grpc.DialOption{grpc.WithInsecure()},</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"cannot start grpc gateway: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    err = http.ListenAndServe(<span class="string">":8080"</span>, mux)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"cannot listen and server: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行客户端</p>
<p>可以在浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:8080/trip/123">http://localhost:8080/trip/123</a>或者用curl 命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/trip/123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : {"id":"123", "trip":{"start":"abc", "end":"def", "startPos":{"latitude":30, "longitude":120}, "endPos":{"latitude":35, "longitude":120}, "path</span><br><span class="line">                    Locations":[{"latitude":35, "longitude":120}, {"latitude":...</span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">                    Grpc-Metadata-Content-Type: application/grpc</span><br><span class="line">                    Content-Length: 288</span><br><span class="line">                    Content-Type: application/json</span><br><span class="line">                    Date: Tue, 19 Oct 2021 09:24:43 GMT</span><br><span class="line"></span><br><span class="line">                    {"id":"123", "trip":{"start":"abc", "end":"de...</span><br><span class="line">Forms             : {}</span><br><span class="line">Headers           : {[Grpc-Metadata-Content-Type, application/grpc], [Content-Length, 288], [Content-Type, application/json], [Date, Tue, 19 Oct 2021 09:24:43 GMT</span><br><span class="line">                    ]}</span><br><span class="line">Images            : {}</span><br><span class="line">InputFields       : {}</span><br><span class="line">Links             : {}</span><br><span class="line">ParsedHtml        : mshtml.HTMLDocumentClass</span><br><span class="line">RawContentLength  : 288</span><br></pre></td></tr></tbody></table></figure>

<h4 id="grpc配合asyncio使用-23-58"><a href="#grpc配合asyncio使用-23-58" class="headerlink" title="grpc配合asyncio使用 (23:58)"></a>grpc配合asyncio使用 (23:58)</h4><p>client 终端输出</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello bobby</span></span><br></pre></td></tr></tbody></table></figure>

<p>server 终端输出</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get metadata error</span><br><span class="line"><span class="meta">[bobby]</span></span><br><span class="line">0 bobby</span><br><span class="line"></span><br><span class="line"><span class="meta">:authority [127.0.0.1:50051]</span></span><br><span class="line"><span class="meta">content-type</span> [application/grpc]</span><br><span class="line">user-agent [grpc-go/1.41.0]</span><br><span class="line">name [bobby]</span><br><span class="line">pasword [imooc]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="grpc的metadata机制-go-21-35"><a href="#grpc的metadata机制-go-21-35" class="headerlink" title="grpc的metadata机制-go (21:35)"></a>grpc的metadata机制-go (21:35)</h4><p>python操作metada (10:05)<br>grpc拦截器 - go (21:18)<br>python实现grpc的拦截器 (11:56)<br>通过拦截器和metadata实现grpc的auth认证 (17:50)<br>grpc的验证器 (32:11)<br>grpc中的错误处理 (25:31)<br>grpc的超时机制 (07:10)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/02/go-bian-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/02/go-bian-yi/" class="post-title-link" itemprop="url">Go 进程的启动过程、调度循环和GPM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-01 16:21:41" itemprop="dateCreated datePublished" datetime="2021-10-01T16:21:41Z">2021-10-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-04 13:16:45" itemprop="dateModified" datetime="2021-10-04T13:16:45Z">2021-10-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="寻找-make-的实现"><a href="#寻找-make-的实现" class="headerlink" title="寻找 make 的实现"></a>寻找 make 的实现</h3><p><a target="_blank" rel="noopener" href="https://golang.org/ref/spec">https://golang.org/ref/spec</a></p>
<p>Making slices, maps and channels ¶<br>The built-in function make takes a type T, which must be a slice, map or channel type, optionally followed by a type-specific list of expressions. It returns a value of type T (not *T). The memory is initialized as described in the section on initial values.</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Call            <span class="built_in"> Type </span>T     Result</span><br><span class="line"></span><br><span class="line">make(T, n)       slice      slice of<span class="built_in"> type </span>T with length n <span class="keyword">and</span> capacity n</span><br><span class="line">make(T, n, m)    slice      slice of<span class="built_in"> type </span>T with length n <span class="keyword">and</span> capacity m</span><br><span class="line"></span><br><span class="line">make(T)          map        map of<span class="built_in"> type </span>T</span><br><span class="line">make(T, n)       map        map of<span class="built_in"> type </span>T with initial space <span class="keyword">for</span> approximately n elements</span><br><span class="line"></span><br><span class="line">make(T)          channel    unbuffered channel of<span class="built_in"> type </span>T</span><br><span class="line">make(T, n)       channel    buffered channel of<span class="built_in"> type </span>T, buffer size n</span><br></pre></td></tr></tbody></table></figure>

<h3 id="观察-make"><a href="#观察-make" class="headerlink" title="观察 make"></a>观察 make</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// make slice</span></span><br><span class="line">    <span class="comment">// 空间开的比较大，是为了让这个 slice 分配在堆上，栈上的 slice 结果不太一样</span></span><br><span class="line">    <span class="keyword">var</span> sl = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100000</span>)</span><br><span class="line">    <span class="built_in">println</span>(sl)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make channel</span></span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">println</span>(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make map</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">22</span>)</span><br><span class="line">    <span class="built_in">println</span>(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ cat -n <span class="built_in">make</span>.<span class="keyword">go</span>  # 一次性显示文件内容和行号</span><br><span class="line">     <span class="number">1</span>    <span class="keyword">package</span> main</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">     <span class="number">3</span>    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">     <span class="number">4</span>        <span class="comment">// make slice</span></span><br><span class="line">     <span class="number">5</span>        <span class="comment">// 空间开的比较大，是为了让这个 slice 分配在堆上，栈上的 slice 结果不太一样</span></span><br><span class="line">     <span class="number">6</span>        <span class="keyword">var</span> sl = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100000</span>)</span><br><span class="line">     <span class="number">7</span>        <span class="built_in">println</span>(sl)</span><br><span class="line">     <span class="number">8</span></span><br><span class="line">     <span class="number">9</span>        <span class="comment">// make channel</span></span><br><span class="line">    <span class="number">10</span>        <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="number">11</span>        <span class="built_in">println</span>(ch)</span><br><span class="line">    <span class="number">12</span></span><br><span class="line">    <span class="number">13</span>        <span class="comment">// make map</span></span><br><span class="line">    <span class="number">14</span>        <span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">22</span>)</span><br><span class="line">    <span class="number">15</span>        <span class="built_in">println</span>(m)</span><br><span class="line">    <span class="number">16</span>    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build make.go &amp;&amp; go tool objdump ./make | grep -E "make.go:6|make.go:10|make.go:14"</span><br></pre></td></tr></tbody></table></figure>

<p>这里使用 go tool compile -S 也是可以的。</p>
<h3 id="寻找-new-的实现"><a href="#寻找-new-的实现" class="headerlink" title="寻找 new 的实现"></a>寻找 new 的实现</h3><p>The built-in function new takes a type T, allocates storage for a variable of that type at run time, and returns a value of type *T pointing to it. The variable is initialized as described in the section on initial values.</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">new</span><span class="params">(T)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>For instance</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> S <span class="keyword">struct</span> { a int; b float64 }</span><br><span class="line"><span class="keyword">new</span>(S)</span><br></pre></td></tr></tbody></table></figure>

<p>allocates storage for a variable of type S, initializes it (a=0, b=0.0), and returns a value of type *S containing the address of the location.</p>
<p>不太好找，需要去看编译器的内部代码，建议放弃</p>
<h3 id="观察-new-输出内容难以读懂，不推荐"><a href="#观察-new-输出内容难以读懂，不推荐" class="headerlink" title="观察 new(输出内容难以读懂，不推荐)"></a>观察 new(<strong>输出内容难以读懂，不推荐</strong>)</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ cat -n <span class="built_in">new</span>.<span class="keyword">go</span></span><br><span class="line">     <span class="number">1</span>    <span class="keyword">package</span> main</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">     <span class="number">3</span>    <span class="keyword">type</span> person <span class="keyword">struct</span>{ age <span class="keyword">int</span> }</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">     <span class="number">6</span>        <span class="keyword">var</span> a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">     <span class="number">7</span>        <span class="keyword">var</span> b = <span class="built_in">new</span>(person)</span><br><span class="line">     <span class="number">8</span>        <span class="keyword">var</span> c = <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">     <span class="number">9</span>        <span class="keyword">var</span> d = <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">    <span class="number">11</span>        <span class="built_in">println</span>(a, b, c, d)</span><br><span class="line">    <span class="number">12</span>    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ go build -gcflags=<span class="string">"-N -l"</span> new.go &amp;&amp; go tool objdump new | grep -E <span class="string">"new.go:6|new.go:7|new.go:8|new.go:9"</span></span><br><span class="line">  new.go:<span class="number">6</span>        <span class="number">0x1051591</span>        <span class="number">48</span>c744241000000000    MOVQ $<span class="number">0x0</span>, <span class="number">0x10</span>(SP)</span><br><span class="line">  new.go:<span class="number">6</span>        <span class="number">0x105159a</span>        <span class="number">488</span>d442410        LEAQ <span class="number">0x10</span>(SP), AX</span><br><span class="line">  new.go:<span class="number">6</span>        <span class="number">0x105159f</span>        <span class="number">4889442430</span>        MOVQ AX, <span class="number">0x30</span>(SP)</span><br><span class="line">  new.go:<span class="number">7</span>        <span class="number">0x10515a4</span>        <span class="number">48</span>c744240800000000    MOVQ $<span class="number">0x0</span>, <span class="number">0x8</span>(SP)</span><br><span class="line">  new.go:<span class="number">7</span>        <span class="number">0x10515ad</span>        <span class="number">488</span>d442408        LEAQ <span class="number">0x8</span>(SP), AX</span><br><span class="line">  new.go:<span class="number">7</span>        <span class="number">0x10515b2</span>        <span class="number">4889442428</span>        MOVQ AX, <span class="number">0x28</span>(SP)</span><br><span class="line">  new.go:<span class="number">8</span>        <span class="number">0x10515b7</span>        <span class="number">48</span>c744244000000000    MOVQ $<span class="number">0x0</span>, <span class="number">0x40</span>(SP)</span><br><span class="line">  new.go:<span class="number">8</span>        <span class="number">0x10515c0</span>        <span class="number">488</span>d442440        LEAQ <span class="number">0x40</span>(SP), AX</span><br><span class="line">  new.go:<span class="number">8</span>        <span class="number">0x10515c5</span>        <span class="number">4889442420</span>        MOVQ AX, <span class="number">0x20</span>(SP)</span><br><span class="line">  new.go:<span class="number">9</span>        <span class="number">0x10515ca</span>        <span class="number">48</span>c744243800000000    MOVQ $<span class="number">0x0</span>, <span class="number">0x38</span>(SP)</span><br><span class="line">  new.go:<span class="number">9</span>        <span class="number">0x10515d3</span>        <span class="number">488</span>d442438        LEAQ <span class="number">0x38</span>(SP), AX</span><br><span class="line">  new.go:<span class="number">9</span>        <span class="number">0x10515d8</span>        <span class="number">4889442418</span>        MOVQ AX, <span class="number">0x18</span>(SP)</span><br></pre></td></tr></tbody></table></figure>

<p>被优化搞得面目全非了。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ go tool compile -N -S  new.go | grep -E <span class="string">"new.go:6|new.go:7|new.go:8|new.go:9"</span></span><br><span class="line">    <span class="number">0x0021</span> <span class="number">00033</span> (new.go:<span class="number">6</span>)    MOVQ    $<span class="number">0</span>, <span class="string">""</span>..<span class="built_in">auto</span>tmp_4+<span class="number">16</span>(SP)</span><br><span class="line">    <span class="number">0x002a</span> <span class="number">00042</span> (new.go:<span class="number">6</span>)    LEAQ    <span class="string">""</span>..<span class="built_in">auto</span>tmp_4+<span class="number">16</span>(SP), AX</span><br><span class="line">    <span class="number">0x002f</span> <span class="number">00047</span> (new.go:<span class="number">6</span>)    MOVQ    AX, <span class="string">""</span>.a+<span class="number">48</span>(SP)</span><br><span class="line">    <span class="number">0x0034</span> <span class="number">00052</span> (new.go:<span class="number">7</span>)    MOVQ    $<span class="number">0</span>, <span class="string">""</span>..<span class="built_in">auto</span>tmp_5+<span class="number">8</span>(SP)</span><br><span class="line">    <span class="number">0x003d</span> <span class="number">00061</span> (new.go:<span class="number">7</span>)    LEAQ    <span class="string">""</span>..<span class="built_in">auto</span>tmp_5+<span class="number">8</span>(SP), AX</span><br><span class="line">    <span class="number">0x0042</span> <span class="number">00066</span> (new.go:<span class="number">7</span>)    MOVQ    AX, <span class="string">""</span>.b+<span class="number">40</span>(SP)</span><br><span class="line">    <span class="number">0x0047</span> <span class="number">00071</span> (new.go:<span class="number">8</span>)    MOVQ    $<span class="number">0</span>, <span class="string">""</span>..<span class="built_in">auto</span>tmp_6+<span class="number">64</span>(SP)</span><br><span class="line">    <span class="number">0x0050</span> <span class="number">00080</span> (new.go:<span class="number">8</span>)    LEAQ    <span class="string">""</span>..<span class="built_in">auto</span>tmp_6+<span class="number">64</span>(SP), AX</span><br><span class="line">    <span class="number">0x0055</span> <span class="number">00085</span> (new.go:<span class="number">8</span>)    MOVQ    AX, <span class="string">""</span>.c+<span class="number">32</span>(SP)</span><br><span class="line">    <span class="number">0x005a</span> <span class="number">00090</span> (new.go:<span class="number">9</span>)    MOVQ    $<span class="number">0</span>, <span class="string">""</span>..<span class="built_in">auto</span>tmp_7+<span class="number">56</span>(SP)</span><br><span class="line">    <span class="number">0x0063</span> <span class="number">00099</span> (new.go:<span class="number">9</span>)    LEAQ    <span class="string">""</span>..<span class="built_in">auto</span>tmp_7+<span class="number">56</span>(SP), AX</span><br><span class="line">    <span class="number">0x0068</span> <span class="number">00104</span> (new.go:<span class="number">9</span>)    MOVQ    AX, <span class="string">""</span>.d+<span class="number">24</span>(SP)</span><br></pre></td></tr></tbody></table></figure>

<p>可见就是生成了一些临时变量。</p>
<p>神奇的内置数据结构<br>教学目标：工作痛点：详细内容：学习 hashtable，timer 等复杂的数据结构实现；了解这些结构的进化历史和相关的优缺点；了解基本<br>的 CSP 编程理念。内置数据结构只会使用 api，碰到了相关的问题不知道该从何下手，对相关数据结构的设计缺乏宏观认<br>识。</p>
<ol>
<li><p>Go 语言的 hash 表实现：map 解析</p>
</li>
<li><p>Go 语言的 timer 实现演进</p>
</li>
<li><p>channel 的实现，CSP 理论基础</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/" class="post-title-link" itemprop="url">Go 进程的启动过程、调度循环和GPM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-01 16:21:41" itemprop="dateCreated datePublished" datetime="2021-10-01T16:21:41Z">2021-10-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-06 07:48:24" itemprop="dateModified" datetime="2021-10-06T07:48:24Z">2021-10-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>基本实验环境准备<br>使用docker构建基础环境</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install golang -y \</span><br><span class="line">   &amp;&amp; yum install dlv -y \ </span><br><span class="line">   &amp;&amp; yum install binutils -y \ </span><br><span class="line">   &amp;&amp; yum install vim -y \ </span><br><span class="line">   &amp;&amp; yum install gdb -y</span><br><span class="line"><span class="comment"># docker build -t test .</span></span><br><span class="line"><span class="comment"># docker run -it --rm test bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用打包好的</span></span><br><span class="line">docker pull xargin/go1.14.12-dev</span><br></pre></td></tr></tbody></table></figure>

<p><code>go build</code> 命令将默认会编译当前目录下和所有子目录下的所有go文本文件编译生成没有任何依赖的可执行二进制文件。即使服务器上没有 go 环境，它也是可以直接运行的。因为编译器已经将运行时依赖项都融进了这单一的可执行文件。这也是 go 语言的特色之处，让用户编写的程序可以轻装上阵。</p>
<p>（go build 后面也可以带具体的文件名，只编译那个文件，不会报错）<br>可能会报错，因为多个go文件中可能存在重复的main函数<br>解决办法：将main函数文件存放在各自的单独的目录下（这个方法也是go语言官方的解决办法，一个项目其实也不会有很多的main函数，所以这个是可行的）<br>每次遇到import会触发gomod，去镜像拉取一些库放到本地统一的缓存<br>所有的依赖</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build hello.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">hello    hello.go</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./hello</span></span><br><span class="line">Hello, World!</span><br><span class="line"><span class="meta">$</span><span class="bash"> hello.exe</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></tbody></table></figure>

<p>执行完毕后可以看到目录下多了一个 hello 的可执行文件。运行它可以直接看到输出结果。</p>
<p><code>go build -x xxx.go</code> 观察编译和链接过程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build -x hello.go</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/0.png" alt="description"></p>
<p>能够通过内置工具、调试器、源代码阅读对底层简单数据结构进行分析；了解如何将应用代码与底层代码做好对应；</p>
<p>Go程序的编译过程：文本 -&gt; 编译 -&gt; 二进制可执行文件<br>编译：文本代码 -&gt; 目标文件(.o, .a)<br>链接：将目标文件合并为可执行文件</p>
<p><code>go tool compile -S ./hello.go | grep “hello.go:5”</code> go文本 -&gt; 编译 -&gt; ⽣成 .o 目标文件，并把⽬标的汇编内容输出</p>
<p>.o 目标文件 -&gt; link -&gt; 可执行文件<br><code>go tool objdump</code> 把可执行文件 -&gt; 反编译 -&gt; 汇编</p>
<p>编译的二进制文件，包含一系列指令和汇编代码， 所以当我们执行程序的时候，操作系统会将文件读入内存，执行对应的指令。操作系统读取二进制可执行文件，其中就包括划分内存区域，分配数据在内存中（可能包含静态的，动态的等等）。这个应该是程序的初始化，</p>
<ol start="2">
<li>在初始化完成后，操作系统会读到entry point address，因为初始化已经完成，这样读入entry point后实际就是开始执行程序的指令和数据了</li>
</ol>
<h3 id="可执行文件在不同的操作系统规范不一样"><a href="#可执行文件在不同的操作系统规范不一样" class="headerlink" title="可执行文件在不同的操作系统规范不一样"></a>可执行文件在不同的操作系统规范不一样</h3><ul>
<li><p>Windows: PE</p>
</li>
<li><p>MacOS: Mach-O</p>
</li>
<li><p>linux: ELF(Executable and Linkable Format) 为例，ELF 由⼏部分构成：</p>
<ul>
<li>ELF header</li>
<li>Section header</li>
<li>Sections</li>
</ul>
</li>
</ul>
<p>操作系统执行可执行文件的步骤（Linux为例）：<br>解析ELF Header -&gt; 加载⽂件内容⾄内存 -&gt; 从 entry point 开始执行代码</p>
<p>计算机是怎么执行我们的程序的呢<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/1.png" alt="description"></p>
<p>CPU 无法理解⽂本，只能执行⼀条⼀条的⼆进制机器码指令，每次执行完⼀条指令，pc寄存器就指向下⼀条继续执行。<br>在 64 位平台上 <code>pc 寄存器 = rip</code>。</p>
<p>计算机会自上而下，依次执行汇编指令<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/2.png" alt="description"></p>
<p>Go 语⾔是⼀⻔有runtime的语⾔<br>肤浅的解释：Runtime 是 【软件/命令/环境/代码】，用来执行编程语言本身。<br>可以认为 runtime 是为了实现额外的功能，⽽在程序运⾏时⾃动加载/运⾏的⼀些模块</p>
<p>更具体的解释：</p>
<blockquote>
<p>Runtime describes software/instructions that are executed while your program is running, especially those instructions that you did not write explicitly, but are necessary for the proper execution of your code.</p>
<p>Low-level languages like C have very small (if any) runtime. More complex languages like Objective-C, which allows for dynamic message passing, have a much more extensive runtime.</p>
<p>You are correct that runtime code is library code, but library code is a more general term, describing the code produced by any library. Runtime code is specifically the code required to implement the features of the language itself.</p>
</blockquote>
<p>Go语言中，运行时、操作系统和程序员定义代码之间的关系如下图：<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/4.png" alt="description"></p>
<p>Runtime 构成：</p>
<ul>
<li>Scheduler：调度器管理所有的 G，M，P，在后台执行调度循环，最核心，它负责串联所有的runtime 流程。</li>
<li>Netpoll：网络轮询负责管理网络 FD 相关的读写、就绪事件</li>
<li>Memory Management 内存管理：当代码需要内存时，负责内存分配⼯作</li>
<li>Garbage Collector 垃圾回收：当内存不再需要时，负责回收内存</li>
</ul>
<p>在linux通过 readelf -h 中的 entry 查看编译后的进程程序入口<br><code>-h</code> –file-header Display the ELF file header</p>
<p>通过entry point找到 Go进程的执行入口，使⽤readelf。进一步找到Go进程要从哪里启动了</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-9-centos ~]# cd gocn</span><br><span class="line">[root@VM-0-9-centos ~/gocn]# ls</span><br><span class="line">a.go</span><br><span class="line"><span class="meta">[root@adafd]#</span><span class="bash"> docker run -v /Users/ashe/gocn:/home -it gocn bash</span></span><br><span class="line">[root@adafd /]# cd /home</span><br><span class="line">[root@adafd home]# ls</span><br><span class="line">a.go</span><br><span class="line">[root@adafd home]# go build a.go</span><br><span class="line"></span><br><span class="line">[root@adafd home]# readelf -h ./a</span><br><span class="line">...</span><br><span class="line">Entry point address:      0x455780 # go 进程的执行入口地址</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@adafd home]# dlv exec ./a # 在 dlv 调试工具中</span><br><span class="line">(dlv) h 帮助文档</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 dlv 调试器中 b *entry_addr 使用断点功能找到代码位置</span></span><br><span class="line">(dlv) b *0x455780</span><br><span class="line">Breakpoint 1 set at 0x455780 for _rt0_amd64_linux() /usr/local/go/src/runtime/rt0_linux_amd64.s:8</span><br><span class="line">(dlv) c  就是continue Run until breakpoint or programe termination</span><br><span class="line">(dlv) si  就是 step-instuction   Single step a single cpu instruction </span><br><span class="line"></span><br><span class="line">==&gt; runtime._rt0_amd64_linux</span><br><span class="line">(dlv) si</span><br><span class="line">==&gt; runtime._rt0_linux</span><br><span class="line">(dlv) si</span><br><span class="line">==&gt; runtime._rt0_go</span><br></pre></td></tr></tbody></table></figure>

<p><code>runtime.rt0_go</code>启动流程：</p>
<ol>
<li>参数 <code>argc</code> <code>argv</code> 处理</li>
<li>全局 <code>m0</code>, <code>g0</code> 初始化，</li>
<li>获取CPU 核心数</li>
<li>初始化内置数据结构</li>
<li>开始执行⽤户主线程 <code>main</code> 函数，启动进⼊调度循环</li>
</ol>
<p>M0是 Go 程序启动后创建的第⼀个的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap 上分配，M0负责执⾏初始化操作和启动第⼀个G，它是进程启动通过汇编直接复制给 m0 的，m0 是个全局变量，而其他的 m 都是 runtime 内自己创建的。m0 的赋值过程，可以看前面 runtime/asm_amd64.s 的代码。在之后M0就和其他的M⼀样了。一个 go 进程只有一个 m0。</p>
<p>Go 使用 GOMAXPROCS 变量限制同时运行的 OS 线程数量，这意味着 Go 必须对每个运行着的线程上的 Goroutine 进行调度和管理。这个调度的功能被委托给了一个叫做 g0 的特殊的 goroutine， g0 是为每个 OS 线程创建的第一个 goroutine：之后，g0 会把就绪状态的 Goroutine 调度到线程上去运行。M在执行G切换的时候，主要也是g0在完成工作，切换的时候，保存现场的变量等，也就是放在g0的栈中，这个栈，也就是M所对应的栈<br>每个 m 都有一个 g0，因为每个线程有一个系统堆栈，g0 虽然也是 g 的结构，但和普通的 g 还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在 linux 上栈大小默认固定 8M，不能扩展，也不能缩小。而普通 g 一开始只有 2K 大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占。因为调度就是在 g0 上跑的。</p>
<p>proc.go 中的全局变量 m0和g0</p>
<p>在 runtime/proc.go 的文件中声明了两个全局变量，m0 表示主线程，这里的 g0 表示和 m0 绑定的 g0，也可以理解为 m0 线程的堆栈，这两个变量的赋值是汇编实现的。</p>
<p>到这里我们应该知道了 g0 和 m0 是什么了？m0 代表主线程、g0 代表了线程的堆栈。调度都是在系统堆栈上跑的，也就是一定要跑在 g0 上，所以 mstart1 函数才检查是不是在 g0 上， 因为接下来就要执行调度程序了。</p>
<p>调度组件</p>
<ol>
<li>Go的生产-消费流程概述<br>每当写下：</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"hello ashe"</span>)</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>

<p>的时候，到底发生了什么？这里其实就是向 <code>runtime</code> 提交了一个计算任务，<code>func() { xxxxx }</code> 里面所裹挟的代码，就是这个计算任务的基本内容</p>
<p>Go的调度流程本质上就是一个生产-消费流程<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/5.png" alt="description"></p>
<ul>
<li><p>右边的生产者就是每次<code>go func() {}</code>的时候提交的任务；</p>
</li>
<li><p>中间的为队列，发送的任务会被打包成一个协程G，即为goroutine；</p>
</li>
<li><p>goroutine会进入到这个队列，而另一端进行消费的就是线程，线程是在循环里面执行消费的操作的；</p>
</li>
<li><p>中间的队列主要会分为2部分，分别是本地队列和全局队列</p>
<ul>
<li><p>本地队列：存放等待运⾏的G，一个本地队列存放的G数量一般不超过256个，优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中。</p>
</li>
<li><p>全局队列：存放等待运行的G，读写要加锁，所以拿取效率在多线程竞争的情况下相比于本地队列来说要低。</p>
</li>
</ul>
</li>
</ul>
<p>GMP：<br>Golang 语言的调度器是基于协程调度模型 GMP，通过三者的相互协作，实现在用户空间管理和调度并发任务。</p>
<p>G：goroutine，⼀个计算任务体。由需要执行的代码和其上下⽂组成，上下⽂包括：当前代码位置，栈顶、栈底地址，状态等。每个Gotoutine对应一个G结构体，G存储Goroutine的栈，指令指针，还有一些对于调用goroutines很重要的其它信息，比如阻塞它的任何channel,以及任务函数，可重用（函数实体）G需要保存到P才能被调度执行，简单的说，G就是一个协程，里面包含了相应的栈，寄存器，执行的函数指令等，</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Stack parameters.</span></span><br><span class="line">    <span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line">    <span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line">    <span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line">    <span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line">    <span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line">    <span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line">    stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">    stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"></span><br><span class="line">    _panic    *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">    _defer    *_defer <span class="comment">// innermost defer</span></span><br><span class="line">    m         *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">    sched     gobuf   <span class="comment">// goroutine切换时，用于保存g的上下文 </span></span><br><span class="line">    syscallsp <span class="keyword">uintptr</span> <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc <span class="keyword">uintptr</span> <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp  <span class="keyword">uintptr</span> <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    <span class="comment">// param is a generic pointer parameter field used to pass</span></span><br><span class="line">    <span class="comment">// values in particular contexts where other storage for the</span></span><br><span class="line">    <span class="comment">// parameter would be difficult to find. It is currently used</span></span><br><span class="line">    <span class="comment">// in three ways:</span></span><br><span class="line">    <span class="comment">// 1. When a channel operation wakes up a blocked goroutine, it sets param to</span></span><br><span class="line">    <span class="comment">//    point to the sudog of the completed blocking operation.</span></span><br><span class="line">    <span class="comment">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed</span></span><br><span class="line">    <span class="comment">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine's</span></span><br><span class="line">    <span class="comment">//    stack may have moved in the meantime.</span></span><br><span class="line">    <span class="comment">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a</span></span><br><span class="line">    <span class="comment">//    closure in the runtime is forbidden.</span></span><br><span class="line">    param        unsafe.Pointer</span><br><span class="line">    atomicstatus <span class="keyword">uint32</span></span><br><span class="line">    stackLock    <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid         <span class="keyword">int64</span></span><br><span class="line">    schedlink    guintptr</span><br><span class="line">    waitsince    <span class="keyword">int64</span>      <span class="comment">// approx time when the g become blocked</span></span><br><span class="line">    waitreason   waitReason <span class="comment">// if status==Gwaiting</span></span><br><span class="line"></span><br><span class="line">    preempt       <span class="keyword">bool</span> <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">    preemptStop   <span class="keyword">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">    preemptShrink <span class="keyword">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// asyncSafePoint is set if g is stopped at an asynchronous</span></span><br><span class="line">    <span class="comment">// safe point. This means there are frames on the stack</span></span><br><span class="line">    <span class="comment">// without precise pointer information.</span></span><br><span class="line">    asyncSafePoint <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    paniconfault <span class="keyword">bool</span> <span class="comment">// panic (instead of crash) on unexpected fault address</span></span><br><span class="line">    gcscandone   <span class="keyword">bool</span> <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">    throwsplit   <span class="keyword">bool</span> <span class="comment">// must not split stack</span></span><br><span class="line">    <span class="comment">// activeStackChans indicates that there are unlocked channels</span></span><br><span class="line">    <span class="comment">// pointing into this goroutine's stack. If true, stack</span></span><br><span class="line">    <span class="comment">// copying needs to acquire channel locks to protect these</span></span><br><span class="line">    <span class="comment">// areas of the stack.</span></span><br><span class="line">    activeStackChans <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// parkingOnChan indicates that the goroutine is about to</span></span><br><span class="line">    <span class="comment">// park on a chansend or chanrecv. Used to signal an unsafe point</span></span><br><span class="line">    <span class="comment">// for stack shrinking. It's a boolean value, but is updated atomically.</span></span><br><span class="line">    parkingOnChan <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line">    raceignore     <span class="keyword">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">    sysblocktraced <span class="keyword">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">    tracking       <span class="keyword">bool</span>     <span class="comment">// whether we're tracking this G for sched latency statistics</span></span><br><span class="line">    trackingSeq    <span class="keyword">uint8</span>    <span class="comment">// used to decide whether to track this G</span></span><br><span class="line">    runnableStamp  <span class="keyword">int64</span>    <span class="comment">// timestamp of when the G last became runnable, only used when tracking</span></span><br><span class="line">    runnableTime   <span class="keyword">int64</span>    <span class="comment">// the amount of time spent runnable, cleared when running, only used when tracking</span></span><br><span class="line">    sysexitticks   <span class="keyword">int64</span>    <span class="comment">// cputicks when syscall has returned (for tracing)</span></span><br><span class="line">    traceseq       <span class="keyword">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">    tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">    lockedm        muintptr</span><br><span class="line">    sig            <span class="keyword">uint32</span></span><br><span class="line">    writebuf       []<span class="keyword">byte</span></span><br><span class="line">    sigcode0       <span class="keyword">uintptr</span></span><br><span class="line">    sigcode1       <span class="keyword">uintptr</span></span><br><span class="line">    sigpc          <span class="keyword">uintptr</span></span><br><span class="line">    gopc           <span class="keyword">uintptr</span>         <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">    ancestors      *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span></span><br><span class="line">    startpc        <span class="keyword">uintptr</span>         <span class="comment">// pc of goroutine function</span></span><br><span class="line">    racectx        <span class="keyword">uintptr</span></span><br><span class="line">    waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">    cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">    labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">    timer          *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line">    selectDone     <span class="keyword">uint32</span>         <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcAssistBytes is this G's GC assist credit in terms of</span></span><br><span class="line">    <span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line">    <span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line">    <span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line">    <span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line">    <span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line">    <span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line">    gcAssistBytes <span class="keyword">int64</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>goroutine切换的时候不同于线程有OS来负责这部分数据，而是由一个gobuf对象来保存，这样能够更加轻量级<br><code>gobuf</code> 描述⼀个 goroutine 所有现场，从⼀个 g 切换到另⼀个 g，<br>只要把这⼏个现场字段保存下来，再把 g 往队列⾥⼀扔，m 就可以执⾏其它 g 了<br>⽆需进⼊内核态<br>其实就是保存了当前的栈指针，计数器，当然还有g自身，这里记录自身g的指针是为了能快速的访问到goroutine中的信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ctxt is unusual with respect to GC: it may be a</span></span><br><span class="line">    <span class="comment">// heap-allocated funcval, so GC needs to track it, but it</span></span><br><span class="line">    <span class="comment">// needs to be set and cleared from assembly, where it's</span></span><br><span class="line">    <span class="comment">// difficult to have write barriers. However, ctxt is really a</span></span><br><span class="line">    <span class="comment">// saved, live register, and we only ever exchange it between</span></span><br><span class="line">    <span class="comment">// the real register and the gobuf. Hence, we treat it as a</span></span><br><span class="line">    <span class="comment">// root during stack scanning, which means assembly that saves</span></span><br><span class="line">    <span class="comment">// and restores it doesn't need write barriers. It's still</span></span><br><span class="line">    <span class="comment">// typed as a pointer so that any other writes from Go get</span></span><br><span class="line">    <span class="comment">// write barriers.</span></span><br><span class="line">    sp   <span class="keyword">uintptr</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span></span><br><span class="line">    g    guintptr</span><br><span class="line">    ctxt unsafe.Pointer</span><br><span class="line">    ret  <span class="keyword">uintptr</span></span><br><span class="line">    lr   <span class="keyword">uintptr</span></span><br><span class="line">    bp   <span class="keyword">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>M：machine，是由操作系统分配的执行 Go 程序的线程 thread，任务消费者，想要在 CPU 上执行代码，必须有线程，与 C 语⾔中的线程相同，通过系统调⽤ clone 来创建。os内核线程抽象，所有M是有线程栈的。如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则M.stack→G.stack，M的PC寄存器指向G提供的函数，然后去执行</p>
<p>一个 thread（M） 和一个 processor（P） 绑定，M 是实际执行体，以调度循环的方式执行 G 并发任务。M 通过修改寄存器，将执行栈指向 G 自带的栈内存，并在此空间内分配堆栈帧，执行任务函数。M 只负责执行，不再持有状态，这时并发任务跨线程调度，实现多路复用的根本所在。每个 processor（P） 维护一个本地 goroutine（G） 队列，此外还有一个全局 goroutine（G） 队列。</p>
<p>其中，M 的数量由操作系统分配，并且如果有 M 阻塞，操作系统会创建新的 M，如果有 M 空闲，操作系统会回收 M 或将空闲 M 睡眠，此外，Golang 语言还可以限定 M 的最大数量为 10000，<code>runtime/debug</code> 包中的 SetMaxThread 函数也可以设置 M 的数量。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> {</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack 带有调度栈的goroutine</span></span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">    procid        <span class="keyword">uint64</span>            <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    gsignal       *g                <span class="comment">// signal-handling g</span></span><br><span class="line">    goSigStack    gsignalStack      <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">    sigmask       sigset            <span class="comment">// storage for saved signal mask</span></span><br><span class="line">    tls           [tlsSlots]<span class="keyword">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    oldp          puintptr <span class="comment">// the p that was attached before executing a syscall</span></span><br><span class="line">    id            <span class="keyword">int64</span></span><br><span class="line">    mallocing     <span class="keyword">int32</span></span><br><span class="line">    throwing      <span class="keyword">int32</span></span><br><span class="line">    preemptoff    <span class="keyword">string</span> <span class="comment">// if != "", keep curg running on this m</span></span><br><span class="line">    locks         <span class="keyword">int32</span></span><br><span class="line">    dying         <span class="keyword">int32</span></span><br><span class="line">    profilehz     <span class="keyword">int32</span></span><br><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">    blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">    newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">    printlock     <span class="keyword">int8</span></span><br><span class="line">    incgo         <span class="keyword">bool</span>   <span class="comment">// m is executing a cgo call</span></span><br><span class="line">    freeWait      <span class="keyword">uint32</span> <span class="comment">// if == 0, safe to free g0 and delete m (atomic)</span></span><br><span class="line">    fastrand      [<span class="number">2</span>]<span class="keyword">uint32</span></span><br><span class="line">    needextram    <span class="keyword">bool</span></span><br><span class="line">    traceback     <span class="keyword">uint8</span></span><br><span class="line">    ncgocall      <span class="keyword">uint64</span>      <span class="comment">// number of cgo calls in total</span></span><br><span class="line">    ncgo          <span class="keyword">int32</span>       <span class="comment">// number of cgo calls currently in progress</span></span><br><span class="line">    cgoCallersUse <span class="keyword">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">    cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line">    doesPark      <span class="keyword">bool</span>        <span class="comment">// non-P running threads: sysmon and newmHandoff never use .park</span></span><br><span class="line">    park          note</span><br><span class="line">    alllink       *m <span class="comment">// on allm</span></span><br><span class="line">    schedlink     muintptr</span><br><span class="line">    lockedg       guintptr</span><br><span class="line">    createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span> <span class="comment">// stack that created this thread. thread创建的栈</span></span><br><span class="line">    lockedExt     <span class="keyword">uint32</span>      <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">    lockedInt     <span class="keyword">uint32</span>      <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">    nextwaitm     muintptr    <span class="comment">// next m waiting for lock</span></span><br><span class="line">    waitunlockf   <span class="function"><span class="keyword">func</span><span class="params">(*g, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">    waitlock      unsafe.Pointer</span><br><span class="line">    waittraceev   <span class="keyword">byte</span></span><br><span class="line">    waittraceskip <span class="keyword">int</span></span><br><span class="line">    startingtrace <span class="keyword">bool</span></span><br><span class="line">    syscalltick   <span class="keyword">uint32</span></span><br><span class="line">    freelink      *m <span class="comment">// on sched.freem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mFixup is used to synchronize OS related m state</span></span><br><span class="line">    <span class="comment">// (credentials etc) use mutex to access. To avoid deadlocks</span></span><br><span class="line">    <span class="comment">// an atomic.Load() of used being zero in mDoFixupFn()</span></span><br><span class="line">    <span class="comment">// guarantees fn is nil.</span></span><br><span class="line">    mFixup <span class="keyword">struct</span> {</span><br><span class="line">        lock mutex</span><br><span class="line">        used <span class="keyword">uint32</span></span><br><span class="line">        fn   <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">bool</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are here because they are too large to be on the stack</span></span><br><span class="line">    <span class="comment">// of low-level NOSPLIT functions.</span></span><br><span class="line">    libcall   libcall</span><br><span class="line">    libcallpc <span class="keyword">uintptr</span> <span class="comment">// for cpu profiler</span></span><br><span class="line">    libcallsp <span class="keyword">uintptr</span></span><br><span class="line">    libcallg  guintptr</span><br><span class="line">    syscall   libcall <span class="comment">// stores syscall parameters on windows</span></span><br><span class="line"></span><br><span class="line">    vdsoSP <span class="keyword">uintptr</span> <span class="comment">// SP for traceback while in VDSO call (0 if not in call)</span></span><br><span class="line">    vdsoPC <span class="keyword">uintptr</span> <span class="comment">// PC for traceback while in VDSO call</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// preemptGen counts the number of completed preemption</span></span><br><span class="line">    <span class="comment">// signals. This is used to detect when a preemption is</span></span><br><span class="line">    <span class="comment">// requested, but fails. Accessed atomically.</span></span><br><span class="line">    preemptGen <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether this is a pending preemption signal on this M.</span></span><br><span class="line">    <span class="comment">// Accessed atomically.</span></span><br><span class="line">    signalPending <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    dlogPerM</span><br><span class="line"></span><br><span class="line">    mOS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Up to 10 locks held by this m, maintained by the lock ranking code.</span></span><br><span class="line">    locksHeldLen <span class="keyword">int</span></span><br><span class="line">    locksHeld    [<span class="number">10</span>]heldLockInfo</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>P：processor，虚拟处理器，你也可以将其理解为⼀种 token，有这个 token，才有在物理 CPU 核心上执行的权⼒。<br>Go 程序启动时，会创建 P 列表，P 的数量由环境变量 GOMAXPROCS 的值设置，也可以在 Go 程序中通过调用 runtime 包的 GOMAXPROCS 函数来设置。自 Go1.5 开始，GOMAXPROCS 的默认值为 CPU 的核心数，但是 GOMAXPROCS 的默认值在某些情况下也不是最优值。</p>
<p>P 的作用类似 CPU 的核心，用来控制可同时并发执行的任务数量，每个内核的线程 M 必须绑定到一个 P 上，M 才可以被允许执行任务，否则被操作系统将其睡眠或回收（后台监控线程除外）。M 独享所绑定的 P 的资源（对象分配内存、本地任务队列等），可以在无锁状态下执行高效操作。</p>
<p>虽然一个 P 绑定一个 M，但是 P 和 M 的数量并不一致。原因是当 M 因陷入系统调用而长时间阻塞时，P 就会被监控线程抢占，去唤醒睡眠的 M，或如果没有睡眠的 M，操作系统会新建 M 去执行 P 的本地任务队列，这样 M 的数量就会增长。并把阻塞的 M 上的 P 绑定到唤醒的睡眠的 M 或新创建的 M，该操作被称为 hand off 机制。阻塞的 M 达到操作系统最大时间就会被操作系统销毁或将其睡眠，未被执行的 G 会加入到其他 P 的队列中。</p>
<p>每个 P 维护一个本地 G 队列，此外，还有一个全局 G 队列，那么新创建的 G 会放在哪里？新创建的 G 优先放在有空闲空间的 P 中（每个 P 的最大存储数量是 256个），如果所有 P 的存储空间都满了，则存放在全局 G 队列中</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> {</span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">    m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">    pcache      pageCache</span><br><span class="line">    raceprocctx <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// runnext, if non-nil, is a runnable G that was ready'd by</span></span><br><span class="line">    <span class="comment">// the current G and should be run next instead of what's in</span></span><br><span class="line">    <span class="comment">// runq if there's time remaining in the running G's time</span></span><br><span class="line">    <span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">    <span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that while other P's may atomically CAS this to zero,</span></span><br><span class="line">    <span class="comment">// only the owner P can CAS it to a valid G.</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    gFree <span class="keyword">struct</span> {</span><br><span class="line">        gList</span><br><span class="line">        n <span class="keyword">int32</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of mspan objects from the heap.</span></span><br><span class="line">    mspancache <span class="keyword">struct</span> {</span><br><span class="line">        <span class="comment">// We need an explicit length here because this field is used</span></span><br><span class="line">        <span class="comment">// in allocation codepaths where write barriers are not allowed,</span></span><br><span class="line">        <span class="comment">// and eliminating the write barrier/keeping it eliminated from</span></span><br><span class="line">        <span class="comment">// slice updates is tricky, moreso than just managing the length</span></span><br><span class="line">        <span class="comment">// ourselves.</span></span><br><span class="line">        <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">        buf [<span class="number">128</span>]*mspan</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">    <span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">    <span class="comment">// has actually been swept.</span></span><br><span class="line">    traceSweep <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">    <span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">    traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    _ <span class="keyword">uint32</span> <span class="comment">// Alignment for atomic fields below</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The when field of the first entry on the timer heap.</span></span><br><span class="line">    <span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">    <span class="comment">// This is 0 if the timer heap is empty.</span></span><br><span class="line">    timer0When <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The earliest known nextwhen field of a timer with</span></span><br><span class="line">    <span class="comment">// timerModifiedEarlier status. Because the timer may have been</span></span><br><span class="line">    <span class="comment">// modified again, there need not be any timer with this value.</span></span><br><span class="line">    <span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">    <span class="comment">// This is 0 if there are no timerModifiedEarlier timers.</span></span><br><span class="line">    timerModifiedEarliest <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-P GC state</span></span><br><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker (atomic)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcMarkWorkerMode is the mode for the next mark worker to run in.</span></span><br><span class="line">    <span class="comment">// That is, this is used to communicate with the worker goroutine</span></span><br><span class="line">    <span class="comment">// selected for immediate execution by</span></span><br><span class="line">    <span class="comment">// gcController.findRunnableGCWorker. When scheduling other goroutines,</span></span><br><span class="line">    <span class="comment">// this field must be set to gcMarkWorkerNotWorker.</span></span><br><span class="line">    gcMarkWorkerMode gcMarkWorkerMode</span><br><span class="line">    <span class="comment">// gcMarkWorkerStartTime is the nanotime() at which the most recent</span></span><br><span class="line">    <span class="comment">// mark worker started.</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">    wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq is a counter indicating whether this P is currently</span></span><br><span class="line">    <span class="comment">// writing any stats. Its value is even when not, odd when it is.</span></span><br><span class="line">    statsSeq <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">    <span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">    timersLock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">    <span class="comment">// standard library's time package.</span></span><br><span class="line">    <span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">    timers []*timer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timers in P's heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timerDeleted timers in P's heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    deletedTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">    timerRaceCtx <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// preempt is set to indicate that this P should be enter the</span></span><br><span class="line">    <span class="comment">// scheduler ASAP (regardless of what G is running on it).</span></span><br><span class="line">    preempt <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Padding is no longer needed. False sharing is now not a worry because p is large enough</span></span><br><span class="line">    <span class="comment">// that its size class is an integer multiple of the cache line size (for any of our architectures).</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/6.png" alt="description"></p>
<ul>
<li>右边的蓝色、黄色、绿色的M即为线程，大部分线程是一直在执行一个调度循环的，调度循环简单就是指线程要去左边的任务队列里（local run queue &amp; global run queue）把任务拿出来然后执行的反复的操作；</li>
<li>当然在整个过程中，线程是按需创建的，因此有一部分线程可能是空闲的，这些线程会被放在一个叫做midle的队列中来进行管理，当没有可用的空闲线程时候就会在midle里面寻找使用；</li>
<li>我们可以看到上图中，除了local run queue（本地队列） 和global run queue（全局队列），还有一个runnext的字段结构，而runnext与local run queue 本质上都是为了解决程序的局部性问题（程序的局部性原理：最近调用的一次代码很有很可能会马上被再一次调用，整体分为代码的局部性和数据的局部性），我们一般不希望所有的生产都进入到全局的global run queue中；</li>
<li>如果所有的线程消费的都是global run queue的话，那么还需要进行额外加锁设计。这就是为什么会分为local run queue 和global run queue的原因。</li>
</ul>
<p>队列：<br>P 的本地 runnext 字段 -&gt; P 的 local run queue -&gt; global run queue，<br>多级队列减少锁竞争</p>
<p>goroutine的生产端（runnext、local run queue、global run queue的过程）<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/7.png" alt="description"></p>
<ul>
<li>左上角会创建一个goroutine，而这个goroutine会创建一个runtime，即通过runtime.newproc生成一个G；</li>
<li>对于G的队列而言，runnext的优先级是最高的，首先会进入到runnext中；</li>
<li>但新的G进去，有可能会导致老的G被挤出，此时需要进行善后工作，老的G会进入到本地队列，而如果本地队列也已经满了的话，就会把本地队列拿出一半，塞给全局队列，以此循环;</li>
<li>注意：runnext本质上并不是队列，而是一个含有一个元素的指针，为了方便理解，将其与另外的本地队列（本质上是一个数组，且只有256的长度）和全局队列（本质上是一个链表）叫法一致</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=242:7&amp;node-id=242:215&amp;viewport=516,209,0.07501539587974548&amp;scaling=scale-down-width">https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=242%3A7&amp;node-id=242%3A215&amp;viewport=516%2C209%2C0.07501539587974548&amp;scaling=scale-down-width</a></p>
<p>goroutine的消费端<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/8.png" alt="description"></p>
<ul>
<li>消费端本质上就是多个线程在反复执行一个循环，这个循环是从队列里面取值，上图右边的蓝色块指的就是标准的调度循环的流程，即runtime里面的4个函数：<code>runtime.schedule</code>、<code>runtime.execute</code>、<code>runtime.goexit</code>、<code>runtime.gogo</code>;</li>
<li>图中红色的区域是垃圾回收gc相关的逻辑，schedule左边的3个黄色框，都为获取G的函数，如果schedule左边的任意一个函数返回一个G给schedule，右边的循环就会一直执行；</li>
<li>在这些函数中，globalrunqget/61指的就是会定期61次执行，去全局队列里面检索获取一个G，防止在全局队列里面的G过度延迟；</li>
<li>如果全局的G没有获取到，或者当前不需要获取全局的G，就会从本地队列进行获取（优先获取runnext），而本地队列的获取就是通过runqget这个函数做到的；</li>
<li>如果还是没有获取到G的话，就会去执行findrunnable函数，这个函数整体分为上下两部分，分别叫top和stop。top部分的函数功能，主要就是再次尝试依次从本地队列-&gt;全局队列获取G，如果依然获取不到，就使用netpoll进行网络轮询情况的查看，如果在这里能找到G，就将G放在全局队列里面，如果依然获取不到，就使用runqsteal从其他的P中偷一半G回来，这个有点像Work stealing 的原理（ runqsteal -&gt; runqgrab）；</li>
</ul>
<p>work stealing机制<br>如果一个 P 的 G 被 M 处理完，本线程 M ⽆可运⾏的 G 时，尝试等待 从其他线 M 程绑定的 P 偷取新的 G，P 优先去其他 P 上获取（偷）它们的待处理的 G，⽽不是销毁线程，该操作被称为 work stealing 机制。</p>
<p>全局的 G Goroutine队列，当Work Stealing失败，如果一个 P 的 G 被 M 处理完，并且其他所有的 P 都没有待处理的 G，那么 M 程绑定的 P 会去全局 G 队列获取 G，此时会触发锁机制。</p>
<p>也许有的读者会说，那如果全局 G 队列也没有待处理的 G 呢？如果这样，该 M 达到最大空闲时间，就会被操作系统回收或将其睡眠。</p>
<ul>
<li>如果执行完整个top部分依然获取不到G，就说明M没有机会得到执行了，那么就开始执行stop部分，即线程的休眠流程，但在stopm执行之前，还是会再次检查一遍G的存在，确认无误后，就会将线程休眠。</li>
<li>M 执行调度循环时，必须与⼀个 P 绑定，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（M最大10000）；每一个P保存着本地G任务队列，也有一个全局G任务队列</li>
</ul>
<p>所有global操作均需要加锁。</p>
<p>下面再单独将右边的调度循环过程摘出来描述一下：<br>线程 M 在持有 P 的情况下不断消费运⾏队列中的 G 的过程。<br><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/9.png" alt="description"></p>
<ul>
<li>在上面的调度循环中，最重要的就是schedule，它可以从相关的语言中去寻找正在执行的任务；</li>
<li>当schedule获取到G后，就进行execute流程（执行go的代码），gogo会把拿到的G的现场回复出来，从PC寄存器开始继续执行，goexit会结束当前的一次流程，并缓存相关的G结构体资源，然后回到schedule继续执行循环；</li>
<li>在调度循环的过程中，会存在一个P.scheditick的字段，用来记录调度循环已经执行了多少次，用于globrunnqget/61等判定中。当执行到execute的时候，P.scheditick就会+1。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=143:212&amp;node-id=143:213&amp;viewport=134,83,0.06213996931910515&amp;scaling=scale-down-width">https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=143%3A212&amp;node-id=143%3A213&amp;viewport=134%2C83%2C0.06213996931910515&amp;scaling=scale-down-width</a></p>
<h2 id="处理阻塞"><a href="#处理阻塞" class="headerlink" title="处理阻塞"></a>处理阻塞</h2><p>前面介绍的就是调度循环及调度组件的内容，但Go仅仅能够处理正常情况是不行的，如果程序中有阻塞的话，需要避免线程阻塞</p>
<p>runtime 中可以接管的阻塞是通过 gopark/goparkunlock 挂起和 goready 恢复<br>的，那么我们只要找到 runtime.gopark 的调⽤⽅，就可以知道在哪些地⽅会被 runtime 接管了，</p>
<p>可以接管的阻塞：channel 收发，加锁，网络连接读/写，select<br>阻塞调度循环，而是会把 goroutine 挂起。所谓的挂起，其实让 G 先进某个数据结构，待 ready 后再继续执行，不会占⽤线程。<br>这时候，线程会进⼊ schedule，继续消费队列，执行其它的 G</p>
<ol>
<li>channel发送：如果阻塞了，会有一个sendq等待队列，将G打包为sudog的数据结构，塞在了等待结构中；</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>channel接收：如果阻塞了，会有一个recvq等待队列，将G打包为sudog的数据结构，塞在了等待结构中；</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&lt;- ch</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>time.Sleep阻塞：将G挂在timer结构的一个参数上。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Hour)</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>链接的读阻塞：G会挂在底层pollDesc的rg中；</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net read</span></span><br><span class="line"> <span class="keyword">var</span> c net.Conn</span><br><span class="line"> <span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//data not ready, block here</span></span><br><span class="line"> n, err := c.Read(buf)</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>链接的写阻塞：G会挂在底层pollDesc的wg中；</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net write</span></span><br><span class="line"><span class="keyword">var</span> c net.Conn</span><br><span class="line"><span class="keyword">var</span> buf = <span class="built_in">make</span>(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// send buffer full, write blocked</span></span><br><span class="line">n, err := c.Write(buf)</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>select阻塞：以图中的3个channel为例，会有3个sendq或者是recvq队列，G则打包为sudog挂在这些队列的尾部；</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// no case ready, block</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ch1 ready"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ch2 ready"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/10.png" alt="description"></p>
<ol start="7">
<li>由于锁的阻塞相对特殊，单独拿出来说。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// somebody already grab the lock</span></span><br><span class="line"><span class="comment">// block here</span></span><br><span class="line">l.Lock()</span><br></pre></td></tr></tbody></table></figure>

<p>应⽤阻塞在锁上的情况，由于锁的阻塞相对特殊，单独拿出来说。</p>
<p><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/11.png" alt="description"></p>
<p>和前面的集中阻塞情况相似的是，锁的阻塞依然会将G打包为sudog，会停留在树堆的结构中，树堆是一个二叉平衡树，且其中的每一个节点就是一个链表；<br>根据上面的介绍，我们可以看到，有些挂起等待结构是sudog而有些是G？<br>因为，⼀个 g 可能对应多个 sudog，⽐如⼀个 g 会同时 select 多个channel，在runtime中有对这里解读的注释：</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudog is necessary because the g ↔ synchronization object relation</span></span><br><span class="line"><span class="comment">// is many-to-many. A g can be on many wait lists, so there may be</span></span><br><span class="line"><span class="comment">// many sudogs for one g; and many gs may be waiting on the same</span></span><br><span class="line"><span class="comment">// synchronization object, so there may be many sudogs for one object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">    <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">    <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">    <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">    <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">    <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">    isSelect <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// success indicates whether communication over channel c</span></span><br><span class="line">    <span class="comment">// succeeded. It is true if the goroutine was awoken because a</span></span><br><span class="line">    <span class="comment">// value was delivered over channel c, and false if awoken</span></span><br><span class="line">    <span class="comment">// because c was closed.</span></span><br><span class="line">    success <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    parent   *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c        *hchan <span class="comment">// channel</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>runtime不可接管处理拦截的阻塞：syscall，cgo，⻓时间运⾏需要剥离 P 执行</p>
<p>在执行 c 代码，或者阻塞在 syscall 上时，必须占⽤⼀个线程</p>
<p>sysnb: syscall nonblocking<br>sys: syscall blocking</p>
<h3 id="sysmon-system-monitor"><a href="#sysmon-system-monitor" class="headerlink" title="sysmon: system monitor"></a>sysmon: system monitor</h3><p>sysmon在后台具有⾼优先级，在专有线程中执行，不需要绑定 P 就可以执行。</p>
<p>sysmon主要有3个作用：</p>
<ol>
<li>checkdead —&gt; 用于检查是否当前的所有线程都被阻塞住了，如果所有线程死锁，说明程序写的有问题，需要直接崩溃提示。对于网络应用而言，一般不会触发。常见的误解是：这个可以检查死锁；检查是否已经没有活动线程，如果是，则崩溃</li>
<li>netpoll 轮询 —&gt; 将G插入到全局队列里面；inject g list to global run queue</li>
<li>retake —&gt; 如果是 syscall 卡了很久，那就把 P 从 M 上剥离(handoffp)、剥离在 syscall 上阻塞的 M 的 P；在go1.14以后，如果是⽤户 G 运⾏很久了，那么发信号抢占已经执行时间过⻓的</li>
</ol>
<p><img src="/2021/10/02/go-jin-cheng-de-qi-dong-guo-cheng-diao-du-xun-huan-he-gpm/12.png" alt="description"></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for deadlock situation.</span></span><br><span class="line"><span class="comment">// The check is based on number of running M's, if 0 -&gt; deadlock.</span></span><br><span class="line"><span class="comment">// sched.lock must be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkdead</span><span class="params">()</span></span> {</span><br></pre></td></tr></tbody></table></figure>

<hr>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ cat -n send_on_close.go  # 一次性显示文件内容和行号</span><br><span class="line">     1    package main</span><br><span class="line">     2</span><br><span class="line">     3    func main() {</span><br><span class="line">     4        var ch = make(chan int)</span><br><span class="line">     5        close(ch)</span><br><span class="line">     6        ch &lt;- 1</span><br><span class="line">     7    }</span><br><span class="line"></span><br><span class="line">[root@adafd home]# dlv debug send_on_close.go</span><br><span class="line">(dlv) b main.main</span><br><span class="line">Breakpoint 1 set at 0x46019f for main.main() ./send_on_close.go:3</span><br><span class="line"></span><br><span class="line">(dlv) c</span><br><span class="line">==&gt;     3    func main() {</span><br><span class="line"></span><br><span class="line">(dlv) n # 下一行</span><br><span class="line">==&gt;     4        var ch = make(chan int)</span><br><span class="line">(dlv) c</span><br><span class="line">==&gt;     close(ch)</span><br><span class="line"></span><br><span class="line">(dlv) n</span><br><span class="line">==&gt;     ch &lt;- 1</span><br><span class="line">(dlv) n</span><br><span class="line">==&gt;     func fatalpanic(msgs *_panic)</span><br><span class="line"></span><br><span class="line">(dlv) r</span><br><span class="line">Proocess restarted with PID 339</span><br><span class="line">(dlv) c</span><br><span class="line">==&gt;     3    func main() {</span><br><span class="line"></span><br><span class="line">(dlv) quit</span><br><span class="line">[root@adafd home]# </span><br></pre></td></tr></tbody></table></figure>

<p>dlv调试关闭值为nil的chan时</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">[root@0783a24aec92 home]<span class="comment"># dlv debug ch.go</span></span><br><span class="line">Type <span class="string">'help'</span> <span class="keyword">for</span> list of commands.</span><br><span class="line">(dlv) b closechan</span><br><span class="line">Breakpoint 1 (enabled) <span class="built_in">set</span> at 0x404b03 <span class="keyword">for</span> runtime.closechan() /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340</span><br><span class="line">(dlv) c</span><br><span class="line">&gt; runtime.closechan() /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340 (hits goroutine(1):1 total:1) (PC: 0x404b03)</span><br><span class="line">Warning: debugging optimized <span class="keyword">function</span></span><br><span class="line">   335:        src := sg.elem</span><br><span class="line">   336:        typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)</span><br><span class="line">   337:        memmove(dst, src, t.size)</span><br><span class="line">   338:    }</span><br><span class="line">   339:</span><br><span class="line">=&gt; 340:    func closechan(c *hchan) {</span><br><span class="line">   341:        <span class="keyword">if</span> c == nil {</span><br><span class="line">   342:            panic(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">   343:        }</span><br><span class="line">   344:</span><br><span class="line">   345:        lock(&amp;c.lock)</span><br><span class="line">(dlv) bt</span><br><span class="line">0  0x0000000000404b03 <span class="keyword">in</span> runtime.closechan</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340</span><br><span class="line">1  0x0000000000430b74 <span class="keyword">in</span> runtime.main</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:192</span><br><span class="line">2  0x000000000045b7c1 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1373</span><br><span class="line">(dlv) frame 1</span><br><span class="line">&gt; runtime.closechan() /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340 (hits goroutine(1):1 total:1) (PC: 0x404b03)</span><br><span class="line">Warning: debugging optimized <span class="keyword">function</span></span><br><span class="line">Frame 1: /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:192 (PC: 430b74)</span><br><span class="line">   187:            cgocall(_cgo_notify_runtime_init_done, nil)</span><br><span class="line">   188:        }</span><br><span class="line">   189:</span><br><span class="line">   190:        doInit(&amp;main_inittask)</span><br><span class="line">   191:</span><br><span class="line">=&gt; 192:        close(main_init_done)</span><br><span class="line">   193:</span><br><span class="line">   194:        needUnlock = <span class="literal">false</span></span><br><span class="line">   195:        unlockOSThread()</span><br><span class="line">   196:</span><br><span class="line">   197:        <span class="keyword">if</span> isarchive || islibrary {</span><br><span class="line">(dlv) l</span><br><span class="line">Goroutine 1 frame 1 at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:192 (PC: 0x430b74)</span><br><span class="line">   187:            cgocall(_cgo_notify_runtime_init_done, nil)</span><br><span class="line">   188:        }</span><br><span class="line">   189:</span><br><span class="line">   190:        doInit(&amp;main_inittask)</span><br><span class="line">   191:</span><br><span class="line">=&gt; 192:        close(main_init_done)</span><br><span class="line">   193:</span><br><span class="line">   194:        needUnlock = <span class="literal">false</span></span><br><span class="line">   195:        unlockOSThread()</span><br><span class="line">   196:</span><br><span class="line">   197:        <span class="keyword">if</span> isarchive || islibrary {</span><br><span class="line">(dlv) frame 0</span><br><span class="line">&gt; runtime.closechan() /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340 (hits goroutine(1):1 total:1) (PC: 0x404b03)</span><br><span class="line">Warning: debugging optimized <span class="keyword">function</span></span><br><span class="line">Frame 0: /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340 (PC: 404b03)</span><br><span class="line">   335:        src := sg.elem</span><br><span class="line">   336:        typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)</span><br><span class="line">   337:        memmove(dst, src, t.size)</span><br><span class="line">   338:    }</span><br><span class="line">   339:</span><br><span class="line">=&gt; 340:    func closechan(c *hchan) {</span><br><span class="line">   341:        <span class="keyword">if</span> c == nil {</span><br><span class="line">   342:            panic(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">   343:        }</span><br><span class="line">   344:</span><br><span class="line">   345:        lock(&amp;c.lock)</span><br><span class="line">(dlv) bt</span><br><span class="line">0  0x0000000000404b03 <span class="keyword">in</span> runtime.closechan</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340</span><br><span class="line">1  0x0000000000430b74 <span class="keyword">in</span> runtime.main</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:192</span><br><span class="line">2  0x000000000045b7c1 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1373</span><br><span class="line">(dlv) c</span><br><span class="line">&gt; runtime.closechan() /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340 (hits goroutine(1):2 total:2) (PC: 0x404b03)</span><br><span class="line">Warning: debugging optimized <span class="keyword">function</span></span><br><span class="line">   335:        src := sg.elem</span><br><span class="line">   336:        typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)</span><br><span class="line">   337:        memmove(dst, src, t.size)</span><br><span class="line">   338:    }</span><br><span class="line">   339:</span><br><span class="line">=&gt; 340:    func closechan(c *hchan) {</span><br><span class="line">   341:        <span class="keyword">if</span> c == nil {</span><br><span class="line">   342:            panic(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">   343:        }</span><br><span class="line">   344:</span><br><span class="line">   345:        lock(&amp;c.lock)</span><br><span class="line">(dlv) bt</span><br><span class="line">0  0x0000000000404b03 <span class="keyword">in</span> runtime.closechan</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/chan.go:340</span><br><span class="line">1  0x00000000004601c3 <span class="keyword">in</span> main.main</span><br><span class="line">   at ./ch.go:9</span><br><span class="line">2  0x0000000000430ba8 <span class="keyword">in</span> runtime.main</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:203</span><br><span class="line">3  0x000000000045b7c1 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1373</span><br><span class="line">(dlv)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>汇编中的SB是静态基地址寄存器，比如：runtime.exitsyscall(SB)， 全局变量、函数声明的时候都需要用</p>
<p>ring0-ring3在os代码中是怎么体现的<br>ring3 -&gt; ring0: syscall(硬件指令)<br>ring0 -&gt; ring3: sysret(硬件指令)<br>函数传参的时候是不是只要在六个之内，就会通过寄存器操作<br>Go 应用层代码函数调用没有寄存器一说，都是通过栈传参的，1.17 以后才会用上寄存器<br>C 语言：6 个以内寄存器，超过 6 个的话，超过部分会放到栈上(这里有简化，如果你参数是 int 和 float 混着的，那每一种类型如 int 能用的寄存器满了，后续这种类型的参数就在栈上)<br>系统调用：专有的调用规约，参数和返回值都是通过寄存器传递，最大 6 个参数，返回值只有一个<br>后面会讲网络编程吗？(netpoller,epoll）这种<br>web 部分讲 netpoll 实现<br>是所有的syscall，都会发生M+G独立出来吗？ 比如getpid这种syscall，感觉是很轻的系统调用行为。<br>先区分 sys(阻塞的系统调用)、sysnb(非阻塞)，非阻塞系统调用不会独立出去；阻塞的系统调用，运行时间超过一定界限才会有独立。<br>还是sysmon在做监控的吗：是的</p>
<p>8.syscall是不是很耗cpu，cpu需要等待syscall 返回吗<br>     a. 上下文切换成本比较高，但阻塞在 syscall 上等待的线程是不消耗 CPU 的<br>     b.<br>9.go 应该有办法获取ring0权限吧？<br>     a. 用户不能随便切换到 ring0，只能通过 syscall、int 80、sysenter<br>     b. 否则操作系统的安全机制就形同虚设了<br>10.select 是使用epoll吗？是一种是同步io吗？1<br>     a. select {} 和 epoll 没关系<br>     b. select 系统调用 epoll 两套东西，epoll 是 select 的进化版本，为了解决网络编程中的 c10k 问题被发明出来的<br>11 陷入系统调用期间的M，它不可用了，被剥离的P，是被新创建的M持有继续执行吗？<br>     a. sysmon -&gt; retake -&gt; handoffp -&gt; mstart<br>12.虚拟寄存器(?)与CPU其他寄存器有什么区别，比如作用或实现<br>     a. Go 伪寄存器<br>     b. 64 位 AX -&gt; rax, BX -&gt; rbx<br>     c. 32 位 AX -&gt; eax<br>13.异步和同步的 Linux有异步的系统调用吗<br>    a. 同步阻塞、同步非阻塞<br>    b. aio_write 是不是不太确定<br>14.go的sysmon 是单独的一个线程吧 跟m0有关系吗？<br>    a. 看一下第一课的 ppt<br>15.像time.sleep 这种底层是通过系统调用实现的sleep么<br>    a. 是的<br>16.可以手动syscall.clone创建M然后放到M idle队列么？<br>    a. 。理论上可以，但其实 runtime 里的 M 除了 clone 返回的结构还有一些别的结构，你得把那些东西也填好，而且要考虑 runtime.m 是个私有变量，你想做这个 hack 可不太容易<br>    b. 但理论上依然是可实现的<br>17.sysmon是查看g.status==syscall吗？那rawsyscall会把g.statu改为多少才不会让sysmon检测到？<br>    a. rawsyscall 不修改 g.status，依然是 running<br>18.那就是如果有并发有大量的阻塞系统调用 系统调用完成后都将m放到了空闲的队列 这时候那么多的 m 会被清空吗<br>    a. 1000 个线程被 syscall 阻塞 -&gt; syscall -&gt; midle 空闲线程列表里<br>19.软中断和硬中断哪一个速度更快？为什么？<br>    a. not sure….<br>20.可以讲一下MADV_FREE和MADV_DONTNEED吗<br>    a. man7.org<br>21.可以列举下内核升级导致应用系统行为变化的例子吗？<br>    a. madvise, 4.5 madv_free，导致的现象是你在监控里看到的 RSS 比实际占用的内存多很多<br>    b. GODEBUG=madvdontneed=1 ./server, go1.12 -&gt; go1.15 + linux 4.5+<br>22.P上不止一个G，为什么剥离PM，未阻塞的G怎么处理的？<br>    a. M-G，syscall 阻塞住，CPU 最大化利用，所以希望 P 上的 local run queue 的任务能被执行<br>23.怎么做性能报告？benchmark pprof 大概做哪些方面的报告，对于第三课的第一题作业不知道做哪些方面的分析<br>     a. go test benchmark，《the go programming language》<br>     b. pprof<br>24.”spec可以搜索到类型的所有用法”, spec是指什么网址？<br>     a. <a target="_blank" rel="noopener" href="https://golang.org/doc/spec">https://golang.org/doc/spec</a><br>25.放到空闲队列的m会绑定到CPU上运行吗 会占用CPU的时间片吗？<br>     a. 空闲的线程，不占用 CPU<br>26 那用户代码能清空空闲队列的m么 或者 有提供函数获得 空闲队列的大小么，那么空闲m队列也不会被gc回收么？<br>     a. go func -&gt; LockOsThread, return<br>27. RSS(Resident Set Size)比实际占用多，有可能是go 运行时调用了cgo的，然后就占内存多了。这里有个哥们探究了的。<br><a target="_blank" rel="noopener" href="https://povilasv.me/go-memory-management/">https://povilasv.me/go-memory-management/</a><br><a target="_blank" rel="noopener" href="https://povilasv.me/go-memory-management-part-2/">https://povilasv.me/go-memory-management-part-2/</a><br><a target="_blank" rel="noopener" href="https://povilasv.me/go-memory-management-part-3/">https://povilasv.me/go-memory-management-part-3/</a></p>
<p>go1.12-&gt;1.15 + kernel 4.5+，没设置 madvdontneed=1<br>RSS 本身占用就比实际要多，GOGC=100，heap goal, SetMaxHeap<br>tcmalloc，内部还是有一些内存碎片<br>Go RSS = Stack + Heap，10w goroutine，10w-5w tcp conn，每一个 goroutine 8k</p>
<p>怎么看实际内存占用？<br>top<br>sar, tsar, asar<br>runtime.MemStats<br>30.调用netpoll 底层应该使用epoll_wait 那个go调用是用阻塞的还是非阻塞的？<br>     a. syscall/runtime<br>有效的环境变量比如 GODEBUG GOGC 的列表，以及可用参数的文档哪里可以查到？<br>google</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/09/28/rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/28/rpc/" class="post-title-link" itemprop="url">RPC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 16:21:41" itemprop="dateCreated datePublished" datetime="2021-09-27T16:21:41Z">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-18 08:36:24" itemprop="dateModified" datetime="2021-10-18T08:36:24Z">2021-10-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RPC（Remote Procedure Call）远程过程调用</p>
<p>通俗地说就是调用远处的一个函数。远处到底有多远呢？可能是同一个文件内的不同函数，也可能是同一个机器的另一个进程的函数，还可能是远在火星好奇号上面的某个秘密方法。因为RPC涉及的函数可能非常之远，远到它们之间说着完全不同的语言，语言就成了两边的沟通障碍。而Protobuf因为支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身特性也非常方便描述服务的接口（也就是方法列表），因此非常适合作为RPC世界的接口交流语言。本章将讨论RPC的基本用法，如何针对不同场景设计自己的RPC服务，以及围绕Protobuf构造的更为庞大的RPC生态。</p>
<p>简单的理解是一个节点请求另一个节点提供的服务<br>对应rpc的是本地过程调用，函数调用是最常见的本地过程调用<br>将本地过程调用变成远程过程调用会面临各种问题</p>
<p>远程过程调用带来的新问题<br>在远程调用时，我们需要执行原本的本地函数体是在远程的服务器机器上去运行，也就是说，add是在另一个进程中执行的。这就带来了几个新问题：</p>
<ol>
<li>Call ID映射。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li>
<li>序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li>
<li>网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</li>
</ol>
<p>解决了上面三个机制，就能实现RPC了，具体过程如下：<br>client端解决的问题：</p>
<ol>
<li>将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</li>
<li>将Call ID，a和b序列化。可以直接将它们的值以二进制形式打包</li>
<li>把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</li>
<li>等待服务器返回结果</li>
<li>如果服务器调用成功，那么就将结果反序列化，并赋给total</li>
</ol>
<p>server端解决的问题</p>
<ol>
<li>在本地维护一个Call ID到函数指针的映射call_id_map，可以用dict完成</li>
<li>等待请求，包括多线程的并发处理能力</li>
<li>得到一个请求后，将其数据包反序列化，得到Call ID</li>
<li>通过在call_id_map中查找，得到相应的函数指针</li>
<li>将a和rb反序列化后，在本地调用add函数，得到结果</li>
<li>将结果序列化后通过网络返回给Client<br>在上面的整个流程中，估计有部分同学看到了熟悉的计算机网络的流程和web服务器的定义。<br>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。</li>
</ol>
<p>其中：<br>● Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。<br>● 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。<br>● 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</p>
<p>实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。</p>
<p>最后提一个问题： 如何将远程的这些过程写出本地函数调用的感觉来</p>
<p>RPC 和 REST 区别是什么？<br>你一定会觉得这个问题很奇怪，是的，包括我，但是你在网络上一搜，会发现类似对比的文章比比皆是，我在想可能很多初学者由于基础不牢固，才会将不相干的二者拿出来对比吧。既然是这样，那为了让你更加了解陌生的RPC，就从你熟悉得不能再熟悉的 REST 入手吧。</p>
<p>REST，是Representational State Transfer 的简写，中文描述表述性状态传递（是指某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式(XML、JSON)等信息。）</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>而RPC 呢，是 Remote Procedure Call Protocol 的简写，中文描述是远程过程调用，它可以实现客户端像调用本地服务(方法)一样调用服务器的服务(方法)。</p>
<p>而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的，按理说它和REST不是一个层面意义上的东西，不应该放在一起讨论，但是谁让REST这么流行呢，它是目前最流行的一套互联网应用程序的API设计标准，某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<p>2、使用方式不同<br>从使用上来看，HTTP 接口只关注服务提供方，对于客户端怎么调用并不关心。接口只要保证有客户端调用时，返回对应的数据就行了。而RPC则要求客户端接口保持和服务端的一致。</p>
<p>REST 是服务端把方法写好，客户端并不知道具体方法。客户端只想获取资源，所以发起HTTP请求，而服务端接收到请求后根据URI经过一系列的路由才定位到方法上面去RPC是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。</p>
<p>3、面向对象不同<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ，REST：所谓的 Representational state transfer ，是面向资源的，除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的，这个接触不多，就不多说了。</p>
<p>4、序列化协议不同<br>接口调用通常包含两个部分，序列化和通信协议。</p>
<p>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。</p>
<p>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>通过以上几点，我们知道了 REST 和 RPC 之间有很明显的差异。</p>
<p>然后第二个问题：为什么要采用RPC呢？</p>
<p>那到底为何要使用 RPC，单纯的依靠RESTful API不可以吗？为什么要搞这么多复杂的协议，渣渣表示真的学不过来了。</p>
<p>关于这一点，以下几点仅是我的个人猜想，仅供交流哈：</p>
<p>RPC 和 REST 两者的定位不同，REST 面向资源，更注重接口的规范，因为要保证通用性更强，所以对外最好通过 REST。而 RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景。RESTful API客户端与服务端之间采用的是同步机制，当发送HTTP请求时，客户端需要等待服务端的响应。当然对于这一点是可以通过一些技术来实现异步的机制的。采用RESTful API，客户端与服务端之间虽然可以独立开发，但还是存在耦合。比如，客户端在发送请求的时，必须知道服务器的地址，且必须保证服务器正常工作。而 rpc + ralbbimq中间件可以实现低耦合的分布式集群架构。说了这么多，我们该如何选择这两者呢？我总结了如下两点，供你参考：</p>
<p>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高（见下条）从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<h3 id="为什么一定要rpc，不能只学http协议和restful协议吗？"><a href="#为什么一定要rpc，不能只学http协议和restful协议吗？" class="headerlink" title="为什么一定要rpc，不能只学http协议和restful协议吗？"></a>为什么一定要rpc，不能只学http协议和restful协议吗？</h3><ol>
<li><p>rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
</li>
<li><p>自定义协议可以优化数据的传输</p>
</li>
</ol>
<p>如果我们只是开发web网站或者一些服务的使用者， 那么我们用restful看起来已经足够了，但是rpc的这种模式在大量的服务中都有，比如redis协议， rabbitmq的AMQP协议， 聊天软件的协议，也就是说我们想要开发一个redis的客户端，我们只需要用我们喜欢的语言实现redis定义的协议就行了，这对于开发服务来说非常有用，一般这种协议的价值在于我们自己开发的服务之间需要通信的时候 - 那你会问了，自己开发的组件之间协作，直接调用函数不就行了吗？ - 对了，有些人已经反映过来了 – 分布式系统，分布式系统中非常常用， 比如openstack中。 还有就是微服务！</p>
<p>所以掌握rpc开发，对于进阶和分布式开发就变得非常重要。</p>
<p>http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以后面讲解到的grpc就会使用http2.0开发</p>
<h3 id="通过httpserver实现"><a href="#通过httpserver实现" class="headerlink" title="通过httpserver实现"></a>通过httpserver实现</h3><p>rpc首先一点需要明确：一定会发起一个网络请求，一定会有个网络连接(tcp/udp)</p>
<p>把远程的函数变成一个http请求</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse, parse_qsl</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line">host = (<span class="string">''</span>, <span class="number">8003</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将url映射到对应的函数 urlconfig route call id的映射</span></span><br><span class="line"><span class="comment"># 反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">        parsed_url = urlparse(self.path)</span><br><span class="line">        qs = dict(parse_qsl(parsed_url.query))</span><br><span class="line">        a = int(qs.get(<span class="string">"a"</span>, <span class="number">0</span>))</span><br><span class="line">        b = int(qs.get(<span class="string">"b"</span>, <span class="number">0</span>))</span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(json.dumps({</span><br><span class="line">            <span class="string">"result"</span>:a+b</span><br><span class="line">        }).encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    server = HTTPServer(host, AddHandler)</span><br><span class="line">    print(<span class="string">"Starting server, listen at: %s:%s"</span> % host)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>本地调用</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>+<span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>总结说来，本地程序调用的过程大致可以分为几个步骤和阶段：<br>● 开发者开发好的程序，并进行编译，编译成机器认可的可执行文件。<br>● 运行可执行文件，调用对应的功能方法，期间会读取可执行文件中的机器指令，进行入栈，出栈赋值等操作。此时，计算机由可执行程序所在的进程控制。<br>● 调用结束，所有的内存数据出栈，程序执行结束。计算机继续由操作系统进行控制。</p>
<p>远程过程调用是在两台或者多台不同的物理机器上实现的调用，其间要跨越网络进行调用。因此，我们再想通过前文本地方法调用的形式完成功能调用，就无法实现了，因为编译器无法通过编译的可执行文件来调用远程机器上的程序方法。因此需要采用RPC的方式来实现远端服务器上的程序方法的调用。<br>RPC技术内部原理是通过两种技术的组合来实现的：<strong>本地方法调用 和 网络通信技术</strong>。<br><strong>如果想要做到不用url来确定调用方法和参数怎么办？</strong></p>
<p>改进一下client的代码</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己实现了一个demo级别的rpc封装 代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientStub</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="comment"># 1. call id</span></span><br><span class="line">        <span class="comment"># 2. 序列化和反序列化</span></span><br><span class="line">        <span class="comment"># 3. 传输协议 http</span></span><br><span class="line">        rsp = requests.get(<span class="string">f"<span class="subst">{self.url}</span>/?a=<span class="subst">{a}</span>&amp;b=<span class="subst">{b}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(rsp.text).get(<span class="string">"result"</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def add(self, a, b):</span></span><br><span class="line">    <span class="comment">#     payload = {</span></span><br><span class="line">    <span class="comment">#         "method": "add",</span></span><br><span class="line">    <span class="comment">#         "params": [a, b],</span></span><br><span class="line">    <span class="comment">#         "jsonrpc": "2.0",</span></span><br><span class="line">    <span class="comment">#         "id": 0,</span></span><br><span class="line">    <span class="comment">#     }</span></span><br><span class="line">    <span class="comment">#     response = requests.post(self.url, json=payload).json()</span></span><br><span class="line">    <span class="comment">#     print(response)</span></span><br><span class="line">    <span class="comment">#     return response["result"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这不是就是写一个web服务器 无非就是自己封装一下client</span></span><br><span class="line"><span class="comment">#不想知道过多的细节 只想像本地一样调用</span></span><br><span class="line">client = ClientStub(<span class="string">"http://127.0.0.1:8003"</span>)</span><br><span class="line">print(client.add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(client.add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(client.add(<span class="number">22</span>, <span class="number">33</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的代码我们关注几点：</p>
<ol>
<li>通信使用了json，所以json中的内容应该如何写就成为了一种协议</li>
<li>要想实现远程调用必须要要有网络连接</li>
<li>上面通过http连接，可以发现客户端和服务器端之间可以独立，实际上除了通过json以外还可以通过xml作为数据格式</li>
<li>rpc不应该和http拿来比较</li>
<li>rpc也不应该和restful拿来比较，我们完全可以把上述代码通过client和server端的封装将rpc编程基于restful来实现</li>
<li>rpc可以理解为一种调用风格，具体实现可以随意写，至于底层是走tcp协议还是http协议看需求</li>
</ol>
<p>rpc开发的四大要素<br>RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。</p>
<p><strong>客户端(Client)：</strong>服务调用发起方，也称为服务消费者。<br><strong>客户端存根(Client  Stub)：</strong>该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。<br><strong>服务端(Server)：</strong>远端的计算机机器上运行的程序，其中有客户端要调用的方法。<br><strong>服务端存根(Server Stub)：</strong>接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。</p>
<p>了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：</p>
<ul>
<li>两台物理机器在网络中要建立稳定可靠的通信连接。</li>
<li>两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。<br>图片.png</li>
</ul>
<p>RPC原理图<br>客户端(Client)服务端(server)10客户端Stub服务端Stubsocket通信Socket通信服务提供端请求发起端</p>
<p>在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：</p>
<p>1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名；<br>2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。<br>3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。<br>4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。<br>5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。<br>6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。<br>7、服务端Stub程序<strong>将程序调用结果按照约定的协议进行序列化，</strong>并通过网络发送回客户端Stub程序。<br>8、客户端Stub程序接收到服务端Stub发送的返回数据，<strong>对数据进行反序列化操作，</strong>并将调用返回的数据传递给客户端请求发起者。<br>9、客户端请求发起者得到调用结果，整个RPC调用过程结束。</p>
<p>rpc需要使用到的术语</p>
<p>通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析：</p>
<p>1、动态代理技术： 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。<br>2、序列化和反序列化：  在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。<br><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。<br><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。<br>我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。</p>
<h3 id="基于xml的rpc调用"><a href="#基于xml的rpc调用" class="headerlink" title="基于xml的rpc调用"></a>基于xml的rpc调用</h3><p>服务端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc.server <span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"></span><br><span class="line"><span class="comment">#python中类的命名方式遵循驼峰命名法</span></span><br><span class="line"><span class="comment">#1. 没有出现url的映射</span></span><br><span class="line"><span class="comment">#2. 没有编码和解码</span></span><br><span class="line"><span class="comment">#序列化和反序列化协议是 xml 不是 json</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculater</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtract</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> abs(x-y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x/y</span><br><span class="line"></span><br><span class="line">obj = Calculater()</span><br><span class="line">server = SimpleXMLRPCServer((<span class="string">"localhost"</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="comment"># 将实例注册给rpc server</span></span><br><span class="line">server.register_instance(obj)</span><br><span class="line">print(<span class="string">"Listening on port 8088"</span>)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc <span class="keyword">import</span> client</span><br><span class="line"></span><br><span class="line"><span class="comment">#xmlrpc挺好用的 和我们调用django的服务器 django这种web框架来说一定是可以做到xmlrpc的效果 django的目的不是这种</span></span><br><span class="line"><span class="comment">#rpc强调的是本地调用效果</span></span><br><span class="line"><span class="comment">#rpc在内部调用很多</span></span><br><span class="line"></span><br><span class="line">server = client.ServerProxy(<span class="string">"http://localhost:8088"</span>)</span><br><span class="line">print(server.add(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 5</span></span><br><span class="line">print(server.multiply(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 6</span></span><br><span class="line">print(server.subtract(<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后，我们通过 server_proxy 对象就可以远程调用之前的rpc server的函数了。</p>
<h3 id="json实现rpc的调用"><a href="#json实现rpc的调用" class="headerlink" title="json实现rpc的调用"></a>json实现rpc的调用</h3><p>SimpleXMLRPCServer 是基于 xml-rpc 实现的远程调用，上面我们也提到 除了 xml-rpc 之外，还有 json-rpc 协议。<br>那 python 如何实现基于 json-rpc 协议呢？答案是很多，很多web框架其自身都自己实现了json-rpc，但我们要独立这些框架之外，要寻求一种较为干净的解决方案，我们使用 jsonrpclib<br><a target="_blank" rel="noopener" href="https://github.com/tcalmant/jsonrpclib/">https://github.com/tcalmant/jsonrpclib/</a></p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jsonrpclib-pelix</span><br></pre></td></tr></tbody></table></figure>

<p>它与 Python 标准库的 SimpleXMLRPCServer 很类似（因为它的类名就叫做 SimpleJSONRPCServer ，不明真相的人真以为它们是亲兄弟）。或许可以说，jsonrpclib 就是仿照 SimpleXMLRPCServer 标准库来进行编写的。<br>它的导入与 SimpleXMLRPCServer 略有不同，因为SimpleJSONRPCServer分布在jsonrpclib库中。</p>
<p>服务端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jsonrpclib.SimpleJSONRPCServer <span class="keyword">import</span> SimpleJSONRPCServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 实例化server</span></span><br><span class="line">server = SimpleJSONRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment">#2. 将函数注册到server中</span></span><br><span class="line">server.register_function(add)</span><br><span class="line"><span class="comment">#3. 启动server</span></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></tbody></table></figure>

<p>多线程<br>协程 go中 netty asyncio<br>jsonrpclib如果只是完成了这样一个简单的调用那么jsonrpclib和xmlrpcserver几乎没有优势可言<br>任何一个web服务如果不具备并发接收和处理的能力的话 那么这个server就没有用</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jsonrpclib.SimpleJSONRPCServer <span class="keyword">import</span> PooledJSONRPCServer</span><br><span class="line"><span class="keyword">from</span> jsonrpclib.threadpool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup the notification and request pools</span></span><br><span class="line">nofif_pool = ThreadPool(max_threads=<span class="number">10</span>, min_threads=<span class="number">0</span>)</span><br><span class="line">request_pool = ThreadPool(max_threads=<span class="number">50</span>, min_threads=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Don't forget to start them</span></span><br><span class="line">nofif_pool.start()</span><br><span class="line">request_pool.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup the server</span></span><br><span class="line">server = PooledJSONRPCServer((<span class="string">'localhost'</span>, <span class="number">8000</span>), thread_pool=request_pool)</span><br><span class="line">server.set_notification_pool(nofif_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register methods</span></span><br><span class="line">server.register_function(add)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 超时机制 - 重试</span></span><br><span class="line"><span class="comment">#2. 限流 处于长期可用的状态 - 高可用</span></span><br><span class="line"><span class="comment">#3. 解耦</span></span><br><span class="line"><span class="comment">#4. 负载均衡 微服务 -分布式应用的一种具体的体现</span></span><br><span class="line"><span class="comment">#5. json-rpc是否满足上述的要求</span></span><br><span class="line"><span class="comment">#6. 序列化和反序列化数据压缩是否高效 json这种数据格式已经非常的简单了 1.这个序列化协议能将数据的压缩变得更小 2. 这个序列化和反序列化的速度够快</span></span><br><span class="line"><span class="comment">#json.dumps() json.loads()</span></span><br><span class="line"><span class="comment">#做架构 技术选型的时候 这些都是我们需要考虑到的点</span></span><br><span class="line"><span class="comment">#更加高效和更加全面的技术 zerorpc</span></span><br><span class="line"><span class="comment">#7. 这个rpc框架是否支持多语言 生态很好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># Stop the thread pools (let threads finish their current task)</span></span><br><span class="line">    request_pool.stop()</span><br><span class="line">    nofif_pool.stop()</span><br><span class="line">    server.set_notification_pool(<span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonrpclib</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">    server = jsonrpclib.ServerProxy(<span class="string">'http://localhost:8000'</span>)</span><br><span class="line">    print(server.add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = threading.Thread(target=request)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">30</span>)  <span class="comment"># 主线程不直接退出</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="zerorpc实现rpc调用"><a href="#zerorpc实现rpc调用" class="headerlink" title="zerorpc实现rpc调用"></a>zerorpc实现rpc调用</h3><p>zerorpc 是利用 zeroMQ消息队列 + msgpack 消息序列化(二进制) 来实现类似 grpc 的功能，跨语言远程调用。<br>主要使用到 zeroMQ 的通信模式是 ROUTER–DEALER，模拟 grpc 的 &nbsp;请求-响应式 和 应答流式 RPC ：zerorpc 还支持 PUB-SUB 通信模式的远程调用。<br>zerorpc实际上会依赖msgpack-python, pyzmq, future, greenlet, gevent</p>
<p><a target="_blank" rel="noopener" href="https://github.com/0rpc/zerorpc-python">https://github.com/0rpc/zerorpc-python</a></p>
<h4 id="一元调用"><a href="#一元调用" class="headerlink" title="一元调用"></a>一元调用</h4><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloRPC</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="comment">#调用了另一个服务</span></span><br><span class="line">        <span class="comment">#流处理</span></span><br><span class="line">        <span class="comment">#本地查询了数据， 源源不断的给数据给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, %s"</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 实例化一个server</span></span><br><span class="line"><span class="comment">#2. 绑定我们的业务代码到server中</span></span><br><span class="line"><span class="comment">#3. 启动server</span></span><br><span class="line">s = zerorpc.Server(HelloRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>客户端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"ni"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"hao"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在功能体验上 client端没有太大的差异</span></span><br><span class="line"><span class="comment">#差异在性能上 服务端上</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> hello():</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line"><span class="comment">#python中的生成器和迭代器</span></span><br><span class="line">print(c.hello(<span class="string">"慕课网"</span>))</span><br></pre></td></tr></tbody></table></figure>

<h4 id="流式响应"><a href="#流式响应" class="headerlink" title="流式响应"></a>流式响应</h4><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingRPC</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">    @zerorpc.stream #@zerorpc.stream这里的函数修饰是必须的，否则会有异常，如TypeError: can’t serialize</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">streaming_range</span>(<span class="params">self, fr, to, step</span>):</span></span><br><span class="line">        <span class="keyword">return</span> range(fr, to, step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = zerorpc.Server(StreamingRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<p>客户端</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 生态 - grpc</span></span><br><span class="line"><span class="comment">#2. 语言的支持 python nodejs go</span></span><br><span class="line"><span class="comment">#3. grpc</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> c.streaming_range(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>):</span><br><span class="line">    print(item)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="传入多个参数"><a href="#传入多个参数" class="headerlink" title="传入多个参数"></a>传入多个参数</h3><ol>
<li>服务端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myRPC</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listinfo</span>(<span class="params">self,message</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"get info : %s"</span>%message</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getpow</span>(<span class="params">self,n,m</span>):</span></span><br><span class="line">        <span class="keyword">return</span> n**m</span><br><span class="line"></span><br><span class="line">s = zerorpc.Server(myRPC())</span><br><span class="line">s.bind(<span class="string">"tcp://0.0.0.0:4242"</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>客户端</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">"tcp://127.0.0.1:4242"</span>)</span><br><span class="line">print(c.listinfo(<span class="string">"this is test string"</span>))</span><br><span class="line">print(c.getpow(<span class="number">2</span>,<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/09/22/go-de-option-mo-shi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/22/go-de-option-mo-shi/" class="post-title-link" itemprop="url">go的Options 模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-21 16:21:41 / 修改时间：14:23:58" itemprop="dateCreated datePublished" datetime="2021-09-21T16:21:41Z">2021-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Options 模式<br>一般原则：</p>
<ol>
<li>定义一个 Option 类型，它是 func(*YourType) 的形式；</li>
<li>在创建的方法那里，增加不定参数options…Option。内部遍历 options，并应用在实例上</li>
<li>WithXXXX的方法定义返回各种 Option<br>Tip：Go 没有构造函数，也没有方法重载，所以一般会用Option 模式来设计一个NewXX方法。<br>偶尔也会考虑用Builder 模式。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    lru <span class="string">"github.com/hashicorp/golang-lru"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StaticResourceHandlerOption <span class="function"><span class="keyword">func</span><span class="params">(h *StaticResourceHandler)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StaticResourceHandler <span class="keyword">struct</span> {</span><br><span class="line">    dir <span class="keyword">string</span></span><br><span class="line">    pathPrefix <span class="keyword">string</span></span><br><span class="line">    extensionContentTypeMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存静态资源的限制</span></span><br><span class="line">    cache *lru.Cache</span><br><span class="line">    maxFileSize <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fileCacheItem <span class="keyword">struct</span> {</span><br><span class="line">    fileName <span class="keyword">string</span></span><br><span class="line">    fileSize <span class="keyword">int</span></span><br><span class="line">    contentType <span class="keyword">string</span></span><br><span class="line">    data []<span class="keyword">byte</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStaticResourceHandler</span><span class="params">(dir <span class="keyword">string</span>, pathPrefix <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    options...StaticResourceHandlerOption)</span> *<span class="title">StaticResourceHandler</span></span> {</span><br><span class="line">    res := &amp;StaticResourceHandler{</span><br><span class="line">        dir: dir,</span><br><span class="line">        pathPrefix: pathPrefix,</span><br><span class="line">        extensionContentTypeMap: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{</span><br><span class="line">            <span class="comment">// 这里根据自己的需要不断添加</span></span><br><span class="line">            <span class="string">"jpeg"</span>: <span class="string">"image/jpeg"</span>,</span><br><span class="line">            <span class="string">"jpe"</span>: <span class="string">"image/jpeg"</span>,</span><br><span class="line">            <span class="string">"jpg"</span>: <span class="string">"image/jpeg"</span>,</span><br><span class="line">            <span class="string">"png"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">            <span class="string">"pdf"</span>: <span class="string">"image/pdf"</span>,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> options {</span><br><span class="line">        o(res)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"><span class="comment">// WithFileCache 静态文件将会被缓存</span></span><br><span class="line"><span class="comment">// maxFileSizeThreshold 超过这个大小的文件，就被认为是大文件，我们将不会缓存</span></span><br><span class="line"><span class="comment">// maxCacheFileCnt 最多缓存多少个文件</span></span><br><span class="line"><span class="comment">// 所以我们最多缓存 maxFileSizeThreshold * maxCacheFileCnt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFileCache</span><span class="params">(maxFileSizeThreshold <span class="keyword">int</span>, maxCacheFileCnt <span class="keyword">int</span>)</span> <span class="title">StaticResourceHandlerOption</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *StaticResourceHandler)</span></span> {</span><br><span class="line">        c, err := lru.New(maxCacheFileCnt)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"could not create LRU, we won't cache static file"</span>)</span><br><span class="line">        }</span><br><span class="line">        h.maxFileSize = maxFileSizeThreshold</span><br><span class="line">        h.cache = c</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMoreExtension</span><span class="params">(extMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">StaticResourceHandlerOption</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *StaticResourceHandler)</span></span> {</span><br><span class="line">        <span class="keyword">for</span> ext, contentType := <span class="keyword">range</span> extMap {</span><br><span class="line">            h.extensionContentTypeMap[ext] = contentType</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StaticResourceHandler)</span> <span class="title">ServeStaticResource</span><span class="params">(c *Context)</span></span>  {</span><br><span class="line">    req := strings.TrimPrefix(c.R.URL.Path, h.pathPrefix)</span><br><span class="line">    <span class="keyword">if</span> item, ok := h.readFileFromData(req); ok {</span><br><span class="line">        fmt.Printf(<span class="string">"read data from cache..."</span>)</span><br><span class="line">        h.writeItemAsResponse(item, c.W)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    path := filepath.Join(h.dir, req)</span><br><span class="line">    f, err := os.Open(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        c.W.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    ext := getFileExt(f.Name())</span><br><span class="line">    t, ok := h.extensionContentTypeMap[ext]</span><br><span class="line">    <span class="keyword">if</span> !ok {</span><br><span class="line">        c.W.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadAll(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        c.W.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    item := &amp;fileCacheItem{</span><br><span class="line">        fileSize: <span class="built_in">len</span>(data),</span><br><span class="line">        data: data,</span><br><span class="line">        contentType: t,</span><br><span class="line">        fileName: req,</span><br><span class="line">    }</span><br><span class="line">    h.cacheFile(item)</span><br><span class="line">    h.writeItemAsResponse(item, c.W)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StaticResourceHandler)</span> <span class="title">cacheFile</span><span class="params">(item *fileCacheItem)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> h.cache != <span class="literal">nil</span> &amp;&amp; item.fileSize &lt; h.maxFileSize {</span><br><span class="line">        h.cache.Add(item.fileName, item)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StaticResourceHandler)</span> <span class="title">writeItemAsResponse</span><span class="params">(item *fileCacheItem, writer http.ResponseWriter)</span></span> {</span><br><span class="line">    writer.WriteHeader(http.StatusOK)</span><br><span class="line">    writer.Header().Set(<span class="string">"Content-Type"</span>, item.contentType)</span><br><span class="line">    writer.Header().Set(<span class="string">"Content-Length"</span>, fmt.Sprintf(<span class="string">"%d"</span>, item.fileSize))</span><br><span class="line">    _, _ = writer.Write(item.data)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *StaticResourceHandler)</span> <span class="title">readFileFromData</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(*fileCacheItem, <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> h.cache != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">if</span> item, ok := h.cache.Get(fileName); ok {</span><br><span class="line">            <span class="keyword">return</span> item.(*fileCacheItem), <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileExt</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br><span class="line">    index := strings.LastIndex(name, <span class="string">"."</span>)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(name) - <span class="number">1</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> name[index+<span class="number">1</span>:]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/09/05/wei-fu-wu-she-ji/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/05/wei-fu-wu-she-ji/" class="post-title-link" itemprop="url">微服务设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-04 16:21:41 / 修改时间：13:11:11" itemprop="dateCreated datePublished" datetime="2021-09-04T16:21:41Z">2021-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><p>我们进行了 SOA 服务化的架构演进，按<br>照垂直功能进行了拆分，对外暴露了一批<br>微服务，但是因为缺乏统一的出口面临了<br>不少困难：<br>• 客户端到微服务直接通信，强耦合。<br>• 需要多次请求，客户端聚合数据，工作量巨大，延迟高。<br>• 协议不利于统一，各个部门间有差异，需要端来兼容。<br>• 面向“端”的API适配，耦合到了内部服务。<br>• 多终端兼容逻辑复杂，每个服务都需要处理。<br>• 统一逻辑无法收敛，比如安全认证、限流。我们之前提到了我们工作模型，要内聚模式配合。</p>
<p>需要一个 Backend for frontend 数据聚合</p>
<p>在服务内进行大量的 dataset join，按照业务场景来设计粗粒度的 API，给后续服务的演进带来的很多优势：</p>
<p>轻量交互：协议精简、聚合。<br>差异服务：数据裁剪以及聚合、针对终端定制化 API。<br>动态升级：原有系统兼容升级，更新服务而非协议。<br>沟通效率提升，协作模式演进为移动业务 + 网关小组。<br>BFF 可以认为是一种适配服务，将后端的微服务进行适配 (主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的 API，方便无线设备接入访问后端服务。</p>
<p>最致命的一个问题是整个 app-interface 属于<br>single point of failure，严重代码缺陷或者流量洪<br>峰可能引发集群宕机。<br>• 单个模块也会导致后续业务集成复杂度高，根据康<br>威法则，单块的无线BFF和多团队之间就出现不匹<br>配问题，团队之间沟通协调成本高，交付效率低下。<br>• 很多跨横切面逻辑，比如安全认证，日志监控，限<br>流熔断等。随着时间的推移，代码变得越来越复杂，<br>技术债越堆越多。</p>
<p>跨横切面(Cross-Cutting Concerns)的功能，需要<br>协调更新框架升级发版(路由、认证、限流、安<br>全)，因此全部上沉，引入了 API Gateway，把业<br>务集成度高的 BFF 层和通用功能服务层 API<br>Gateway 进行了分层处理。<br>在新的架构中，网关承担了重要的角色，它是解耦拆分<br>和后续升级迁移的利器。在网关的配合下，单块 BFF<br>实现了解耦拆分，各业务线团队可以独立开发和交付各<br>自的微服务，研发效率大大提升。另外，把跨横切面逻<br>辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以<br>更加专注业务逻辑交付，实现了架构上的关注分离<br>(Separation of Concerns)。<br>我们业务流量实际为：<br>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice，在<br>FE Web业务中，BFF 可以是 nodejs 来做服务端渲染<br>(SSR，Server-Side Rendering)，注意这里忽略了上<br>游的 CDN、4/7层负载均衡(ELB)。</p>
<h2 id="Mircoservice-划分"><a href="#Mircoservice-划分" class="headerlink" title="Mircoservice 划分"></a>Mircoservice 划分</h2><p>在实际项目中通常会采用两种不同的<br>方式划分服务边界，即通过业务职能(Business<br>Capability)或是 DDD 的限界上下文(Bounded<br>Context)。<br>• Business Capability<br>由公司内部不同部门提供的职能。例如客户服务部<br>门提供客户服务的职能，财务部门提供财务相关的职能。<br>• Bounded Context<br>限界上下文是 DDD 中用来划分不同业务边界的元素，<br>这里业务边界的含义是“解决不同业务问题”的问题域<br>和对应的解决方案域，为了解决某种类型的业务问题，<br>贴近领域知识，也就是业务。<br>这本质上也促进了组织结构的演进：Service per team</p>
<p>CQRS（查询职责分离），将应用程序分为两部分：命令端和查询端。</p>
<p>命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。<br>查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新</p>
<p>在稿件服务演进过程中，我们发现围绕着创作稿件、审<br>核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿<br>件本身的状态也有非常多种，但是最终前台用户只关注<br>稿件能否查看，我们依赖稿件数据库 binlog 以及订阅<br>binlog 的中间件 canal，将我们的稿件结果发布到消息<br>队列 kafka 中，最终消费数据独立组建一个稿件查阅结<br>果数据库，并对外提供一个独立查询服务，来拆分复杂<br>架构和业务。<br>我们架构也从 Polling publisher -&gt; Transaction log<br>tailing 进行了演进(Pull vs Push)。</p>
<h2 id="Mircoservice-安全"><a href="#Mircoservice-安全" class="headerlink" title="Mircoservice 安全"></a>Mircoservice 安全</h2><p>对于外网的请求来说，我们通常在 API Gateway 进行统一的认证拦截，一旦认证成功，我们会使用 JWT 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 校验 Token 完整性后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息 (UserID) 请求服务。</p>
<p>• API Gateway -&gt; BFF -&gt; Service<br>Biz Auth -&gt; JWT -&gt; Request Args<br>对于服务内部，一般要区分身份认证和授权。</p>
<ul>
<li>Full Trust</li>
<li>Half Trust</li>
<li>Zero Trust</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2021/09/03/wei-fu-wu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/03/wei-fu-wu/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-02 16:21:41" itemprop="dateCreated datePublished" datetime="2021-09-02T16:21:41Z">2021-09-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-09 00:57:35" itemprop="dateModified" datetime="2021-09-09T00:57:35Z">2021-09-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>微服务将单体应用系统拆分成多个分而治之的小应用,降低系统整体崩溃的风险性;同时也可根据这些小应用的不同需求调整实体机的性能</p>
<p>微服务主要缺点是将系统复杂化,但对于本身就复杂的系统,微服务受益会很高  </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/03/wei-fu-wu/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
