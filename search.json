[{"title":"admin的一些优化配置","url":"https://bubbleboy11.github.io/2021/04/03/admin-de-yi-xie-you-hua-pei-zhi/","content":"admin的一些优化配置12# LANGUAGE_CODE = 'en-us'LANGUAGE_CODE = # LANGUAGE_CODE = 'en-us'LANGUAGE_CODE = 'zh-hans'\n\n• 查询速度优化\n\n减少每页的数据大小，比如分页；    • 减少SQL查询的次数，外键关联等一次性查询。list_per_page 分页大小，默认每页100条list_select_related 外键关联查询优化paginator 分页器    • 字段格式化字段优化场景：将用户名、手机号等脱敏处理在定义的admin类中添加自定义方法，然后再将名称传入list_display。同时还能指定方法\nfrom django.contrib import adminfrom django.contrib.auth.admin import UserAdminfrom accounts.models import User\nadmin.site.register(User,UserAdmin)class UserAdmin(UserAdmin):“”” 用户管理 “””list_display = (‘username’,’nickname’,’integral’)\ndef format_username(self,obj):“”” 用户名脱敏处理 “””format_username = obj.username[0:2] + ‘***’return format_username\nformat_username.short_description = ‘用户名’search_list = (‘username’,’nickname’)\n•list_filter 快捷搜索字段• 实现用户名、昵称搜索搜索Python1    search_fields = (‘username’,’nickname’)aaps.py添加verbose_name可修改在管理系统的显示名称, 模型也可以通过verbose_name修改显示的名称\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"Django后台管理","url":"https://bubbleboy11.github.io/2021/04/02/django-hou-tai-guan-li/","content":"Django后台管理\n框架自动生成的后台管理界面\n从ORM模型中读取元数据，简单配置即可使用\n功能强大，可用于对数据库中数据的管理\ndjango admin 用来对数据的维护\n\n实现步骤\n\n第一步：框架部分的配置\n第二步：ORM模型中的配置\n\n \n\n框架配置\n步骤1：INSTALLED_APPS配置应用及依赖trip\\settings.py\n12345678910INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    # 用户账户    INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    # 用户账户    'accounts.apps.AccountsConfig',]\n\n步骤2：模板选项配置TEMPLATES中的OPTIONS添加上下文处理器：context_processorstrip\\settings.py\n123456789101112TEMPLATES = [    {        'OPTIONS': {            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                TEMPLATES = [    {        'OPTIONS': {            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                'django.contrib.messages.context_processors.messages',            ],        },    },]\n\n\n\n\n上下文处理器context_processor.py文件处于模块中，但是该上下文处理器能够在整个项目中起作用，即数据会传入所有模板中\n\n渲染上下文Context\n请求上下文RequestContext\n连接views(视图)和templates(模板)\n场景举例:在每个页面都显示IP地址,多个页面页脚展示购物车信息\n\n上下文处理器vs中间件相同点：都用来做全局处理不同点上下文处理器:为模板添加全局变量中间件:过滤请求,拦截请求\n\n步骤3：添加中间件MIDDLEWAREtrip\\settings.py\n1234MIDDLEWARE = [    'django.contrib.auth.middleware.AuthenticationMiddleware',    MIDDLEWARE = [    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',]\n\n步骤4：配置URLtrip\\settings.py\n\n\n12345from django.contrib import adminfrom django.urls import pathurlpatterns = [    path(from django.contrib import adminfrom django.urls import pathurlpatterns = [    path('admin/', admin.site.urls)]\n\n访问后台管理：http://127.0.0.1:8000/admin/\n将模型添加到后台管理\nORM模型配置到后台管理\n步骤一：\n方式一 通过装饰器注册后台管理：在模块中新建accounts\\admin.py文件其中model的Product和Profile来自ORM模型\n\n\n\n1234567891011121314from django.contrib import adminfrom mall.models import Product@admin.register(Product)class ProductAdmin(admin.ModelAdmin):    \"\"\" 商品信息 \"\"\"    # 列表中显示的字段    list_display = ['name','types','price','status','img','is_valid','reorder','created_at','online_time','offline_time']    # 修改分页的大小    list_per_page = 7    # 优化搜索，可以选择商品的类型状态    list_filer = ('types','status',)    # 按名称进行搜索    search_fields = (from django.contrib import adminfrom mall.models import Product@admin.register(Product)class ProductAdmin(admin.ModelAdmin):    \"\"\" 商品信息 \"\"\"    # 列表中显示的字段    list_display = ['name','types','price','status','img','is_valid','reorder','created_at','online_time','offline_time']    # 修改分页的大小    list_per_page = 7    # 优化搜索，可以选择商品的类型状态    list_filer = ('types','status',)    # 按名称进行搜索    search_fields = ('name',)\n\n1234567891011121314from django.contrib import adminfrom mall.models import Profile@admin.register(Profile)class UserProfileAdmin(admin.ModelAdmin):    \"\"\" 用户详细信息 \"\"\"    # 列表中显示的字段    list_display = ['user','phone_no','sex','created_at']    # 修改分页的大小    list_per_page = 7    # 优化搜索，可以选择商品的类型状态    list_filer = ('sex',)    # 按名称进行搜索    search_fields = ('username', from django.contrib import adminfrom mall.models import Profile@admin.register(Profile)class UserProfileAdmin(admin.ModelAdmin):    \"\"\" 用户详细信息 \"\"\"    # 列表中显示的字段    list_display = ['user','phone_no','sex','created_at']    # 修改分页的大小    list_per_page = 7    # 优化搜索，可以选择商品的类型状态    list_filer = ('sex',)    # 按名称进行搜索    search_fields = ('username', 'user_nickname')\n\n\n\n\n方式二注册后台管理：\n1admin.site.register(Product,ProductAdmin)\n\n步骤二：封装模型自定义的管理后台功能和选项  • 每个模型创建一个ModelAdmin的子类\n\nModelAdmin配置选项\nfiled/exclude——需要编辑/不需要编辑的字段列表\nform——自定义表单\nlist_display——在列表中显示的字段\nordering——指定排序规则\n\n\n\n\n步骤3：INSTALLED_APPS配置应用及依赖需要管理的ORM模型自动搜索添加至后台管理trip\\settings.py\n12345INSTALLED_APPS = [    # 用户账户    'accounts.apps.AccountsConfig',    INSTALLED_APPS = [    # 用户账户    'accounts.apps.AccountsConfig',    'system.apps.SystemConfig',]\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网删除订单接口联调","url":"https://bubbleboy11.github.io/2021/04/02/lu-you-wang-shan-chu-ding-dan-jie-kou-lian-diao/","content":"删除订单接口联调实现步骤\n\n第一步，阅读接口文档在我的订单页面判断订单状态是否是已完成和已取消，有删除订单按钮，点击后弹框确认是否删除，点击确认删除把订单在数据库中做逻辑删除，通过某一字段标记它是否已经删除，在前端通过这个字段进行控制该订单不会再我的订单页面列表显示，\n第二步，配置接口地址\n\n12345678910111213141516&lt;!-- 我的订单列表页面 --&gt;&lt;div class=\"page-order-list\"&gt;  &lt;!-- 订单记录 --&gt;  &lt;div class=\"order-list\"&gt;    &lt;div class=\"order-item\" v-for=\"item in dataList\"      :key=\"item.sn\"      v-show=\"item.sn\"&gt;      &lt;div class=\"order-footer\"&gt;        &lt;van-button round size=\"small\" type=\"warning\"          v-if=\"item.status == constants.ORDER_STATUS_DONE || item.status == constants.ORDER_STATUS_CANCEL\"          @click=\"deleteOrder(item)\"&gt;删除订单&lt;/van-button&gt;        &lt;van-button round size=\"small\" type=\"info\"&gt;订单详情&lt;/van-button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/&lt;!-- 我的订单列表页面 --&gt;&lt;div class=\"page-order-list\"&gt;  &lt;!-- 订单记录 --&gt;  &lt;div class=\"order-list\"&gt;    &lt;div class=\"order-item\" v-for=\"item in dataList\"      :key=\"item.sn\"      v-show=\"item.sn\"&gt;      &lt;div class=\"order-footer\"&gt;        &lt;van-button round size=\"small\" type=\"warning\"          v-if=\"item.status == constants.ORDER_STATUS_DONE || item.status == constants.ORDER_STATUS_CANCEL\"          @click=\"deleteOrder(item)\"&gt;删除订单&lt;/van-button&gt;        &lt;van-button round size=\"small\" type=\"info\"&gt;订单详情&lt;/van-button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div>\n\n12345678910111213141516171819202122232425262728293031323334353637383940import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      status: 0,      // 订单列表      dataList: [],      constants    }  },  methods: {    /**     * 删除订单     */    deleteOrder (item) {      // 弹框确认      this.$dialog.alert({        title: '温馨提示',        message: '删除订单将无法恢复，确认删除订单？'      }).then(() =&gt; {        // 调用接口 sn替换为传递过来item下面的sn        const url = OrderApis.orderDetailUrl.replace('#{sn}', item.sn)        ajax.delete(url).then(res =&gt; {          // 告诉用户已经删除成功了          // 隐藏界面上的显示          if (res.status === 201) {            this.$notify({              type: 'success',              message: '删除成功'            })            // 清空sn，该订单在已完成和已取消页面隐藏，display:none            item.sn = import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      status: 0,      // 订单列表      dataList: [],      constants    }  },  methods: {    /**     * 删除订单     */    deleteOrder (item) {      // 弹框确认      this.$dialog.alert({        title: '温馨提示',        message: '删除订单将无法恢复，确认删除订单？'      }).then(() =&gt; {        // 调用接口 sn替换为传递过来item下面的sn        const url = OrderApis.orderDetailUrl.replace('#{sn}', item.sn)        ajax.delete(url).then(res =&gt; {          // 告诉用户已经删除成功了          // 隐藏界面上的显示          if (res.status === 201) {            this.$notify({              type: 'success',              message: '删除成功'            })            // 清空sn，该订单在已完成和已取消页面隐藏，display:none            item.sn = ''          }        })      })    }  }}\n\n\n第三步，使用axios获取数据\n第四步，将数据设置到模型层\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网取消订单接口联调","url":"https://bubbleboy11.github.io/2021/04/02/lu-you-wang-qu-xiao-ding-dan-jie-kou-lian-diao/","content":"取消订单接口联调实现步骤\n第一步，完成页面间的跳转从我的订单列表页面跳转到待支付的页面，在我的订单页面判断订单状态是否是待支付状态有去支付按钮，，点击后弹框跳转时候绑定事件，\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344                                    <van-button round size=\"small\" type=\"warning\"            v-if=\"item.status == constants.ORDER_STATUS_PAY\"            @click=\"goPay(item)\">去支付                    export default {  data () {    return {      status: 0,      // 订单列表      dataList: [],      constants    }  },  methods: {    /**     * 跳转到支付页面     */    goPay (item) {      this.$router.push({name: 'OrderPay', params: {sn: item.sn}})    },    /**     * tab点击之后，重新去获取数据     */    tabChange (name, value) {      console.log(name, value)      this.$router.push({name: 'OrderList', params: { status: name }})    },}\n\n\n第二步，配置接口地址及请求参数右上角点击取消订单按钮，点击确认把订单在数据库中做，该订单不会再我的订单页面显示，\n\n第三步，处理数据返回，给用户一个提示，取消订单成功状态码是201则已经取消成功，是201则已经被取消一次了，不能重复取消且有弹框src\\views\\order\\Pay.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354          <van-nav-bar      right-text=\"取消订单\"      @click-right=\"onCancelOrder\"    />import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      // 订单的流水号      sn: '',      // 订单的信息      orderDetail: {}    }  },  methods: {    /**     * 取消订单     */    onCancelOrder () {      this.$dialog.confirm({        title: '温馨提示',        message: '确认取消该订单？'      }).then(() => {        const url = OrderApis.orderDetailUrl.replace('#{sn}', this.sn)        // put方式调用接口        ajax.put(url).then(res => {          console.log(res)          // 给用户提示          if (res.status === 201) {            this.$notify({              type: 'success',              message: '订单已成功取消'            })          } else if (res.status === 200) {            this.$notify({              type: 'warning',              message: '订单已被取消，请勿重复操作'            })          }          // 回到上一个我的订单页面          this.$router.go(-1)        })      })    }  }}\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网订单详细信息页面的展示","url":"https://bubbleboy11.github.io/2021/04/02/lu-you-wang-ding-dan-xiang-xi-xin-xi-ye-mian-de-zhan-shi/","content":"我的订单中的订单详细信息页面的展示。1、 点击全部订单可以跳转到我的订单页面，包括所有的订单，点击订单详情可以跳转到订单详情页，该页面中包括导航条(包括返回按钮及当前订单的状态)、订单信息(包括订单号和下单时间)、订单明细(包括下单的商品快照，会显示商品图片、商品标题、数量、价格及备注信息)、订单总计(总共几件商品及价格合计)、对应的按钮\n实现订单详细信息接口 实现订单详细信息页面 完成订单详细信息页面展示 实现页面间的跳转、订单删除功能\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网我的订单列表接口联调","url":"https://bubbleboy11.github.io/2021/04/02/lu-you-wang-wo-de-ding-dan-lie-biao-jie-kou-lian-diao/","content":"我的订单列表接口联调实现步骤\n第一步，完成页面间的跳转src\\views\\Mine.vue\n1234567891011121314151617181920212223242526272829303132333435363738                          <router-link          :to=\"{name: 'OrderList', params: {status: constants.ORDER_STATUS_ALL}}\">                    全部订单                            <router-link          :to=\"{name: 'OrderList', params: {status: constants.ORDER_STATUS_PAY}}\">                    待支付                            <router-link          :to=\"{name: 'OrderList', params: {status: constants.ORDER_STATUS_DONE}}\">                    已完成                            <router-link          :to=\"{name: 'OrderList', params: {status: constants.ORDER_STATUS_CANCEL}}\">                    已取消                            \n\n第二步，配置接口地址及请求参数\n12345678const OrderApis = {  // 订单列表  orderListUrl: apiHost + '/order/order/list/'}const OrderApis = {  // 订单列表  orderListUrl: apiHost + '/order/order/list/'}export {  OrderApis}\n\n第三步，处理通过ajax拿到数据返回，填充到页面\n\n\nsrc\\views\\order\\List.vue\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364                  <van-tab        v-for=\"(value, key, index) in constants.ORDER_STATUS\"        :title=\"value\"        :name=\"key\"        :key=\"index\">                                    订单号：{{ item.sn }}          {{ constants.ORDER_STATUS[item.status] }}                                                                      {{ item.item_first.flash_name }}            {{ item.item_first.remark }}                                    总共{{ item.buy_count }}件商品 合计 ￥{{ item.buy_amount }}          删除订单          订单详情                    import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      status: 0,      // 订单列表      dataList: [],      constants    }  },  methods: {    /**     * 加载订单列表     */    getDataList () {      ajax.get(OrderApis.orderListUrl, {        params: {          status: this.status        }      }).then(({ data }) => {        this.dataList = data.objects      })    }}\n\n\n\n第四步，用watch监听路由的变化，从个人中心点击订单列表的数据处理，点击全部、待支付、已完成、已取消都能跳转每一次路由变化之后，重新调用调用接口，把数据渲染出来src\\views\\order\\List.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394                  <van-tab        v-for=\"(value, key, index) in constants.ORDER_STATUS\"        :title=\"value\"        :name=\"key\"        :key=\"index\">                                    订单号：{{ item.sn }}          {{ constants.ORDER_STATUS[item.status] }}                                                                      {{ item.item_first.flash_name }}            {{ item.item_first.remark }}                                    总共{{ item.buy_count }}件商品 合计 ￥{{ item.buy_amount }}          删除订单          订单详情                    import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      status: 0,      // 订单列表      dataList: [],      constants    }  },  watch: {    $route () {      this.loadData()    }  },  methods: {    /**     * tab点击之后，重新去获取数据     */    tabChange (name, value) {      console.log(name, value)      this.$router.push({name: 'OrderList', params: { status: name }})    },    /**     * 加载页面的数据     */    loadData () {      // 订单状态      this.status = this.$route.params.status      // 清空数据      this.dataList = []      // 加载数据列表      this.getDataList()    },    /**     * 加载订单列表     */    getDataList () {      ajax.get(OrderApis.orderListUrl, {        params: {          status: this.status        }      }).then(({ data }) => {        this.dataList = data.objects      })    },    goBack () {      this.$router.go(-1)    }  },  mounted () {    this.loadData()  }}\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网门票支付接口联调","url":"https://bubbleboy11.github.io/2021/04/01/lu-you-wang-men-piao-zhi-fu-jie-kou-lian-diao/","content":"门票支付接口联调实现步骤\n第一步，阅读接口文档\n第二步，配置接口地址在填写订单提交之后跳转订单支付页面，会把流水id从url传递到订单支付页面，显示订单下面的门票的信息，通过ajax的http的get请求获取订单的详细信息，通过ajax的post请求点击立即支付，跳转到我的订单列表src\\utils\\apis.js1234567const SightApis = {  // 订单详情、订单支付、订单删除、订单取消  orderDetailUrl: apiHost + '/order/order/detail/#{sn}/',}const SightApis = {  // 订单详情、订单支付、订单删除、订单取消  orderDetailUrl: apiHost + '/order/order/detail/#{sn}/',}export {  OrderApis}\n\n\n\nsrc\\views\\order\\Pay.vue\n1234567891011121314151617181920&lt;!-- 订单确认及支付 --&gt;&lt;div class=\"page-order-pay\"&gt;  &lt;!-- 订单号 --&gt;  &lt;van-cell title=\"订单号\" :value=\"sn\" class=\"order-mum\" /&gt;  &lt;!-- 描述信息 --&gt;  &lt;div class=\"order-info\" v-for=\"item in orderDetail.items\"    :key=\"item.pk\"&gt;    &lt;div class=\"left\"&gt;      &lt;h3&gt;{{ item.flash_name }}&lt;/h3&gt;      &lt;div&gt;&lt;van-icon name=\"clock-o\" /&gt; {{ item.remark }}&lt;/div&gt;      &lt;!-- &lt;div class=\"tips\"&gt;短信接收&lt;/div&gt; --&gt;    &lt;/div&gt;    &lt;div class=\"right\"&gt;      &lt;van-icon name=\"arrow\" /&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- //描述信息 --&gt;  &lt;!-- 提交表单 --&gt;  &lt;van-submit-bar :price=\"orderDetail.buy_amount * 100\" button-text=\"立即支付\" @submit=\"onSubmit\" /&gt;&lt;/&lt;!-- 订单确认及支付 --&gt;&lt;div class=\"page-order-pay\"&gt;  &lt;!-- 订单号 --&gt;  &lt;van-cell title=\"订单号\" :value=\"sn\" class=\"order-mum\" /&gt;  &lt;!-- 描述信息 --&gt;  &lt;div class=\"order-info\" v-for=\"item in orderDetail.items\"    :key=\"item.pk\"&gt;    &lt;div class=\"left\"&gt;      &lt;h3&gt;{{ item.flash_name }}&lt;/h3&gt;      &lt;div&gt;&lt;van-icon name=\"clock-o\" /&gt; {{ item.remark }}&lt;/div&gt;      &lt;!-- &lt;div class=\"tips\"&gt;短信接收&lt;/div&gt; --&gt;    &lt;/div&gt;    &lt;div class=\"right\"&gt;      &lt;van-icon name=\"arrow\" /&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- //描述信息 --&gt;  &lt;!-- 提交表单 --&gt;  &lt;van-submit-bar :price=\"orderDetail.buy_amount * 100\" button-text=\"立即支付\" @submit=\"onSubmit\" /&gt;&lt;/div>\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      // 订单的流水号      sn: '',      // 订单的信息      orderDetail: {}    }  },  methods: {    /**     * 获取订单的详细信息     */    getOrderDetail () {      // SightApis.ticketDetailUrl的#{sn}替换为通过created函数里面从url中动态传递过来的sn      const url = OrderApis.orderDetailUrl.replace('#{sn}', this.sn)      ajax.get(url).then(({ data }) =&gt; {        this.orderDetail = data      })    },    /**     * 确认支付     */    onSubmit () {      this.$dialog.confirm({        title: '温馨提示',        message: `确认支付${this.orderDetail.buy_amount}吗？`      }).then(() =&gt; {        const url = OrderApis.orderDetailUrl.replace('#{sn}', this.sn)        // 调用支付接口        ajax.post(url).then(() =&gt; {          // 提示语          this.$notify({            type: 'success',            message: '支付成功, 已为您跳转到订单列表'          })          // 跳转到我的订单列表          this.$router.replace({ name: 'OrderList', params: { status: constants.ORDER_STATUS_ALL}})        })      })    },    /**     * 后退     */    goBack () {      this.$dialog.confirm({        title: '温馨提示',        message: '您还没有支付，确认放弃支付吗？'      }).then(() =&gt; {        this.$router.go(-1)        // on confirm      })    },    /**     * 取消订单     */    onCancelOrder () {      this.$dialog.confirm({        title: '温馨提示',        message: '确认取消该订单？'      }).then(() =&gt; {        // TODO 调用接口on confirm        this.$router.go(-1)      })    }  },  created () {    // 组件被挂载或创建的时候获取订单流水号    this.sn = this.$route.params.sn    // 获取订单信息    import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import * as constants from '@/utils/constants'export default {  data () {    return {      // 订单的流水号      sn: '',      // 订单的信息      orderDetail: {}    }  },  methods: {    /**     * 获取订单的详细信息     */    getOrderDetail () {      // SightApis.ticketDetailUrl的#{sn}替换为通过created函数里面从url中动态传递过来的sn      const url = OrderApis.orderDetailUrl.replace('#{sn}', this.sn)      ajax.get(url).then(({ data }) =&gt; {        this.orderDetail = data      })    },    /**     * 确认支付     */    onSubmit () {      this.$dialog.confirm({        title: '温馨提示',        message: `确认支付${this.orderDetail.buy_amount}吗？`      }).then(() =&gt; {        const url = OrderApis.orderDetailUrl.replace('#{sn}', this.sn)        // 调用支付接口        ajax.post(url).then(() =&gt; {          // 提示语          this.$notify({            type: 'success',            message: '支付成功, 已为您跳转到订单列表'          })          // 跳转到我的订单列表          this.$router.replace({ name: 'OrderList', params: { status: constants.ORDER_STATUS_ALL}})        })      })    },    /**     * 后退     */    goBack () {      this.$dialog.confirm({        title: '温馨提示',        message: '您还没有支付，确认放弃支付吗？'      }).then(() =&gt; {        this.$router.go(-1)        // on confirm      })    },    /**     * 取消订单     */    onCancelOrder () {      this.$dialog.confirm({        title: '温馨提示',        message: '确认取消该订单？'      }).then(() =&gt; {        // TODO 调用接口on confirm        this.$router.go(-1)      })    }  },  created () {    // 组件被挂载或创建的时候获取订单流水号    this.sn = this.$route.params.sn    // 获取订单信息    this.getOrderDetail()  }}\n\n第三步，使用axios获取数据\n第四步，将数据设置到模型层\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"门票详细信息接口联调","url":"https://bubbleboy11.github.io/2021/04/01/lu-you-wang-men-piao-xiang-xi-xin-xi-jie-kou-lian-diao/","content":"门票详细信息接口联调实现步骤\n第一步，阅读接口文档\n第二步，配置接口地址src\\utils\\apis.js12345678const SightApis = {  // 门票详情  ticketDetailUrl: apiHost + '/sight/ticket/detail/#{id}/'}const SightApis = {  // 门票详情  ticketDetailUrl: apiHost + '/sight/ticket/detail/#{id}/'}export {  SightApis}\n\n\n\nsrc\\components\\sight\\TicketTips.vue\n123456789101112131415161718192021222324252627282930313233343536373839        预订须知          有效期      {{ ticketDetail.expire_date }} 日内有效              退改政策      {{ ticketDetail.return_policy }}              发票      我司提供发票      不提供发票              预订须知                    暂无                    入园方式      {{ ticketDetail.entry_way }}              备注信息      {{ ticketDetail.remark }}      export default {  props: ['ticketDetail']}\n\nsrc\\views\\order\\Submit.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167            <van-nav-bar title=\"填写订单\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"/>                      {{ ticketDetail.name }}        {{ ticketDetail.desc }}                              明日可定                                条件退                                      ￥{{ ticketDetail.sell_price }}/张        <van-button plain hairline type=\"info\"          size=\"mini\"          @click=\"showPopup=true\">预订须知        <van-popup          v-model=\"showPopup\"          closeable          position=\"bottom\"          :style=\"{ height: '80%' }\"        >                                                      <van-cell title=\"选择出行日期\"          :value=\"form.play_date\"          @click=\"showCalendar = true\" />                                                                  <van-field          v-model=\"form.to_user\"          type=\"text\"          label=\"收件人\"          placeholder=\"输入收件人\"          :rules=\"[{ required: true, message: '请输入收件人' }]\"        />        <van-field          v-model=\"form.to_phone\"          type=\"text\"          label=\"手机号码\"          placeholder=\"输入手机号码\"          :rules=\"[{ required: true, message: '请输入手机号码' }]\"        />                      import { OrderApis, SightApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import { mapState } from 'vuex'import TicketTips from '@/components/sight/TicketTips'export default {  components: {    TicketTips  },  data () {    return {      // 门票ID      id: '',      // 预订须知弹框显示      showPopup: false,      // 日期选择弹框      showCalendar: false,      // 门票的详细信息      ticketDetail: {},      form: {        play_date: '',        buy_count: 1,        to_user: '',        to_phone: ''      }    }  },  computed: {    /**     * 计算总价     */    totalPrice () {      return this.ticketDetail.sell_price * this.form.buy_count * 100    },    /**     * 从vuex读取手机号码     */    ...mapState({      phoneNum: state => state.user.username,      nickname: state => state.user.nickname    })  },  methods: {    /**     * 门票详情     */    getTicketDetail () {      // SightApis.ticketDetailUrl的#{id}替换为通过created函数里面从url中动态传递过来的id      const url = SightApis.ticketDetailUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data }) => {        this.ticketDetail = data      })    },    onSubmit () {      console.log('提交表单')      // ajax接口的调用      ajax.post(OrderApis.ticketSubmitUrl, {        ticket_id: this.id, // 通过url传递动态参数        ...this.form      }).then(({ data }) => {        // 提示用户        this.$notify({          type: 'success',          message: '提交成功，请支付'        })        // 跳转到待支付的页面，会把流水id从url传递到支付页面，防止点击后退的时候再去重复提交一个相同的订单        this.$router.replace({ name: 'OrderPay', params: { sn: data.sn } })      })    },    formatDate (date) {      return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`    },    /**     * 选择日期     */    onConfirm (date) {      // 隐藏日历弹框      this.showCalendar = false      // 保存数据      this.form.play_date = this.formatDate(date)    },    goBack () {      this.$router.go(-1)    }  },  created () {    // 门票ID    this.id = this.$route.params.id    this.form.to_user = this.nickname || ''    this.form.to_phone = this.phoneNum || ''    // 获取门票信息    this.getTicketDetail()  }}\n\n\n第三步，使用axios获取数据\n第四步，将数据设置到模型层\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网","url":"https://bubbleboy11.github.io/2020/08/21/3/","content":"\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"CSRF","url":"https://bubbleboy11.github.io/2020/08/21/csrf/","content":"CSRF：Cross-site request forgery 跨站请求伪造利用网站对已认证的权限去执行未授权的命令的一种恶意攻击攻击者它们会利用登录过的用户在浏览器中的认证信息，欺骗用户的浏览器去访问以你的身份在一个自己曾经认证过的网站上模拟发送请求，，然后做了一些没有经过你授权的一些行为，比发邮件，发消息，甚至财产操作如转账和购买商品。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。\n这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的或者批准发送的\n\n用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。\n\nCsrf 是利用网站本身的漏洞，比如一个网站a用cookie就可以登录，不需要用户重新输入用户名和密码。那么我们就可以利用csrf攻击，携带cookie去登录网站a，进行钱的转账Xss是在网站a里面注入恶意的脚本，我们一访问这个网站a，那么就执行恶意的代码\nCsrf是需要登录的，xss是不需要进行登录的。\n2.CSRF产生的条件要完成一个 CSRF攻击，需要具备两个条件受害者已经登录到目标网站并且没有退出( 保持登录状态 ）受害者访问了攻击者发布的链接或者表单按钮二者必须缺一不可\n3.如何防范 CSRF？使用CSRF保护（针对同步提交，比如注册页面）    在使用Get请求的时候非常容易伪造链接，所以尽量不要在GET请求里有任务数据修改操作。目前所有Python主流的web 框架所采用的的方式令牌同步。\n令牌同步(Synchronizer token pattern , 简称STP)：在用户请求的表单中嵌入一个隐藏的csrf_token，服务端验证其是否与cookie中的一致(基于同源策略其他网站是无法获取cookie中的csrf_token)。黑客是拿不到你cookie中的 csrftoken值的，前提是网站本身没有 xss漏洞。\n如果是 js 提交需要先从cookie获取csrf_token作为 X-CSRFToken请求头提交    1. 在MIDDLEWARE设置中激活CSRF中间件django.middleware.csrf.CsrfViewMiddleware    2. 元素中使用csrf_token标签（POST请求)Html    1    &lt;form class=\"xxx\" method=\"post\" action=\".\"&gt;    2    {% csrf_token %}    3. 选择合适的渲染方式视图函数中，确保使用RequestContext来渲染（或者render()函数）\n其他：检测来源HTTP Referer(容易被伪造)；验证码方式(安全但是繁琐)\n开启使用CSRF保护之后，浏览器源码会生成一个隐藏的表单域。这个表单中自动生成了唯一的value值（每一次request都会有不同的value值），提交表单时候会将其一并提交，因为value值唯一，就不会有重复提交的情况。\n图解：左边是用户，右边是需要登陆的网站。一个用户A通过自己的身份验证，去登陆网站SNS，网站会返回一个cookie值Cookie: sid=1234567890用来标识这个用户。然后中间一个攻击者给你发一个链接或者给你一个图片你可能会对它进行一个点击，比如发给你一个图&lt;img src=\"http://example.com/msg?q=你好\"&gt;误导你来去点击，这个链接是发送评论的请求地址，如果你点击这个地址它就会以你的名义来发送这个你好。这个时候假如你误点这个图片就会触发这个链接的操作，然后你就会携带你的Cookie去请求SNS网站。这个时候你就会发现你实际上并没有想去发送你好这个评论。但是你通过攻击者留下的链接陷阱点进去之后然后你就误发这个评论。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["django","剑指offer"]},{"title":"CPython GIL","url":"https://bubbleboy11.github.io/2020/08/21/cpython-gil/","content":"GIL Global Interpreter Lock (全局解释器锁) ，CPython GIL 就是 Cpython解释器的全局解释锁。\n\nCpython解释器的内存管理并不是线程安全的（如果有多个线程话它可能会同时去修改同一个对象，这样可能会出现一些问题）\n保护多线程情况下对Python对象的访问\nCpython使用简单的锁机制避免多线程同时执行字节码\n\nGIL影响\n限制了程序的多核执行，单核CPU系统中，不存在真正的并发\n\n同一个时间只能有一个线程执行字节码，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。\nCPU密集程序难以利用多核优势\n\n\nIO期间会释放GIL，对IO密集程序影响不大解释图：这个图里面有三个线程Thread1，Thread2，Thread3，在处理网络请求的过程中，虽然一个时间只能执行一个线程，但是在等待网络请求的时候来释放全局解释锁切换到不同线程Run运行，这就是对IO密集的程序会小一些。\n\n一般程序分为CPU密集还有IO密集，\n\nCPU密集：把大量时间花在计算上面，磁盘硬盘读写\nIO密集：把大量时间花费在了传输上面。\n\n\n\n如何规避GIL影响首先区分CPU和IO密集程序\nCPU密集可以使用多进程+进程池来充分利用多核\nIO密集使用 多线程 / 协程\nCPU密集时候还可以用cython编写一些扩展来转换成cython代码。\n（cython不是Cpython解释器它是一个用来把python程序转换成C代码一个扩展）\n\nGIL实现  Cpython里面才会有GIL，其他的实现不一定会有\n\n解释图：每隔一段时间我们尝试去释放当前线程的锁，然后让其它线程尝试去获取锁并且去执行\nGIL执行顺序\n设置GIL\n切换进一个线程去运行\n执行下面操作之一：\n\n\n指定数量的字节码指令\n线程主动让出控制权（可以调用time.sleep(0)来完成）\n\n\n把线程设置回睡眠状态（切换出线程）\n解锁GIL\n重复上述步骤\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import timefrom threading import Threadimport sysimport threading# 单线程版def CountDown(n):    while n &gt; 0:        n -= 1if __name__ == \"__main__\":    n = 3000000    start_time = time.perf_counter()    CountDown(n)    end_time = time.perf_counter()    print(\"n = {}，单线程版耗时{}\".format(n, end_time-start_time))    # 多线程版    start_time = time.perf_counter()    t1 = Thread(target = CountDown, args = [n//2])    t2 = Thread(target = CountDown, args = [n//2])    t1.start()    t2.start()    t1.join()    t2.join()    end_time = time.perf_counter()    print(\"n = {}，多线程版耗时{}\".format(n, end_time-start_time))    # 对象引用计数    for k in range(100):        a = []        b = a        print(sys.getrefcount(a))        # 线程安全        n = 0        def foo():            global n            n += 1        threads = []        for i in range(100):            t = threading.Thread(target = foo)            threads.append(t)        for t in threads:            t.start()        for t import timefrom threading import Threadimport sysimport threading# 单线程版def CountDown(n):    while n &gt; 0:        n -= 1if __name__ == \"__main__\":    n = 3000000    start_time = time.perf_counter()    CountDown(n)    end_time = time.perf_counter()    print(\"n = {}，单线程版耗时{}\".format(n, end_time-start_time))    # 多线程版    start_time = time.perf_counter()    t1 = Thread(target = CountDown, args = [n//2])    t2 = Thread(target = CountDown, args = [n//2])    t1.start()    t2.start()    t1.join()    t2.join()    end_time = time.perf_counter()    print(\"n = {}，多线程版耗时{}\".format(n, end_time-start_time))    # 对象引用计数    for k in range(100):        a = []        b = a        print(sys.getrefcount(a))        # 线程安全        n = 0        def foo():            global n            n += 1        threads = []        for i in range(100):            t = threading.Thread(target = foo)            threads.append(t)        for t in threads:            t.start()        for t in threads:            t.join()        print(n)\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"扩展Django中的用户模型","url":"https://bubbleboy11.github.io/2020/08/21/django-zhong-kuo-zhan-yong-hu-mo-xing/","content":"扩展Django中的用户模型是对ORM抽象模型的应用\n对用户进行扩展\n思考如下场景如何实现\n\nDjango内置的用户模型满足不了需求怎么办？\n要用户模型添加头像字段怎么办？\n\n\n两种方式解决用户问题\n\n方式1：使用OneToOneField对用户进行扩展\n\n方式2：替换现有的用户模型\n\n步骤一：配置用户模型，告诉django框架setting.py    1AUTH_USER_MODEL = AUTH_USER_MODEL = 'accounts.User'\n步骤二：继承自AbstractUser抽象模型，不会生成对应的数据表\n\naccounts\\models.py\n123456789from django.contrib.auth.models import AbstractUserclass User(from django.contrib.auth.models import AbstractUserclass User(AbstractUser):```        - 步骤三：添加字段，同步模型到数据库```bashpython manage.py checkpython manage.py makemigrationspython manage.py makemigrate\n数据库生成表格account_user和account_user_group和account_user_user_permissions\n\n\n\n创建普通用户 命令行输入命令\n1python manage.py shell  // django控制台\n或者pycharm的Python Console引入用户\n1from accounts.models from accounts.models import User\n使用命令行创建超级管理员\n1>>>python manage.py createsuperuser\n\n获取用户对象\n12345user = User.objects.create_user('john','john@example.com','johnpassword')user = User.objects.create_user('admin','admin@example.com','123456')u = User.objects.get(username='admin')u = User.objects.get(username='13500000000')u.check_password(user = User.objects.create_user('john','john@example.com','johnpassword')user = User.objects.create_user('admin','admin@example.com','123456')u = User.objects.get(username='admin')u = User.objects.get(username='13500000000')u.check_password('123456')\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["django"]},{"title":"Git Bash, CMD配置代理","url":"https://bubbleboy11.github.io/2020/08/21/git-bash-cmd-pei-zhi-dai-li/","content":"方法一 pip linux配置文件换成清华源linux:修改 ~/.pip/pip.conf (没有就创建一个)，文件夹要加“.”，表示是隐藏文件夹)，内容如下：\n1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simple[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn\n\nwindows:直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，在pip 目录下新建文件pip.ini，内容如下\n1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simple[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn\n\n在安装python库，在网络不好的情况会遇到raise ReadTimeoutError(self._pool, None, ‘Read timed out.’)ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.\n\npycharm-setting-proxy-manual-127.0.0.1 prot 7890\n\nping的协议不是https，是ICMP协议，不是TCP/UDP协议不要输入ping www.google.comping,Ping无法走代理。如果你坚持要能Ping通才行，请考虑常规VPN（PPTP/L2PT/IPSec等）。\n设置代理基本思路 : 配置梯子的 ip : port ,梯子会为通过此端口的流量加密混淆 , 将配置端口的命令以某种格式写入到配置文件中实现长久代理\n-vvlink123456789101112131415161718192021222324```curl -I www.google.com``` , 测试连接是否成功的 看状态码是否为 200失败时```curl: (7) Failed to connect to www.google.com port 80: Timed out```直接打开CFW-setting—port点击terminal图标，点击端口是设置端口速度### Windows 下给cmd配置代理```sh# 设置本地代理的端口号 7890 为你实际的端口号set http_proxy=http://127.0.0.1:7890set https_proxy=http://127.0.0.1:7890# 设置代理的用户名和密码（Clash For Windows不需要）# HTTPset http_proxy_user=usernameset http_proxy_pass=password# HTTPSset https_proxy_user=usernameset https_proxy_pass=password# 如果需要恢复本地代理（清除代理）set http_proxy=set https_proxy=\nWindows 下给终端Git Bash，配置代理\n命令行配置\n123# 设置本地代理的端口号 7890 为你实际的端口号export http_proxy=http://127.0.0.1:7890# 设置本地代理的端口号 7890 为你实际的端口号export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890\n\n配置文件\n\n每次新建一个终端会话时,默认让终端去走代理,这样就不需要每次都复制拷贝一下了, 代理程序去智能分流(国内 IP 直连,国外走代理)，避免了连接国内 IP 地址时“绕远”.\n\n\n假设 Git 默认路径为 C:\\Program Files\\Git那么配置文件路径为C:\\Program Files\\Git\\etc\\bash.bashrc\n\n\n\n\n或者 ~/.gitconfig中添加1234[http]    proxy = http://127.0.0.1:7890[https]    proxy = https://127.0.0.1:7890\n\n\n\n\ngit配置ssh协议代理linux目录 : ~/.ssh/config (没有就自己新建一个,注意没有后缀)进入 ssh 配置目录cd ~/.ssh编辑 config 文件,如果没有那就新建一个 config 文件touch configvi config\n12Host github.com  ProxyCommand Host github.com  ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -H 127.0.0.1:7890 %h %p\n\n12345Host *    ProxyCommand nc -X 5 -x localhost:7890 %h %p# 第一行代表所有的 ssh 的主机# 第二行代表让所有的 ssh 的主机在连接的时候,通过你本地的端口为 7890 的 socks5 代理去连接,一般来讲,本地的 socks5 都是由翻墙工具提供,Host *    ProxyCommand nc -X 5 -x localhost:7890 %h %p# 第一行代表所有的 ssh 的主机# 第二行代表让所有的 ssh 的主机在连接的时候,通过你本地的端口为 7890 的 socks5 代理去连接,一般来讲,本地的 socks5 都是由翻墙工具提供,#诸如 Surge  ClashX 或者 Ssr,所以,7891这个端口需要换成对应的服务端口即可\n```-S```为socks5代理123456789以后不管是在用 git 进行 push 和 pull 操作还是 ssh 连接服务器的时候,均可获得畅快体验,### npm配置代理- 命令行配置- 文件配置```~/.npmrc```随便哪一行添加下面的命令```shproxy=http://127.0.0.1:7890https-proxy=http://127.0.0.1:7890\n\n在 vscode 中添加 git bash在 vscode setting.json末尾添加\n123//使用Git Bash的配置\"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\",\"terminal.integrated.shellArgs.windows\": [\"--login\",//使用Git Bash的配置\"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\",\"terminal.integrated.shellArgs.windows\": [\"--login\",\"-i\"]\n\nWindows 下给终端PowerShell配置代理 env:https_proxy = “127.0.0.1:8080”123456789101112131415161718192021222324# NOTE: registry keys for IE 8, may vary for other versions$regPath = 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings'function Clear-Proxy{    Set-ItemProperty -Path $regPath -Name ProxyEnable -Value 0    Set-ItemProperty -Path $regPath -Name ProxyServer -Value ''    Set-ItemProperty -Path $regPath -Name ProxyOverride -Value ''    [Environment]::SetEnvironmentVariable('http_proxy', $null, 'User')    [Environment]::SetEnvironmentVariable('https_proxy', $null, 'User')}function Set-Proxy{    $proxy = 'http://example.com'    Set-ItemProperty -Path $regPath -Name ProxyEnable -Value 1    Set-ItemProperty -Path $regPath -Name ProxyServer -Value $proxy    Set-ItemProperty -Path $regPath -Name ProxyOverride -Value '&lt;local&gt;'    [Environment]::SetEnvironmentVariable('http_proxy', $proxy, 'User')    [Environment]::SetEnvironmentVariable('https_proxy', $proxy, # NOTE: registry keys for IE 8, may vary for other versions$regPath = 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings'function Clear-Proxy{    Set-ItemProperty -Path $regPath -Name ProxyEnable -Value 0    Set-ItemProperty -Path $regPath -Name ProxyServer -Value ''    Set-ItemProperty -Path $regPath -Name ProxyOverride -Value ''    [Environment]::SetEnvironmentVariable('http_proxy', $null, 'User')    [Environment]::SetEnvironmentVariable('https_proxy', $null, 'User')}function Set-Proxy{    $proxy = 'http://example.com'    Set-ItemProperty -Path $regPath -Name ProxyEnable -Value 1    Set-ItemProperty -Path $regPath -Name ProxyServer -Value $proxy    Set-ItemProperty -Path $regPath -Name ProxyOverride -Value '&lt;local&gt;'    [Environment]::SetEnvironmentVariable('http_proxy', $proxy, 'User')    [Environment]::SetEnvironmentVariable('https_proxy', $proxy, 'User')}\n\n在 idea 中添加 git bashsetting-tools-terminal-application settiing-shell path\"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" --login -i\n就是两条命令，前两条。要点一定要加 http://，直接写域名或者 IP 不行。http 和 https 都要设置。\nlinux 配置终端代理推荐使用qv2r*yarchlinux 下载 :\n12sudo pacman -S v2r*ysudo pacman -S qv2r*y\n\n配置代理 :\n1export http_proxy=http://127.0.0.1:7890;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890\n添加到当前 shell 的配置文件中,比如 zsh 的配置文件为家目录下的~/.zshrc\n1234# 设置本地代理的端口号 7890 为你实际的端口号export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890# 设置本地代理的端口号 7890 为你实际的端口号export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890export all_proxy=socks5://127.0.0.1:7891\n\nVM虚拟机配置共享主机，访问外网查看是否启动VM服务(win+R)输入:services.msc代理工具设置允许来自局域网的访问：5、VMware可以设置为NAT模式，或者桥接（桥接需要编辑虚拟网络编辑器–更改设置–添加网络-选择桥接模式–选择实体网卡即可），建议使用NAT简单\n6、设置网络浏览器中的代理设置，设置的IP为主机的IP，端口号默认为7890则浏览器即可使用主机的网络访问外网\n、设置虚拟机中的终端设置临时代理：\n12export http_proxy=http://主机IP:7890export http_proxy=http://主机IP:7890export https_proxy=http://主机IP:7890\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["代理"]},{"title":"Gunicorn","url":"https://bubbleboy11.github.io/2020/08/21/gunicorn/","content":"Gunicorn：Python WSGI HTTP Server.纯 Python 编写的高性能的 WSGI Server\npre-fork 预先分配多个 worker 进程处理请求(master-slave)。master-slave方式：一个master负责去管理多个worker进程，比如那个worker超时了把它重启，worker负责处理客服端的用户请求。\n多钟 worker 支持：Sync 同步worker / Async(Gevent) 基于gevent的异步worker/ Tornado / AsyncIO。一般需要支持比较高的并发的时候，可以采用基于gevent的异步worker。\n图解：使用Gunicorn来去部署 web的一种方式，首先客户端的请求先到Nginx这一层，Nginx负责反向代理，它就又把请求直接转发给Gunicorn。Gunicorn通过Pre-fork预先fork一堆worker进程，然后把请求转给worker进程处理请求。master进程它不会负责去处理请求，它只是负责监控和重启worker进程。\n2.Gunicorn的代码示例\n1$ pip install gunicorn     $ pip install gunicorn     # 安装gunicorn\n\n1234567891011# 创建文件 myapp.py, 添加内容如下def app(environ, start_response):  # 一个web应用    data = b'Hello, World!\\n'    start_response( \"200 OK\", [        (\"Content-Type\", \"text/plain\"),        (\"Content-Length\", str(len(data))    ])    return iter([data])``` ```shell $ gunicorn -w 4 myapp:app  # 创建文件 myapp.py, 添加内容如下def app(environ, start_response):  # 一个web应用    data = b'Hello, World!\\n'    start_response( \"200 OK\", [        (\"Content-Type\", \"text/plain\"),        (\"Content-Length\", str(len(data))    ])    return iter([data])``` ```shell $ gunicorn -w 4 myapp:app  # 使用gunicorn指定4个worker启动 web应用\n由于gunicorn部署个启动都非常容易，所以很多公司都使用 Gunicorn来作为 WSGI server。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["剑指offer","Leetcode"]},{"title":"HTTP 方法","url":"https://bubbleboy11.github.io/2020/08/21/http-fang-fa/","content":"常见的 HTTP 方法、接口的分类： \nGET 请求\n\n可以用浏览器直接访问\n请求参数直接放在URL后面，明文传递\n\nPOST请求\n\n不能使用浏览器直接访问\n可以用来上传文件、登录注册等需求\n通过 request body传递参数，加密传递数据\n\n幂等性(Idempotent): 是一个数学上的概念，在这里表示发送一次和多次请求引起的边界效应是一致的，幂等方法是无论调用多少次都得到相同请求结果的 HTTP 方法幂等的方法客户端可以安全地重新请求，因为不会对服务器上的数据造成什么影响。例如：a = 4 是幂等的，但是 a += 4 就是非幂等的\nGET 是幂等的，就是对服务器没有副作用；POST 非幂等，就是每一次创建一个新的东西会影响数据库的数据。    • GET请求参数放到url(明文显示)，长度限制，没有请求体；POST放在Http报文实体的主体请求体，更安全。    post请求携带的数据量比get请求大，多，常用于传输大文本的时候    • get请求所包含的参数会被缓存(浏览器cache)，而post不会    • get的url能被存为标签，post不会    • get只能被url编码，而post可以被多种编码    • get只接受ASCII字符，而post没有限制    • get后退无害，而post后退会再次发送请求\n高级区别：HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。    • get产生一个tcp数据包，post产生两个数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。\n因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？\n\nGET与POST都有自己的语义，不能随便混用。\n据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。\n并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。\n\n（1）web开发中 Post 和 Get 有哪些区别，各适合用于什么情况 ？    一般向服务器请求数据资源用Get；    向服务器发送处理数据用Post。\n（2）http协议中get、post的区别详解？ ① 功能差异：    get ：获取数据，客户端去服务器端取数据。\npost：提交数据，从客户端向服务器上传数据。\n\n② 数据传输：   get：通过URL里面加上参数去把数据传输给服务器端，然后服务器端根据发送过来参数返回对应内容。   get把请求的数据拼接在URL后面，在地址栏里提交(长度受地址栏限制   浏览器的地址栏会显示出来当前URL，get会把所有的数据放到url部分，数据会以明文显示对于用户来说是可见的，并且浏览器会有历史记录的功能。\n  post：URL唯一标识，通过唯一标识向唯一标识路径下提交一些数据，数据在Body部分放着不在URL里面，  Post把所有请求的数据放到WebForm里Body里面提交给服务器，以表单的形式提交,服务器会把Body(消息主题)里面的数据存储到服务器端数据库。  post会把所有的数据放到Body部分，这一部分是浏览器无法记录，地址栏也是无法直接发送一个post请求，post请求一般在页面里面通过form表单或者Ajax等方式发送一个请求给服务器端。post把所有数据放到Body部分对于用户来说是不可见的\n③ 安全性：post相对于get更安全。安全指的是是否会修改数据。安全性：GET,HEAD 和 OPTIONS 均被认为是安全的方法，因为它们旨在实现对数据的获取，并不具有’边界效应(side effect)’无论是get还是post如果传输的数据未经过加密，通过第三方抓包工具依然是可以把数据抓取到的，一旦抓取到数据还是可以看到传输的数据内容都包含哪些。为了保证传输的内容安全，一般对关键信息或者敏感信息都会采用这种加密的形式。GET 方法是从指定的资源请求数据GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据\nPOST 方法向指定资源提交要被处理的数据POST 请求不会被缓存POST 请求不会保留在浏览器历史记录中POST 不能被收藏为书签\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["计算机网络"],"tags":["GET","POST"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/io-duo-lu-fu-yong/","content":"Unix网络编程中提到了5种网络模型\n\nBlocking IO 阻塞式IO，一次只能处理一个请求。\nNoblocking IO 非阻塞式IO\nIO multiplexing IO多路复用（高并发框架使用）\nSignal Driven IO 信号驱动的IO\nAsynchronous IO 异步IO\n\n如何提升服务器的并发能力呢？就是如何处理多个客户端连接一些常见的提升并发能力的方式\n\n多线程模型，创建新的线程处理请求\n多进程模型，创建新的进程处理请求\n\n线程 / 进程创建开销比较大，可以用线程池方式解决线程 / 进程比较占用资源，难以同时创建太多\n现在服务器基本使用 IO多路复用，实现单进程同时处理多个 socket 请求。\n3.什么是IO多路复用？IO多路复用就是操作系统提供的同时监听多个 socket 的机制\n\n为了实现高并发需要一种机制并发处理多个 socket\nLinux 常见的是 select / poll / epoll 系统调用\n可以使用单线程单进程处理多个 socket为什么 select 就能实现高并发呢？select 可以同时处理多个 socket，有一个就绪应用程序代码就可以处理它123456# 使用IO复用代码格式while True:    events = sel.select()    # 系统阻塞在select，直到有一个socket就绪    for key,mask in events:   # 使用IO复用代码格式while True:    events = sel.select()    # 系统阻塞在select，直到有一个socket就绪    for key,mask in events:   # 当socket就绪之后就遍历事件        callback = key.data        callback(key.fileobj, mask)\n\n\n\n重点是索引就绪文件的时间复杂度，一般优先使用epoll,O(1)\nPython 封装了操作系统的IO多路复用Python 的IO多路复用基于操作系统实现( select / poll / epoll )Python2 select 模块Python3 selectors 模块selectors模块事件类型: \n\nEVENT_READ 表示socket可读，\nEVENT_WRITE 表示socket可写\n\nDefault selector:自动根据平台选取合适的o模型\n\nregister(fileobj, events, data=None)\nunregister(fileobj)\nmodify(fileobj, events, data=None)\nselect(timeout=None): returns[(key, events)]\nclose()\n\n下面是一个简单的echo服务器实现 ：异步的TCP回显,它能够并发的处理客户端请求，把客户端发的再发回去，这就是TCP回显服务器。\n123456789101112131415161718192021222324252627282930313233import selectorsimport socket sel = selectors.DefaultSelector() def accept(sock, mask):    conn, addr = sock.accept()  # Should be ready    print('accepted', conn, 'from', addr)    conn.setblocking(False)    sel.register(conn, selectors.EVENT_READ, read)  # 注册read回调 def read(conn, mask):    data = conn.recv(1000)  # Should be ready    if data:        print('echoing', repr(data), 'to', conn)        conn.send(data)  # Hope it won't block    else:        print('closing', conn)        sel.unregister(conn)        conn.close() # 服务端sock = socket.socket()sock.bind(('localhost', 1234))sock.listen(100)sock.setblocking(False)sel.register(sock, selectors.EVENT_READ, accept) # 注册accept回调 while True:       # 事件循环    events = sel.select()    for key, mask import selectorsimport socket sel = selectors.DefaultSelector() def accept(sock, mask):    conn, addr = sock.accept()  # Should be ready    print('accepted', conn, 'from', addr)    conn.setblocking(False)    sel.register(conn, selectors.EVENT_READ, read)  # 注册read回调 def read(conn, mask):    data = conn.recv(1000)  # Should be ready    if data:        print('echoing', repr(data), 'to', conn)        conn.send(data)  # Hope it won't block    else:        print('closing', conn)        sel.unregister(conn)        conn.close() # 服务端sock = socket.socket()sock.bind(('localhost', 1234))sock.listen(100)sock.setblocking(False)sel.register(sock, selectors.EVENT_READ, accept) # 注册accept回调 while True:       # 事件循环    events = sel.select()    for key, mask in events:        callback = key.data        callback(key.fileobj, mask)\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/lrucache/","content":"假如空间有限怎么办，我们不可能一直向缓存塞东西，当缓存达到一定个数之后，当缓存空间不够用的时候需要一种方法剔除key，我们需要一种策略踢出一些元素，用来给新的元素腾出空间。\n\n缓存剔除（失效）策略\nLFU(Least-Frequently-Used): 缓存污染问题(一个先前流行的缓存对象会在缓存中驻留很长时间)、(从使用次数下手把次数最少剔除掉)，\nFirst in First out(FIFO)\nRandom Cache: 随机选一个删除\n\nLRUCache Least-Recently-Used 替换掉最近最少使用的对象\n(从使用的时间下手把时间长剔除掉), 实际中使用最广。cpu缓存淘汰和虚拟内存效果好，web应用欠佳，比如 redis 就实现了这个策略，\nLRU通过使用一个循环双端队列不断把最新访问的 Key 放到表头，就是把最新访问的放到最前(右边)，把最远的访问保持在尾部(左边)，把最远访问的key剔除就可以了。\n\n146. LRUCache 缓存机制的实现   字典用来缓存，循环双端链表用来记录访问顺序\n\n利用Python 内置的 dict +collections.OderedDict(它可以记录key访问顺序) 实现\ndict 用来当做 k/v 键值对的缓存\nOderedDict 用来实现更新最近访问的 key\n\n要想实现一个 LRU，我们需要一种方式能够记录访问的顺序，并且每次访问之后我们要把最新使用到的元素放到最后（表示最新访问）。当容量满了以后，我们踢出最早访问的元素。假如用一个链表来表示的话：\n[1] -&gt; [2] -&gt; [3]\n假设最后边是最后访问的，当访问到一个元素以后，我们把它放到最后。当容量满了，我们踢出第一个元素就行了。一开始的想法可能是用一个链表来记录访问顺序，但是单链表有个问题就是如果访问了中间一个元素，我们需要拿掉它并且放到链表尾部。而单链表无法在O(1)的时间内删除一个节点（必须要先搜索到它），但是双端链表可以，因为一个节点记录了它的前后节点，只需要把要删除的节点的前后节点链接起来就行了。还有个问题是如何把删除后的节点放到链表尾部，如果是循环双端链表就可以啦，我们有个 root 节点链接了首位节点，只需要让 root 的前一个指向这个被删除节点，然后让之前的最后一个节点也指向它就行了。\n使用了循环双端链表之后，我们的操作就都是 O(1) 的了。这也就是使用一个 dict 和一个 循环双端链表 实现LRU 的思路。不过一般我们使用内置的 OrderedDict(原理和这个类似)就好了，要实现一个循环双端链表是一个不简单的事情，因为链表操作很容易出错。\n补充：其实 lru 有个缺点就是额外的链表比较占用空间，如果你感兴趣的话可以看看 redis 如何实现的 lru 算法\n运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。实现 LRUCache 类：\n\nLRUCache(int capacity) 以正整数作为容量&nbsp;capacity 初始化 LRU 缓存\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？\n\n示例：\n1234567891011121314151617181920212223242526272829303132输入[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得关键字 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得关键字 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); 输入[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得关键字 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得关键字 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3\n\n12345678910111213141516171819202122232425262728from collections import OrderedDict  class LRUCache():        def __init__(self, capacity=128):         # 参数capacity表示容量,允许128个key/value存在        self.od = OrderedDict()         self.capacity = capacity          def get(self, key): # 每次访问更新最新使用的 key        if key in self.od:             val = self.od[key]  # 取出key对应value值            # 把key放到最尾部，就是最近访问的放到最右边            self.od.move_to_end(key)             return val        else:            return -1        def put(self, key, value): # 更新key/value的值        if key in self.od:            del self.od[key] # 删除            self.od[key] = value  # 重新赋值，跟新key到表头        else: # insert            self.od[key] = value            # 判断当前容量是否已经满了            if len(self.od) &gt; self.capacity:                self.od.popitem(last=False) from collections import OrderedDict  class LRUCache():        def __init__(self, capacity=128):         # 参数capacity表示容量,允许128个key/value存在        self.od = OrderedDict()         self.capacity = capacity          def get(self, key): # 每次访问更新最新使用的 key        if key in self.od:             val = self.od[key]  # 取出key对应value值            # 把key放到最尾部，就是最近访问的放到最右边            self.od.move_to_end(key)             return val        else:            return -1        def put(self, key, value): # 更新key/value的值        if key in self.od:            del self.od[key] # 删除            self.od[key] = value  # 重新赋值，跟新key到表头        else: # insert            self.od[key] = value            # 判断当前容量是否已经满了            if len(self.od) &gt; self.capacity:                self.od.popitem(last=False) # 把最早的key删除\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class ListNode:    def __init__(self, key=None, value=None):        self.key = key        self.value = value        self.prev = None        self.next = Noneclass LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.hashmap = {}  # 集合        # 新建两个节点 head 和 tail        self.head = ListNode()        self.tail = ListNode()        # 初始化链表为 head &lt;-&gt; tail        self.head.next = self.tail        self.tail.prev = self.head    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法    def move_node_to_tail(self, key):        # 先将哈希表key指向的节点拎出来，为了简洁起名node        #      hashmap[key]                               hashmap[key]        #           |                                          |        #           V              --&gt;                         V        # prev &lt;-&gt; node &lt;-&gt; next         pre &lt;-&gt; next   ...   node        node = self.hashmap[key]        node.prev.next = node.next        node.next.prev = node.prev        # 之后将node插入到尾节点前        #                 hashmap[key]                 hashmap[key]        #                      |                            |        #                      V        --&gt;                 V        # prev &lt;-&gt; tail  ...  node                prev &lt;-&gt; node &lt;-&gt; tail        node.prev = self.tail.prev        node.next = self.tail        self.tail.prev.next = node        self.tail.prev = node    def get(self, key: int) -&gt; int:        res = self.hashmap.get(key, -1)        if res == -1:            return res        else:            # 如果已经在链表中了久把它移到末尾（变成最新访问的）            self.move_node_to_tail(key)            return res.value    def put(self, key: int, value: int) -&gt; None:        if key in self.hashmap:            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点            # 但是需要更新字典该值对应节点的value            self.hashmap[key].value = value            # 之后将该节点移到末尾            self.move_node_to_tail(key)        else:            if len(self.hashmap) == self.capacity:                # 去掉哈希表对应项                self.hashmap.pop(self.head.next.key)                # 去掉最久没有被访问过的节点，即头节点之后的节点                self.head.next = self.head.next.next                self.head.next.prev = self.head            # 如果不在的话就插入到尾节点前            new = ListNode(key, value)            self.hashmap[key] = new            new.prev = self.tail.prev            new.next = self.tail            self.tail.prev.next = new            self.tail.prev = newif __name__ == '__main__':    cache = LRUCache(2)    cache.put(1, 1)    cache.put(2, 2)    print(cache.get(1))    cache.put(3, 3)    print(cache.get(2))    cache.put(4, 4)    print(cache.get(1))    print(cache.get(3))    print(cache.get(class ListNode:    def __init__(self, key=None, value=None):        self.key = key        self.value = value        self.prev = None        self.next = Noneclass LRUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.hashmap = {}  # 集合        # 新建两个节点 head 和 tail        self.head = ListNode()        self.tail = ListNode()        # 初始化链表为 head &lt;-&gt; tail        self.head.next = self.tail        self.tail.prev = self.head    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法    def move_node_to_tail(self, key):        # 先将哈希表key指向的节点拎出来，为了简洁起名node        #      hashmap[key]                               hashmap[key]        #           |                                          |        #           V              --&gt;                         V        # prev &lt;-&gt; node &lt;-&gt; next         pre &lt;-&gt; next   ...   node        node = self.hashmap[key]        node.prev.next = node.next        node.next.prev = node.prev        # 之后将node插入到尾节点前        #                 hashmap[key]                 hashmap[key]        #                      |                            |        #                      V        --&gt;                 V        # prev &lt;-&gt; tail  ...  node                prev &lt;-&gt; node &lt;-&gt; tail        node.prev = self.tail.prev        node.next = self.tail        self.tail.prev.next = node        self.tail.prev = node    def get(self, key: int) -&gt; int:        res = self.hashmap.get(key, -1)        if res == -1:            return res        else:            # 如果已经在链表中了久把它移到末尾（变成最新访问的）            self.move_node_to_tail(key)            return res.value    def put(self, key: int, value: int) -&gt; None:        if key in self.hashmap:            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点            # 但是需要更新字典该值对应节点的value            self.hashmap[key].value = value            # 之后将该节点移到末尾            self.move_node_to_tail(key)        else:            if len(self.hashmap) == self.capacity:                # 去掉哈希表对应项                self.hashmap.pop(self.head.next.key)                # 去掉最久没有被访问过的节点，即头节点之后的节点                self.head.next = self.head.next.next                self.head.next.prev = self.head            # 如果不在的话就插入到尾节点前            new = ListNode(key, value)            self.hashmap[key] = new            new.prev = self.tail.prev            new.next = self.tail            self.tail.prev.next = new            self.tail.prev = newif __name__ == '__main__':    cache = LRUCache(2)    cache.put(1, 1)    cache.put(2, 2)    print(cache.get(1))    cache.put(3, 3)    print(cache.get(2))    cache.put(4, 4)    print(cache.get(1))    print(cache.get(3))    print(cache.get(4))\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"MVC","url":"https://bubbleboy11.github.io/2020/08/21/mvc/","content":"什么是 MVC模式？mvc出现的意义就是解耦，比如：模型代表数据，视图代表展示层，控制器代表操作，解耦数据、展示和操作。\nM=Mode 模型：负责业务对象和数据库的交互(ORM)。数据模型层，通常对数据加工和一些其它处理 ( 数据相关操作 )。V=View 视图：负责与用户的交互展示，前端输出的内容,比如:颜色、文字、表单等等。视图层，跟用户交互的页面上东西。一个视图的工作就是：从参数获取数据，装载一个模板，然后将根据获取的数据对模板进行渲染。C= Controller控制器：起到粘合剂的作用，接收请求参数调用模型和视图完成请求，实现的功能,比如:加减乘除、增删改写。业务处理层，处理业务逻辑。\n&nbsp; &nbsp; &nbsp;图解：典型的一个web框架使用MVC模式怎么处理请求。首先用户在浏览器输入url之后，后端web框架通过url的routes，寻找url匹配之后调用那个controller，在controller通过model跟数据库一个交互，然后通过调用view层去展示逻辑这里一般指模板渲染。但随着现在这种前后分离比较流行之后，视图层只是做序列化的工作。\nORM Object Relational Mapping，对象关系映射&nbsp; &nbsp;用于实现业务对象与数据表中的字段映射 ，比较流行 Sqlalchemy / Django自带的 Django ORM / 轻量级Peewee 。优势：代码更加面向对象面向对象的编程思想，代码量更少，灵活性高，方便扩充，提升开发效率。◆少写(几乎不写)SQL,提升开发效率◆支持多种类型的数据库,方便切换◆ORM技术成熟,能解决绝大部分问题\n缺点：拼接对象比较耗时，有一定性能影响一般都是优先使用 ORM 框架提升开发效率和可维护性\nDjango框架提供了ORM来解决数据持久化问题，因为Python是面向对象的编程语言，在Python程序中使用对象模型来保存数据，而关系型数据库使用关系模型，用二维表来保存数据，这两种模型并不匹配。使用ORM是为了实现对象模型到关系模型的双向转换，这样就不用在Python代码中书写SQL语句和游标操作，因为这些都会由ORM自动完成。\n模型类都直接或间接继承自Model类，模型类跟关系型数据库的二维表对应，模型对象跟表中的记录对应，模型对象的属性跟表中的字段对应。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["剑指offer","Leetcode"]},{"title":"OS模块","url":"https://bubbleboy11.github.io/2020/08/21/os/","content":"OS模块 operating system 提供了不少与操作系统相关联的函数sys: 通常用于命令行参数\n要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。模块导入：import os\n函数/变量描述environ包含环境变量的映射\n123456789101112```sep```路径中使用的分隔符```pathsep```分隔不同路径的分隔符```linesep```行分隔符(\\n'、\\r'或\\r\\n')```urandom(n)```返回n个字节的强加密随机数据```pyprint(dir(os))# print(help(os))# \n\nos.path \n文件目录相关操作123456import sysimport osprint(os.path)# &lt;module 'ntpath' from 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\ntpath.py'&gt;print(sys.path)  # 模块的路径集['c:\\\\python代码\\\\牛客网剑指offer66题思路分析\\\\代码', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\python38.zip', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\DLLs', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38', 'C:\\\\Users\\\\rose\\\\AppData\\\\Roaming\\\\Python\\\\Python38\\\\site-packages', import sysimport osprint(os.path)# &lt;module 'ntpath' from 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\ntpath.py'&gt;print(sys.path)  # 模块的路径集['c:\\\\python代码\\\\牛客网剑指offer66题思路分析\\\\代码', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\python38.zip', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\DLLs', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38', 'C:\\\\Users\\\\rose\\\\AppData\\\\Roaming\\\\Python\\\\Python38\\\\site-packages', 'C:\\\\Users\\\\rose\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\site-packages']\n\n返回文件名123456789```os.path.dirname(path)```    返回文件目录路径```os.path.split(path)``` 用元祖返回目录路径和文件名，且两者用\",\"分割```os.path.join(path1[, path2[, ...]])```表示当前所处的文件夹上一级文件夹的绝对路径，把目录和文件名合成一个路径 ```pyprint(os.path.basename('/root/runoob.txt'))  # runoob.txtprint(os.path.dirname('/root/runoob.txt'))  # /rootprint(os.path.split('/root/runoob.txt'))  # ('/root', 'runoob.txt')print(os.path.join('root', 'test', 'runoob.txt'))  # root\\test\\runoob.txt\n\nos.path.splitext(path)Split the pathname path into a pair (root, ext) such that root + ext == path, and ext is empty or begins with a period and contains at most one period. Leading periods on the basename are ignored; splitext(‘.cshrc’) returns (‘.cshrc’, ‘’).\n1234567891011121314151617```os.path.isdir(\"dir1\")```判断是否是文件夹，```os.path.isfile(\"file\")```判断是否是文件```os.path.abspath('.')```表示当前所处的文件夹的绝对路径  ```os.path.abspath('..')```表示当前所处的文件夹上一级文件夹的绝对路径```os.listdir(path)```返回指定的文件夹所包含的文件或文件夹名字的列表。### 执行文件处理操作的方法```os.rename(current_file_name, new_file_name)```重命名文件两个参数，当前的文件名和新文件名。```pyimport os # 重命名一个已经存在的文件test1.txt到test2.txt。os.rename( \"test1.txt\", \"test2.txt\" )\n\n123456789unlink的功能和remove一样是删除一个文件，但是删除一个删除一个正在使用的文件会报错。```os.remove(file_name)```删除文件，path是文件的路径，如果这个路径是一个文件夹，则会抛出OSError的错误，这时需用用```rmdir()```来删除```pyimport os # 删除一个已经存在的文件test2.txtos.remove(\"test2.txt\")\n\n123456在删除这个目录之前，它的所有内容应该先被清除，即文件夹需要时空的才能被删除```pyimport os # 删除”/tmp/test”目录os.rmdir( \"/tmp/test\"  )\n\n递归地删除目录。如果子目录成功被删除，则将会成功删除父目录，子目录没成功删除，将抛异常。1234567```pyimport osfor root, dirs, files in os.walk(top, topdown=False):    for name in files:        os.remove(os.path.join(root, name))    for name in dirs:        os.rmdir(os.path.join(root, name))\n\nshutil.rmtree()\n12345```pyimport os # 在当前目录下创建一个目录testos.mkdir(\"test\")\n\n1234567参数是你想设成当前目录的目录名称```pyimport os # 将当前目录改为\"/home/newdir\"os.chdir(\"/home/newdir\")\n\n1234567参数是你想设成当前目录的目录名称```pyimport os # 打印当前的目录路径print(os.getcwd())\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"Python web框架 Django vs Flask vs Tornado 对比","url":"https://bubbleboy11.github.io/2020/08/21/python-web-kuang-jia-django-vs-flask-vs-tornado-dui-bi/","content":"Django vs Flask vs Tornado\nDjango：非常完善大而全框架，内置ORM、Admin等组件，第三方插件较多。\nFlask：微框架，插件机制，比较灵活。很多中小公司和个人开发者都非常喜欢使用Flask。Flask优点很多人喜欢它比较灵活，可以使用各种方式组织代码，但是它也有缺点就是过于灵活的话没有统一代码结构很有可能对维护造成一定的困难。所以一些公司它会使用 cookiecutter-flask 模板生成工具来生成统一的项目模板，这样在维护的时候也会比较方便一些，代码格式都比较一致，组织也比较一致。(cookiecutter-flask生成统一的项目模板)\nTornado：异步支持的微框架和异步网络库，它既是是一个web微框架同时也是一个异步网络库，所以也可以用来编写web应用。但是它有一个比较大缺点就是轮子比较少，相关的一些支持和第三方插件非常少。所以有时候写起来需要造很多轮子就会有很多额外的工作，它的生产力可能就不会像Django和Flask那么高。\n很多公司其实并不会使用太多的框架混用，因为这样维护成本就比较高，不同的项目都使用的不同框架，所以一般都会有统一的框架或者模板生成。\nWeb 框架的组成中间件(middleware)，用于请求之前和请求之后做一些处理 ( 比如记录日志等 )。比如在很多web框架里面看到关于日志记录的中间件，请求完成之后需要记录一些日志，这样方便后面分析问题。还有很多在请求之前去做的，比如校验一个用户的合法性跟一个用户的身份，假如这个用户不合法就没有比较往下去执行了。很多框架提供这个功能，比如before_request 和 after_request分别去做什么工作。\nweb框架常用组件：路由，表单验证、权限认证、ORM、视图函数、模板渲染、序列化。其实看一个请求的生命周期大概就知道用到哪些组件。路由：把url跟所用到的哪个handle来去做映射就是这个url用哪一块 逻辑来去处理。一般拿到参数之后做一个表单的验证，客户端的输入一般都不可信，需要对外界的输入参数来去做一个验证，还有关于用户权限的验证。接下来就是调用ORM框架跟数据库做一个交互，还有视图函数的实现。最后就是使用一些模板渲染框架或者序列化的库来去把数据返回。一个官方实现的web 框架实际上还有很多地方无法满足真正业务需求的，所以还需要大量的第三方插件。\n第三方插件：Redis链接，RESTful支持等。如：redispy跟Redis做一个链接；前后端分离之后很多后端服务只用来提供数据，所以很多框架提供Restful的一个实现。\n这三块基本上就是一个web 框架的基本组成，现有的大部分框架都实现了部分或者这里面的所用的功能。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["web"],"tags":["剑指offer","Leetcode"]},{"title":"Python 传参方式","url":"https://bubbleboy11.github.io/2020/08/21/python-chuan-can-fang-shi/","content":"Python如何传递参数  对引用类型参数（Reference Data Type Arguments）\n唯一支持的参数传递是共享传参 Call by Object (Call by Reference or Call by Sharing)\n\n函数形参获得实参中各个引用的副本，\n\n传递参数的时候实际是通过对象引用进行传递的，根据传递变量是可变还是不可变对象，然后得到两种不同结果。\n\n在C语言中，变量不止是个名字，它是字节集合并真实存在于内存某个位置上。\n\n在Python中，变量名和对象是划分开的，变量名永远没有任何关联的类型信息，类型是和对象关联的，而不存在于变量名中，变量只是引用了不同类型的对象、指向对象的标签。从变量到对象的连接，在 python 和 java 里没有实际的 指针概念，称之为引用。在内部，变量事实上是到对象内存空间的一个指针，而且指向的对象可以随着程序赋值语句而不断变化。\n\n\n\n赋值：对象的引用（绑定），比浅拷贝还浅拷贝的，无论是不是可变对象，修改一个就会改变另一个。 \n将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒），a和b是这个对象的两个引用（reference）\ncur = cur.next是将cur.next 赋给cur，cur指向cur.next的内存，相当于指针后移  123456789101112  * 每个变量在使用前都必须赋值，一个变量名当第一次被赋值一个对象的同时变量也就创建了，这个对象的类型是在运行的过程中自动决定的，而不是通过代码声明的，这意味着没有必要事先声明变量，不能隐式转换成另一个类型，而当新的赋值表达式出现时，他会马上被当前新引用的对象所代替。这就是python所谓的动态类型机制。```pya = [888, 2, 3, [4, 666]]b = aprint(b)  # [888, 2, 3, [4, 666]]b[0] = 1print(b)  # [1, 2, 3, [4, 666]]print(a)  # [1, 2, 3, [4, 666]]b[3][0] = 1print(b)  # [1, 2, 3, [1, 666]]print(b)  # [1, 2, 3, [1, 666]]\n\n\n\n\n\n每一个对象都包含了两个头部信息，\n\n一个是类型标志符，标识这个对象的类型，\n以及一个引用的计数器，用来表示这个对象被多少个变量名所引用，如果此时没有变量引用他，那么就可以回收这个对象。（1）可变(mutable)与类型作为参数，可变对象 list / set / dict 等，形参和实参都是指向同一个对象，引用（内存地址）传递，修改可变对象不需要开辟新的空间直接可以在内存中修改它，改变了源对象。\n\n执行 l.append(0) ，把 0 列表对象在“方法传参”中传递所在的内存地址（引用）加到 l 中 ；再执行 l.append(0) ，不断地变长变短、变长变短的 l 变量所指向的列表在整个过程中只有一份，指向的是同一块内存地址。l 里面是这样的：[0 在内存中的地址, 0 在内存中的地址]\n12345678910111213141516171819202122def f_list(l):    l.append(0)    print(l)    print(id(l))ll = []  # list 是可变对象print(id(ll))f_list(ll)f_list(ll)ll.pop()print(ll)print(id(ll))# 输出结果：# 1778485960384# [0]# 1778485960384# [0, 0]# 1778485960384# [0]def f_list(l):    l.append(0)    print(l)    print(id(l))ll = []  # list 是可变对象print(id(ll))f_list(ll)f_list(ll)ll.pop()print(ll)print(id(ll))# 输出结果：# 1778485960384# [0]# 1778485960384# [0, 0]# 1778485960384# [0]# 1778485960384\n\n\n\n（2）不可变类(immutable)对象型作为参数 不可变对象 bool / int / float / bool/ tuple/ str / frozenset(固定集合) 指向相同地址值传递，拷贝复制值，实际上的变量有多份，\n不可修改，你传进去，如果在函数中对参数修改（赋值）时候它会新建对象（开辟新的空间）并且让你原来的形参去指定新对象，不会影响到源对象，新旧对象独立\n12345678a = 1b = aprint(id(a))  # 140728410609312print(id(b))  # 140728410609312a = 2print(b)  # 1print(id(a))  # 140728410609344print(id(b))  a = 1b = aprint(id(a))  # 140728410609312print(id(b))  # 140728410609312a = 2print(b)  # 1print(id(a))  # 140728410609344print(id(b))  # 140728410609312\n\n12345678910111213141516def fstr(s):    s += 'a'    print(s)    print(id(s)) ss = 'hehe'  # str 是不可变对象print(id(ss))fstr(ss)fstr(ss)# 输出结果：# 2361587561840# hehea# 2361587572848# heheadef fstr(s):    s += 'a'    print(s)    print(id(s)) ss = 'hehe'  # str 是不可变对象print(id(ss))fstr(ss)fstr(ss)# 输出结果：# 2361587561840# hehea# 2361587572848# hehea# 2361587572848\n\n一个小例题，请问这段代码会输出什么结果？提示：可变对象的一个错觉以为改变原来的值。\n12345678def clear_list(l):    l = []  # 形参指向一个新的值ll = [1, 2, 3]clear_list(ll)print(ll)  def clear_list(l):    l = []  # 形参指向一个新的值ll = [1, 2, 3]clear_list(ll)print(ll)  # [1, 2, 3]并不是[]\n首先在一块内存中定义一个列表[1, 2, 3], 定义变量时候 ll 变量指向这块内存，调用函数传入 ll 实参，此时 l 形参也指向和 ll一样这块内存。这时候又在一块内存中定义空列表[]，并赋值给 l ，然后 l 指向就变了指向了空列表这块内存。列表[1, 2, 3]并没有被操作。ll 指向没有改变所以值也就不变。\nPython可变参数作为默认参数，默认参数只计算一次12345678910def flist(l=[1]):  # 列表[1]是可变对象    l.append(1)    print('l = ', l)flist()flist()# 输出结果：# [1, 1]def flist(l=[1]):  # 列表[1]是可变对象    l.append(1)    print('l = ', l)flist()flist()# 输出结果：# [1, 1]# [1, 1, 1]\n\n先定义一个函数，传入一个list，添加一个END再返回：\n123def add_end(L=[]):    L.append('END')    def add_end(L=[]):    L.append('END')    return L\n当你正常调用时，结果似乎不错：\n1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', &gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END']\n当你使用默认参数调用时，一开始结果也是对的：\n12&gt;&gt;&gt; add_end()[&gt;&gt;&gt; add_end()['END']\n但是，再次调用add_end()时，结果就不对了：\n1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', &gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END']\n\nPython不可变参数作为默认参数，无论调用多少次，默认参数的内容不变，一直是函数定义时的初始值。12345678910# 用None这个不变对象来实现，def add_end(L=None):    if L is None:        L = []    L.append('END')    print(L)add_end()  # ['END']add_end()  # 用None这个不变对象来实现，def add_end(L=None):    if L is None:        L = []    L.append('END')    print(L)add_end()  # ['END']add_end()  # ['END']\n\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。\n将列表中各个值快速赋值给多个变量\n1234567891011list1 = [1, 2, 3, 4]a, b, c, d = list1print(a, b, c, d)  # 1 2 3 4list1 = [1, 2, 3]a, b, c, d = list1# ValueError: not enough values to unpack (expected 4, got 3)tuple1 = (1, 2, 3, 4)a, b, c, d = tuple1print(a, b, c, d)  list1 = [1, 2, 3, 4]a, b, c, d = list1print(a, b, c, d)  # 1 2 3 4list1 = [1, 2, 3]a, b, c, d = list1# ValueError: not enough values to unpack (expected 4, got 3)tuple1 = (1, 2, 3, 4)a, b, c, d = tuple1print(a, b, c, d)  # 1 2 3 4\n方式只有当左边的变量个数等于列表长度,否则会抛出ValueError.\n那么怎么样处理才能使得我们的可变对象在经过函数后不改变呢网上看到的一个方法是在函数中新建对象,然后将传递的参数赋给他。\n对比:\n1234567891011121314151617181920212223242526272829303132333435# 处理多个银行账户的余额信息def addInterest(balances, rates):print()print(\"第二处\", id(balances))    for i in range(len(balances)):        balances[i]= balances[i]*(1+rates)        print()        print(\"第三处\",id(balances))def test():    amounts = [1000,105,3500,739]    print()    print(\"第一处\",id(amounts))    rate = 0.05    addInterest(amounts, rate)    print()    print(amounts)    print()    print(\"第四处\",id(amounts))test()#结果第一处 41203656第二处 41203656第三处 41203656第三处 41203656第三处 41203656第三处 41203656[1050.0, 110.25, 3675.0, 775.95]第四处 # 处理多个银行账户的余额信息def addInterest(balances, rates):print()print(\"第二处\", id(balances))    for i in range(len(balances)):        balances[i]= balances[i]*(1+rates)        print()        print(\"第三处\",id(balances))def test():    amounts = [1000,105,3500,739]    print()    print(\"第一处\",id(amounts))    rate = 0.05    addInterest(amounts, rate)    print()    print(amounts)    print()    print(\"第四处\",id(amounts))test()#结果第一处 41203656第二处 41203656第三处 41203656第三处 41203656第三处 41203656第三处 41203656[1050.0, 110.25, 3675.0, 775.95]第四处 41203656\n1234567891011121314151617181920212223242526272829303132333435363738# 计算单个银行账户余额def addinterest(balance, rate):   print(\"第二处\", id(balance))   newBalance = balance * (1 + rate)   print()   print(\"第三处\", id(balance))   print()   print(\"第四处\", id(newBalance))   return newBalancedef main():   amount = 1000   print(\"第一处\", id(amount))   print()   rate = 0.05   amount = addinterest(amount, rate)   print()   print(\"第五处\", id(amount))   print()   print(amount)   print(\"第六处\", id(amount))main()#结果第一处 33533648第二处 33533648第三处 33533648第四处 33563344第五处 335633441050.0第六处 # 计算单个银行账户余额def addinterest(balance, rate):   print(\"第二处\", id(balance))   newBalance = balance * (1 + rate)   print()   print(\"第三处\", id(balance))   print()   print(\"第四处\", id(newBalance))   return newBalancedef main():   amount = 1000   print(\"第一处\", id(amount))   print()   rate = 0.05   amount = addinterest(amount, rate)   print()   print(\"第五处\", id(amount))   print()   print(amount)   print(\"第六处\", id(amount))main()#结果第一处 33533648第二处 33533648第三处 33533648第四处 33563344第五处 335633441050.0第六处 33563344\n可以看到第一种情况,id都是一样的,而第二种情况新建了对象,id是变化的了得出结论:对于可变对象作为函数参数，且参数不指向其他对象时，相当于引用传递；否则，若参数指向其他对象，则对参数变量的操作并不影响原变量的对象值\n对于不可变对象作为函数参数，相当于C系语言的值传递；对于可变对象作为函数参数，且参数不指向其他对象时，相当于C系语言的引用传递。对于可变对象作为函数参数，参数指向其他对象，对参数变量的操作不影响原变量的值。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"Python单元测试","url":"https://bubbleboy11.github.io/2020/08/21/python-dan-yuan-ce-shi/","content":"单元测试 Unit Testing\n针对程序模块进行正确的验证\n一个函数，一个类进行验证\n自底向上保证程序正确性\n\n是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。单元测试粒度最小，一般由开发人员采用白盒方式来测试，主要测试单元是否符合设计。单元测试的主要过程仍是通过给定的输入，判断得到的结果是否符合预期的代码结果测试的过程。\n为什么要写单元测试   三无代码不可取（无文档、无注释、无单侧）\n\n保证代码逻辑的正确性（甚至有些采用测试驱动开发TTD[Test-Driven Development]最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。）\n单测影响设计，易测的代码往往是高内聚低耦合的（各模块的内聚程度越高，模块间的耦合程度就越低）\n回归测试，防止改一处整个服务不可用\n\n\n确保代码质量\n改善代码设计，难以测试的代码一般是设计不够简洁的代码。\n保证重构不会引入新问题，以函数为单位进行重构的时候，只需要重新跑测试就基本可以保证重构没引入新问题\n通过单元测试，可以增强代码的执行与预期一致，增强对于代码的自信。\n在测试驱动编程的理念中，首先程序员要编写测试程序，然后编写可以通过测试的程序。测试程序就是程序的需求说明，它能够帮助程序员在开发程序时，不偏离需求。单元测试最大作用 例如 ：当你逻辑修改了，只需要重新跑一下测试就知道有没有把之前的逻辑给改坏。\n\n单元测试相关的库\nnose / pytest 较为常见 终端输入pytest xxx.py\nmock 模块用来模拟替换网络请求等，一般在测试的时候是不需要真的发送请求，比如request() 直接使用 mock() 替换,直接写死,测试代码最后是”纯净的”,要像什么网络请求都考虑进来\ncoverage 统计测试覆盖率\n\n如何设计测试用例：（等价类划分）\n正常值功能测试\n边界值（比如最大最小，最左最右值）boundary/edge case\n异常值（比如 None，空值，非法值）当然我们也不用做的非常细致，要不然写测试是一件非常繁琐累人的事情，甚至有时候为了测试而测试，只是为了让单测覆盖率好看点。当然如果是web应用用户输入，我们要假设所有的参数都是不可信的。但是很多内部调用的函数我们基于约定来编程，如果你瞎传参数，那就是调用者的责任了。①首先需要你安装pytest测试库pytest 是 python的第三方测试框架,是基于 unittest 的扩展框架,比unittest更简洁,更高效。1&gt;&gt; pip install pytest\n②用 pytest 命令运行文件名，它会自动发现所有test开头的函数并去执行里面的测试用例pytest file_address而不是python file_address\n\nassert \n以下是单元测试示例：\n1234567891011121314151617181920212223242526272829def binary_search(array, target):  # 二分查找    if not array:        return -1    beg, end = 0, len(array)    while beg &lt; end:        mid = beg + (end - beg) // 2  # py3取整操作        if array[mid] == target:            return mid        elif array[mid] &gt; target:            end = mid        else:            beg = mid + 1    return -1def test():    '''binary_search()函数的单元测试用例代码'''    # 正常值， 包含有和无两种结果    assert binary_search([0, 1, 2, 3, 4, 5], 1) == 1    assert binary_search([0, 1, 2, 3, 4, 5], 6) == -1    assert binary_search([0, 1, 2, 3, 4, 5], -1) == -1    # 边界值测试    assert binary_search([0, 1, 2, 3, 4, 5], 0) == 0    assert binary_search([0, 1, 2, 3, 4, 5], 5) == 5    assert binary_search([0], 0) == 0    # 异常值测试    assert binary_search([], 1) == def binary_search(array, target):  # 二分查找    if not array:        return -1    beg, end = 0, len(array)    while beg &lt; end:        mid = beg + (end - beg) // 2  # py3取整操作        if array[mid] == target:            return mid        elif array[mid] &gt; target:            end = mid        else:            beg = mid + 1    return -1def test():    '''binary_search()函数的单元测试用例代码'''    # 正常值， 包含有和无两种结果    assert binary_search([0, 1, 2, 3, 4, 5], 1) == 1    assert binary_search([0, 1, 2, 3, 4, 5], 6) == -1    assert binary_search([0, 1, 2, 3, 4, 5], -1) == -1    # 边界值测试    assert binary_search([0, 1, 2, 3, 4, 5], 0) == 0    assert binary_search([0, 1, 2, 3, 4, 5], 5) == 5    assert binary_search([0], 0) == 0    # 异常值测试    assert binary_search([], 1) == -1\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["测试"],"tags":["剑指offer","Leetcode"]},{"title":"Python语言特性","url":"https://bubbleboy11.github.io/2020/08/21/python-yu-yan-te-xing/","content":"Python语言特性\nPython是动态强类型 脚本语言\n动态还是运行期确定数据类型，不用给变量指定类型，一个变量可以是字符串，也可赋值成一个数字，灵活，执行前不需要编译，执行时才编译，因此效率低。\n静态是编译期是确定数据类型，要申明变量数据类型 java c c++ c#\n弱类型语言是指变量的类型可以被隐式转换。\n强类型：\nPHP和Javascript就是弱类型语言 =&gt; 1 + “1”  在JS不会报错，在Python会报错\n非独立：JavaScript语言依赖执行环境，对于客户端来说是浏览器，对于服务端来说是node。\n\nthis```Python之禅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950### 为什么要用Python？  * 胶水语言，轮子多，应用广泛（优点）  * 语言灵活，生产力高（优点）  * 性能问题、代码维护问题、python2/python3兼容问题（缺点）### 鸭子类型“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以称为鸭子”  * 关注点在对象的行为、接口的方法，而不是类型（duck typing）它并不要求严格的继承体系  * 比如file，String，scoket对象都支持read/write方法（file like object）  对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。  许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。  * 再比如定义了__iter__魔术方法的对象都可以for迭代```pythonclass Duck:    def quack(self):        print(\"gua gua\")           class Person:    def quack(self):        print(\"我是人类， 但我也会 gua gua gua\")  def in_the_forest(duck):    duck.quack()     def game():    donald = Duck()    john = Person()    in_the_forest(donald)    in_the_forest(john)    # 输出类型    print(type(donald))    print(type(john))    # 判断类型    print(isinstance(donald, Duck))    print(isinstance(john, Person))  game()# 输出结果：# gua gua# 我是人类， 但我也会 gua gua gua# # # True# True\n\n1、pass语句 空语句 什么也不做，一般作为占位符或者创建占位程序，pass语句不会执行任何操作2、保证格式完整 3、保证语义完整\nPython 表示复数的语法是real + image j方法conjugate返回复数的共轭复数复数的实部与虚部均为浮点数；虚部的后缀可以是 “j” 或者 “J”；复数的 conjugate 方法可以返回该复数的共轭复数。复数不能比大小\n1234567a = 1 + 2jprint(a)  # (1+2j)b = 1 + 2Jprint(b)  # (1+2j)print(a == b)  # Trueprint(a.imag)  # 2.0print(a.real)  a = 1 + 2jprint(a)  # (1+2j)b = 1 + 2Jprint(b)  # (1+2j)print(a == b)  # Trueprint(a.imag)  # 2.0print(a.real)  # 1.0\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"SMTP发送邮件","url":"https://bubbleboy11.github.io/2020/08/21/smtp-fa-song-you-jian/","content":"SMTP发送邮件SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。\npython的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。\n123import smtplibsmtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )\n\nhost: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如: runoob.com，这个是可选参数。port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下 SMTP 端口号为25。local_hostname: 如果 SMTP 在你的本机上，你只需要指定服务器地址为 localhost 即可。Python SMTP 对象使用 sendmail 方法发送邮件，语法如下：\nSMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])参数说明：\nfrom_addr: 邮件发送者地址。to_addrs: 字符串列表，邮件发送地址。msg: 发送消息这里要注意一下第三个参数，msg 是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意 msg 的格式。这个格式就是 smtp 协议中定义的格式。\n实例以下执行实例需要你本机已安装了支持 SMTP 的服务，如：sendmail。\n以下是一个使用 Python 发送邮件简单的实例：\n123456789101112131415161718192021222324import smtplibfrom email.mime.text import MIMETextfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8')message['From'] = Header(\"菜鸟教程\", 'utf-8')   # 发送者message['To'] =  Header(\"测试\", 'utf-8')        # 接收者 subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8')  try:    smtpObj = smtplib.SMTP('localhost')    smtpObj.sendmail(sender, receivers, message.as_string())    print(\"邮件发送成功\")    server.quit()except smtplib.SMTPException:    print(\"Error: 无法发送邮件\")    import smtplibfrom email.mime.text import MIMETextfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8')message['From'] = Header(\"菜鸟教程\", 'utf-8')   # 发送者message['To'] =  Header(\"测试\", 'utf-8')        # 接收者 subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8')  try:    smtpObj = smtplib.SMTP('localhost')    smtpObj.sendmail(sender, receivers, message.as_string())    print(\"邮件发送成功\")    server.quit()except smtplib.SMTPException:    print(\"Error: 无法发送邮件\")    # 邮件发送成功\n\n我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： From, To, 和 Subject ，每个信息直接使用空行分割。\n我们通过实例化 smtplib 模块的 SMTP 对象 smtpObj 来连接到 SMTP 访问，并使用 sendmail 方法来发送信息。\n执行以上程序，如果你本机安装 sendmail（邮件传输代理程序），就会输出：\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"TCP socket 编程原理","url":"https://bubbleboy11.github.io/2020/08/21/tcp-socket-bian-cheng/","content":"了解TCP socket 编程原理如何使用 socket 模块如何建立TCP socket 客户端和服务端客户端和服务端之间的通信\n本质传输字节。所有网络通信都基于socket\nsocket建立连接的过程？服务器建立监听，socket，bind，listen客户端发送请求，connect，send连接确认，accept，response\n首先在服务器端建立监听；然后客户端发起连接，同时发送数据( request )；服务器端收到连接请求之后accept接受建立连接，同时对发送过来的请求做出响应( response)。\n服务端要先启动，然后再启动客户端。不要在ide里同时执行服务端和客户端，如果你在同一个IDEL里开服务和客户端就会出那个问题，因为开一个就要把另一个停了。最好打开两个cmd窗口，以此执行服务端和客户端。两个程序都执行才有结果，通信两个人都接受发送信息\n编写代码与网络交互的时候都需要把参数变成字节，处理的时候都需要转换成Unicode(py3为str)\n123456789101112131415161718# 客户端 tcp_server.pyimport socket# 创建socket对象，第一个参数协议族，第二个参数是类型，TCP还是UDP# AF_INET是IPV4，SOCK_STREAM是TCPs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 连接服务端s.connect((\"127.0.0.1\", 6666))  # 参数是一个tuple对象,ip和端口# 发送数据s.sendall(b'Hello World')# 接收数据data = s.recv(1024)  # 1024字节数print(data.decode())# 关闭客户端s.close()# 客户端输出结果：# 客户端 tcp_server.pyimport socket# 创建socket对象，第一个参数协议族，第二个参数是类型，TCP还是UDP# AF_INET是IPV4，SOCK_STREAM是TCPs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 连接服务端s.connect((\"127.0.0.1\", 6666))  # 参数是一个tuple对象,ip和端口# 发送数据s.sendall(b'Hello World')# 接收数据data = s.recv(1024)  # 1024字节数print(data.decode())# 关闭客户端s.close()# 客户端输出结果：# Tue Dec 15 11:54:43 2020\n\n1234567891011121314151617181920212223242526# 服务端 tcp_client.pyimport socketimport time# 创建socket对象s = socket.socket()# 绑定端口s.bind((\"127.0.0.1\", 6666))  # 参数是一个tuple对象，hostname和port# s.bind((\"DESKTOP-3VCRA3T\", 6666))  # 参数是一个tuple对象，hostname和port# 监听s.listen()while True:    # 如果请求到来就接受    client, addr = s.accept()  # return conn, addr    print(client)    timestr = time.ctime(time.time()) + '\\r\\n'  # 返回当前的时间戳    # 发送数据    client.send(timestr.encode())  # 把send 里面参数encode('utf8')成字节    # 关闭socket    client.close()# 服务端输出结果：# &lt;socket.socket fd=344, family=AddressFamily.AF_INET, # type=SocketKind.SOCK_STREAM, proto=0, # 服务端 tcp_client.pyimport socketimport time# 创建socket对象s = socket.socket()# 绑定端口s.bind((\"127.0.0.1\", 6666))  # 参数是一个tuple对象，hostname和port# s.bind((\"DESKTOP-3VCRA3T\", 6666))  # 参数是一个tuple对象，hostname和port# 监听s.listen()while True:    # 如果请求到来就接受    client, addr = s.accept()  # return conn, addr    print(client)    timestr = time.ctime(time.time()) + '\\r\\n'  # 返回当前的时间戳    # 发送数据    client.send(timestr.encode())  # 把send 里面参数encode('utf8')成字节    # 关闭socket    client.close()# 服务端输出结果：# &lt;socket.socket fd=344, family=AddressFamily.AF_INET, # type=SocketKind.SOCK_STREAM, proto=0, # laddr=('127.0.0.1', 6666), raddr=('127.0.0.1', 51620)>\n\n123456789101112131415161718import socket  # 导入 socket 模块s = socket.socket()  # 创建 socket 对象host = socket.gethostname()  # 获取本地主机名print('当前主机名称为: ' + host)port = 42683  # 设置端口s.bind((host, port))  # 绑定端口s.listen(5)  # 监听连接,传入连接请求的最大数5while True:    c, addr = s.accept()  # 建立客户端连接。    print('连接地址：', addr)    data = 'hello word,你好，世界！'    c.send(data.encode())    c.close()  # 关闭连接# 当前主机名称为: DESKTOP-3VCRA3Timport socket  # 导入 socket 模块s = socket.socket()  # 创建 socket 对象host = socket.gethostname()  # 获取本地主机名print('当前主机名称为: ' + host)port = 42683  # 设置端口s.bind((host, port))  # 绑定端口s.listen(5)  # 监听连接,传入连接请求的最大数5while True:    c, addr = s.accept()  # 建立客户端连接。    print('连接地址：', addr)    data = 'hello word,你好，世界！'    c.send(data.encode())    c.close()  # 关闭连接# 当前主机名称为: DESKTOP-3VCRA3T# 连接地址： ('192.168.110.248', 50733)\n\n123456789101112import socket  # 导入 socket 模块s = socket.socket()  # 创建 socket 对象host = socket.gethostname()  # 获取本地主机名port = 42683  # 设置端口号s.connect((host, port))print(s.recv(1024).decode())s.close()# 输出import socket  # 导入 socket 模块s = socket.socket()  # 创建 socket 对象host = socket.gethostname()  # 获取本地主机名port = 42683  # 设置端口号s.connect((host, port))print(s.recv(1024).decode())s.close()# 输出# hello word,你好，世界！\n\n如何使用 socket 发送HTTP请求使用 socket 接口发送 HTTP请求\nHTTP建立在TCP基础之上的一个应用层协议\nHTTP是基于文本的协议发送GET请求的数据格式：\n1socket.sendall(socket.sendall(b'GET /index/?name=aa&sex=bb http1.1\\r\\nAccept:text/html\\r\\nAccept-Encoding:gzip, deflate\\r\\n\\r\\n')\n浏览器发送POST请求的数据格式：POST请求也可以在url上传参\n1​socket.sendall(​socket.sendall(b'GET /index/?name=aa&sex=bb http1.1\\r\\nAccept:text/html\\r\\nAccept-Encoding:gzip, deflate\\r\\n\\r\\na1=1&a2=2&a3=3')\n\n1234567891011121314# socket_send_http.pyimport socket s = socket.socket()# 连接到百度的主机s.connect(('www.baidu.com', 80))# 发送HTTP请求体http = b\"GET / HTTP/1.1\\r\\nHost: www.baidu.com\\r\\n\\r\\n\"s.sendall(http)# 接收响应内容buf = s.recv(1024)print(buf)# socket_send_http.pyimport socket s = socket.socket()# 连接到百度的主机s.connect(('www.baidu.com', 80))# 发送HTTP请求体http = b\"GET / HTTP/1.1\\r\\nHost: www.baidu.com\\r\\n\\r\\n\"s.sendall(http)# 接收响应内容buf = s.recv(1024)print(buf)# 关闭sockets.close()\n输出内容：\n12b'HTTP/1.1 200 OK\\r\\nAccept-Ranges: bytes\\r\\nCache-Control: no-cache\\r\\nConnection: keep-alive\\r\\nContent-Length: 14615\\r\\nContent-Type: text/html\\r\\nDate: Tue, 15 Dec 2020 14:44:38 GMT\\r\\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\\r\\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\\r\\nPragma: no-cache\\r\\nServer: BWS/1.1\\r\\nSet-Cookie: BAIDUID=DF34EFEBEB41F49B4169B86013EDC8FA:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: BIDUPSID=DF34EFEBEB41F49B4169B86013EDC8FA; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: PSTM=1608043478; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: BAIDUID=DF34EFEBEB41F49B93C5DFE6A700898F:FG=1; max-age=31536000; expires=Wed, 15-Dec-21 14:44:38 GMT; domain=.baidu.com; path=/; version=1; comment=bd\\r\\nTraceid: 1608043478045537332210543503774960632313\\r\\nVary: Accept-Encoding\\r\\nX-Ua-Compatible: IE=Edge,chrome=b'HTTP/1.1 200 OK\\r\\nAccept-Ranges: bytes\\r\\nCache-Control: no-cache\\r\\nConnection: keep-alive\\r\\nContent-Length: 14615\\r\\nContent-Type: text/html\\r\\nDate: Tue, 15 Dec 2020 14:44:38 GMT\\r\\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\\r\\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\\r\\nPragma: no-cache\\r\\nServer: BWS/1.1\\r\\nSet-Cookie: BAIDUID=DF34EFEBEB41F49B4169B86013EDC8FA:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: BIDUPSID=DF34EFEBEB41F49B4169B86013EDC8FA; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: PSTM=1608043478; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\\r\\nSet-Cookie: BAIDUID=DF34EFEBEB41F49B93C5DFE6A700898F:FG=1; max-age=31536000; expires=Wed, 15-Dec-21 14:44:38 GMT; domain=.baidu.com; path=/; version=1; comment=bd\\r\\nTraceid: 1608043478045537332210543503774960632313\\r\\nVary: Accept-Encoding\\r\\nX-Ua-Compatible: IE=Edge,chrome=1\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\t<meta http-equ'\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"URL Uniform Resource Locator","url":"https://bubbleboy11.github.io/2020/08/21/url/","content":"URL Uniform Resource Locator 统一资源定位符）是对可以从互联网上得到对资源位置和访问方法对一种简洁的表示，是互联网上标准资源的地址。⼀般统⼀资源定位符的开始标志着⼀个计算机⽹络所使⽤的⽹络协议互联网上的每个文件都有一个唯一的URL，且⼀个URL指向⼀个数据资源⽂件的路径\nURL是通过HTTP协议存取资源的Internet路径，\nURL是URI的子集，URI还包括URN，在互联网中，我们一般的网页链接、网址可以被称为URL或者URI，大多数人称为URL。\n基本URL包含模式（或称协议）、服务器名称（或IP地址）、文件所在路径和文件名scheme://host[:port#]/path/.…/[;url-params][?query-string][#anchor]\nURL格式 http://host[:port][path]\nhost：合法的Internet主机域名或IP地址port：端口号，缺省端口为80path：请求资源的路径\n代理服务器位于客户端和真正的服务器之间，充当一个中间人的角色。当跟客户端交互的时候，是服务器。跟服务器交互的时候，又充当客户端，\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":[],"tags":[]},{"title":"Vuex状态管理介绍","url":"https://bubbleboy11.github.io/2020/08/21/vuex-zhuang-tai-guan-li-jie-shao/","content":"Vuex状态管理介绍\n专为 Vue.js 应用程序开发的状态管理模式\nstate: 驱动应用的数据源，data中的数据\nview: 以声明方式将 state 映射到视图，在模板中使用{{}}\nactions: 响应在 view 上的用户输入导致的状态变化\n跨组件和页面直接来全局共享数据单例模式：vue项目生命周期当中只有一个vuex的实例提交订单会读取当前登录用户的昵称和手机号信息\n\nVuex的工作流程\nstate：存放数据\nmutation：同步提交数据\naction：异步提交数据\n\n安装及配置\n\n第一步，安装1cnpm install vuex -S\n第二步，配置src\\main.js123456import store from './store'new Vue({  store,  // store: store,  render: h =&gt; h(App),}).$mount(import store from './store'new Vue({  store,  // store: store,  render: h =&gt; h(App),}).$mount('#app')\n\n\n\n新建src\\store\\index.js\n123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    }  },\n\nstate\n含义单一状态树，全局唯一数据源查询state中的数据\n示例代码12345678910111213141516171819202122232425262728          首页    当前计数: {{ count }}               当前登录的用户是：{{ user.username }}      export default {  // state  data () {    return {      count: 0,      uname: ''    }  },    computed: {    user () {      return this.$store.state.user    }  }}\n\n\n\n使用Vuex保存用户信息\nmutation\n示例代码\n更改store中状态的唯一方法，注意不要通过赋值语法去修改store中的状态定义的函数参数是state\n\n场景1src\\store\\index.js\n123456789export default new Vuex.Store({    mutations: {    updateUsername (state) {      console.log(state)      // 变更状态      this.state.user.username = export default new Vuex.Store({    mutations: {    updateUsername (state) {      console.log(state)      // 变更状态      this.state.user.username = 'lisi'    }  }})\nsrc\\views\\Home.vue\n1234567891011121314151617181920export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    increment () {      this.count++    },    submit () {  // 改变state里面的username      this.$store.commit('updateUsername')  }}\n\n\n场景2src\\store\\index.js\n123456789export default new Vuex.Store({    mutations: {    updateUsername (state) {      console.log(state)      // 变更状态      this.state.user.username = export default new Vuex.Store({    mutations: {    updateUsername (state) {      console.log(state)      // 变更状态      this.state.user.username = 'lisi'    }  }})\n不用commitsrc\\views\\Home.vue\n1234567891011121314151617181920export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    increment () {      this.count++    },    submit () {  // 改变state里面的username      this.$store.state.user.username = 'wangwu'  }}\n\n场景3src\\store\\index.js\n123456789export default new Vuex.Store({    mutations: {    updateUsername (state, payload) {      // 变更状态      console.log(state, payload)      export default new Vuex.Store({    mutations: {    updateUsername (state, payload) {      // 变更状态      console.log(state, payload)      this.state.user.username = payload.uname    }  }})\n\nsrc\\views\\Home.vue\n12345678910111213141516171819202122export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    increment () {      this.count++    },    submit () {  // 改变state里面的username      this.$store.commit('updateUsername', {        uname: this.uname      })  }}\n\n\n场景4src\\store\\index.js\n123456789export default new Vuex.Store({    mutations: {    updateUsername2 (state, uname) {      console.log(state, uname)      // 变更状态      export default new Vuex.Store({    mutations: {    updateUsername2 (state, uname) {      console.log(state, uname)      // 变更状态      this.state.user.username = uname    }  }})\n\nsrc\\views\\Home.vue\n1234567891011121314151617181920export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    increment () {      this.count++    },    submit () {  // 改变state里面的username      this.$store.commit('updateUsername2', this.uname)  }}\n\n\naction\n示例代码\n提交的是mutation，可异步定义的函数参数是context123456789101112131415161718192021222324252627282930313233```src\\store\\index.js``````jsexport default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    }  },  mutations: {    // updateUsername (state) {    //   console.log(state)    //   this.state.user.username = 'lisi'    // }    // updateUsername (state, payload) {    //   console.log(state, payload)    //   this.state.user.username = payload.uname    // }    updateUsername2 (state, uname) {      console.log(state, uname)      this.state.user.username = uname    }  },  actions: {    updateUser (context, payload) {      setTimeout(() => {        context.commit('updateUsername2', payload.uname)      }, 5000)    }  },})\n\n\n\nsrc\\views\\Home.vue\n12345678910111213141516171819202122export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    increment () {      this.count++    },    submit () {  // 改变state里面的username      this.$store.dispatch('updateUser', {        uname: this.uname      })  }}\n\n\n辅助函数使我们的代码更加精简箭头函数可使代码更简练\nmapState方便在vue组件中获取vuex的状态，即state的内容\n1234567891011export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    },    profile: {      name: export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    },    profile: {      name: '我的详细信息'    }  }})\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849                        当前登录的用户是：{{ user.username }} - {{ profile.name }}                          import { mapState } from 'vuex'export default {  // state  data () {    return {      uname: ''    }  },  // actions  methods: {    submit () {  // 改变state里面的username      this.$store.dispatch('updateUser', {  // 触发action        uname: this.uname      })    }  },  // 传递对象  // computed: mapState({  //   username: state => state.user.username,  //   nname: state => state.user.nickname  // })  // 传递数组法一  // computed: mapState(['user', 'profile']),  // 传递数组法二  computed: {    conent () {      return ''    },    ...mapState(['user', 'profile'])  }}\n\nmapMutationsindex.js\n12345678910111213141516171819202122232425262728293031export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    },    profile: {      name: '我的详细信息'    }  },  mutations: {    updateUsername (state, payload) {      console.log(state, payload)      this.state.user.username = payload.uname    },    updateUsername2 (state, uname) {      console.log(state, uname)      this.state.user.username = uname    }  },  actions: {    updateUser (context, payload) {      setTimeout(() =&gt; {        context.commit('updateUsername2', payload.uname)      }, export default new Vuex.Store({  state: {    user: {      username: 'zhangsan',      nickname: '张三'    },    profile: {      name: '我的详细信息'    }  },  mutations: {    updateUsername (state, payload) {      console.log(state, payload)      this.state.user.username = payload.uname    },    updateUsername2 (state, uname) {      console.log(state, uname)      this.state.user.username = uname    }  },  actions: {    updateUser (context, payload) {      setTimeout(() =&gt; {        context.commit('updateUsername2', payload.uname)      }, 5000)    }  },  modules: {  }})\n\n\nsrc\\views\\Home.vue\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152                当前登录的用户是：{{ user.username }} - {{ profile.name }}                          import { mapState, mapMutations } from 'vuex'export default {  // state  data () {    return {      uname: ''    }  },  // actions  methods: {    // 场景1  数组    // ...mapMutations(['updateUsername']),    // 场景2  对象    ...mapMutations({      update: 'updateUsername'    }),    increment () {      this.count++    },    submit () {  // 改变state里面的username      // 使用mapMutations之后      // 场景1 数组方式      // this.updateUsername({uname: this.uname})      // 场景2 对象            this.update({uname: this.uname})    }  },  computed: {    conent () {      return ''    },    ...mapState(['user', 'profile'])  }}\n\nmapActions```````\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354                当前登录的用户是：{{ user.username }} - {{ profile.name }}                          import { mapState, mapMutations, mapActions } from 'vuex'export default {  // state  data () {    return {      count: 0,      uname: ''    }  },  // actions  methods: {    // ...mapMutations(['updateUsername']),    ...mapMutations({      update: 'updateUsername'    }),    // 场景1  数组        // ...mapActions(['updateUser']),    // 场景2  对象    ...mapActions({      updateUserInfo: 'updateUser'    }),    increment () {      this.count++    },    submit () {  // 改变state里面的username      // 使用mapActions之后      // 场景1  数组             // this.updateUser({uname: this.uname})      // 场景2  对象       this.updateUserInfo({uname: this.uname})    }  },  computed: {    conent () {      return ''    },    ...mapState(['user', 'profile'])  }}\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["django"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/wsgi/","content":"WSGI ？经常使用 uwsgi / gunicorn 部署 Django / Flask为什么Flask/Django都可以运行在gunicorn之上？存在意义：做一个规范，因为有了规范之后，如果遵守这个规范就，能让任意的Python Web框架运行在 web server上，这就是所说的WSGI。所有的web 应用都可以跑在实现相同的WSGI服务器上。\nWSGI(Web Server Gateway Interface (pep3333) web服务器网关接口是 Python的 web server 跟 web application 或者 web 框架 之间定义的一种交互规范。\nPEP 3333 - Python Web服务器网关接口：web服务器和Python web应用程序或框架之间拟议的标准接口，以促进跨各种web服务器的web应用程序可移植性。\n出现的意义：解决 Python Web Server 乱象 mod_python，CGI，FastCGI等\n解决的问题：描述了Web Server (Gunicorn / uWSGI)如何与 web框架(Flask/Django)交互，Web框架如何处理请求\n2.WSGI规范定义\n1def application(def application(environ, start_response)\n① application 就是 WSGI app，一个可调用对象\n② 参数：     environ：一个包含 WSGI 环境信息的字典，由 WSGI 服务器提供，常见的 key 有 PATH_INFO，QUERY_STRING等\n start_response：生成 WSGI 响应的回调函数，接收两个参数，status 和 headers\n\n③ 函数返回响应体的可迭代对象 \n编写一个简单兼容 WSGI 的 web应用并运行\n12345678910111213def myapp(environ, start_response):    print(environ['QUERY_STRING'])  # 打印环境变量参数, 建议打印出来这个字典看看有哪些参数    status = '200 OK'  # 定义状态码    headers = [('Content-Type', 'text/html; charset=utf8')]  # 返回的响应头    start_response(status, headers)  # 调用回调函数    return [b'&lt;h1&gt;Hello World&lt;/h1&gt;']  # 返回可迭代对象，同时返回字节if __name__ == '__main__':    from wsgiref.simple_server import make_server  # 引入 web server    httpd = make_server('127.0.0.1', 8888, myapp)  # 设置server IP/端口号等    httpd.serve_forever()  def myapp(environ, start_response):    print(environ['QUERY_STRING'])  # 打印环境变量参数, 建议打印出来这个字典看看有哪些参数    status = '200 OK'  # 定义状态码    headers = [('Content-Type', 'text/html; charset=utf8')]  # 返回的响应头    start_response(status, headers)  # 调用回调函数    return [b'&lt;h1&gt;Hello World&lt;/h1&gt;']  # 返回可迭代对象，同时返回字节if __name__ == '__main__':    from wsgiref.simple_server import make_server  # 引入 web server    httpd = make_server('127.0.0.1', 8888, myapp)  # 设置server IP/端口号等    httpd.serve_forever()  # 启动server\n\n运行WSGI Server (Web Server)代码后，在浏览器访问 127.0.0.1:8888 ,网页返回Hello World。\n到这里没有使用任何框架就实现了一个简单的 web 应用。\n3). web server(WSGI 服务器) 把 HTTP参数信息通过 environ 传递给框架在浏览器输入 http://127.0.0.1:6666/?name=ipython\n命令端窗口返回内容\n1234name=ipython127.0.0.1 - - [19/Dec/2020 18:06:31] \"GET /?name=ipython HTTP/1.1\" 200 20127.0.0.1 - - [19/Dec/2020 18:06:32] \"GET /favicon.ico HTTP/1.1\" 200 name=ipython127.0.0.1 - - [19/Dec/2020 18:06:31] \"GET /?name=ipython HTTP/1.1\" 200 20127.0.0.1 - - [19/Dec/2020 18:06:32] \"GET /favicon.ico HTTP/1.1\" 200 20\n平常在使用web框架的时候，可以通过web框架提供的一些函数获取到用户信息，如查询字符串。其实这个就是框架去把这个一些请求的信息，从environment ( environ )里面拿出来之后给你。\n3). 使用Tornado的时候，可以去初始化一个application，然后启动这个application\n1234567891011121314class Application(object):    def __init__(self, routers, **kwargs):        self.routers = routers            # 把定义的可调用对象放入类的call方法，实现WSGI的规定    def __call__(self, environ, start_response):          try:            request = Request(environ)            callback, args = routers.match(request.path)            response = callback(request, *args)        except NotFoundError:            response = Response(\"&lt;h1&gt;Not found&lt;/h1&gt;\", status=404)        start_response(response.status, response.headers.items())        class Application(object):    def __init__(self, routers, **kwargs):        self.routers = routers            # 把定义的可调用对象放入类的call方法，实现WSGI的规定    def __call__(self, environ, start_response):          try:            request = Request(environ)            callback, args = routers.match(request.path)            response = callback(request, *args)        except NotFoundError:            response = Response(\"&lt;h1&gt;Not found&lt;/h1&gt;\", status=404)        start_response(response.status, response.headers.items())        return iter(response)\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"XSS(Cross Site Scripting)","url":"https://bubbleboy11.github.io/2020/08/21/xss/","content":"XSS Cross Site Scripting, 跨站脚本。因为CSS名字被层叠样式表给占用，所以就改成XSS。实施XSS攻击需要具备两个条件：　　一、需要向web页面注入恶意代码；　　二、这些恶意代码能够被浏览器成功的执行。当我们的用户访问一个站点的时候，在渲染页面的时候，恶意用户将代码植入到提供给其他用户使用的页面中，出现了一些我们没有预期到的脚本的指令，这些指令是恶意的，未经转义的恶意代码输出到其他用户的浏览器被执行，这样就是产生了xss攻击。用户浏览页面的时候嵌入页面中的脚本( js )会被执行，攻击用户。\n为什么能盗取获取用户的信息，比如cookie，删除用户本地的一些东西通过document.cookie把这个Cookie发送到攻击者的服务器上，这样他就能拿到用户的cookie可以想干嘛就干嘛。\n   XSS攻击主要分为两类：反射型(非持久型)，存储型(持久型)。反射型攻击方式就是把可以执行的 js脚本放到URL参数里面。存储型的攻击方式通过评论的这种方式，加载评论的时候把它写入到评论里面，它被后台存储之后，用户再打开的时候就会执行评论里面的脚本。\n\n    (1) .评论框中输入script 代码&lt;script&gt;alert('hello')&lt;/script&gt;, 一段未经转义过的 JS 代码被插入到页面之后，其他用户浏览的时候也会去执行它。\n    如果是黑客它插一段JS代码，把用户cookie的值发送到指定的服务器上，这样他就能拿到用户的cookie值想干嘛就可以干嘛。\n     我们知道HTTP协议它是没有状态，所以很多网站是通过Cookie去识别用户的，一旦黑客获取到你这个cookie就相当于拥有了你的账户就可以随便使用你这个账号了。这是个什么类型的 xss? 这个是把提交的脚本插入到数据库里面，所以这个是存储型的攻击方式。\n\n    (2).有一些后端它是通过URL参数来去获取的，有时候会把脚本放入URL参数里面。如：http://test.com/xss/example.php?name=&lt;script&gt;alert(\" hey! \")&lt;/script&gt;，然后通过邮件方式发送给用户，诱导用户去点击，这就是非存储形式的 XSS。\n\n2.XSS利用 js的危害盗用用户 cookie，获取敏感信息利用用户私人账号执行一些违法操作，比如盗取个人或者商业资料，执行一些隐私操作甚至可以在一些访问量很大的网站上实现DDoS攻击\n3.如何防范 XSS？  不要相信用户的任何输入，因为只要是用户的输入都有可能被黑客精心的构造来去做一些不好的事。\n过滤(针对用户的输入和URL中参数)。针对敏感标签、、等把它过滤掉，假如都没有script标签了也就没有办法执行 JS 代码了。\n转义。对常见符号( “&amp;”, “&lt;” and “&gt;”)转义，现在很多模板引擎已经实现自动转义，不需要手动实现这个功能。 (python3 html.escape)\n12345&gt;&gt;&gt; import html&gt;&gt;&gt; html.escape(&#x27;&lt;script&gt;&#x27;) # 转义操作&#x27;&amp;lt;script&amp;gt;&#x27;&gt;&gt;&gt; html.unescape(html.escape(&#x27;&lt;script&gt;&#x27;)) # 反转义操作&gt;&gt;&gt; import html&gt;&gt;&gt; html.escape(&#x27;&lt;script&gt;&#x27;) # 转义操作&#x27;&amp;lt;script&amp;gt;&#x27;&gt;&gt;&gt; html.unescape(html.escape(&#x27;&lt;script&gt;&#x27;)) # 反转义操作&#x27;&#x27;\n设置HttpOnly 禁止浏览器JS脚本访问和操作 Document.cookie。这个时候也就没办法使用JS脚本搞破坏了。浏览器禁止js 脚本访问和修改 cookie。但是发送给当前域名的请求里依然是有这个 cookie 的，后端可以通过 cookie 里的信息识别用户。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"python assert","url":"https://bubbleboy11.github.io/2020/08/21/assert/","content":"assert condition, messagecondition为True时，程序继续运行，下一个语句会被执行condition为False时将会抛出AssertionError异常，该异常的信息为message\n1234567891011def divide(num1, num2):    assert num2 != 0, \"Divisor cannot be zero\"    return num1 / num2if __name__ == '__main__':    try:        a2 = divide(12, 0)    except AssertionError as e:        print(e)    def divide(num1, num2):    assert num2 != 0, \"Divisor cannot be zero\"    return num1 / num2if __name__ == '__main__':    try:        a2 = divide(12, 0)    except AssertionError as e:        print(e)    # Divisor cannot be zero\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/b-tree/","content":"查找结构进化史线性查找：一个一个去找，实际上是全表扫描，优点实现简单；缺点查找太慢。二分查找：需要有序结构；优点实现简单；缺点要求是有序的，插入特别慢。哈希(Hash):优点查询快；缺点占用空间，不太适合存储大规模的数据二叉查找树(Binary Search Tree)：优点插入和查询很快(log(n))；缺点无法存储大规模数据，复杂度退化(二叉查找树只往一边增长，退化成线性结构)，树型查找结构，如二叉搜索树、平衡树、多路平衡查找树。）平衡树:解决bst退化的问题,树是平衡的;节点非常多的时候,依然树高很高多路查找树：一个父亲多个孩子节点(度)；节点过多树高不会特别深( 树的查找跟树高成正比 )多路平衡查找树(B-Tree)：(每个结点最多 m (m&gt;=2) )个孩子，称为m 阶或者度，当度超的时候会执行分裂操作，该B-Tree称为m阶的多路平衡查找树。叶结点具有相同的深度结点中的数据 key 从到右是递增的。B-Tree没有办法实现范围查找一个结点可以有多个孩子，每个节点 key 从左到右都是递增的。阶就是包含最大孩子个数，如结点(25,30,31,35)，该B-Tree是一颗4阶多路平衡查找树。\nB+树 是 B-Tree的变形只在叶子结点带有指向记录的指针。B+树只在叶子结点存储数据，其它非叶子结点可以存储更过孩子(对B-Tree的优化)。\n叶子结点通过指针相连。叶子结点里面有从左到右指针，它是一个双向指针，通过这个指针就可以非常方便实现范围查询。\n是不是树的度越多越好呢？如果树的阶越高，树高就会越小，因为每个孩子结点越多整体的树高就越小。不是每个结点的阶越大就越好，硬盘是以块来存储的，内存的基本管理单位是页，实际上阶是根据磁盘块大小来去确定的，主要是根据操作系统管理硬件有关。为了让操作系统更好的来去读取和缓存数据，以磁盘块的大小来确定B+树，一个磁盘块可以存储多少的孩子也就是多少阶。\nMySQL索引的原理Mysql 实际使用的 B+Tree作为索引的数据结构。MySQL索引是用一种叫做聚簇索引的数据结构实现的聚簇索引是一种数据存储方式，它实际上是在同一个结构中保存了B+树索引和数据行，InnoDB表是按照聚簇索引组织的（类似于Oracle的索引组织表）。\nB+ 树是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。B+ 树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。InnoDB通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。\n对于普通的堆组织表来说（右图），表数据和索引是分别存储的，主键索引和二级索引存储上没有任何区别。而对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据，二级索引的叶结点存储行的主键值。聚簇索引表最大限度地提高了I/O密集型应用的性能，但它也有以下几个限制：\n1）插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。2）更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。3）二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\nMyISAM索引实现？MyISAM存储引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引方式也叫做非聚簇索引的，之所以这么称呼是为了与InnoDB的聚簇索引区分。\nMyISAM索引与InnoDB索引的区别？InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/call/","content":"模拟可调用对象\nargs...])``` 此方法会在实例作为一个函数被“调用”时被调用；如果定义了此方法，则 ```x(arg1, arg2, ...)``` 就相当于 ```x.__call__(arg1, arg2, ...)``` 的快捷方式。 也就是说在类被实例化成对象后，对象可以像函数一样被调用。1234567891011121314151617181920212223242526272829303132我们可以将它们作为输入传递到其他的函数/方法中并调用它们,正如我们调用一个正常的函数那样。而类中的call()函数的意义正在于此.为了将一个类实例当作函数调用,我们需要再类中事先call()方法.假设x是X类的一个实例.调用x.__call__(1,2)等同于调用x(1,2).这个实例本身在这里相当于一个函数.下述用例可以通过，这里我定义了__call__方法，如果sorted函数生效时调用了__call__方法，那上述写法一定会出错。```pythonclass LargerNumKey:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value + other.value > other.value + self.value    def __call__(self, *args, **kwargs):        print('call')class Solution:    def largestNumber(self, nums):        ans = ''.join(sorted(map(str, nums), key=LargerNumKey))        return '0' if ans[0] == '0' else ansif __name__ == \"__main__\":    arr = [10, 3, 20]    sl = Solution()    l = LargerNumKey(3)    l1 = l()    print(l == l1)    print(sl.largestNumber(arr))    # call    # False    # 32010\n12arr = [10, 3, arr = [10, 3, 20]\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"django-auth","url":"https://bubbleboy11.github.io/2020/08/21/dango-auth/","content":"django-auth模块django-auth用户认证组件(重点)实现用户注册、登录及权限验证，通过取表单数据跟数据库对应表存储的值做比对用于判断当前的用户是否合法，并跳转到登陆成功或失败页面。功能主要有：\n自带用户认证授权系统\n用户：记录用户的登录账号密码等信息，        \n权限：用户是否有权限访问某一资源（执行操作）\n组：对多个用户进行权限管理登录密码：加密后的密码存储自带后台管理\n\n安装及配置setting.py\n\n第一步：INSTALLED_APPS安装应用\n\ndjango.contrib.auth\ndjango.contrib.contenttypes1234INSTALLED_APPS = [    'django.contrib.auth',    INSTALLED_APPS = [    'django.contrib.auth',    'django.contrib.contenttypes',]\n\n\n\n第二步：MIDDLEWARE中间件配置\n\nSessionMiddleware  用户登录\nAuthenticationMiddleware 用户在不同url对应的视图之间切换1234MIDDLEWARE = [    'django.contrib.sessions.middleware.SessionMiddleware',    MIDDLEWARE = [    'django.contrib.sessions.middleware.SessionMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',]\n\n\n\n第三步：migrate同步模型到数据库\n\n用户模型\n\n用户认证、登录、退出等分为两种用户\n\n游客(AnonymousUser )\n注册用户（User） \n\n\n\nUser常用属性\n对应ORM的模型或数据库中的一条记录1234567891011121314151617属性    描述```username```    用户名```password```    登录密码email    电子邮箱```is_staff```    是否为内部员工，true可以登录django后台管理系统```is_active```    是否为激活用户，true可以登录系统```is_superuser```    是否为超级管理员，可以在线管理所有的数据表```is_authenticated```    用户是否已登录的只读属性```is_anonymous```    用户登录是否已失效的只读属性```last_login```    最后登录时间```date_joined```    注册时间```groups```    用户组多对多关系```user_permissions```    用户权限多对多关系- 创建普通用户 命令行输入命令```bashpython manage.py shell  // django控制台\n或者pycharm的Python Console\n引入用户\n1from django.contrib.auth.models from django.contrib.auth.models import User\n\n12user = User.objects.create_user('john','john@example.com','johnpassword')user = User.objects.create_user('zhangsan','zhangsan@example.com',user = User.objects.create_user('john','john@example.com','johnpassword')user = User.objects.create_user('zhangsan','zhangsan@example.com','123456')\n能在auth_user表格中看到新加的用户，is_staff和is_superuser都是0\n\n使用命令行创建超级管理员\n1>>>python manage.py createsuperuser\n能在auth_user表格中看到新加的用户，is_staff和is_superuser都是1\n\n在auth_user表格修改is_staff和is_superuser切换超级管理员和普通用户\n\n获取用户对象\n1234&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; u = User.objects.get(username='john')&gt;&gt;&gt; u = User.objects.get(id=2)user = User.objects.get(username=&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; u = User.objects.get(username='john')&gt;&gt;&gt; u = User.objects.get(id=2)user = User.objects.get(username='admin')\n\n设置、修改用户的密码\n1>>python manage.py changepassword\n123&gt;&gt;&gt; u.set_password('new password')&gt;&gt;&gt; u.set_password(&gt;&gt;&gt; u.set_password('new password')&gt;&gt;&gt; u.set_password('12345678')>>> u.save()\n\n检查用户的密码是否正确\n1&gt;&gt;&gt; u.check_password(&gt;&gt;&gt; u.check_password('my password')\n\n\n\n12&gt;&gt;python manage.py clearsessions 清除过期会话&gt;&gt;python manage.py clearsessions 清除过期会话>>python manage.py collectstatic 收集依赖中的静态文件\n\n\n后台管理浏览器http://127.0.0.1:8000/admin/\n\n切换超级管理员和普通用户\n\n用户管理、权限分配普通用户名zhangsan-permission-group\n\n\n\n\n判断用户是否具备某权限\n1request.user.has_perm(request.user.has_perm('foo.add_bar')\n\n强制权限验证\n123@permission_required('foo.add_bar')def my_view(request):  @permission_required('foo.add_bar')def my_view(request):  pass\n\n命令行工具\n\n\n用户退出：使用logout函数退出当前登录用户Username (leave blank to use ‘rose’): adminEmail address: admin@exaple.com为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin。比如，我们之前在 TestModel 中已经创建了模型 Test 。\n1234from django.contrib.auth import logoutdef logout_view(request):logout(request)from django.contrib.auth import logoutdef logout_view(request):logout(request)# 执行后面的操作\n对象，代表当前登录的用户。1234567如果访问用户当前没有登录，```user```将被初始化为```django.contrib.auth.models.AnonymousUser```的实例。你可以通过```user```的```is_authenticated()```方法来辨别用户是否登录：```pyif request.user.is_authenticated():    # Do something for logged-in users.else:    # Do something for anonymous users.\n只有激活Django中的AuthenticationMiddleware时该属性才可用\n登录及退出步骤一：认证验证用户名和密码是否匹配\n1user = authenticate(username='john',password=user = authenticate(username='john',password='secret')\n\n步骤二：判断认证后的用户是否为None，不为None则表示用户认证通过步骤三：调用login函数登录用户login(request,user,backend=None)\n\n在视图中获取当前用户request.user 不必再次调用sql\n\n   需要登录才可以访问的视图\n123@login_requireddef my_view(request):  @login_requireddef my_view(request):  pass\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/datetime-mo-kuai/","content":"支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。\n该模块还支持时区处理:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from datetime import datetime, dateimport time# dates are easily constructed and formattednow_time = datetime.now()print(\"now: {0}\".format(now_time))# now: 2021-02-15 17:11:14.226178# 当前的日期print('now day: {0}'.format(now_time.date()))# now day: 2021-02-15# 当前的时间print('now time: {0}'.format(now_time.time()))# now time: 17:11:14.226178print('now day2: {0}'.format(datetime.today()))# now day2: 2021-02-15 17:11:14.226178print('year: {0}'.format(now_time.year))# year: 2021print('month: {0}'.format(now_time.month))# month: 2print('day: {0}'.format(now_time.day))# day: 15print('microsecond: {0}'.format(now_time.microsecond))# microsecond: 226178print(dir(now_time))'''['__add__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__radd__', '__reduce__', '__reduce_ex__', '__repr__', '__rsub__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'astimezone', 'combine', 'ctime', 'date', 'day', 'dst', 'fold', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace', 'resolution', 'second', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'today', 'toordinal', 'tzinfo', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday', 'year']'''# datenow = date.today()print(now)# 2021-02-15print(now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\"))# 02-15-21. 15 Feb 2021 is a Monday on the 15 day of February.# dates support calendar arithmeticbirthday = date(1997, 1, 1)age = now - birthdayprint(age.days)# 8811d1 = datetime(2020, 6, 20)  # 第一个日期d2 = datetime(2020, 6, 21)  # 第二个日期interval = d2 - d1  # 1 两日期差距print(interval.days)  # 0 具体的天数print(interval.seconds)  # 0 具体的秒数print('------------------')# 获取到毫秒数print(time.time())  # 1613380274.227134time.sleep(from datetime import datetime, dateimport time# dates are easily constructed and formattednow_time = datetime.now()print(\"now: {0}\".format(now_time))# now: 2021-02-15 17:11:14.226178# 当前的日期print('now day: {0}'.format(now_time.date()))# now day: 2021-02-15# 当前的时间print('now time: {0}'.format(now_time.time()))# now time: 17:11:14.226178print('now day2: {0}'.format(datetime.today()))# now day2: 2021-02-15 17:11:14.226178print('year: {0}'.format(now_time.year))# year: 2021print('month: {0}'.format(now_time.month))# month: 2print('day: {0}'.format(now_time.day))# day: 15print('microsecond: {0}'.format(now_time.microsecond))# microsecond: 226178print(dir(now_time))'''['__add__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__radd__', '__reduce__', '__reduce_ex__', '__repr__', '__rsub__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'astimezone', 'combine', 'ctime', 'date', 'day', 'dst', 'fold', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace', 'resolution', 'second', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'today', 'toordinal', 'tzinfo', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday', 'year']'''# datenow = date.today()print(now)# 2021-02-15print(now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\"))# 02-15-21. 15 Feb 2021 is a Monday on the 15 day of February.# dates support calendar arithmeticbirthday = date(1997, 1, 1)age = now - birthdayprint(age.days)# 8811d1 = datetime(2020, 6, 20)  # 第一个日期d2 = datetime(2020, 6, 21)  # 第二个日期interval = d2 - d1  # 1 两日期差距print(interval.days)  # 0 具体的天数print(interval.seconds)  # 0 具体的秒数print('------------------')# 获取到毫秒数print(time.time())  # 1613380274.227134time.sleep(2)\n1234567891011from datetime import datetime, date, time, timedeltastr_ = '2019-9-10 8:10:56'str_date = datetime.strptime(str_, '%Y-%m-%d %H:%M:%S')print(str_date)# 2019-09-10 08:10:56now = datetime.now()date_str = now.strftime('%Y/%m/%d %H:%M:%S')print(date_str)from datetime import datetime, date, time, timedeltastr_ = '2019-9-10 8:10:56'str_date = datetime.strptime(str_, '%Y-%m-%d %H:%M:%S')print(str_date)# 2019-09-10 08:10:56now = datetime.now()date_str = now.strftime('%Y/%m/%d %H:%M:%S')print(date_str)# 2021/02/15 17:28:16\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"django","url":"https://bubbleboy11.github.io/2020/08/21/django/","content":"Django\n1python manage.py // 查看相关命令\n\n路由规则    - /index/    - /index/\\d+    - /index/(\\d+)    - /index/?P&lt;name(\\d+)&gt;    - include    - 反向生成url        - {% url \"\" %}        - reverse(‘a1’,args = (1,2,3))\n视图函数    请求相关    响应相关\n模板语言    if for    索引    执行：不加括号自动执行函数\nfilter和simple_tag\n\nORM操作    创建表        类  继承 models.Model        字段 Inter Char Foreign MantToMany    操作表        增        删        改        查    补充：        fliter传参：            a=1,b=2            **{}            Q()|Q()         values:         values_list:\n     all/values/values_list:\n     \n 双下划线跨表查询:\n        正向：\n        反向：\n\nDjango的生命周期：\nwsgi协议：web服务网关接口\n模块：wsgiref  uwsgi\n\n路由系统：    /index/  views.func    /index/\\d+  views.func    /index/  views.include()\n视图函数：    FBV function based view    CBV class based view\nORM    models &lt;=&gt; sql\ntemplate    html/css  渲染\n渲染工作在Django中执行完毕之后，字符串返回给浏览器。\n遇到js /css等再发一次请求，不会渲染，仅返回静态文件。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["剑指offer","Leetcode"]},{"title":"docker","url":"https://bubbleboy11.github.io/2020/08/21/docker/","content":"DockerDocker是一个容器化的平台，他将应用程序和所需要的依赖打包在一个容器里面，在其他的环境下 ，拿上镜像就可以运行，学习docker就是，学习在docker中安装依赖和将项目部署到docker中。\nDocker架构是什么Docker deamon  ： docker的守护进程Client  ：         docker的客户端Images ：   docker的镜像Container   ：  docker的容器Registry：      docker的仓库\nDocker镜像的常用的命令：Docker images：  列出已经下载的镜像Docker  search 镜像名字：tag     ：  搜索这个镜像Docker  pull  镜像名称:tag        拉取镜像Docker  rmi   镜像名称:tag         删除镜像Docker 容器常用的命令：创建容器docker create -p 3306:3306 –name suiyi -e MYSQL_ROOT_PASSWORD=smallming mysql:5.7新建并且启动docker run -p 3306:3306 –name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 \n列出正在运行的容器： docker container ls查看docker容器进程信息： docker ps [options]互docker exec [options] 容器ID [command]docker exec -it mysql /bin/bash5    停止容器docker stop 容器IDdocker stop mysql6    启动容器docker start 容器IDdocker start mysql7    强制停止容器不推荐使用，容易造成容器服务不正常关闭，影响后续使用。docker kill 容器IDdocker kill mysql8    删除容器要删除的容器，必须是关闭状态的。docker rm 容器IDdocker rm mysql9    查看容器日志docker logs -f -t –tail 行数 容器IDdocker logs -f -t –tail 5 mysql10    查看容器中运行的进程可以知道容器中到底运行的是哪个应用程序。docker top 容器IDdocker top mysql11    查看容器内部详情docker inspect 容器IDdocker inspect mysql12    复制容器数据到宿主机docker cp 容器ID:容器内路径 宿主机路径复制MySQL配置到宿主机：  docker cp mysql:/etc/mysql ~/tmp/conf    \n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["docker"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/doctest-mo-kuai/","content":"doctest模块扫描模块并根据程序中内嵌的文档字符串执行测试。测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。\n123456789101112131415161718192021222324252627282930313233343536373839```doctest.test_mod```函数从一个模块中读取所有文档字符串，找出所有看起来像是在交互式解释器中输入的例子的文本，之后检查例子是否符合实际要求。在python代码中寻找类似交互解释器里执行的命令，执行它们并且和这些命令的期望值进行比较。通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:用来验证docstring中的注释和代码实际的作用是一致的可以作为回归测试来验证代码能够正确执行可以用来编写模块的文档演示这些模块是如何处理输入得到输出的。一般写在函数的docstring里面，较为标准的文档字符串格式，用```>>>```表示一个用例的开始，>>>后有一个空格，直到遇到```空行```或者下一个```>>>``````’’’```后的英文文档后有一个空行。使用```#doctest: +ELLIPSIS（中文含义省略）```来表示下面的省略号匹配任意内容```python sample.py```只打印出错的用例结果```python sample.py -v``` 将会打印所有测试用例的结果。pychamr右键 run doctest定义如下函数代码square，求一个数的平方，并且在它的文档字符串中添加两个例子，文件名为my_math.py```py# my_math.pyimport doctestdef square(x):    '''    Squares a number and returns the result        >>> square(2)    4    >>> square(3)    9    '''    return x * xif __name__ == '__main__':    import my_math    doctest.testmod(my_math)\n\n在 win或 Linux终端命令行中运行查看测试结果。\n1234567891011121314151617181920[root@centos ~]# python my_math.py#[root@centos ~]# python my_math.py# 没反应，因为符合预期结果，默认只打印出错的用例结果[root@centos ~]# python my_math.py -vTrying:    square(2)Expecting:    4okTrying:    square(3)Expecting:    9ok1 items had no tests:    my_math1 items passed all tests:   2 tests in my_math.square2 tests in 2 items.2 passed and 0 failed.Test passed.\n\n12345678910111213[root@centos ~]# python my_math.py**********************************************************************File \"my_math.py\", line 9, in __main__.averageFailed example:    print(average([20, 30, 70]))Expected:    50.0Got:    40.0**********************************************************************1 items had failures:   1 of   2 [root@centos ~]# python my_math.py**********************************************************************File \"my_math.py\", line 9, in __main__.averageFailed example:    print(average([20, 30, 70]))Expected:    50.0Got:    40.0**********************************************************************1 items had failures:   1 of   2 in __main__.average***Test Failed*** 1 failures.\n\n1234567891011121314151617181920212223242526[root@centos ~]# python my_math.py -vTrying:    print(average([20, 30, 70]))Expecting:    40.0okTrying:    print(average([20, 30, 70]))Expecting:    50.0**********************************************************************File \"my_math.py\", line 9, in __main__.averageFailed example:    print(average([20, 30, 70]))Expected:    50.0Got:    40.01 items had no tests:    __main__**********************************************************************1 items had failures:   1 of   2 in __main__.average2 tests [root@centos ~]# python my_math.py -vTrying:    print(average([20, 30, 70]))Expecting:    40.0okTrying:    print(average([20, 30, 70]))Expecting:    50.0**********************************************************************File \"my_math.py\", line 9, in __main__.averageFailed example:    print(average([20, 30, 70]))Expected:    50.0Got:    40.01 items had no tests:    __main__**********************************************************************1 items had failures:   1 of   2 in __main__.average2 tests in 2 items.1 passed and 1 failed.***Test Failed*** 1 failures.\n\n\n123456789101112131415161718192021def add(x, y):    \"\"\" add two number or string    &gt;&gt;&gt; add(1, 2)    3    &gt;&gt;&gt; add(\"hello\", \" world\")    'hello world'    &gt;&gt;&gt; add(1, 2.0)    3    &gt;&gt;&gt; add(\"hello\", \" python\")  # doctest: +ELLIPSIS    'hello ...'    \"\"\"    return x+yif __name__ == '__main__':    def add(x, y):    \"\"\" add two number or string    &gt;&gt;&gt; add(1, 2)    3    &gt;&gt;&gt; add(\"hello\", \" world\")    'hello world'    &gt;&gt;&gt; add(1, 2.0)    3    &gt;&gt;&gt; add(\"hello\", \" python\")  # doctest: +ELLIPSIS    'hello ...'    \"\"\"    return x+yif __name__ == '__main__':    import doctest    doctest.testmod()\n\n123456789101112131415161718192021222324252627282930313233343536[root@centos ~]# python my_math.py -vTrying:    add(1, 2)Expecting:    3okTrying:    add(\"hello\", \" world\")Expecting:    'hello world'okTrying:    add(1, 2.0)Expecting:    3**********************************************************************File \"my_math.py\", line 9, in __main__.add  Failed example:    add(1, 2.0)Expected:    3Got:    3.0Trying:    add(\"hello\", \" python\")  # doctest: +ELLIPSISExpecting:    'hello ...'ok1 items had no tests:    __main__**********************************************************************1 items had failures:   1 of   4 in __main__.add4 tests in 2 items.3 passed and 1 failed.***Test Failed**[root@centos ~]# python my_math.py -vTrying:    add(1, 2)Expecting:    3okTrying:    add(\"hello\", \" world\")Expecting:    'hello world'okTrying:    add(1, 2.0)Expecting:    3**********************************************************************File \"my_math.py\", line 9, in __main__.add  Failed example:    add(1, 2.0)Expected:    3Got:    3.0Trying:    add(\"hello\", \" python\")  # doctest: +ELLIPSISExpecting:    'hello ...'ok1 items had no tests:    __main__**********************************************************************1 items had failures:   1 of   4 in __main__.add4 tests in 2 items.3 passed and 1 failed.***Test Failed*** 1 failures.\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/enumerate-mei-ju/","content":"将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596seasons = ['Spring', 'Summer', 'Fall', 'Winter']print(enumerate(seasons))  # &lt;enumerate object at 0x00000217ADAB6F40&gt;print(list(enumerate(seasons)))  # 下标从 0 开始# [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]print(list(enumerate(seasons, start=1)))  # 下标从 1 开始# [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]# for 循环使用 enumerate的对象for i, val in enumerate(seasons):    print(i, seasons[i])# 0 Spring# 1 Summer# 2 Fall# 3 Winter# for 循环使用 enumerate对象的列表print('------')for i, val in list(enumerate(seasons)):    print(i, seasons[i])# 0 Spring# 1 Summer# 2 Fall# 3 Winteri = 0print('------')for val in seasons:  # 普通的 for 循环，不使用 enumerate    print(i, seasons[i])    i += 1# 0 Spring# 1 Summer# 2 Fall# 3 Winterdef print_multiple_args(*args):    print(type(args), args)    for k, val in enumerate(args):        print(k, val)print('======')print_multiple_args('a', 'b', 'c')  # 法一print('======')print_multiple_args(*['a', 'b', 'c'])  # 法二 列表打包成关键字参数# 给定一个整数数组和一个目标值，找出数组中和为目标值的两个整数，并返回它们的数组下标nums = [1, 2, 5, 6, 4, 3]target = 8print('-----')for i, j in enumerate(nums):    if target - j in nums[i + 1:]:        # 字符串.index(子串,起始位置,结束位置)    返回开始的索引值，没找到则抛出异常。        print([i, nums[i + 1:].index(target - j) + i + 1])print('******')# .items 处理可遍历的字典，返回元组数组。dictionary = {'Name': 'Runoob', 'Age': 7}print(\"Value : %s\" % dictionary.items())# Value : dict_items([('Name', 'Runoob'), ('Age', 7)])print(type(dictionary.items()), dictionary.items())# &lt;class 'dict_items'&gt; dict_items([('Name', 'Runoob'), ('Age', 7)])def print_kwargs(**kwargs):    print(type(kwargs), kwargs)    for key, val in kwargs.items():        print('{}：{}'.format(key, val))print('---------')print_kwargs(a=1, b=2)  # 法一# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a：1# b：2print('---------')print_kwargs(**dict(a=1, b=2))  # 法二 字典打包成关键字参数# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a：1# b：2def print_all(a, *args, **kwargs):    print(a)    if args:        print(args)    if kwargs:        print(kwargs)print('--------')print_all('hello', 'world', name='cyf')# hello# ('world',)seasons = ['Spring', 'Summer', 'Fall', 'Winter']print(enumerate(seasons))  # &lt;enumerate object at 0x00000217ADAB6F40&gt;print(list(enumerate(seasons)))  # 下标从 0 开始# [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]print(list(enumerate(seasons, start=1)))  # 下标从 1 开始# [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]# for 循环使用 enumerate的对象for i, val in enumerate(seasons):    print(i, seasons[i])# 0 Spring# 1 Summer# 2 Fall# 3 Winter# for 循环使用 enumerate对象的列表print('------')for i, val in list(enumerate(seasons)):    print(i, seasons[i])# 0 Spring# 1 Summer# 2 Fall# 3 Winteri = 0print('------')for val in seasons:  # 普通的 for 循环，不使用 enumerate    print(i, seasons[i])    i += 1# 0 Spring# 1 Summer# 2 Fall# 3 Winterdef print_multiple_args(*args):    print(type(args), args)    for k, val in enumerate(args):        print(k, val)print('======')print_multiple_args('a', 'b', 'c')  # 法一print('======')print_multiple_args(*['a', 'b', 'c'])  # 法二 列表打包成关键字参数# 给定一个整数数组和一个目标值，找出数组中和为目标值的两个整数，并返回它们的数组下标nums = [1, 2, 5, 6, 4, 3]target = 8print('-----')for i, j in enumerate(nums):    if target - j in nums[i + 1:]:        # 字符串.index(子串,起始位置,结束位置)    返回开始的索引值，没找到则抛出异常。        print([i, nums[i + 1:].index(target - j) + i + 1])print('******')# .items 处理可遍历的字典，返回元组数组。dictionary = {'Name': 'Runoob', 'Age': 7}print(\"Value : %s\" % dictionary.items())# Value : dict_items([('Name', 'Runoob'), ('Age', 7)])print(type(dictionary.items()), dictionary.items())# &lt;class 'dict_items'&gt; dict_items([('Name', 'Runoob'), ('Age', 7)])def print_kwargs(**kwargs):    print(type(kwargs), kwargs)    for key, val in kwargs.items():        print('{}：{}'.format(key, val))print('---------')print_kwargs(a=1, b=2)  # 法一# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a：1# b：2print('---------')print_kwargs(**dict(a=1, b=2))  # 法二 字典打包成关键字参数# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a：1# b：2def print_all(a, *args, **kwargs):    print(a)    if args:        print(args)    if kwargs:        print(kwargs)print('--------')print_all('hello', 'world', name='cyf')# hello# ('world',)# {'name': 'cyf'}\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"ftp","url":"https://bubbleboy11.github.io/2020/08/21/ftp/","content":"FTP是应用层的一个文件传输协议。其主要作用是在服务器和客户端之间实现文件的传输和共享。FTP协议运行在TCP连接上,保证了文件传输的可靠性。FTP支持两种方式的传输:\n\n文本方式\n二进制方式\n\nFTP有两种传输模式:\n\n主动模式的核心是TFP客户端告诉服务端自己开发那个端口作为数据端口,然后让服务端来连接自己 \n和被动模式 连接的核心是控制连接请求和数据连接请求都是由客户端发起。\n\nFTP局限性:当客户端用户数量不断增多,FTP服务器所要维持的会话总数,也会迅速增长。会大大限制FTP服务器的性能。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["计算机网络"],"tags":["剑指offer","Leetcode"]},{"title":"hexo 常用命令","url":"https://bubbleboy11.github.io/2020/08/21/hexo-chang-yong-ming-ling/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new $ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n1$ hexo s\n\nMore info: Server\nGenerate static files1$ hexo generate\n1$ hexo g\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n1$ hexo d\nMore info: Deployment\nclean to remote sites1$ hexo clean\n\nMore info: Deployment\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["hexo"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/html/","content":"\ntitle: HTMLdate: 2020-08-20 16:21:41author: 外心人Dtoc: truemathjax: falsesummary: 爱编程categories: Markdowntags:\n\nLeetcode\n剑指offer\n\n\nhtml在vscode没有高亮，右下角语言模式把django html切换成htmllive Server可以本地服务器的形式来运行html文件,或者项目,实现边改边在浏览器看见效果。打开浏览器进行预览和调试页面。这个插件就可以实现静态、动态页面的实时预览，保存就能看见页面更新，不需要手动去刷新。\njs中用/**表示方法的注释\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/http-huan-cun/","content":"\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/http/","content":"HTTP HyperText Transfer Protocol 超文本传输协议HTTP是基于TCP/IP的关于数据如何在万维网（WWW:World Wide Web ）中如何通信的协议，用来传递来传递数据（HTML 文件, 图片文件, 查询结果等）。是用于从万维网服务器传输超文本到本地浏览器。默认80端口它可以使浏览器更加高效，使网络传输减少。保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。HTTP是一个基于“请求与响应”模式的、无状态的应用层协议HTTP协议采用URL作为定位网络资源的标识以明文的形式传输 效率更高，但是不安全\n-HTTPS:HTTP + SSL用安全套接字层传送的超文本传输协议，传输之前采用证书密钥加密数据 ，之后解密获取内容默认端口：443-安全 效率较低，\nHttp与Https的区别：\n\n   HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头\n   HTTP 是不安全的，而 HTTPS 是安全的\n   HTTP 标准端口是80 ，而 HTTPS 的标准端口是443\n   在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层\n   HTTP 无法加密，而HTTPS 对传输的数据进行加密\n   HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书\n\nHTTP协议由哪些部分组成？可以使用抓包工具去查看和理解HTTP 请求的组成：状态行、请求头、消息主体HTTP 响应的组成：状态行、响应头、响应正文\n​- 请求头之间：\\r\\n​- 请求头与请求体：\\r\\n\\r\\n\n① 在命令行下查看HTTP协议，可以使用 curl 或 http 命令发起HTTP请求\n1[root@localhost ~][root@localhost ~]# curl www.baidu.com    # 使用curl发起HTTP请求\n② 使用http 命令需要首先安装httpie，然后在通过http命令发起HTTP请求\n12[root@localhost ~]# pip install httpie      # 安装httpie[root@localhost ~][root@localhost ~]# pip install httpie      # 安装httpie[root@localhost ~]# http baidu.com          # 使用http发起HTTP请求\n查看HTTP协议详细输出过程， http -v 详细输出过程\n12345678910111213141516171819202122232425[root@localhost ~]# http -v baidu.comGET / HTTP/1.1               # 状态行包括请求方法、路径、http版本Accept: */*                  # 3~7行是http的请求头Accept-Encoding: gzip, deflate    # 接收的编码Connection: keep-alive            # 连接，Host: baidu.com                   # 域名User-Agent: HTTPie/1.0.2          # 请求的代理# 空一行 # 消息主体（不一定又），这里为空没有显示，一般是由GET请求的时候它就没有消息主体-------------------------------------------------------------------------------------HTTP/1.1 200 OK                  # 响应行 下面是HTTP响应Accept-Ranges: bytes             # 3~7行是http的响应头Cache-Control: max-age=86400Connection: Keep-AliveContent-Length: 81Content-Type: text/htmlDate: Fri, 02 Aug 2019 10:07:15 GMTETag: \"51-47cf7e6ee8400\"Expires: Sat, 03 Aug 2019 10:07:15 GMTLast-Modified: Tue, 12 Jan 2010 13:48:00 GMTServer: Apache# 空一行 &lt;html&gt;         # 响应正文。返回的是一个HTML&lt;meta http-equiv=\"refresh\" content=[root@localhost ~]# http -v baidu.comGET / HTTP/1.1               # 状态行包括请求方法、路径、http版本Accept: */*                  # 3~7行是http的请求头Accept-Encoding: gzip, deflate    # 接收的编码Connection: keep-alive            # 连接，Host: baidu.com                   # 域名User-Agent: HTTPie/1.0.2          # 请求的代理# 空一行 # 消息主体（不一定又），这里为空没有显示，一般是由GET请求的时候它就没有消息主体-------------------------------------------------------------------------------------HTTP/1.1 200 OK                  # 响应行 下面是HTTP响应Accept-Ranges: bytes             # 3~7行是http的响应头Cache-Control: max-age=86400Connection: Keep-AliveContent-Length: 81Content-Type: text/htmlDate: Fri, 02 Aug 2019 10:07:15 GMTETag: \"51-47cf7e6ee8400\"Expires: Sat, 03 Aug 2019 10:07:15 GMTLast-Modified: Tue, 12 Jan 2010 13:48:00 GMTServer: Apache# 空一行 &lt;html&gt;         # 响应正文。返回的是一个HTML&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\">\nfiddler保存HTTP请求文本打开测试页面→到Fiddler中选中该请求→Shift+Del清空其他请求→右键→Save→Selected Sessions→as Text…  \n提交一些表单的时候HTTP请求里面就会包含消息主体。\n发送一个POST请求，带上hello=World参数\n123456789101112131415161718192021222324252627[root@localhost ~]# http -f POST baidu.com hello=World -v POST / HTTP/1.1                  # 请求状态行Accept: */*                      # 3~9是请求头Accept-Encoding: gzip, deflateConnection: keep-aliveContent-Length: 11Content-Type: application/x-www-form-urlencoded; charset=utf-8Host: baidu.comUser-Agent: HTTPie/1.0.2 hello=World                    # 消息主体，当然有时候可以为空------------------------------------------------------------------------------HTTP/1.1 200 OK           # 响应状态行，包括HTTP版本、状态码200、OK表示成功Accept-Ranges: bytes      # 14~23是响应头Cache-Control: max-age=86400Connection: Keep-AliveContent-Length: 81Content-Type: text/htmlDate: Fri, 02 Aug 2019 10:13:42 GMTETag: \"51-47cf7e6ee8400\"Expires: Sat, 03 Aug 2019 10:13:42 GMTLast-Modified: Tue, 12 Jan 2010 13:48:00 GMTServer: Apache &lt;html&gt;         # 响应正文。返回的是一个HTML&lt;meta http-equiv=\"refresh\" content=[root@localhost ~]# http -f POST baidu.com hello=World -v POST / HTTP/1.1                  # 请求状态行Accept: */*                      # 3~9是请求头Accept-Encoding: gzip, deflateConnection: keep-aliveContent-Length: 11Content-Type: application/x-www-form-urlencoded; charset=utf-8Host: baidu.comUser-Agent: HTTPie/1.0.2 hello=World                    # 消息主体，当然有时候可以为空------------------------------------------------------------------------------HTTP/1.1 200 OK           # 响应状态行，包括HTTP版本、状态码200、OK表示成功Accept-Ranges: bytes      # 14~23是响应头Cache-Control: max-age=86400Connection: Keep-AliveContent-Length: 81Content-Type: text/htmlDate: Fri, 02 Aug 2019 10:13:42 GMTETag: \"51-47cf7e6ee8400\"Expires: Sat, 03 Aug 2019 10:13:42 GMTLast-Modified: Tue, 12 Jan 2010 13:48:00 GMTServer: Apache &lt;html&gt;         # 响应正文。返回的是一个HTML&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\">\n\n\nHTTP常见状态码status code\n\n1** 信息。服务器收到请求，需要请求者继续执行操作。\n\n2** 请求成功。操作被成功接受并处理。 \n\n3** 重定向。需要进一步操作完成请求。\n\n4** 客户端错误,请求错误示,请求⽅式不被允许，请求有语法错误或者无法完成请求，服务器无法处理请求\n\n5** 服务器错误。服务器在处理请求的过程中发生错误。\n\n\n200(ok) – 请求已成功，请求所希望的响应头或数据体将随此响应返回201(created) – 而且有一个新的资源已经依据请求的需要而建立 post新建成功202(accepted) – 已接收处理请求但尚未完成（异步处理），put跟新成功301(moved permanently) – 资源的URI被更新 永久重定向,302临时重定向,对象临时移动。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303(see other) – 其他（如负载均衡）304(Not Modified) – 没有变化，客户端可以使用缓存数据属于重定向。自上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容\n400(Bad Request) – 指代坏请求，参数错误，确切的错误应该在error payload中描述，例如：“JSON 不合法 ”\n401(Unauthorized) – 访问的页面或资源没有授权认证，当前请求需要用户验证，\n403(Forbidden) – 服务器已经理解请求，但是拒绝执行 被禁止，没有权限访问这个页面 \n404(not found) – 请求的页面或资源没找到\n406(not acceptable) – 服务端不支持所需表示,请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体409 (conflict) - 通用冲突412(precondition failed) – 服务器在验证请求头中给出先决条件时，没能满足其中的一个或多个, 前置条件失败（如执行条件更新时的冲突）\n415(unsupported media type) - 请求中提交的实体并不是服务器中所支持的格式(请求中的内容类型是错误的)\n500(Internal Server Error) – 服务器内部错误，服务器遇到错误，无法完成请求。503(service unavailable) - 服务不可用，当前无法处理请求（临时的服务器维护或者过载）505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\nHTTP persistent connection， HTTP1.1实现长连接短连接：建立连接…数据传输…关闭连接(连接的建立和关闭开销大)\n长连接：Connection：Keep-alive。保持 TCP 连接不断开如何区分不同的 HTTP 请求呢？Content-Length | Transfer-Encoding:chunked。\nContent-Length首部告诉浏览器报文中实体主体的大小\n第一种情况 就是客户端告诉服务端发送的 HTTP 请求多长(Content-Length)，接收这么多字节之后就认为你这次HTTP请求就结束了。(静态发送)非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n第二种情况 请求是动态发送的不知道有多长，HTTP提供了一种分段发送方式(| Transfer-Encoding:chunked),每次发送一个chunk size和chunk body告诉每一次发送多长和发送的内容是什么，直到chunksize为0的时候，服务端就认为结束了。(动态发送)\n当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。\ncookie 和 session 区别HTTP是无状态的，每次发送HTTP实际和之前的HTTP请求都没有什么关系，如何识别用户呢？HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n需要在服务端给用户生成一个标识，然后每次让客户端带过去给后端，识别用户会话。用户会话就是用户识别的一种方式。\nSession“会话控制” 一般是服务器生成之后给客户端 （通过 url参数或cookie）对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。\nCookie 是实现 session 的一种机制，通过 HTTP cookie 字段实现类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息用来存储用户信息的，每次请求会被携带上发送给对方的 浏览器-要获取登录后才能访问的页面-对方的服务器会通过cookie来判断是我们是一个爬虫Cookie不能存储对象Cookie被禁用了怎么办Cookie可能会被浏览器禁用。客户端禁用cookie采用url重写的方式 ，也就是上面说的将sessionid写在url上，用户登陆之后，需要将用户的信息存到Cookie中，但因为Cookie中只能存储字符串，所以想到了先把用户实体序列化成Json串，存储在Cookie中，用到的时候再拿出来反序列化。\nsession数据sessionid 识别用户 放在服务器cookie数据存放在客户的浏览器上，在客户端的Cookie 中存储session id，以此来标记服务器的哪个session 文件是当前用户的。（session 文件：session 存储介质视服务器而定）\nCookie 减轻服务器存储压力，一般存储安全性要求不高的数据。Session 存储安全性较高的数据。\n单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。Session没有大小限制\nHTTP Header\n\nAccept：指定客户端能够接收的内容类型\nAccept-Charset：浏览器可以接受的字符编码集。\nAuthorization: HTTP 授权的授权证书\nContent-type：请求的与实体对应的 MIME 信息，发送端实际发送的数据类型\nReferer：先前网页的地址，当前请求网页紧随其后，即来路 防盗链\n\n响应头信息content-Type: 服务器响应回客户端的数据类型\n\napplication/x-www-form-urlencoded: 请求默认方式，数据是简单、平面的key-value键值对\napplication/json: 数据是复杂的嵌套关系，有多层数据\nmultipart/form-data 既可发送文本数据，也支持二进制数据上载\n\n请求头信息User-Agent:用户代理：知道当前请求对方资源的是什么浏览器，请求载体的身份标识Connection：请求完毕后，是断开连接还是保持连接\n浏览器的请求-url-在chrome中点击检童，点到network,-url =谓求的协议+网站的域名+资源的路径+参数\n-浏览器谓求url地址\n-当前url对应的晌应+js+css+图片—》elements中的内容-爬虫谓求url地址-当前url对应的晌应\n\nelements的内容和爬虫获取到的url地址的晌应不同，爬虫中需要以当 前url地址对应的响应为准提取数据\n\n-当前url地址对应的晌应在哪里\n-从network中找到当前的url地址，点击response-在页面上右键显示网页源码\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"java基础","url":"https://bubbleboy11.github.io/2020/08/21/java-ji-chu/","content":"JVM Java Virtual Machine java虚拟机JVM是java平台无关性实现的关键\nJava程序执行过程源文件.java 编译器compiler 字节码文件.class 解释器interpreter 程序\nJDK Java Development Kit 软件开发工具包两个主要主键\n\njavac 编译器，将源程序转化为字节码\njava 运气编译后的java程序 (.class后缀的)\n\nJRE Java Runtime Environment包括Java虛拟机(JVM)、Java核心类库和支持文件如果只需要运行Java程序,下载并安装JRE即可如果要开发Java软件，需要下载JDK在JDK中附带有JRE\nJRE = JVM+ Javase标准类库JDK = JRE+开发工具集(例如 Javac编译工具等)\nJava se Java标准版 桌面程序Java ee Java企业版 Web程序Java me Java微型版 为移动设备提供了基于Java环境的开发与应用平台\n编码流程：创建java项目：java project （src 是存放源文件）创建程序包：src目录下右击建（package程序包）编写java源程序：package目录下右击建（class源代码文件）运行java程序：源文件空白处右击选择run as -&gt;java anclication 运行成功（1）创建一个java Project（2）src——创建包java package （Eclipse中的src是用来放置我们的源代码文件；关于Package包名：域名的反向例如：com.imoocclass命名：文件开头大写）（3）在包下创建类Java class（4）编写Java源程序：\n1234public class HelloWord{public static void main(String[] args){\\System.out.println(public class HelloWord{public static void main(String[] args){\\System.out.println(\"I Love Imooc\");} \n12345678910111213141516package com.imooc;public class HelloImooc {    public static void main(String[] args) {        System.out.println(\"Hello,imooc!\");        System.out.println(\"我爱学Java!\");            String a =\"hello\";       String b =\"www.imooc.com\";    System.out.println(a+\"\\n\"+b);    }}// cd C:\\python代码\\步骤4 Flask基础及项目实战\\Java初识-src\\ImoocProj\\src// 编译:C:\\code&gt;javac com/imooc/HelloImooc.javapackage com.imooc;public class HelloImooc {    public static void main(String[] args) {        System.out.println(\"Hello,imooc!\");        System.out.println(\"我爱学Java!\");            String a =\"hello\";       String b =\"www.imooc.com\";    System.out.println(a+\"\\n\"+b);    }}// cd C:\\python代码\\步骤4 Flask基础及项目实战\\Java初识-src\\ImoocProj\\src// 编译:C:\\code&gt;javac com/imooc/HelloImooc.java// 运行:C:\\code>java com.imooc.HelloImooc\n\n\nJava中的关键字是有对编译器有特殊意义的词，区分大小写class是用来定义类的关键字，编译器遇到class就知道这是创建定义了一个类。public可以删掉，公共的static 定义静态成员的关键字main 主方法定义，程序的入口void 方法返回值的关键字，但 Void 就不是了System首字母大写\n\n保留字是Java预留的关键字，虽然现在还没有作为关键字，但是以后的升级版本中会成为关键字保留字包括：goto、const\n程序的移植导出：找到项目右击-&gt;properties-&gt;location处显示的就是文件位置-&gt;拷贝-&gt;删除源程序（可略）导入：右侧空白处-&gt;import-&gt;General-&gt;exiting Projects into workspace-&gt;找到导入的项目-&gt;导入\n使用标识符identifier 时，需要遵守几条规则：\n&nbsp;标识符首字母可以是字母、下划线（_）、美元符（$），加上任意多的数字字母、下划线（_）、美元符（$）组成但不能包含下划线（_）、美元符（$）以外的其它特殊字符开头， @、%、空格等不能以数字开头。譬如：123name&nbsp;就是不合法滴\n\n&nbsp;标识符不能是 Java 关键字和保留字，但可以包含关键字和保留字。如：不可以使用&nbsp;void&nbsp;作为标识符，但是&nbsp;Myvoid&nbsp;可以\n\n变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，称驼峰命名法），如 myAge\n\n变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 stuName&nbsp;保存“学生姓名”信息\n\n\nprint(x)输出后不换行print(x + '\\n')输出后不换行println()换行println(x)输出后换行\n常量：指程序里持续不变的值在整个程序运行过程中它是不可改变的。在声明数定量或变量时，必须制定数据类型。final关键字修饰的常量无法再次赋值\n常量名的命名规则变量名用大写\n        final int N = 6;\n        final double PI = 3.14159;\n        final double MIN_VALUE = 0;\n\n变量：在程序运行过程中随时发生变化的来量，程序中数据的临时存放场所申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。java变量先定义后使用\n变量的三个元素：变量类型、变量名和变量值。通过定义不同类型的变量，可以在内存中储存整数、小数或者字符变量 存的是数据值，直接放在抽屉里的东西 入住的客人变量名，抽屉名字 房间名变量类型 房价类型\n变量名的命名规则\n满足标识符命名规则\n符合驼峰法命名规范，一个单词所有字母小写，多个单词第一个单词全部小写，后面的单词首字母大写，age,stuName\n尽量简单，做到见名知意\n变量名的长度没有限制\n\n类的命名规则\n满足Pascal命名法规范当类名是一个单词，首字母大写，多个单词组成，每一个首字母大写\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["java"],"tags":["剑指offer","Leetcode"]},{"title":"jenkins","url":"https://bubbleboy11.github.io/2020/08/21/jenkins/","content":"浏览器地址栏输入localhost:8080/restart等于在win10管理中找到jenkins右键重启\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["测试"],"tags":["剑指offer","Leetcode"]},{"title":"json","url":"https://bubbleboy11.github.io/2020/08/21/json/","content":"JSON JavaScript Object Notation, JS 对象标记它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。JSON 是存储和交换文本信息的语法，类似 XML。是轻量级的文本数据交换格式。\nJSON载体/表现形式：JSON字符串，是指符合JSON格式的字符串JSON中只能使用双引号\"\"，不能用单引号''\nJSON优势：\n\n比 XML 更小、更快，\n网络传输效率高，\n简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 适合跨语言交换数据\n易于人阅读和编写，\n易于机器解析和生成\n\nPython中内置了json这个库\nfp, *, skipkeys123456789101112131415indent参数表示转换后缩进单位```json.dumps(obj, separators=(',', ':')))```紧凑编码，去除json.dumps()生成的空格有非ascii码字符，比如中文，默认就用该字符的unicode数字来表示。想输出真正的中文需要用Unicode字符串，禁用ascii编码```ensure_ascii = False``````pyprint(json.dumps('中文'))# \"\\u4e2d\\u6587\"  对应的ascii 字符码print(json.dumps('中文', ensure_ascii=False))# \"中文\"print('中文'.encode('unicode_escape'))# b'\\\\u4e2d\\\\u6587'print('中文'.encode('unicode-escape'))# b'\\\\u4e2d\\\\u6587'\n\n1234567891011121314151617181920212223242526272829303132333435363738import jsonhistoryTransactions = [    {        'time': '20170101070311',  # 交易时间        'amount': '3088',  # 交易金额        'productid': '45454455555',  # 货号        'productname': 'iphone7'  # 货名    },    {        'time': '20170101050311',  # 交易时间        'amount': '18',  # 交易金额        'productid': '453455772955',  # 货号        'productname': '奥妙洗衣液'  # 货名    }]json_str = json.dumps(historyTransactions)print(type(json_str))  # &lt;class 'str'&gt;print(json_str)# [{\"time\": \"20170101070311\", \"amount\": \"3088\", \"productid\": \"45454455555\", \"productname\": \"iphone7\"}, {\"time\": \"20170101050311\", \"amount\": \"18\", \"productid\": \"453455772955\", \"productname\": \"\\u5965\\u5999\\u6d17\\u8863\\u6db2\"}]json_str = json.dumps(historyTransactions, ensure_ascii=False, indent=4)print(type(json_str))  # &lt;class 'str'&gt;print(json_str)# [#     {#         \"time\": \"20170101070311\",       #         \"amount\": \"3088\",#         \"productid\": \"45454455555\",     #         \"productname\": \"iphone7\"        #     },#     {#         \"time\": \"20170101050311\",       #         \"amount\": \"18\",#         \"productid\": \"453455772955\",    #         \"productname\": \"奥妙洗衣液\"     #     }import jsonhistoryTransactions = [    {        'time': '20170101070311',  # 交易时间        'amount': '3088',  # 交易金额        'productid': '45454455555',  # 货号        'productname': 'iphone7'  # 货名    },    {        'time': '20170101050311',  # 交易时间        'amount': '18',  # 交易金额        'productid': '453455772955',  # 货号        'productname': '奥妙洗衣液'  # 货名    }]json_str = json.dumps(historyTransactions)print(type(json_str))  # &lt;class 'str'&gt;print(json_str)# [{\"time\": \"20170101070311\", \"amount\": \"3088\", \"productid\": \"45454455555\", \"productname\": \"iphone7\"}, {\"time\": \"20170101050311\", \"amount\": \"18\", \"productid\": \"453455772955\", \"productname\": \"\\u5965\\u5999\\u6d17\\u8863\\u6db2\"}]json_str = json.dumps(historyTransactions, ensure_ascii=False, indent=4)print(type(json_str))  # &lt;class 'str'&gt;print(json_str)# [#     {#         \"time\": \"20170101070311\",       #         \"amount\": \"3088\",#         \"productid\": \"45454455555\",     #         \"productname\": \"iphone7\"        #     },#     {#         \"time\": \"20170101050311\",       #         \"amount\": \"18\",#         \"productid\": \"453455772955\",    #         \"productname\": \"奥妙洗衣液\"     #     }# ]\n\njson.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])反序列化，JSON编码的字符串解码转换回一个Python数据结构对象\n1234567import jsonjsonstr = '[{\"time\": \"20170101070311\", \"amount\": \"3088\", \"productid\": \"45454455555\", \"productname\": \"iphone7\"}, {\"time\": \"20170101050311\", \"amount\": \"18\", \"productid\": \"453455772955\", \"productname\": \"\\u5965\\u5999\\u6d17\\u8863\\u6db2\"}]'translist = json.loads(jsonstr)print(type(translist))  # &lt;class 'list'&gt;print(translist)import jsonjsonstr = '[{\"time\": \"20170101070311\", \"amount\": \"3088\", \"productid\": \"45454455555\", \"productname\": \"iphone7\"}, {\"time\": \"20170101050311\", \"amount\": \"18\", \"productid\": \"453455772955\", \"productname\": \"\\u5965\\u5999\\u6d17\\u8863\\u6db2\"}]'translist = json.loads(jsonstr)print(type(translist))  # &lt;class 'list'&gt;print(translist)# [{'time': '20170101070311', 'amount': '3088', 'productid': '45454455555', 'productname': 'iphone7'}, {'time': '20170101050311', 'amount': '18', 'productid': '453455772955', 'productname': '奥妙洗衣液'}]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566object -- 对象。返回一个对象的 string 格式。```__repr__```返回字符串的字面值，```'\\'```变成```'\\\\'```的转义字符串。```pyimport jsonprint(json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}]))# [\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]print(json.dumps(\"\\\"foo\\bar\"))# \"\\\"foo\\bar\"print(json.dumps('\\u1234'))# \"\\u1234\"print(type(json.dumps('\\u1234')))# print(repr(json.dumps('\\u1234')))# '\"\\\\u1234\"'print(type(repr(json.dumps('\\u1234'))))# print(json.dumps('\\\\'))# \"\\\\\"print(repr(json.dumps('\\\\')))# '\\\\\\\\'print(type(repr(json.dumps('\\\\'))))# print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))# {\"a\": 0, \"b\": 0, \"c\": 0}data1 = {'no': 1, 'name': 'Runoob', 'url': 'http://www.runoob.com'}print(\"Python 原始数据：\", repr(data1))# Python 原始数据： {'no': 1, 'name': 'Runoob', 'url': 'http://www.runoob.com'}print(type(repr(data1)))  # # Python 字典类型转换为 JSON 对象json_str = json.dumps(data1)print(\"JSON 对象：\", json_str)# JSON 对象： {\"no\": 1, \"name\": \"Runoob\", \"url\": \"http://www.runoob.com\"}print(type(json_str))  # # 将 JSON 对象转换为 Python 字典data2 = json.loads(json_str)print(data2)# {'no': 1, 'name': 'Runoob', 'url': 'http://www.runoob.com'}print(type(data2))  # print(\"data2['name']: \", data2['name'])# data2['name']:  Runoobprint(\"data2['url']: \", data2['url'])# data2['url']:  http://www.runoob.com# 紧凑编码，去除json.dumps()生成的空格print(json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':')))# [1,2,3,{\"4\":5,\"6\":7}]data2 = json.dumps({'a': 'Ashe', 'b': 7}, sort_keys=True, indent=4, separators=(',', ': '))print(data2)# {#     \"a\": \"Ashe\",#     \"b\": 7# }\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["json"]},{"title":"lambda","url":"https://bubbleboy11.github.io/2020/08/21/lambda/","content":"匿名函数：lambda参数:表达式匿名函数有个限制，就是只能有一个表达式，不能是语句或代码块，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：\n无参匿名函数:\n1234t = lambda: True  #冒号前无任何参数print(t())  # Truet = lambda: 1  # 冒号前无任何参数print(t())  t = lambda: True  #冒号前无任何参数print(t())  # Truet = lambda: 1  # 冒号前无任何参数print(t())  # 1\n等价于下面的def定义的函数\n12345def func():    return Trueprint(func())  def func():    return Trueprint(func())  # True\n\n12345678s = \"this is\\na\\ttest\"print(s)# this is# a       testprint(s.split())  # split函数默认以空格分割成列表，换行符，TAB# ['this', 'is', 'a', 'test']print(' '.join(s.split()))  # 用join函数转一个列表为字符串s = \"this is\\na\\ttest\"print(s)# this is# a       testprint(s.split())  # split函数默认以空格分割成列表，换行符，TAB# ['this', 'is', 'a', 'test']print(' '.join(s.split()))  # 用join函数转一个列表为字符串# 'this is a test'\n等价于\n123f1 = (lambda s: ' '.join(s.split()))(\"this is\\na\\ttest\")print(f1)f1 = (lambda s: ' '.join(s.split()))(\"this is\\na\\ttest\")print(f1)# 'this is a test'\n\n123456# 普通python函数def func(a, b, c):    return a + b + cprint(func(1, 2, 3))  # 普通python函数def func(a, b, c):    return a + b + cprint(func(1, 2, 3))  # 6\n\n匿名函数调用：直接赋值给一个变量，然后再像一般函数调用\n1234567891011f1 = lambda x: x**3  # 一个参数print(f1(3))  # 27f2 = lambda x, y, z: x + y + z  # 多个参数print(f2(1, 2, 3))  # 6f3 = lambda x, y=3: x * y  # 允许参数存在默认值print(f3(1))  # 3f4 = lambda x, y=3: x * y  # 允许参数存在默认值print(f4(1, 5))  f1 = lambda x: x**3  # 一个参数print(f1(3))  # 27f2 = lambda x, y, z: x + y + z  # 多个参数print(f2(1, 2, 3))  # 6f3 = lambda x, y=3: x * y  # 允许参数存在默认值print(f3(1))  # 3f4 = lambda x, y=3: x * y  # 允许参数存在默认值print(f4(1, 5))  # 5\n\n123a = lambda *z: z  # *z返回的是一个元祖print(a('Testing1', 'Testing2'))a = lambda *z: z  # *z返回的是一个元祖print(a('Testing1', 'Testing2'))#  ('Testing1', 'Testing2')\n\n1234567891011121314151617c = lambda **Arg: Arg  # arg返回的是一个字典print(c())# {}#直接后面传递实参print((lambda x:x**2)(3))  # 9print((lambda x,y: x if x&gt; y else y)(101,102))  #  102print([x for x in [1, 2, 3, 4, 5, 6] if x % 3 == 0])  # [3, 6]# lambda返回的值，结合map,filter,reduce使用 等价于下面的列表推导式# filter 函数传入两个参数，第一个参入的是lambda函数，第二个参数是列表print(filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6]))  # [3, 6]f1 = filter(lambda x: True if x != 0 else False, [1, 0, 2, 0, 5, 0, 0])print(f1)  # &lt;filter object at 0x000001C27B35DAC0&gt;print(list(f1))  c = lambda **Arg: Arg  # arg返回的是一个字典print(c())# {}#直接后面传递实参print((lambda x:x**2)(3))  # 9print((lambda x,y: x if x&gt; y else y)(101,102))  #  102print([x for x in [1, 2, 3, 4, 5, 6] if x % 3 == 0])  # [3, 6]# lambda返回的值，结合map,filter,reduce使用 等价于下面的列表推导式# filter 函数传入两个参数，第一个参入的是lambda函数，第二个参数是列表print(filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6]))  # [3, 6]f1 = filter(lambda x: True if x != 0 else False, [1, 0, 2, 0, 5, 0, 0])print(f1)  # &lt;filter object at 0x000001C27B35DAC0&gt;print(list(f1))  # [1, 2, 5]\n\n嵌套使用\n1234567#lambda嵌套到普通函数中,lambda函数本身做为return的值def increment(n):    return lambda x: x + nf = increment(4)print(f(2))  #lambda嵌套到普通函数中,lambda函数本身做为return的值def increment(n):    return lambda x: x + nf = increment(4)print(f(2))  # 6\n\n12345678def say():    title = 'Sir, '    action = lambda x: title + x    return actionact = say()print(act('Smith!'))  def say():    title = 'Sir, '    action = lambda x: title + x    return actionact = say()print(act('Smith!'))  # 'Sir,Smith!'\n\n大量例子:\n例01: 字符串联合，有默认值，也可以x=(lambda…)这种格式\n\n\n\nx = (lambda x=”Boo”,y=”Too”,z=”Zoo”: x+y+z)x(“Foo”)‘FooTooZoo’\n\n\n\n例02: 和列表联合使用\n\n\n\nL = [lambda x:x2,lambda x:x3,lambda x:x**4]\n\n\n\n\n\n\nfor f in L:… print f(2)…4816\n\n\n\n也可以如下面这样调用\n\n\n\nprint L09\n\n\n\n例03: 和字典结合使用\n\n\n\nkey = ‘B’dic = { ‘A’: lambda: 22,… ‘B’: lambda: 24,… ‘C’: lambda: 2*8}dickey8\n\n\n\n例04: 求最小值\n\n\n\nlower = lambda x,y: x if x&lt;y else ylower(‘aa’,’ab’)‘aa’\n\n\n\n例05: 和map及list联合使用\n\n\n\nimport sysshowall = lambda x:list(map(sys.stdout.write,x))showall([‘Jerry\\n’,’Sherry\\n’,’Alice\\n’])JerrySherryAlice\n\n\n\n\n\n\nshowall([‘Jerry’,’Sherry’,’Alice’])JerrySherryAlice\n\n\n\n等价于下面\n\n\n\nshowall = lambda x: [sys.stdout.write(line) for line in x]showall((‘I\\t’,’Love\\t’,’You!’))I Love You![None, None, None]\n\n\n\n例06: 在Tkinter中定义内联的callback函数\nimport sysfrom Tkinter import Button,mainloop\nx = Button(text=’Press me’,command=(lambda:sys.stdout.write(‘Hello,World\\n’)))x.pack()x.mainloop()\n\n\n\n\n\n\nHello,World!\nHello,World!\n例07: lambda和map联合使用,\n\n\n\n out = lambda *x: sys.stdout.write(‘ ‘.join(map(str,x)))out(‘This’,’is’,’a’,’book!\\n’)This is a book!\n\n\n\n例08: 判断字符串是否以某个字母开头\n\n\n\nprint (lambda x: x.startswith(‘B’))(‘Bob’)True\n\n\n\n\n\n\n\nNames = [‘Anne’, ‘Amy’, ‘Bob’, ‘David’, ‘Carrie’, ‘Barbara’, ‘Zach’]B_Name= filter(lambda x: x.startswith(‘B’),Names)B_Name[‘Bob’, ‘Barbara’]\n\n\n\n例09: lambda和map联合使用:\n\n\n\n squares = map(lambda x:x**2,range(5))squares[0, 1, 4, 9, 16]\n\n\n\n例10. lambda和map,filter联合使用:\n\n\n\n squares = map(lambda x:x**2,range(10))filters = filter(lambda x:x&gt;5 and x&lt;50,squares)filters[9, 16, 25, 36, 49]\n\n\n\n例11. lambda和sorted联合使用\n#按death名单里面，按年龄来排序\n#匿名函数的值返回给key，进来排序\n\n\n\ndeath = [ (‘James’,32),(‘Alies’,20),(‘Wendy’,25)]\n\n\n\n\n\n\nsorted(death,key=lambda age:age[1]) #按照第二个元素，索引为1排序[(‘Alies’, 20), (‘Wendy’, 25), (‘James’, 32)]\n\n\n\n例12. lambda和reduce联合使用\n\n\n\nL = [1,2,3,4]sum = reduce(lambda x,y:x+y,L)sum10\n\n\n\n例13. 求2-50之间的素数\n#素数:只能被1或被自己整除的数\n\n\n\nnums = range(2,50)for i in nums:nums = filter(lambda x:x==i or x % i,nums)nums[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n\n\n\n例14. 求两个列表元素的和\n\n\n\na = [1,2,3,4]b = [5,6,7,8]map(lambda x,y:x+y, a,b)[6, 8, 10, 12]\n\n\n\n例15. 求字符串每个单词的长度\n\n\n\nsentence = “Welcome To Beijing!”words = sentence.split()\n\n\n\n\n\n\nlengths = map(lambda x:len(x),words)lengths[7, 2, 8]\n\n\n\n写成一行:\n\n\n\n print map(lambda x:len(x),’Welcome To Beijing!’.split())\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"leetcode json 数据库","url":"https://bubbleboy11.github.io/2020/08/21/leetcode-json-shu-ju-ku/","content":"将leetcode案例的json格式数据转成数据库插入语句，并插入到数据库。\njson用例数据：\n12345678910111213141516171819202122232425262728{    \"headers\": {        \"student\": [            \"name\",            \"continent\"        ]    },    \"rows\": {        \"student\": [            [                \"Jane\",                \"America\"            ],            [                \"Pascal\",                \"Europe\"            ],            [                \"Xi\",                \"Asia\"            ],            [                \"Jack\",                {    \"headers\": {        \"student\": [            \"name\",            \"continent\"        ]    },    \"rows\": {        \"student\": [            [                \"Jane\",                \"America\"            ],            [                \"Pascal\",                \"Europe\"            ],            [                \"Xi\",                \"Asia\"            ],            [                \"Jack\",                \"America\"            ]        ]    }}\n\n123456789101112131415161718192021222324252627import jsondef get_mysql_sql_from_leetcodejson(json_str):    '''    json_str -- leetcode 题目的案例输入。通常是json串    输出 -- SQL插入串 insert ... values     '''    jo = json.loads(json_str)    res = []    for db_name in jo['headers'].keys():        col_list = jo['headers'][db_name]        sql = 'insert into %s (%s) values' %(db_name,','.join(col_list))        #print(sql)        values = []        for x in jo['rows'][db_name]:            tos = ['NULL' if y is None else '\\'%s\\'' % (y) for y in x]            values.append('(%s)' % (','.join(tos)))        sql += ','.join(values)+';'        res.append(sql)    return resjson_str = input('input leetcode json string:')for sql in get_mysql_sql_from_leetcodejson(json_str):    print(sql)# 输入上面的json用例数据，执行程序得出：import jsondef get_mysql_sql_from_leetcodejson(json_str):    '''    json_str -- leetcode 题目的案例输入。通常是json串    输出 -- SQL插入串 insert ... values     '''    jo = json.loads(json_str)    res = []    for db_name in jo['headers'].keys():        col_list = jo['headers'][db_name]        sql = 'insert into %s (%s) values' %(db_name,','.join(col_list))        #print(sql)        values = []        for x in jo['rows'][db_name]:            tos = ['NULL' if y is None else '\\'%s\\'' % (y) for y in x]            values.append('(%s)' % (','.join(tos)))        sql += ','.join(values)+';'        res.append(sql)    return resjson_str = input('input leetcode json string:')for sql in get_mysql_sql_from_leetcodejson(json_str):    print(sql)# 输入上面的json用例数据，执行程序得出：# insert into student (name,continent) values('Jane','America'),('Pascal','Europe'),('Xi','Asia'),('Jack','America');\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据库"],"tags":["Leetcode"]},{"title":"markdown","url":"https://bubbleboy11.github.io/2020/08/21/markdown/","content":"[toc]Table of Contents使用HTML中下标下标的语法即可。H2O  CO2AppleTM\n一级二级删除线（开启识别HTML标签时）下划线\n粗体斜体这里是行内代码print(\"hello world)\".这也是行内代码块print \"...\"这也是行内代码块print \"...\". \nstruct {  int year;  int month;  int day; }bdate;\n123Here are some code with tab at start.     Here are some code with Here are some code with tab at start.     Here are some code with 4 blank.\n\n123Here are some code with tab at start.  Here are some code with Here are some code with tab at start.  Here are some code with 4 blank.\n标准代码块表示使用空格/tab来开头的块状代码块,而不是``` ~~~.\nEnter就可以插入一个新的段落。按Shift+Enter可以创建一个比段落间距更小的行间距。换行方法1: 连续两个以上空格+回车方法2：使用html语言换行标签\n分割线：你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。\n\n\n\n\n\n链接：链接文字都是用 [方括号] 来标记，在方块括号后面紧接着圆括号并插入网址链接link to youtube  \n\n1.1 连接markdown\n1.2 连接markdown自定义所通往链接的网站标题i@typora.io\n\nAlt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。图片链接：可以是图片的本地地址或者是网址。“optional title”：鼠标悬置于图片上会出现的标题文字，可选标题，可以不写。\n插入本地图片只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图。\n插入互联网图片：\n把图片存入markdown文件用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。基础用法：这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。高级用法比如：![avatar][base64str][base64str]:data:image/png;base64,iVBORw0……\n幻灯片图片&lt;pic,pic,pic&gt;&lt;![image.png](/\">https://pic1.png,!image.png&gt;\n首行缩进两个字符：(每个表示一个空格，连续使用两个即可  半角的空格   两个半角的空格  全角的空格\n我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=7 face=”黑体”color=#00ffffcolor=gray  \n无序列表\n\nRed\nGreen\nBlue\n\n\nRed\nGreen\nBlue\n\n\nRed\nGreen\nBlue\n\n有序列表则使用数字加英文句点.来表示\n\nRed\nGreen\nBlue05. 可以使用：数字. 来取消显示为列表，在行前显示数字和 .  \n\n嵌套的列表\n\n第一层\n1-1\n\n\n1-2\n\n\n1-3\n\n\n\n\n第一层\n\n\n1-1\n1-2\n\n\n无序列表和有序列表可以随意相互嵌套\n2-1\n2-2\n\n\n\nhtml标签\n背景色是：orange\n\n  \n   \n      字段\n      必选\n      类型\n      说明\n   \n  \n  \n   \n      types\n      true\n      int\n      轮播图类型（10:首页轮播）\n   \n  \n\n\n\n\n\nFirst Header\nSecond Header\nSecond Header\n\n\n\nCell\nContent Cell\nContent Cell\n\n\nContent Cell\nContent Cell\nContent Cell\n\n\n\n\n\nLeft-Aligned\nCenter Aligned\nRight Aligned\n\n\n\n左对齐\n剧中对齐\n居右$1600\n\n\ncol 2 is\ncentered\n$12\n\n\nzebra stripes\nare neat\n$1\n\n\n引用块 输入&gt;之后输入需要的引用内容就可以生成引用块格式，自动为你添加&gt;和行间隔\n\n这是一个由两个段落组成的引用块，这是第一个段落。\n这是第二个段落，爱饭打森，爱乖出台，请曾爱萨菲，撒㩐，经爱抚，百分赛法。\n\n\n这是另一个只有一个段落的引用块。两个代码块间可以用一空行来分隔。\n\n脚注示范[^这是一个脚注] 鼠标移动到这是一个脚注超链接可以看到脚注的文本内容。本网站基于MkDocs[^1]系统，采用了Material for MkDocs[^2]主题样式，感谢开源社区的贡献！[^1]: https://www.mkdocs.org/[^2]: https://squidfunk.github.io/mkdocs-material/\n\n请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n\n主要内容\nMarkdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下\n正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    \n2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。    \n他有着足以让你跪拜的人生经历：    \n\n14岁参与RSS 1.0规格标准的制订。     \n2004年入读斯坦福，之后退学。   \n2005年创建Infogami，之后与Reddit合并成为其合伙人。   \n2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   \n2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     \n2013年1月自杀身亡。    \n\n\n天才都有早逝的归途。\n3. 为什么要使用它？\n它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。\n兼容HTML，可以转换为HTML格式发布。\n跨平台使用。\n越来越多的网站支持Markdown。\n更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）\n摆脱Word（我不是认真的）。\n\n4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。\nMarkdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \\**，符号’`’**。\n4.1 标题两种形式：1）使用=和-标记一级和二级标题。\n\n一级标题=========二级标题---------\n\n效果：\n\n一级标题   二级标题\n2）使用#，可表示1-6级标题。\n\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题    \n\n效果：\n\n一级标题二级标题三级标题四级标题五级标题六级标题\n4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：\n\n&gt; 区块引用&gt;&gt; 嵌套引用  \n\n效果：\n\n区块引用  \n\n嵌套引用\n\n\n4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落：\nvoid main(){    printf(“Hello, Markdown.”);}    \n代码区块：\nvoid main()\n{\n    printf(\"Hello, Markdown.\");\n}\n\n注意:需要和普通段落之间存在空行。\n4.5 强调在强调内容两侧分别加上*或者_，如：\n\n*斜体*，_斜体_**粗体**，__粗体__\n\n效果：\n\n斜体，斜体粗体，粗体\n\n4.6 列表使用·、+、或-标记无序列表，如：\n\n-（+*） 第一项-（+*） 第二项- （+*）第三项\n\n注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果：\n\n\n第一项\n第二项\n第三项\n\n\n有序列表的标记方式是将上述的符号换成数字,并辅以.，如：\n\n1 . 第一项2 . 第二项3 . 第三项    \n\n效果：\n\n\n第一项\n第二项\n第三项\n\n\n4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。\n4.8 链接链接可以由两种形式生成：行内式和参考式。行内式：\n\n[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。\n\n效果：\n\nyounghz的Markdown库。\n\n参考式：\n\n[younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown”    \n\n效果：\n\nyounghz的Markdown库1younghz的Markdown库2\n\n注意：上述的[1]:https:://github.com/younghz/Markdown \"Markdown\"不出现在区块中。\n4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n4.10 反斜杠\\相当于反转义作用。使符号成为普通符号。\n4.11 符号’`’起到标记作用。如：\n\n`ctrl+a`\n\n效果：\n\nctrl+a    \n\n5. 谁在用？Markdown的使用者：\n\nGitHub\n简书\nStack Overflow\nApollo\nMoodle\nReddit\n等等\n\n6. 尝试一下\nChrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。\n在线的dillinger.io评价也不错   \nWindowns下的MarkdownPad也用过，不过免费版的体验不是很好。    \nMac下的Mou是国人贡献的，口碑很好。\nLinux下的ReText不错。    \n\n当然，最终境界永远都是笔下是语法，心中格式化 :)。\n\n注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。\n\n以上基本是所有traditonal markdown的语法。\n其它：列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。\n\n\n\n代码库\n链接\n\n\n\nMarkDown\nhttps://github.com/younghz/Markdown\n\n\nMarkDownCopy\nhttps://github.com/younghz/Markdown\n\n\n关于其它扩展语法可参见具体工具的使用说明。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["markdown"],"tags":["django"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/monkey-patch-hou-zi-bu-ding/","content":"monkey patch（动态语言中提到的猴子补丁）\n所谓的monkey patch就是运行时类型替换\n比如gevent库需要修改内置的socket，把内置阻塞的库替换成非阻塞的socket\n\n1234567891011121314151617# code02_猴子补丁.pyimport socketprint(socket.socket)  # 输出结果:&lt;class 'socket.socket'&gt;print(\"After monkey patch\")from gevent import monkeymonkey.patch_socket()  # 把内置的阻塞socket替换为非阻塞的socketprint(socket.socket)  # 输出结果:&lt;class 'gevent._socket3.socket'&gt;import selectprint(select.select)  # 输出结果:&lt;built-in function select&gt;monkey.patch_select()print(\"After monkey patch\")print(select.select)  # code02_猴子补丁.pyimport socketprint(socket.socket)  # 输出结果:&lt;class 'socket.socket'&gt;print(\"After monkey patch\")from gevent import monkeymonkey.patch_socket()  # 把内置的阻塞socket替换为非阻塞的socketprint(socket.socket)  # 输出结果:&lt;class 'gevent._socket3.socket'&gt;import selectprint(select.select)  # 输出结果:&lt;built-in function select&gt;monkey.patch_select()print(\"After monkey patch\")print(select.select)  # 输出结果：\n\n12345678910111213# 自己实现猴子补丁.pyimport timeprint(time.time())  # 输出内置时间戳# 1562568697.2385693def _time():    return 1234time.time = _time  # 进行函数替换print(time.time())  # 输出替换后的时间戳，就是运行时替换函数# 自己实现猴子补丁.pyimport timeprint(time.time())  # 输出内置时间戳# 1562568697.2385693def _time():    return 1234time.time = _time  # 进行函数替换print(time.time())  # 输出替换后的时间戳，就是运行时替换函数# 1234\n自省 introspection /ɪntrə(ʊ)’spekʃ(ə)n/\n运行时判断一个对象所属类型\nPython一切皆对象，用type，id，isinstance获取对象的类型信息\nInspect模块提供了更多获取对象信息的函数\n\n代码一：\n12345678910111213141516171819202122232425262728293031323334353637ll = [1,2,3]d = dict(q=1) # {a:1} print(type(ll))  # 输出结果:&lt;class 'list'&gt;print(type(d))  # 输出结果:&lt;class 'dict'&gt; # 判断一个对象所属的类型print(isinstance(ll,list))  # 输出结果:Trueprint(isinstance(d,dict))   # 输出结果:True # 根据不同的类型来执行不同的逻辑 def add(a, b):    if isinstance(a, int):        return a + b    elif isinstance(a, str):        return a.upper() + b  print(add(1, 2))   # 输出结果:3print(add('head', 'tail'))  # 输出结果:HEADtail # 变量所在内存中的地址print(id(ll))  # 输出结果:2337544905544print(id(d))  # 输出结果:2337544963344# 使用 is 可以判断是否为同一个对象# 本质就是 id(ll) == id(d)print(ll is d)  # 输出结果:Falseprint(ll is ll)  # 输出结果:True l1 = [1, 2, 3]l2 = [1, 2, 3]# 比较值是否相同print(l1 == l2)  # 输出结果:True# 比较ID是否相同print(l1 is l2)     # 输出结果:Falseprint(id(l1), id(l2))   ll = [1,2,3]d = dict(q=1) # {a:1} print(type(ll))  # 输出结果:&lt;class 'list'&gt;print(type(d))  # 输出结果:&lt;class 'dict'&gt; # 判断一个对象所属的类型print(isinstance(ll,list))  # 输出结果:Trueprint(isinstance(d,dict))   # 输出结果:True # 根据不同的类型来执行不同的逻辑 def add(a, b):    if isinstance(a, int):        return a + b    elif isinstance(a, str):        return a.upper() + b  print(add(1, 2))   # 输出结果:3print(add('head', 'tail'))  # 输出结果:HEADtail # 变量所在内存中的地址print(id(ll))  # 输出结果:2337544905544print(id(d))  # 输出结果:2337544963344# 使用 is 可以判断是否为同一个对象# 本质就是 id(ll) == id(d)print(ll is d)  # 输出结果:Falseprint(ll is ll)  # 输出结果:True l1 = [1, 2, 3]l2 = [1, 2, 3]# 比较值是否相同print(l1 == l2)  # 输出结果:True# 比较ID是否相同print(l1 is l2)     # 输出结果:Falseprint(id(l1), id(l2))   # 输出结果:2337543699976 2337544905416\n经常用到：\n判断一个对象是不是none，经常用is none而不是等于none，就因为none本身是单例的，所以我们经常使用is来判断是不是同一个对象。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/namespace/","content":"命名空间(Namespace)A namespace is a mapping from names to objects.Most namespaces are currently implemented as Python dictionaries.是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。\n命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。\n变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。\n举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。\n三种命名空间\n\n内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n命名空间查找顺序:\n假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间。\n如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:NameError: name 'runoob' is not defined\n命名空间的生命周期：取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。\n12345var1 = 5  # var1 是全局名称def some_func():    var2 = 6  # var2 是局部名称    def some_inner_func():        var3 = 7  var1 = 5  # var1 是全局名称def some_func():    var2 = 6  # var2 是局部名称    def some_inner_func():        var3 = 7  # var3 是内嵌的局部名称\n\n作用域A scope is a textual region of a Python programwhere a namespace is directly accessible.“Directly accessible” here means thatan unqualified reference to a name attempts to find the name in the namespace.作用域就是一个 Python 程序可以直接访问命名空间的正文区域。在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。\n程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：\n\nL（Local）：最内层，包含局部变量，比如一个函数/方法内部在新建一个变量时，默认作用域为当前局部作用域，函数外引用不了，\nE（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal，将变量声明为外层变量（外层函数的局部变量，而且不能是全局变量）标识该变量是上一级函数中的局部变量    只能用于嵌套函数中\nG（Global）：当前脚本的最外层，比如当前模块的全局变量，就不会在局部命名空间里寻找这个变量了，可以被多个函数引用\nB（Built-in）： 包含了内建的变量/关键字等，最后被搜索\n规则顺序： L –&gt; E –&gt; G –&gt;gt; B。在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。\n\n\n\n12345g_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外的函数中    def inner():        i_count = 2  g_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外的函数中    def inner():        i_count = 2  # 局部作用域\n\n内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。\n1234import builtinsdir(builtins)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', import builtinsdir(builtins)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] \n\nPython 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：\n123456&gt;&gt;&gt; if True:...  msg = 'I am from Runoob'... &gt;&gt;&gt; msg'I am from Runoob'&gt;&gt;&gt; if True:...  msg = 'I am from Runoob'... &gt;&gt;&gt; msg'I am from Runoob'>>> \n实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。\n如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：\n12345678&gt;&gt;&gt; def test():...     msg_inner = 'I am from Runoob'... &gt;&gt;&gt; msg_innerTraceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'msg_inner' is not defined&gt;&gt;&gt; def test():...     msg_inner = 'I am from Runoob'... &gt;&gt;&gt; msg_innerTraceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'msg_inner' is not defined>>> \n从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。###全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：\n12345678910111213total = 0  # 这是一个全局变量def sum(arg1, arg2):    # 返回2个参数的和.    total = arg1 + arg2  # total在这里是局部变量.    print(\"函数内是局部变量 : \", total)    return total# 调用sum函数sum(10, 20)  # 30print(\"函数外是全局变量 : \", total)  total = 0  # 这是一个全局变量def sum(arg1, arg2):    # 返回2个参数的和.    total = arg1 + arg2  # total在这里是局部变量.    print(\"函数内是局部变量 : \", total)    return total# 调用sum函数sum(10, 20)  # 30print(\"函数外是全局变量 : \", total)  # 0\n\n###global 和 nonlocal关键字以下实例不修改全局变量 num：\n123456789101112num = 1def fun1():    num = 123  # num在这里是局部变量    print(num)fun1()# 123print(num)num = 1def fun1():    num = 123  # num在这里是局部变量    print(num)fun1()# 123print(num)# 1  全局变量\n另外有一种特殊情况，假设下面这段代码被运行：\n12345678910a = 10def test():  # 没有定义a为自变量    a = a + 1    print(a)test()a = 10def test():  # 没有定义a为自变量    a = a + 1    print(a)test()# UnboundLocalError: local variable 'a' referenced before assignment\n错误信息为局部变量 a 在使用前未定义。第一行定义了一个全局变量，在test 函数中程序会因为“如果内部函数有引用外部函数的同名变量或者全局变量，并且对这个变量有修改。那么python会认为它是一个局部变量，又因为test函数中没有a的定义和赋值，无法修改。修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为：\n12345678910a = 10def test(x):  # 定义a是变量而不是x    a += 1    print(a)test(a)a = 10def test(x):  # 定义a是变量而不是x    a += 1    print(a)test(a)# UnboundLocalError: local variable 'a' referenced before assignment\n\n12345678910a = 10def test(a):    a = a + 1    print(a)test(a)a = 10def test(a):    a = a + 1    print(a)test(a)# 11\n\n12345678910a = 10def test(x):    global a    a += 1    print(a)test(a)  a = 10def test(x):    global a    a += 1    print(a)test(a)  # 11\n\n123456789101112131415161718no = 1def fun2():    print(no)    no = 123    print(no)fun2()print(no)# 则UnboundLocalError: local variable 'num' referenced before assignment# 若没有上面global no，# 局部变量 no 在定义之前就引用了。# 报错的是 print(no) 这一行。结合第1个例子，只是增加了一行 no = 2，# 但是却是 print(no) 报错。这说明在 print(no) 之前，# python 已经知道了 no 是一个局部变量，只能从局部作用域中查找。no = 1def fun2():    print(no)    no = 123    print(no)fun2()print(no)# 则UnboundLocalError: local variable 'num' referenced before assignment# 若没有上面global no，# 局部变量 no 在定义之前就引用了。# 报错的是 print(no) 这一行。结合第1个例子，只是增加了一行 no = 2，# 但是却是 print(no) 报错。这说明在 print(no) 之前，# python 已经知道了 no 是一个局部变量，只能从局部作用域中查找。# 从哪里知道的？ 从 no = 123 这一行知道的。\n\n在局部如果不声明全局变量，访问且不修改全局变量。则可以正常使用全局变量\n123456789no = 1def fun2():    print(no)fun2()  # 1print(no)  no = 1def fun2():    print(no)fun2()  # 1print(no)  # 1\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int = 0def fun1():    int = 1    def fun2():        int = 2        print(int)    fun2()fun1()  # 2int = 0def fun3():    int = 1    def fun4():        # int = 2        print(int)  # 在函数内部找不到对 int 的定义，则去外层查询。输出1。    fun4()fun3()  # 1int = 0def fun5():    def fun6():        print(int)    fun6()fun5()  # 0del intdef fun5():    def fun6():        print(int)    fun6()fun5()  int = 0def fun1():    int = 1    def fun2():        int = 2        print(int)    fun2()fun1()  # 2int = 0def fun3():    int = 1    def fun4():        # int = 2        print(int)  # 在函数内部找不到对 int 的定义，则去外层查询。输出1。    fun4()fun3()  # 1int = 0def fun5():    def fun6():        print(int)    fun6()fun5()  # 0del intdef fun5():    def fun6():        print(int)    fun6()fun5()  #  local、non-local、global 中都没有 int 的值，便去 built-in 中寻找 int 的值\n\n当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。\n定义的变量，表明其作用域在局部以外，12345678910111213即局部函数执行完之后才能变成全局，不销毁 函数内部以global定义的变量```pythona = 1def add_a():    global a    a = 3add_a()print(a)  # 3\n\n123456789101112131415no = 1def fun2():    global no  # global 关键字声明，修改全局变量 no    print(no)    no = 123    print(no)fun2()# 1# 123print(no)no = 1def fun2():    global no  # global 关键字声明，修改全局变量 no    print(no)    no = 123    print(no)fun2()# 1# 123print(no)# 123 global关键字\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344no = 1def fun2():    nonlocal no      print(no)    no = 123    print(no)fun2()# 1# 123print(no)# Syntax Error: no binding for nonlocal ‘no’ found# nonlocal 表示外层变量，但是一旦外层变量是全局变量，则只能用 global。# 在使用 nonlocal no 之前，必须保证外层的确已经定义过 no 了，```~如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的同名变量则需要 nonlocal 关键字了，如下实例：```pythondef make_counter():    count = 0    def counter():        nonlocal count        count += 1        return count    return counterdef make_counter_test():    mc = make_counter()    print(mc())    print(mc())    print(mc())make_counter_test()# 1# 2no = 1def fun2():    nonlocal no      print(no)    no = 123    print(no)fun2()# 1# 123print(no)# Syntax Error: no binding for nonlocal ‘no’ found# nonlocal 表示外层变量，但是一旦外层变量是全局变量，则只能用 global。# 在使用 nonlocal no 之前，必须保证外层的确已经定义过 no 了，```~如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的同名变量则需要 nonlocal 关键字了，如下实例：```pythondef make_counter():    count = 0    def counter():        nonlocal count        count += 1        return count    return counterdef make_counter_test():    mc = make_counter()    print(mc())    print(mc())    print(mc())make_counter_test()# 1# 2# 3\n\n1234567891011121314151617181920def outer():    num = 10    def inner():        # print(num)        nonlocal num  # nonlocal关键字声明为外层变量        print(num)  # 10        num = 100        print(num)  # 100    inner()    print(num)  # 100outer() # 10# 100# 100print(num) def outer():    num = 10    def inner():        # print(num)        nonlocal num  # nonlocal关键字声明为外层变量        print(num)  # 10        num = 100        print(num)  # 100    inner()    print(num)  # 100outer() # 10# 100# 100print(num) # NameError: name 'num' is not defined\n\n\n12345678910111213141516def outer():    num = 10    def inner():        # print(num)        global num  # global        print(num)        num = 100        print(num)    inner()    print(num)outer()def outer():    num = 10    def inner():        # print(num)        global num  # global        print(num)        num = 100        print(num)    inner()    print(num)outer()# NameError: name 'num' is not defined\n1234567891011121314151617def outer():    num = 10    def inner():        # print(num)        global num  # num为全局变量，与上面等于1的 num 没有关系        num = 20  # 定义全局变量        print(num)  # 输出20        num = 100        print(num)  # 输出100    inner()    print(num)  # 输出10，局部变量outer()print(num)  def outer():    num = 10    def inner():        # print(num)        global num  # num为全局变量，与上面等于1的 num 没有关系        num = 20  # 定义全局变量        print(num)  # 输出20        num = 100        print(num)  # 输出100    inner()    print(num)  # 输出10，局部变量outer()print(num)  # 输出100，全局变量\n\n\n123456789101112131415161718192021# 在函数 add_b 内 global 定义的变量 b，只能在 函数 do_global 内引用，# 如果要在 do_global 内修改，# 必须在 do_global 函数里面声明 global b ，# 表明是修改外面的 全局变量 b ：def add_b():    global b    b = 42    def do_global():        global b        b = b + 10        print(b)    do_global()    print(b)add_b()# 52# 在函数 add_b 内 global 定义的变量 b，只能在 函数 do_global 内引用，# 如果要在 do_global 内修改，# 必须在 do_global 函数里面声明 global b ，# 表明是修改外面的 全局变量 b ：def add_b():    global b    b = 42    def do_global():        global b        b = b + 10        print(b)    do_global()    print(b)add_b()# 52# 52\n\n12345678910111213141516171819202122# 在函数 add_b 内 global 定义的变量 b，只能在 函数 do_global 内引用，# 如果要在 do_global 内修改，# 必须在 do_global 函数里面声明 global b ，# 表明是修改外面的 全局变量 b ：def add_b():    global b    b = 42    def do_global():        # global b        b = b + 10        print(b)    do_global()    print(b)add_b()# UnboundLocalError: local variable 'b' referenced before assignment# 如果将do_global()里的global b注释掉,会报错。# 在函数 add_b 内 global 定义的变量 b，只能在 函数 do_global 内引用，# 如果要在 do_global 内修改，# 必须在 do_global 函数里面声明 global b ，# 表明是修改外面的 全局变量 b ：def add_b():    global b    b = 42    def do_global():        # global b        b = b + 10        print(b)    do_global()    print(b)add_b()# UnboundLocalError: local variable 'b' referenced before assignment# 如果将do_global()里的global b注释掉,会报错。# global 定义的 b ，只能引用，不能修改。\n12345678910111213141516171819def add_b():    # global  b    b = 42    def do_global():        nonlocal b        b = 10        print(b)    do_global()    print(b)add_b()# 10# 10# 如果在最后加上print(\" b = %s \" % b)，则会报错# NameError: name 'b' is not defineddef add_b():    # global  b    b = 42    def do_global():        nonlocal b        b = 10        print(b)    do_global()    print(b)add_b()# 10# 10# 如果在最后加上print(\" b = %s \" % b)，则会报错# NameError: name 'b' is not defined# 说明： nonlocal  适用于在局部函数 中 的局部函数， 把最内层的局部 变量设置成外层局部可用，但是还不是全局的。\n\n\n123456789101112131415161718192021222324252627282930313233def scope_test():    def do_local():        spam = \"local spam\"        # 此函数定义了另外的一个spam字符串变量，        # 并且生命周期只在此函数内。        # 此处的spam和外层的spam是两个变量，        # 如果写出spam = spam + “local spam” 会报错    def do_nonlocal():        nonlocal spam  # 使用外层的spam变量        spam = \"nonlocal spam\"    def do_global():        global spam        spam = \"global spam\"    spam = \"test spam\"    do_local()    print(\"After local assignment:\", spam)    do_nonlocal()    print(\"After nonlocal assignment:\", spam)    do_global()    print(\"After global assignment:\", spam)scope_test()# After local assignment: test spam# After nonlocal assignment: nonlocal spam# After global assignment: nonlocal spamprint('----')# ----print(\"In global scope:\", spam)def scope_test():    def do_local():        spam = \"local spam\"        # 此函数定义了另外的一个spam字符串变量，        # 并且生命周期只在此函数内。        # 此处的spam和外层的spam是两个变量，        # 如果写出spam = spam + “local spam” 会报错    def do_nonlocal():        nonlocal spam  # 使用外层的spam变量        spam = \"nonlocal spam\"    def do_global():        global spam        spam = \"global spam\"    spam = \"test spam\"    do_local()    print(\"After local assignment:\", spam)    do_nonlocal()    print(\"After nonlocal assignment:\", spam)    do_global()    print(\"After global assignment:\", spam)scope_test()# After local assignment: test spam# After nonlocal assignment: nonlocal spam# After global assignment: nonlocal spamprint('----')# ----print(\"In global scope:\", spam)# In global scope: global spam\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/pytest/","content":"官方文档 给出了 pytest 寻找 测试项 的 具体规则\n\n如果未指定命令行参数，则从 testpath（如果已配置）或当前目录开始收集。\n\n如果命令行参数， 指定了 目录、文件名 或 node id 的任何组合，则按参数来找\n\n寻找过程会递归到目录中，除非它们匹配上 norecursedirs。\n\n在这些目录中，搜索由其测试包名称导入的 test_*.py 或 *_test.py 文件。\n\n从这些文件中，收集如下测试项：\n\n\n\ntest为前缀 的 函数\nTest为前缀的 类 里面的 test为前缀的方法\n\n我们编写的测试用例代码文件， 必须以 test_ 开头，或者以 _test 结尾比如，我们创建一个 文件名为 test_错误登录.py ，放在目录 autotest\\cases\\登录 下面。其中 autotest 是 我们创建的 自动化项目根目录\n如果我们把测试用例存放在类中， 类名必须以 Test 为前缀的 类 ，用例对应的方法必须以 test 为前缀的方法。\npytest 中用例的检查点 直接用 Python 的 assert 断言。\nassert 后面的表达式结果 为 True ，就是 检查点 通过，结果为False ，就是检查点 不通过。\n我们这里先快速给大家介绍 pytest 的基本用法， 就先用简单的 表达式演示一下，后面的教程会有实际的测试代码 和 检查点。\n#运行测试执行测试非常简单，打开命令行窗口，进入自动化项目根目录（我们这里就是 autotest），执行命令程序 pytest 即可显示找到3个测试项，2个执行通过，1个不通过。\n通过的用例 是用一个绿色小点表示， 不通过的用例用一个红色的F表示\n并且会在后面显示具体不通过的用例 和不通过的检查点 代码细节。\n\n希望 显示测试代码中print的内容，因为这些打印语句在调试代码时很有用，可以加上命令行参数 -s\n\n希望得到更详细的执行信息，包括每个测试类、测试函数的名字，可以加上参数 -v，这个参数可以和 -s 合并为 -sv\n\n\n指定一个模块执行\n1pytest 路径\\模块名.py -sv\n\n指定一个目录执行\n1pytest 目录名1 目录名pytest 目录名1 目录名2 -sv\n\n指定一个类执行\n1pytest 路径\\模块名.py::类名pytest 路径\\模块名.py::类名1 -sv\n\n指定一个类里面的方法执行\n1pytest 路径\\模块名.py::类名pytest 路径\\模块名.py::类名1::方法名 -sv\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"python random","url":"https://bubbleboy11.github.io/2020/08/21/python-random/","content":"random提供了生成随机数的工具123456789import randomprint(random.choice(['apple', 'pear', 'banana']))# 'apple'print(random.sample(range(100), 10))  # sampling without replacement# [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]print(random.random())  # random float# 0.17970987693706186print(random.randrange(6))  # random integer chosen from range(6)import randomprint(random.choice(['apple', 'pear', 'banana']))# 'apple'print(random.sample(range(100), 10))  # sampling without replacement# [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]print(random.random())  # random float# 0.17970987693706186print(random.randrange(6))  # random integer chosen from range(6)# 4\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"python3新增的语法和内置库","url":"https://bubbleboy11.github.io/2020/08/21/python3-xin-zeng-de-yu-fa-he-nei-zhi-ku/","content":"① yield from 链接子生成器② asyncio内置库， async/await原生协程支持异步编程③ 新的内置库enum枚举库, mock库做单测试mock掉一些网络接口, asyncio, ipaddress处理IP地址库, concurrent.futures并发相关库等④ python3把生成的pyc文件统一放到__pycache__文件夹下面。⑤ 一些内置库的修改。urllib, selector等⑥ 性能优化等\n兼容2/3的工具six模块\n\n2to3等工具转换代码\n\n__future__\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"python慢","url":"https://bubbleboy11.github.io/2020/08/21/python-man/","content":"py代码主要是干什么事情。通常的处理如果是干一些文件操作，网络操作，和c++差距人都感知不出来。性能敏感的代码可以用c++做成库去调用。其实很多Python的库核心都是c语言c加加写的，然后Python去调用它。Python qt库也是这样。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"python模块","url":"https://bubbleboy11.github.io/2020/08/21/python-mo-kuai/","content":"\n模块是对内部逻辑的封装，只对外提供接口\n一个py文件就是一个模块，模块的名称就是不含.py后缀的文件名import关键字导入一个模块\n\n◆可维护性更强◆方便代码重用python中模块是包含变量、函数、……代码块的文件；包是存放多个文件/模块的文件夹，可以统一组织和管理多个python模块；标准的包结构中包含一个特殊的文件[_init_py]。两者的区别：包是一个文件夹，可以包含多个文件/模块，模块是一个文件\n什么叫反射？给定一个对象，返回该对象的所有属性和函数列表，或给定对象和该对象的函数或者属性的名字，返回对象的函数或者属性实例。dir函数就是反射的实现，dir()函数:如果要获得一个对象的所有属性和方法，dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数\nhelp——查看类，方法的帮助信息__name__—模块的名称__file__——文件全路径\n当你导入一个模块，Python 解析器对模块位置的搜索顺序是：1、当前目录（包）2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。（内置函数）3、如果都找不到，Python会察看默认路径。模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。（环境变量）PYTHONPATH 变量作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。\n导入模块时，只需要写模块名只导入模块名时，引用模块中的函数时，格式是模块名.函数名\n包python package◆可以用来组织模块（可以包含其它模块的模块），包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。◆目录（文件夹）必须包含文件_init.py，, 该文件的内容可以为空。init.py 用于标识当前文件夹是一个包。◆模块重名问题解决\n包Package的引用·引入整个包：import module,还要确保该模块所在包中的_init__.py模块，写入具体要引入的模块名。·只是引入所需要的属性和方法：from module.xx.xx import xx在init.py为空的前提下，包的引入有三种，分别是from 包名 import 模块名、from 包名.模块名 import 函数名、import 包名.模块名，利用as可以给模块或包指定别名\n◆指定别名，导入不同包同名模块：from module.xx.xx import xx as renename·引入所有：from module.xx.xx import * 不推荐，需要什么导入什么导入包的本质就是执行该包下的init.py文件\n在引入目录Directory中内容时，只可以引入该目录的子目录中的内容，也可以手动为Directory添加init.py使之可以像包一样引用\n函数/变量描述argv命令行参数，包括脚本名getcwd返回当前所在的目录modules一个字典，将模块名映射到加载的模块path一个列表，包含要在其中查找模块的目录的名称platform一个平台标识符，如sunos5或win32mkdir/rmdir创建和删除文件夹\nDateTime模块函数/变量  描述timedelta对日期/时间进行加减操作时使用date() 表示一个日期datetime.strftime 将datetime对象格式化成字符串datetime.strptime 将字符串按照一定的格式转换成datetime对象time() 表示一个时间的类datetime.now 系统的当前时间day datetime对象的属性，类似的还有minute，hour等days Timedelta的属性，类似的还有minutes, hour等datetime.now()，datetime.today()得到当前日期时间，datetime.now().day 当前月的第几天datetime.today().time 当前时间\nDateTime模块转换参数表参数含义%A星期的名称，如Monday%B月份名，如anuary%m用数字表示的月份（0112）%d用数字表示月份中的一天（01～31）%Y四位的年份，如2015%y两位的年份，如15%H 24小时制的小时数（0023）%l12小时制的小时数（0112）%p am或pm%M分钟数（0059%S秒数（00~61）\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"python虚拟环境","url":"https://bubbleboy11.github.io/2020/08/21/python-xu-ni-huan-jing/","content":"关掉前面的baseconda deactivate 退出 conda base 环境\nPyPi Python Package Index，一个Python库的托管平台，https://pypi.org/ \npip install –index-url https://pypi.tuna.tsinghua.edu.cn/simple/ pytest-html\n延长timeout时间pip –default-timeout=100 install –index-url https://pypi.tuna.tsinghua.edu.cn/simple/ package\n使⽤源码安装：下载安装包并解压，然后进⼊setup.py所在的⽬录，执⾏python setup.py installpip uninstall 包名pip list 查看安装的包\npip install pipenv在创建好的目录下执行pip –pythonpipenv install 包名pipenv shell 进入python -m pip install –upgrade pippipenv graph 查看依赖包exit 退出\nPython中的虚拟环境具有隔离性，Python的虚拟环境可以使一个Python程序拥有独立的库library和解释器interpreter，而不用与其他Python程序共享统一个library和interpreter，主要应用于解决因为版本问题所引发的冲突问题\n-virtualenv◆pip install virtualenvmkdirvirtualenv 虚拟环境名pip install –index-url https://pypi.tuna.tsinghua.edu.cn/simple/ 包名pythonimport 包名quit()激活虚拟环境并进入/退出虚拟环境：activate/deactivatevirtualenv+虚拟环境名字 创建虚拟环境\n◆pip install virtualenvwrapper-win◆虚拟环境自由切换，关掉之后进入：workon 虚拟环境名\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"redis","url":"https://bubbleboy11.github.io/2020/08/21/redis/","content":"Redis是一种Key-Value存储结构的NoSQL非关系数据库\nredis的使用场景\n\n数据存储\n\n数据存储在内存，可以持久化保存至硬盘\n高效的数据结构 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）\n\n\n高速缓存\n\n10万+的QPS（查询次数/秒），集群可达百万级以上\n首页内容缓存优化（门户、新闻等）\n秒杀业务、抢购业务、库存控制等\n\n\n启动redis&gt;&gt; redis-server redis.windows.conf可以做一个包含此命令的bat文件，每次双击启动\n\n连接redis&gt;&gt; redis-cli\n\"password\"```登录才有权限，不能漏掉双引号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748redis 没有表 缓存经常被读取的热数据的平台redis里面取出来的数据都是bytes类型的，所以要用decode方法转成字符串flushdb 清空逻辑表格flushall  清空逻辑库数据#### 字符串（String）相关操作- ```set``` -- 设置值- ```get``` -- 获取值- ```mset``` -- 设置多个键值对key-value- ```mget``` -- 获取多个键值对key-value- ```append``` -- 在字符串结尾添加字符串内容- ```del``` -- 删除- ```incr```/```decr``` -- 增加/减少 1incr num 数字自增加1incrby num 25 数字加上指定的整数值incrbyfloat num 2.5 数字加上指定的整数值decr num 数字自增减1decrby num 25 数字减去指定的整数值```redis>set email scott@163.com>get email>mset a 10 b 20 c 30>mget a b c emailmset username scott sex male mget username sex  append username 123 在字符串结尾追加内容``` ```redis> incr count(integer) 1> incr count(integer) 2> incr count(integer) 3> get count\"3\"> incr count(integer) 4> incr count(integer) 5\n\n\n\n\n缓存\n\n内容变化不频繁\n几个小时、几天才变化一次\n重复性工作\n查询数据库\n生成响应数据\n优化一下：不查数据库，缓存内容\n\ngetrange email 0 3 获得截取字符串内容strlen emai 获得字符串长度\nsetex 设置带有过期时间（秒）的 key-valuesetex city 5 Beijing\n数据类型String(字符串)：用来实现简单的 KV 键值对存储，比如计数器\n哈希表 存储彼此相关信息的键值对，用HSET key filed value 来去设置一组相关信息，例如设置用户ID和名字相关联HSET name { id: user_name}hset 8000 ename Tomhset  8000 job salesmanhmset 9000 ename Scott job salesman deptno 10\nhget 8000 enamehmget 8000 ename job deptnoHGETALL 8000  必须大写\nhkeys 8000 获得所有哈希表字段名,key\nhlen 8000 获得所有哈希表key数量hexists 8000 job 判断哈希表是否存在某个key字段名\nhvals 9000 获得哈希表素有字段值hdel 9000 job deptno 删除哈希表的字段\nhdel 9000 key1 key2 \nHINCRBY 8000 deptno 10让哈希表某个字段加上指定的整数值HINCRBYfloat 8000 sal 6.6\n列表类型：向value 保存序列化的数据，可重复List(链表)：实现双向链表，比如用户的关注，粉丝列表rpush list 1 2 3 # 创建并且依次向右边添加lrange list 0 -1123\nlpush list2 1 2 3 创建并且依次向右边添加lrange list2 0 -1321\nlpush dname 秘书处   # 在已存在的字段向左边\nlset dname 2 销售部 # 第二个位置lrange dname 0 -1 打印列表第一个元素到最后一个元素秘书处技术部销售部售后部\nllen dname 获得列表长度lindex 数字 获得列表某个元素linsert dname before 秘书处 董事会 在某个位置插入元素之前lpop dname 删除列表最左边的元素rpop dname 删除列表最右边的元素\nrpush employee Scottrpush employee Jackrpush employee Scottlrem employee 1 Scott 删除列表第一个元素lrem employee 2 Scott 删除列表2个元素\n集合类型set 列表中的元素不可以重复 存储不重复元素，比如用户的关注者，没有顺序SADD EMPNO 8000SADD EMPNO 8001 8002SMEMBERS EMPNO  获得集合所有元素，按照哈希值排序\nSCARD EMPNO 获得集合长度sismember EMPNO 8000 判断是否含有某个元素srem EMPNO 8001 删除元素，\nspop empno 随机删除并返回集合的某个元素srandmember empno 33 随机返回集合中的3个元素\n有序集合Sorted Set 带排序功能的集合，按照元素分数值排序zadd keyword 0 ‘JACK’ 0 ‘Miko’ 0 ‘Ashe’ 定义有序集合 先写分数值zincrby keyword 1 ‘JACK’zincrby keyword 5 ‘Ashe’zincrby keyword 3 ‘Miko’zincrby keyword 2 ‘Mikko’  mikko不存在则新建zrange keyword 0 -1 获得有序集合的内容（升序）zrevrange keyword 0 -1 获得有序集合的内容（降序）zrevrange keyword 0 0 分数值最高的元素zrangebyscore 获得分数值区间内容的集合内容（升序）zrangebyscore keyword 0 2zrangebyscore keyword 0 (2  不包括2zrangebyscore keyword 2 +inf 正无穷zrerangebyscore 获得分数值区间内容的集合内容（降序）zrevrangebyscore keyword 3 0zrevrangebyscore keyword (3 0   不包括3\nzcard keyword 获得有序集合长度zcount keyword 2 4 查询某个分数值区间的元素数量zscore keyword ‘Ashe’ 返回元素的分数值\nzrank keyword ‘Ashe’ 获得元素的升序排名（从0开始）zrevrank keyword ‘Ashe’ 获得元素的降序排名（从0开始）zrevrank keyword ‘Ashe’\nzrem keyword  ‘Miko’  ‘Ashe’  删除有序集合中的元素zremrangebyrank keyword 0 2  删除排名区间内的元素zremrangebyscore keyword -inf 2  删除排名区间内的元素\nexists employee 判断是否存在某个keyexpire employee 5设置过期时间expireat employee 12设置记录的过期时间(UNIX时间戳)move keyword 1 记录迁移到其他逻辑库,1号逻辑库select 1 切换到1号逻辑库rename employee emppresistkeyword 移除过期时间type keyword 判断value数据类型\n为什么要一如线程池如果程序中经常需要用到线程，频繁的创建和销毁线程会浪费很多硬件资源，所以需要把线程和任务分离开。线程可以反复利用，省去了重复创建的麻烦。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据库"],"tags":["redis"]},{"title":"replace","url":"https://bubbleboy11.github.io/2020/08/21/replace/","content":"主串.replace(‘旧子串’,’新子串’,匹配次数)多种异常字段替换成一种字段\n12345678910111213141516171819# 原数据data = [123, 234, '零', 'None', 8975]# 需要替换字段replace = ['零', 'None']result = [0 if i in replace else i for i in data]print(result)# [123, 234, 0, 0, 8975]# 多字段替换# 原数据data = [123, 234, '零', 'None', 8975]# 需要替换字段replace = {'零': 0, 123: '一二三'}result = [replace[i] if i in replace else i for i in data]print(result)# ['一二三', 234, 0, 'None', 8975]print('tea for too'.replace('too', 'two'))# 原数据data = [123, 234, '零', 'None', 8975]# 需要替换字段replace = ['零', 'None']result = [0 if i in replace else i for i in data]print(result)# [123, 234, 0, 0, 8975]# 多字段替换# 原数据data = [123, 234, '零', 'None', 8975]# 需要替换字段replace = {'零': 0, 123: '一二三'}result = [replace[i] if i in replace else i for i in data]print(result)# ['一二三', 234, 0, 'None', 8975]print('tea for too'.replace('too', 'two'))# 'tea for two'\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"request模块","url":"https://bubbleboy11.github.io/2020/08/21/request-mo-kuai/","content":"urllib 是 Python 标准库中用于网络请求的库。该库有四个模块，分别是urllib.request，urllib.error，urllib.parse，urllib.robotparser。其中urllib.request，urllib.error两个库在爬虫程序中应用比较频繁。urllib一般要先构建get或者post请求，然后再发起请求。\nrequests模块 基于HTTP请求的模块第三方的Python库，小规模，数据量小，速度不敏感、爬取网页\nrequests可以直接构建常用的get和post请求并发起，使用了urllib3，多次请求重复使用一个socket，“connection”:”keep-alive”，说明多次请求使用一个连接，消耗更少的资源\n作用：模拟浏览器发送HTTP请求。用于爬虫或接口的测试如何使用：\n\n指定url\n发起请求\n获取响应数据\n持久化存储\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Requests方法的13个访问控制参数参数名    说明```url```:获取页面的url链接```params```    字典或字节序列，作为参数增加到url中**kwargs：12个控制访问的参数```data```    字典、字节序列或文件对象，作为Request的内容```json```    JSON格式的数据，作为Request的内容```headers```    字典、HTTP定制头```cookies```    字典或CookieJar，Request中的cookie```auth```    元组，支持HTTP认证功能```files```    字典类型，传输文件```timeout```    设定超时时间，秒为单位```proxies```    字典类型，设定访问代理服务器，可以增加登录认证```allow_redirects    True/False```,默认为True，重定向开关```stream    True/False```,默认为True，获取内容立即下载开关```verify    True/False```,默认为True，认证SSL证书开关```cert```    本地SSL证书路径Request:构造一个向服务器请求资源的Request对象Response：返回一个包含服务器资源的Response对象### Response对象的属性```r.status_code```    HTTP请求的返回状态码```r.text```    HTTP响应内容的字符串形式，即 url对应的页面内容```r.encoding```    从HTTP header中猜测的响应内容编码方式，如果header中不存在charset字段，则认为编码为 ISO-8859-1```r.apparent_encoding```    从内容中分析出的响应内容编码方式（备选编码方式）```r.content```    HTTP响应内容的二进制形式### Requests库的异常```requests.ConnectionError```    网络连接异常，如DNS查询失败、拒绝连接等```requests.HTTPError```    HTTP错误异常```requests.URLRequired```    URL缺失异常```requests.TooManyRedirects```    超过最大重定向次数，产生重定向异常```requests.ConnectTimeout```    连接远程服务器超时异常```requests.Timeout```    请求URL超时，产生异常```requuests.request()```    构造一个请求，支撑以下各方法的基础方法```requests.get()```    获取HTML网页的主要方法，对应于HTTP的GET```requests.head()```    获取HTML网页头信息的方法，对应于HTTP的HEAD```requests.post()```    向HTML网页提交POST请求的方法，对应于HTTP的POST```requests.put()```    向HTML网页提交PUT请求的方法，对应于HTTP的PUT```requests.patch()```    向HTML网页提交局部修改请求，对应于HTTP的PATCH```requests.delete()```    向HTML网页提交删除请求，对应于HTTP的DELETE```pyimport requestsr = requests.get(\"http://www.baidu.com\")print(r.status_code)  # 检测请求网页的状态码# 输出200r.encoding = 'utf-8'print(r.text)# 输出网页内容\n\n通用框架\n12345678910111213141516import requestsdef getHTMLText(url):    try:        r = requests.get(url, timeout=30)        r.raise_for_status()  # 如果状态不是200，引发HTTPError异常        r.encoding = r.apparent_encoding  # 使得返回内容的解码是正确的        return r.text    except:        return \"产生异常\"if __name__ == \"__main__\":    url = import requestsdef getHTMLText(url):    try:        r = requests.get(url, timeout=30)        r.raise_for_status()  # 如果状态不是200，引发HTTPError异常        r.encoding = r.apparent_encoding  # 使得返回内容的解码是正确的        return r.text    except:        return \"产生异常\"if __name__ == \"__main__\":    url = \"http://www.baidu.com\"    print(getHTMLText(url))\n\nrequest使用代理很多网站如果发现同一个IP发出的大量请求，就会封禁这样的IP爬虫为了避免被封IP，必须不断地更换IP地址发出请求，这个时候就需要使用代理\nrequests库有一个代理参数proxies可以指定通过代理服务器发起请求proxies参数是一个字典，里面包含了http和https的代理URL\n12345678910111213141516import requests# 不使用代理resp = requests.get('http://httpbin.org/ip')print(resp.text)# {\"origin\": \"114.93.163.248\"}proxies = {    'http': 'http://139.227.252.141:8118',    'https': 'https://139.227.252.141:8118'}# 使用代理resp = requests.get('http://httpbin.org/ip', proxies=proxies)print(resp.text)import requests# 不使用代理resp = requests.get('http://httpbin.org/ip')print(resp.text)# {\"origin\": \"114.93.163.248\"}proxies = {    'http': 'http://139.227.252.141:8118',    'https': 'https://139.227.252.141:8118'}# 使用代理resp = requests.get('http://httpbin.org/ip', proxies=proxies)print(resp.text)# {\"origin\": \"139.227.252.141\"}\n\n需求1：爬取搜狗首页的页面数据\n1234567891011121314import requests if __name__ == '__main__':    # 第一步：指定url    url = 'https://www.sogou.com/'    # 第二步：发起请求    response = requests.get(url)    # 第三步：获取响应数据    page_text = response.text    # print(page_text)    # 第四步：持久化存储    with open('./搜狗首页.html', 'w', encoding='utf-8')as fp:        fp.write(page_text)    print(import requests if __name__ == '__main__':    # 第一步：指定url    url = 'https://www.sogou.com/'    # 第二步：发起请求    response = requests.get(url)    # 第三步：获取响应数据    page_text = response.text    # print(page_text)    # 第四步：持久化存储    with open('./搜狗首页.html', 'w', encoding='utf-8')as fp:        fp.write(page_text)    print('爬取结束')\n\n需求2：实现一个简易的网页采集器（爬取搜狗指定词条对应的搜索结果页面）UA伪装：门户网站的服务器会检测载体身份标识，如果检测到是爬虫发起就会拒绝访问，所以需要伪装成正常的浏览器访问身份。\n123456789101112131415161718import requests if __name__ == '__main__':    url = 'https://www.sogou.com/web'    # 处理url携带的参数：封装到字典中    keyWord = input('请输入关键字：')    param = {        'query': keyWord    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.get(url=url, params=param, headers=headers)    page_text = response.text    filename = './简易网页采集/' + keyWord + '.html'    with open(filename, 'w', encoding='utf-8') as fp:        fp.write(page_text)    print(keyWord + import requests if __name__ == '__main__':    url = 'https://www.sogou.com/web'    # 处理url携带的参数：封装到字典中    keyWord = input('请输入关键字：')    param = {        'query': keyWord    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.get(url=url, params=param, headers=headers)    page_text = response.text    filename = './简易网页采集/' + keyWord + '.html'    with open(filename, 'w', encoding='utf-8') as fp:        fp.write(page_text)    print(keyWord + '  保存成功！')\n\n需求3：破解百度翻译注意：响应数据为json类型；请求方式为POST\n123456789101112131415161718import jsonimport requests if __name__ == '__main__':    url = 'https://fanyi.baidu.com/sug'    keyWord = input('请输入关键字：')    data = {        'kw': keyWord    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.post(url=url, data=data, headers=headers)    page_json = response.json()    # print(page_json)    fp = open('./百度翻译/' + keyWord + \".json\", 'w', encoding='utf-8')    json.dump(page_json, fp=fp, ensure_ascii=False)    print(import jsonimport requests if __name__ == '__main__':    url = 'https://fanyi.baidu.com/sug'    keyWord = input('请输入关键字：')    data = {        'kw': keyWord    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.post(url=url, data=data, headers=headers)    page_json = response.json()    # print(page_json)    fp = open('./百度翻译/' + keyWord + \".json\", 'w', encoding='utf-8')    json.dump(page_json, fp=fp, ensure_ascii=False)    print('翻译结束！已保存')\n\n需求4：爬取豆瓣电影分类排行榜\n123456789101112131415161718192021import jsonimport requests if __name__ == '__main__':    url = 'https://movie.douban.com/j/chart/top_list'    num = input('请输入前多少名数据:')    param = {        'type': '11',        'interval_id': '100:90',        'action': '',        'start': '0',        'limit': num    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.get(url=url, params=param, headers=headers)    list_data = response.json()    fp = open('./豆瓣排行/豆瓣排行.json', 'w', encoding='utf-8')    json.dump(list_data, fp=fp, ensure_ascii=False)    print(import jsonimport requests if __name__ == '__main__':    url = 'https://movie.douban.com/j/chart/top_list'    num = input('请输入前多少名数据:')    param = {        'type': '11',        'interval_id': '100:90',        'action': '',        'start': '0',        'limit': num    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.get(url=url, params=param, headers=headers)    list_data = response.json()    fp = open('./豆瓣排行/豆瓣排行.json', 'w', encoding='utf-8')    json.dump(list_data, fp=fp, ensure_ascii=False)    print('保存完成')\n\n需求5：肯德基餐厅查询（http://www.kfc.com.cn/kfccda/storelist/index.aspx）\n123456789101112131415161718192021222324252627import jsonimport requests if __name__ == '__main__':    url = 'http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx'    cname = input('请输入城市：')    keyword = input('请输入关键字：')    op = 'keyword'    param = {        'op': op    }    data = {        'cname': cname,        'pid': '',        'keyword': keyword,        'pageIndex': '1',        'pageSize': '10'    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.post(url=url, data=data, headers=headers, params=param)    print(response.json())    table_data = response.json()    fp = open('./肯德基餐厅/'+cname+'_'+keyword+'.json', 'w', encoding='utf-8')    json.dump(table_data, fp=fp, ensure_ascii=False)    print(import jsonimport requests if __name__ == '__main__':    url = 'http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx'    cname = input('请输入城市：')    keyword = input('请输入关键字：')    op = 'keyword'    param = {        'op': op    }    data = {        'cname': cname,        'pid': '',        'keyword': keyword,        'pageIndex': '1',        'pageSize': '10'    }    headers = {        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Edg/88.0.705.56'    }    response = requests.post(url=url, data=data, headers=headers, params=param)    print(response.json())    table_data = response.json()    fp = open('./肯德基餐厅/'+cname+'_'+keyword+'.json', 'w', encoding='utf-8')    json.dump(table_data, fp=fp, ensure_ascii=False)    print('保存完成')\n\n1234567891011121314151617181920212223import requestsURL_GET = \"https://api.douban.com/v2/event/list\"def use_params_requests():    # 构建请求参数    params = {'loc': '108288', 'day_type': 'weekend', 'type': 'exhibition'}    # 发送请求    response = requests.get(URL_GET, params=params)    # 处理响应    print('&gt;&gt;&gt;&gt;&gt;&gt;Response Headers:')    print(response.headers)    print('&gt;&gt;&gt;&gt;&gt;&gt;Status Code:')    print(response.status_code)    print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;Response Body:')    print(response.text)if __name__ == '__main__':    print(import requestsURL_GET = \"https://api.douban.com/v2/event/list\"def use_params_requests():    # 构建请求参数    params = {'loc': '108288', 'day_type': 'weekend', 'type': 'exhibition'}    # 发送请求    response = requests.get(URL_GET, params=params)    # 处理响应    print('&gt;&gt;&gt;&gt;&gt;&gt;Response Headers:')    print(response.headers)    print('&gt;&gt;&gt;&gt;&gt;&gt;Status Code:')    print(response.status_code)    print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;Response Body:')    print(response.text)if __name__ == '__main__':    print('Use params requests:')    use_params_requests()\n\n网络图片爬取及存储\n12345678910111213141516171819202122'''r.content  #表示返回内容的二进制格式'''import requestsimport osnew_folder = './Picture/'  # 相对路径url = 'http://img0.dili360.com/ga/M00/02/AB/wKgBzFQ26i2AWujSAA_-xvEYLbU441.jpg@!rw9'path = new_folder + url.split('/')[-1].split('@')[0]try:    if not os.path.exists(new_folder):        os.mkdir(new_folder)  # 创建新目录    if not os.path.exists(path):        r = requests.get(url)        # 如何将二进制转化为图片保存        with open(path, 'wb') as f:            # 新建wKgBzFQ26i2AWujSAA_-xvEYLbU441.jpg            f.write(r.content)            f.close()            print('图片保存成功')    else:        print('文件已存在')except:    print('''r.content  #表示返回内容的二进制格式'''import requestsimport osnew_folder = './Picture/'  # 相对路径url = 'http://img0.dili360.com/ga/M00/02/AB/wKgBzFQ26i2AWujSAA_-xvEYLbU441.jpg@!rw9'path = new_folder + url.split('/')[-1].split('@')[0]try:    if not os.path.exists(new_folder):        os.mkdir(new_folder)  # 创建新目录    if not os.path.exists(path):        r = requests.get(url)        # 如何将二进制转化为图片保存        with open(path, 'wb') as f:            # 新建wKgBzFQ26i2AWujSAA_-xvEYLbU441.jpg            f.write(r.content)            f.close()            print('图片保存成功')    else:        print('文件已存在')except:    print(\"爬取失败\")\n\n百度/360搜索关键字\n1234567891011#实例3：爬取搜索页面import requeststry:    kw = {'wd': 'python'}    r = requests.get('https://www.baidu.com/s', params=kw)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(len(r.text))  # 227    # r.request.url  返回的是百度安全验证的链接？except:    print(#实例3：爬取搜索页面import requeststry:    kw = {'wd': 'python'}    r = requests.get('https://www.baidu.com/s', params=kw)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(len(r.text))  # 227    # r.request.url  返回的是百度安全验证的链接？except:    print(\"爬取失败\")\n\n123456789import requeststry:    kw = {'q': 'python'}  # 360搜索的关键字的键为q    r = requests.get('https://www.so.com/s', params=kw)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(len(r.text))  #257468except:    print(import requeststry:    kw = {'q': 'python'}  # 360搜索的关键字的键为q    r = requests.get('https://www.so.com/s', params=kw)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(len(r.text))  #257468except:    print(\"爬取失败\")\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"REST","url":"https://bubbleboy11.github.io/2020/08/21/restful/","content":"web service 是一种跨编程语言 和 跨操作系统平台的远程调用技术。\n最重要的两种实现方式： SOAP &amp; REST \nweb 2.0时代，REST方法的广泛普及\nSOAP - Simple Object Access Protocol 简单对象访问协议，一种协议规范，是一种轻量的，简单的，基于XML的协议。\nSOAP与REST区别：\n\n安全性：SOAP会好于REST\n效率和易用性：REST更胜一筹\n成熟度：总的来说SOAP在成熟度上优于REST\n\nREST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义，\n\nhttp是应用协议而非传输协议\n是一种以资源为中心的 web软件系统架构设计风格(它既不是一个标准规范也不是一个强制性约束)，一种分布式系统的应用层解决方案，\n目的：Client 和 Server 端进一步解耦 \n可以用 Ajax 和RESTful web服务构建应用\n可以降低开发的复杂性，提高系统的可伸缩性。\n\nRESTful API：RESTful 风格的 API接口实现 设计概念和准则RESTful 三个名词的解释面向资源的接口设计 （不同于 SOAP协议，SOAP 是面向服务的）\n\nResources(资源)：使用 URI 指向的一个实体，比如：在web应用当中一个用户，一首音乐或者一个订单都是可把它表示成一个实体。\n\n所有事物抽象为资源(resource)，资源对应唯一的标识(identifier)。标识符在网站上的表现形式就是URI。每一个URL代表1种资源，\n\n\n对资源的操作不会改变资源的标识。因为你一旦改变了资源的标识就会导致链接不可用或者资源查找不到。\n\nRepresentation(表现层)：资源的表现形式，比如图片、HTML文本等\n\nState Transfer(状态转化)： \n\n以及对资源的四种HTTP的GET、POST、PUT、DELETE动词语义的增删改查操作实现这个url对应的资源状态的改变，(把 HTTP 请求方式和数据库的增删改查CRUD(create/retrieve/update/delete)联系结合到一起)，\n\n资源通过接口进行操作实现状态转移，操作本身是无状态的。因为HTTP协议本身就是一个无状态的协议，它只能通过每次发的cookie值来识别用户，但是每两次http之间的请求它们是没有任何关系的、没有先后顺序。\n\n一般使用 JSON 格式返回数据，而一般比较少使用XML，因为JSON它比较可读。\n\n更“精简”的方式处理返回结果设计对于每一个http请求的响应结果都要指明一个状态码，具体产品由具体产品 api 文档给出。比如修改一个数据的时候，只需要得到http状态码的结果，200或201表示修改成功\n12345{    \"msg\":\"uri_not_found\",    \"code\":1001,    \"request\": {    \"msg\":\"uri_not_found\",    \"code\":1001,    \"request\": \"GET \\/v2\\/photo\\/132\"}\n\n\n\nREST 和 RESTful的区别：\n\nRESTful是REST的形容词形式\n一般来说REST等于RESTful，区别一个是名词一个是形容词\n\n\n新建资源-用HTTP POST请求、\n获取资源-用HTTP GET请求、\n获取某个资源的头部信息-用HTTP HEAD请求、\n更新资源-用HTTP PUT请求、\n删除资源-用HTTP DELETE请求\n\nREST API 接口实例 url用名词HTTP方法          URL后缀                         动作【head】     /product                          # 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息【GET】      /product                          # 请求获取URL位置的资源，查询所有商品信息列表【GET】      /product/product_id               # 查看某个指定商品信息【GET】      /product/product_id/purchase      # 列出某个指定商品的所有投资者【GET】      /product/product_id/purchase/ID   # 获取某个指定商品的指定投资者信息\n【POST】     /product                          # 请求向URL位置的资源后附加新的数据，新建一个商品【PUT】      /product/product_id               # 请求向URL位置存储一个资源，覆盖原URL位置的资源，更新某个指定商品信息(全部字段)【PATCH】    /product/product_id               # 请求局部更新URL位置的资源，覆盖原URL位置的资源，更新商品信息(部分字段)【DELETE】   /product/product_id               # 请求删除URL位置存储的资源，删除某个商品\n\n一般 web 框架都有相应的插件支持 RESTful API。比如Django有 rest framework，Flask和Tornado分别有flask restful 和 tornado restful。现在主流的web框架都是相关的RESTful API插件。\n\n如何设计RESTful API？设计规范：\n\n协议：使用 HTTPs 协议，确保交互数据的传输安全。\n域名：应该尽量将 API 部署在专用域名之下。i.e https://api.example.com\n版本控制：将版本号放在 URL 或者 Header 中\n路径：只能包含名词，不能包括动词\n过滤信息：?limit=10 ?offset=10 ?page=1 ?sortby=name\nHypermedia API：在返回结果中提供相关资源的链接，连向其他 API 方法\n验证（Authentication）：确定用户是其申明的身份，比如提供账户的密码。\n授权（Authorization）：保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访可，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等。\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["web"],"tags":[]},{"title":"selenium","url":"https://bubbleboy11.github.io/2020/08/21/selenium/","content":"selenium一个浏览器自动化测试的框架，可以通过 Python 代码来控制浏览器完成相关的测试，同时也能辅助完成数据的爬取。利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","测试"]},{"title":"sort sorted","url":"https://bubbleboy11.github.io/2020/08/21/sort-sorted/","content":"list.sort()只是为列表定义的，返回的是对已经存在的列表进行操作，没有新建列表\n1234a = [5, 2, 3, 1, 4]a.sort()  # sort返回的是对已经存在的列表进行操作print(a)  # [1, 2, 3, 4, 5]print([5, 2, 3, 1, 4].sort())  a = [5, 2, 3, 1, 4]a.sort()  # sort返回的是对已经存在的列表进行操作print(a)  # [1, 2, 3, 4, 5]print([5, 2, 3, 1, 4].sort())  # None sort返回的是对已经存在的列表进行操作，没有新建列表\n\nsorted(iterable, key=None, reverse=False)返回的是一个新的对所有可迭代的对象进行排序操作的列表，而不是在原来的基础上进行的操作。iterable – 可迭代对象。key – 用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。Key参数/键函数从python2.4开始，list.sort()和sorted()函数增加了key参数来指定在进行比较前要在每个列表元素上调用的函数（或其他可调用对象）。key 形参的值应该是个函数（或其他可调用对象），它接受一个参数并返回一个用于排序的键。 这种机制速度很快，因为对于每个输入记录只会调用一次键函数。\nreverse – 排序规则，reverse = True 降序 ，reverse = False 升序（默认）。\n12345678910example_list = [5, 0, 6, 1, 2, 7, 3, 4]result_list = sorted(example_list)print(result_list)# [0, 1, 2, 3, 4, 5, 6, 7]默认升序result_list = sorted(example_list, reverse=True)print(result_list)# [7, 6, 5, 4, 3, 2, 1, 0] 反转降序result_list = sorted(example_list, key=lambda x: x * -1)print(result_list)example_list = [5, 0, 6, 1, 2, 7, 3, 4]result_list = sorted(example_list)print(result_list)# [0, 1, 2, 3, 4, 5, 6, 7]默认升序result_list = sorted(example_list, reverse=True)print(result_list)# [7, 6, 5, 4, 3, 2, 1, 0] 反转降序result_list = sorted(example_list, key=lambda x: x * -1)print(result_list)# [7, 6, 5, 4, 3, 2, 1, 0]\n\n将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序法一\n12print(sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5 - x)))  print(sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5 - x)))  # [5, 4, 6, 3, 7, 2, 8, 1, 9]\n\n法二\n12345678list = [1, 2, 3, 4, 5, 6, 7, 8, 9]def run(x):    return abs(5 - x)print(sorted(list, key=run))  list = [1, 2, 3, 4, 5, 6, 7, 8, 9]def run(x):    return abs(5 - x)print(sorted(list, key=run))  # [5, 4, 6, 3, 7, 2, 8, 1, 9]\n\n1234print(sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}))# [1, 2, 3, 4, 5]print(sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}, key=lambda x: x * -1))print(sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}))# [1, 2, 3, 4, 5]print(sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'}, key=lambda x: x * -1))# [5, 4, 3, 2, 1]\n\n通过key指定的内置函数来\n1234567891011# 按照小写字母排序print(sorted(\"This is a test string from Andrew\".split(), key=str.lower))# ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']print(sorted([\"adf\", \"Adfdg\", \"aDfgbdfafg\", \"Gahgfh\"], key = str.lower)) #输出 ['adf', 'Adfdg', 'aDfgbdfafg', 'Gahgfh']# 把数组按照长度大小进行排序，只需设置key等于一个函数即可sorted([\"adf\", \"Adfdg\", \"aDfgbdfafg\", \"Gahgfh\"], key = len) # 按照小写字母排序print(sorted(\"This is a test string from Andrew\".split(), key=str.lower))# ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']print(sorted([\"adf\", \"Adfdg\", \"aDfgbdfafg\", \"Gahgfh\"], key = str.lower)) #输出 ['adf', 'Adfdg', 'aDfgbdfafg', 'Gahgfh']# 把数组按照长度大小进行排序，只需设置key等于一个函数即可sorted([\"adf\", \"Adfdg\", \"aDfgbdfafg\", \"Gahgfh\"], key = len) #输出 ['adf', 'adfdg', 'gahgfh', 'adfgbdfafg']\n一种常见的模式是使用对象的一些索引作为键对复杂对象进行排序。例如：\n12345678&gt;&gt;&gt; student_tuples = [        ('john', 'A', 15),        ('jane', 'B', 12),        ('dave', 'B', 10),]# sort by age&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', &gt;&gt;&gt; student_tuples = [        ('john', 'A', 15),        ('jane', 'B', 12),        ('dave', 'B', 10),]# sort by age&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2])[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n同样的技术也适用拥有命名属性的对象，例如：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 在排序时, 可以用lambda表达式将对象map成keys# 亦可以使用operator包中的attrgetter和itemgetter函数以提高效率class Student:    def __init__(self, name, grade, age):        self.name = name        self.grade = grade        self.age = age    def __repr__(self):        return repr((self.name, self.grade, self.age))# 建立一组Student对象students = [    Student('jane', 'B', 12),    Student('john', 'A', 15),    Student('dave', 'B', 10),]from operator import itemgetter, attrgetterprint(sorted(students, key=lambda o: o.age))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]print(sorted(students, key=itemgetter(2))) # TypeError: 'Student' object is not subscriptable# 对students按照年龄排序print(sorted(students, key=attrgetter('age')))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# Operator 模块功能允许多级排序。 先按age再按grade排序print(sorted(students, key=attrgetter('age', 'grade')))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# 例如，要按 grade 降序然后 age 升序对学生数据进行排序，请先 age 排序，然后再使用 grade 排序：# sort on secondary keys = sorted(students, key=attrgetter('age'))# now sort on primary key, descendingprint(sorted(s, key=attrgetter('grade'), reverse=True))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# 抽象为一个包装函数，该函数能接受一个列表以及字段和顺序的元组，以对它们进行多重排序。def multisort(xs, specs):    for key, reverse in reversed(specs):        xs.sort(key=attrgetter(key), reverse=reverse)    return xsprint(multisort(list(students), (('grade', True), ('age', False))))# 在排序时, 可以用lambda表达式将对象map成keys# 亦可以使用operator包中的attrgetter和itemgetter函数以提高效率class Student:    def __init__(self, name, grade, age):        self.name = name        self.grade = grade        self.age = age    def __repr__(self):        return repr((self.name, self.grade, self.age))# 建立一组Student对象students = [    Student('jane', 'B', 12),    Student('john', 'A', 15),    Student('dave', 'B', 10),]from operator import itemgetter, attrgetterprint(sorted(students, key=lambda o: o.age))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]print(sorted(students, key=itemgetter(2))) # TypeError: 'Student' object is not subscriptable# 对students按照年龄排序print(sorted(students, key=attrgetter('age')))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# Operator 模块功能允许多级排序。 先按age再按grade排序print(sorted(students, key=attrgetter('age', 'grade')))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# 例如，要按 grade 降序然后 age 升序对学生数据进行排序，请先 age 排序，然后再使用 grade 排序：# sort on secondary keys = sorted(students, key=attrgetter('age'))# now sort on primary key, descendingprint(sorted(s, key=attrgetter('grade'), reverse=True))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# 抽象为一个包装函数，该函数能接受一个列表以及字段和顺序的元组，以对它们进行多重排序。def multisort(xs, specs):    for key, reverse in reversed(specs):        xs.sort(key=attrgetter(key), reverse=reverse)    return xsprint(multisort(list(students), (('grade', True), ('age', False))))# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n1234567891011121314151617181920212223242526272829303132from operator import itemgetter, attrgetter__author__ = 'blackmatrix'get_name = lambda user: user['name']get_address = lambda user: getattr(user, 'address')class User:    def __init__(self, name, address):        self.name = name        self.address = addresslaowang = {'name': '老王', 'address': '隔壁'}laoli = User('老李', '楼下')if __name__ == '__main__':    # itemgetter('name') 和 get_name 作用是相同的    # 都是接受一个对象，获取对象key为name的值    # 主要用来替代只是为了获取value的lambda函数    print(itemgetter('name')(laowang))  # 老王    print(itemgetter('address')(laowang))  # 隔壁    print(get_name(laowang))  # 老王    # print(get_address(laowang))  # 'dict' object has no attribute 'address'          # 同样的，attrgetter('address')也是等同于get_address    # 用来替代只为了获取attr的lambda函数    print(attrgetter('address')(laoli))  # 楼下    print(get_address(laoli))  from operator import itemgetter, attrgetter__author__ = 'blackmatrix'get_name = lambda user: user['name']get_address = lambda user: getattr(user, 'address')class User:    def __init__(self, name, address):        self.name = name        self.address = addresslaowang = {'name': '老王', 'address': '隔壁'}laoli = User('老李', '楼下')if __name__ == '__main__':    # itemgetter('name') 和 get_name 作用是相同的    # 都是接受一个对象，获取对象key为name的值    # 主要用来替代只是为了获取value的lambda函数    print(itemgetter('name')(laowang))  # 老王    print(itemgetter('address')(laowang))  # 隔壁    print(get_name(laowang))  # 老王    # print(get_address(laowang))  # 'dict' object has no attribute 'address'          # 同样的，attrgetter('address')也是等同于get_address    # 用来替代只为了获取attr的lambda函数    print(attrgetter('address')(laoli))  # 楼下    print(get_address(laoli))  # 楼下\n\n\n多字段排序按照第一个数从小到大排序，如果第一个数相同，就按第二个数从大到小。\n123a = [[2,3],[4,1],(2,8),(2,1),(3,4)]sorted(a, key = lambda x: (x[0], -x[1])) a = [[2,3],[4,1],(2,8),(2,1),(3,4)]sorted(a, key = lambda x: (x[0], -x[1])) # 输出：[(2, 8), [2, 3], (2, 1), (3, 4), [4, 1]]\n其实掌握自定义规则排序，多字段排序也就会了，因为它是自定义排序的子集！\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566array = [{    \"age\": 20,    \"name\": \"a\"}, {    \"age\": 25,    \"name\": \"b\"}, {    \"age\": 10,    \"name\": \"c\"}]# 法一array = sorted(array, key=lambda x: x[\"age\"])print(array)# [{'age': 10, 'name': 'c'}, {'age': 20, 'name': 'a'}, {'age': 25, 'name': 'b'}]# 法二# def by_age(info):#     array = [{\"age\": 20, \"name\": \"a\"}, {\"age\": 25, \"name\": \"b\"}, {\"age\": 10, \"name\": \"c\"}]#     return array.### l1 = sorted(array, key=by_age)# print('***')# print(l1)# 多列排序# 先按照成绩降序排序，相同成绩的按照名字升序排序：d1 = [{    'name': 'alice',    'score': 38}, {    'name': 'bob',    'score': 18}, {    'name': 'darl',    'score': 28}, {    'name': 'christ',    'score': 28}]l = sorted(d1, key=lambda x: (-x['score'], x['name']))print(l)# 输出结果：# [{'name': 'alice', 'score': 38}, {'name': 'christ', 'score': 28}, {'name': 'darl', 'score': 28}, {'name': 'bob', 'score': 18}]dictionary = {'name': 'Ashe', 'age': 18, 'city': 'Guilin', 'tel': '110'}print('---------')# dict.items()结果是键值对元组print(dictionary.items())# dict_items([('name', 'Ashe'), ('age', 18), ('city', 'Guilin'), ('tel', '110')])# i[0]表示key i[1]表示valuelist = sorted(dictionary.items(), key=lambda i: i[0], reverse=False)  # 不反转，即升序print('sorted根据字典key排序', list)print('-----')new_dict = {}for i in list:    new_dict[i[0]] = i[1]print('new dict', new_dict)print('***')# list = sorted(dictionary.items(), key=lambda i: i[1], reverse=False)# print('sorted根据字典value排序', list)# new_dict = {}# for i in list:#     new_dict[i[0]] = i[1]# print('***')array = [{    \"age\": 20,    \"name\": \"a\"}, {    \"age\": 25,    \"name\": \"b\"}, {    \"age\": 10,    \"name\": \"c\"}]# 法一array = sorted(array, key=lambda x: x[\"age\"])print(array)# [{'age': 10, 'name': 'c'}, {'age': 20, 'name': 'a'}, {'age': 25, 'name': 'b'}]# 法二# def by_age(info):#     array = [{\"age\": 20, \"name\": \"a\"}, {\"age\": 25, \"name\": \"b\"}, {\"age\": 10, \"name\": \"c\"}]#     return array.### l1 = sorted(array, key=by_age)# print('***')# print(l1)# 多列排序# 先按照成绩降序排序，相同成绩的按照名字升序排序：d1 = [{    'name': 'alice',    'score': 38}, {    'name': 'bob',    'score': 18}, {    'name': 'darl',    'score': 28}, {    'name': 'christ',    'score': 28}]l = sorted(d1, key=lambda x: (-x['score'], x['name']))print(l)# 输出结果：# [{'name': 'alice', 'score': 38}, {'name': 'christ', 'score': 28}, {'name': 'darl', 'score': 28}, {'name': 'bob', 'score': 18}]dictionary = {'name': 'Ashe', 'age': 18, 'city': 'Guilin', 'tel': '110'}print('---------')# dict.items()结果是键值对元组print(dictionary.items())# dict_items([('name', 'Ashe'), ('age', 18), ('city', 'Guilin'), ('tel', '110')])# i[0]表示key i[1]表示valuelist = sorted(dictionary.items(), key=lambda i: i[0], reverse=False)  # 不反转，即升序print('sorted根据字典key排序', list)print('-----')new_dict = {}for i in list:    new_dict[i[0]] = i[1]print('new dict', new_dict)print('***')# list = sorted(dictionary.items(), key=lambda i: i[1], reverse=False)# print('sorted根据字典value排序', list)# new_dict = {}# for i in list:#     new_dict[i[0]] = i[1]# print('***')# print('new dict', new_dict)\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"turtle","url":"https://bubbleboy11.github.io/2020/08/21/turtle/","content":"turtle在屏幕上绘制图形1.画布(canvas)画布就是turtle为我们展开用于绘图区域默认大小(400, 300)，我们可以设置它的大小和初始位置。\n2.画笔（pen）2.1画笔的状态在画布上，默认有一个坐标原点为画布中心的坐标轴，坐标原点上有一只面朝x轴正方向小乌龟。这里我们描述小乌龟时使用了两个词语：坐标原点(位置)，面朝x轴正方向(方向)， turtle绘图中，就是使用位置方向描述小乌龟(画笔)的状态。\n2.2 画笔的属性画笔(画笔的属性，颜色、画线的宽度等)\nturtle.pensize()：设置画笔的宽度；turtle.pencolor()：没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如”green”,&nbsp;“red”,也可以是RGB&nbsp;3元组。turtle.speed(speed)：设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。2.3 绘图命令操纵海龟绘图有着许多的命令，这些命令可以划分为3种：一种为运动命令，一种为画笔控制命令，还有一种是全局控制命令。\n2.3.1 画笔运动命令:\n命令    说明turtle.home()    将turtle移动到起点（0,0）和向东turtle.speed(speed)    画笔绘制的速度范围[0,10]整数turtle.forward(distance)    向当前画笔方向移动distance像素长turtle.backward(distance)    向当前画笔相反方向移动distance像素长度turtle.right(degree)    顺时针移动degree°turtle.left(degree)    逆时针移动degree°turtle.pendown()    移动时绘制图形放下笔,,默认绘制turtle.penup()    移动时不绘制图形,提起笔，用于另起一个地方绘制时用turtle.circle(r,extent,step)    绘制一个指定半径、弧度范围、阶数(正多边形)的圆turtle.dot(diameter,color)    绘制一个指定直径和颜色的圆\n绘制长方形\n1234567891011121314import turtleturtle.pensize(4)turtle.pencolor('red')turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(import turtleturtle.pensize(4)turtle.pencolor('red')turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.mainloop()\n\n绘制奥运五环\n123456789101112131415161718192021222324import turtleturtle.width(10)turtle.color(\"blue\")turtle.circle(50)turtle.color(\"black\")turtle.penup()turtle.goto(120, 0)turtle.pendown()turtle.circle(50)turtle.color(\"red\")turtle.penup()turtle.goto(240, 0)turtle.pendown()turtle.circle(50)turtle.color(\"yellow\")turtle.penup()turtle.goto(60, -50)turtle.pendown()turtle.circle(50)turtle.color(\"green\")turtle.penup()turtle.goto(180, -50)turtle.pendown()turtle.circle(import turtleturtle.width(10)turtle.color(\"blue\")turtle.circle(50)turtle.color(\"black\")turtle.penup()turtle.goto(120, 0)turtle.pendown()turtle.circle(50)turtle.color(\"red\")turtle.penup()turtle.goto(240, 0)turtle.pendown()turtle.circle(50)turtle.color(\"yellow\")turtle.penup()turtle.goto(60, -50)turtle.pendown()turtle.circle(50)turtle.color(\"green\")turtle.penup()turtle.goto(180, -50)turtle.pendown()turtle.circle(50)\n\n12345678910111213import turtle #导入 turtle 模块turtle.showturtle() #显示箭头turtle.write(\"xy\") #写字符串turtle.forward(300) #前进 300 像素turtle.color(\"red\") #画笔颜色改为 redturtle.left(90) #箭头左转 90 度turtle.forward(300)turtle.goto(0,50) #去坐标（0,50）turtle.goto(0,0)turtle.penup() #抬笔。这样，路径就不会画出来turtle.goto(0,300)turtle.pendown() #下笔。这样，路径就会画出来turtle.circle(100) import turtle #导入 turtle 模块turtle.showturtle() #显示箭头turtle.write(\"xy\") #写字符串turtle.forward(300) #前进 300 像素turtle.color(\"red\") #画笔颜色改为 redturtle.left(90) #箭头左转 90 度turtle.forward(300)turtle.goto(0,50) #去坐标（0,50）turtle.goto(0,0)turtle.penup() #抬笔。这样，路径就不会画出来turtle.goto(0,300)turtle.pendown() #下笔。这样，路径就会画出来turtle.circle(100) #画圆\n\npentagram\n1234567891011121314151617181920import turtleimport timeturtle.pensize(5)turtle.pencolor(\"yellow\")turtle.fillcolor(\"red\")turtle.begin_fill()for _ in range(5):    turtle.forward(200)    turtle.right(144)turtle.end_fill()time.sleep(2)turtle.penup()turtle.goto(-150, -120)turtle.color(\"violet\")turtle.write(\"Done\", font=('Arial', 40, 'normal'))turtleimport turtleimport timeturtle.pensize(5)turtle.pencolor(\"yellow\")turtle.fillcolor(\"red\")turtle.begin_fill()for _ in range(5):    turtle.forward(200)    turtle.right(144)turtle.end_fill()time.sleep(2)turtle.penup()turtle.goto(-150, -120)turtle.color(\"violet\")turtle.write(\"Done\", font=('Arial', 40, 'normal'))turtle.mainloop()\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/unittest/","content":"unittest基于Java的流行测试框架Junit，通过使用unittest我们可以以结构化的方式编写大型而且周详的测试集。\n123456789101112help('unittest')DESCRIPTION    Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's    Smalltalk testing framework (used with permission).    This module contains the core framework classes that form the basis of       specific test cases and suites (TestCase, TestSuite etc.), and also a        text-based utility class for running the tests and reporting the results      (TextTestRunner).dir(help('unittest')DESCRIPTION    Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's    Smalltalk testing framework (used with permission).    This module contains the core framework classes that form the basis of       specific test cases and suites (TestCase, TestSuite etc.), and also a        text-based utility class for running the tests and reporting the results      (TextTestRunner).dir(unittest)[‘BaseTestSuite’, ‘FunctionTestCase’, ‘SkipTest’, ‘TestCase’, ‘TestLoader’, ‘TestProgram’, ‘TestResult’, ‘TestSuite’, ‘TextTestResult’, ‘TextTestRunner’, ‘_TextTestResult’, ‘all’, ‘builtins’, ‘doc’, ‘file’, ‘name’, ‘package’, ‘path’, ‘__unittest’, ‘_expectedFailureInRpmBuild’, ‘_skipInRpmBuild’, ‘case’, ‘defaultTestLoader’, ‘expectedFailure’, ‘findTestCases’, ‘getTestCaseNames’, ‘installHandler’, ‘loader’, ‘main’, ‘makeSuite’, ‘registerResult’, ‘removeHandler’, ‘removeResult’, ‘result’, ‘runner’, ‘signals’, ‘skip’, ‘skipIf’, ‘skipUnless’, ‘suite’, ‘util’]\n\n四大组件\n\nTestCase 测试用例所有测试用例类继承的基本类。测试行为的最小单位，通过对一些输入输出值的对比来进行测试检查。放置测试步骤和检查点\n\nTestLoader 测试加载器\n\n负责根据各种各样的规则收集测试用例，并把这些测试用例包装在一个TestSuite中。\n\ntest fixture: 用来在多个用例之间分享的预置条件操作和清理操作，说白了就是setup和teardown的集合。三种fixture类型\n\nsetUp, tearDown每个测试类的用例都会执行\nsetUpClass, tearDownClass每个类的第一个用例被执行前和最后一个用例执行后被执行\nsetUpModule, tearDownModule每个测试模的第一个用例被执行前和最后一个用例执行后被执行\n\n\n\n出现异常\n\n如果setup和teardown间的用例出现异常或者失败，teardown照样会被执行\n\n如果setUpClass和setUpModule中出现异常，那么他们控制范围内的用例不会被执行，并且对应的tearDownClass和tearDownModule也不会被执行\n\nTestSuite 测试套件组织测试用例的实例，支持测试用例的添加和删除，最终将传递给 testRunner进行测试执行。一个test suite由许多个TestCase组成，常见的情形是创建一个TestSuite的实例，然后向TestSuite实例添加测试用例TestCase实例，当所有测试添加之后，可以把TestSuite的实例传递给TextTestRunner，它会按照添加测试用例的顺序逐个去执行测试用例，并手机测试结果一组测试用例的集合，用来管理和组织测试用例。\n\nTextTestRunner一个test runner类会以文本的形式显示结果，在它们运行时会打印测试名字，发生的错误，并且在测试运行结束之后打印结果概要。将测试用例或测试用例集合聚合起来的集合，批量执行，并且向用户提供测试结果。\n\nTextTestResult由TextTestRunner调用，会显示出格式化的文本。\n\n\nunittest 模块使用的模式有三种，如下：\n通过调用unittest.main()来执行模块里所有的测试用例\n想要运行指定的用例需要将这些用例加入测试套件TestSuite中来运行，主要是4步\n新建一个测试套件TestSuite\n将测试用例一个一个加入该TestSuite\n新建一个TestRunner\n用该TestRunner来运行TestSuite\n\n\n通过testloader运行测试集\n\n测试类必须继承自unittest.TestCase测试用例必须以小写test开头断言函数需要通过测试类的self调用\n1234567891011121314151617181920212223242526import unittestclass TestStringMethods(unittest.TestCase):    def test_upper(self):        self.assertEqual('foo'.upper(), 'FOO')    def test_isupper(self):        self.assertTrue('FOO'.isupper())        self.assertFalse('Foo'.isupper())    def test_split(self):        s = 'hello world'        self.assertEqual(s.split(), ['hello', 'world'])        # check that s.split fails when the separator is not a string        with self.assertRaises(TypeError):            s.split(2)if __name__ == '__main__':    unittest.main()# ...# ----------------------------------------------------------------------# Ran 3 tests in 0.001simport unittestclass TestStringMethods(unittest.TestCase):    def test_upper(self):        self.assertEqual('foo'.upper(), 'FOO')    def test_isupper(self):        self.assertTrue('FOO'.isupper())        self.assertFalse('Foo'.isupper())    def test_split(self):        s = 'hello world'        self.assertEqual(s.split(), ['hello', 'world'])        # check that s.split fails when the separator is not a string        with self.assertRaises(TypeError):            s.split(2)if __name__ == '__main__':    unittest.main()# ...# ----------------------------------------------------------------------# Ran 3 tests in 0.001s# OK\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import unittestdef setUpModule():    print(\"setUpModule &gt;&gt;&gt;\")def tearDownModule():    print(\"tearDownModule &gt;&gt;&gt;\")class Test1(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(\"setUpClass for Test1 &gt;&gt;\")    @classmethod    def tearDownClass(cls):        print(\"tearDownClass for Test1 &gt;&gt;\")    def setUp(self):        # 测试前需执行的操作        print(\"setUp for Test1 &gt;\")    def tearDown(self):        # 测试用例执行完后所需执行的操作        print(\"tearDown for Test1 &gt;\")    def testCase1(self):        # 测试用例1 具体的测试脚本        print(\"testCase1 for Test1\")    def testCase2(self):        # 测试用例2 具体的测试脚本        print(\"testCase2 for Test1\")class Test2(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(\"setUpClass for Test2 &gt;&gt;\")    @classmethod    def tearDownClass(cls):        print(\"tearDownClass for Test2 &gt;&gt;\")    def setUp(self):        print(\"setUp for Test2 &gt;\")    def tearDown(self):        print(\"tearDown for Test2 &gt;\")    def testCase1(self):        print(\"testCase1 for Test2\")    def testCase2(self):        print(\"testCase2 for Test2\")if __name__ == \"__main__\":    unittest.main()# setUpModule &gt;&gt;&gt;# setUpClass for Test1 &gt;&gt;# setUp for Test1 &gt;# testCase1 for Test1# tearDown for Test1 &gt;# .setUp for Test1 &gt;# testCase2 for Test1# tearDown for Test1 &gt;# .tearDownClass for Test1 &gt;&gt;# setUpClass for Test2 &gt;&gt;# setUp for Test2 &gt;# testCase1 for Test2# tearDown for Test2 &gt;# .setUp for Test2 &gt;# testCase2 for Test2# tearDown for Test2 &gt;# .tearDownClass for Test2 &gt;&gt;# tearDownModule &gt;&gt;&gt;# ----------------------------------------------------------------------# Ran 4 tests in 0.002simport unittestdef setUpModule():    print(\"setUpModule &gt;&gt;&gt;\")def tearDownModule():    print(\"tearDownModule &gt;&gt;&gt;\")class Test1(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(\"setUpClass for Test1 &gt;&gt;\")    @classmethod    def tearDownClass(cls):        print(\"tearDownClass for Test1 &gt;&gt;\")    def setUp(self):        # 测试前需执行的操作        print(\"setUp for Test1 &gt;\")    def tearDown(self):        # 测试用例执行完后所需执行的操作        print(\"tearDown for Test1 &gt;\")    def testCase1(self):        # 测试用例1 具体的测试脚本        print(\"testCase1 for Test1\")    def testCase2(self):        # 测试用例2 具体的测试脚本        print(\"testCase2 for Test1\")class Test2(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(\"setUpClass for Test2 &gt;&gt;\")    @classmethod    def tearDownClass(cls):        print(\"tearDownClass for Test2 &gt;&gt;\")    def setUp(self):        print(\"setUp for Test2 &gt;\")    def tearDown(self):        print(\"tearDown for Test2 &gt;\")    def testCase1(self):        print(\"testCase1 for Test2\")    def testCase2(self):        print(\"testCase2 for Test2\")if __name__ == \"__main__\":    unittest.main()# setUpModule &gt;&gt;&gt;# setUpClass for Test1 &gt;&gt;# setUp for Test1 &gt;# testCase1 for Test1# tearDown for Test1 &gt;# .setUp for Test1 &gt;# testCase2 for Test1# tearDown for Test1 &gt;# .tearDownClass for Test1 &gt;&gt;# setUpClass for Test2 &gt;&gt;# setUp for Test2 &gt;# testCase1 for Test2# tearDown for Test2 &gt;# .setUp for Test2 &gt;# testCase2 for Test2# tearDown for Test2 &gt;# .tearDownClass for Test2 &gt;&gt;# tearDownModule &gt;&gt;&gt;# ----------------------------------------------------------------------# Ran 4 tests in 0.002s# OK\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import unittestclass Count(object):    def __init__(self, a, b):        self.a = int(a)        self.b = int(b)    def add(self):        return self.a + self.bclass TestCount(unittest.TestCase):    def setUp(self):        print(\"Test Start\")    def tearDown(self):        print(\"Test End\")    def test_add1(self):        j = Count(2, 3)        self.assertEqual(j.add(), 5)    def test_add2(self):        j = Count(3, 3)        self.assertEqual(j.add(), 5)if __name__ == \"__main__\":    # 1. 新建测试套件    suite = unittest.TestSuite()    # 2. 将用例加入测试套件    suite.addTest(TestCount(\"test_add1\"))    suite.addTest(TestCount(\"test_add2\"))    # 3. 新建TestRunner    runner = unittest.TextTestRunner()    # 4. 用TestRunner来执行TestSuite    runner.run(suite)# Test Start# Test End# .Test Start# Test End# F# ======================================================================# FAIL: test_add2 (__main__.TestCount)# ----------------------------------------------------------------------# Traceback (most recent call last):#   File \"c:/python代码/牛客网剑指offer66题思路 # 分析/空.py\", line 26, in test_add2#     self.assertEqual(j.add(), 5)# AssertionError: 6 != 5# ----------------------------------------------------------------------# Ran 2 tests in 0.001simport unittestclass Count(object):    def __init__(self, a, b):        self.a = int(a)        self.b = int(b)    def add(self):        return self.a + self.bclass TestCount(unittest.TestCase):    def setUp(self):        print(\"Test Start\")    def tearDown(self):        print(\"Test End\")    def test_add1(self):        j = Count(2, 3)        self.assertEqual(j.add(), 5)    def test_add2(self):        j = Count(3, 3)        self.assertEqual(j.add(), 5)if __name__ == \"__main__\":    # 1. 新建测试套件    suite = unittest.TestSuite()    # 2. 将用例加入测试套件    suite.addTest(TestCount(\"test_add1\"))    suite.addTest(TestCount(\"test_add2\"))    # 3. 新建TestRunner    runner = unittest.TextTestRunner()    # 4. 用TestRunner来执行TestSuite    runner.run(suite)# Test Start# Test End# .Test Start# Test End# F# ======================================================================# FAIL: test_add2 (__main__.TestCount)# ----------------------------------------------------------------------# Traceback (most recent call last):#   File \"c:/python代码/牛客网剑指offer66题思路 # 分析/空.py\", line 26, in test_add2#     self.assertEqual(j.add(), 5)# AssertionError: 6 != 5# ----------------------------------------------------------------------# Ran 2 tests in 0.001s# FAILED (failures=1)    \n\n123456789101112131415161718192021222324import unittest # 执行测试的类class UCTestCase(unittest.TestCase):    def setUp(self):        #测试前需执行的操作        .....           def tearDown(self):        #测试用例执行完后所需执行的操作        .....# 测试用例1    def testCreateFolder(self):        #具体的测试脚本        ......       def testDeleteFolder(self):    # 具体的测试脚本If __name__ == \"__main__\":       # 构造测试集， 添加测试用例            suite = unittest.TestSuite()suite.addTest(UC7TestCase(\"testCreateFolder\"))suite.addTest(UC7TestCase(\"testDeleteFolder\"))import unittest # 执行测试的类class UCTestCase(unittest.TestCase):    def setUp(self):        #测试前需执行的操作        .....           def tearDown(self):        #测试用例执行完后所需执行的操作        .....# 测试用例1    def testCreateFolder(self):        #具体的测试脚本        ......       def testDeleteFolder(self):    # 具体的测试脚本If __name__ == \"__main__\":       # 构造测试集， 添加测试用例            suite = unittest.TestSuite()suite.addTest(UC7TestCase(\"testCreateFolder\"))suite.addTest(UC7TestCase(\"testDeleteFolder\"))# 执行测试， 构造runner。  runner = unittest.TextTestRunner()runner.run(suite)\n\n\n\n12345678910111213141516171819202122import unittest class TestCase1(unittest.TestCase):    #def setUp(self):    #def tearDown(self):    def testCase1(self):        print 'aaa'          def testCase2(self):        print 'bbb'  class TestCase2(unittest.TestCase):    #def setUp(self):    #def tearDown(self):    def testCase1(self):        print 'aaa1'      def testCase2(self):        print 'bbb1'        if __name__ == \"__main__\":    #此用法可以同时测试多个类suite1=unittest.TestLoader().loadTestsFromTestCase(TestCase1)     suite2=unittest.TestLoader().loadTestsFromTestCase(TestCase2) suite = unittest.TestSuite([suite1, suite2]) unittest.TextTestRunner(verbosity=import unittest class TestCase1(unittest.TestCase):    #def setUp(self):    #def tearDown(self):    def testCase1(self):        print 'aaa'          def testCase2(self):        print 'bbb'  class TestCase2(unittest.TestCase):    #def setUp(self):    #def tearDown(self):    def testCase1(self):        print 'aaa1'      def testCase2(self):        print 'bbb1'        if __name__ == \"__main__\":    #此用法可以同时测试多个类suite1=unittest.TestLoader().loadTestsFromTestCase(TestCase1)     suite2=unittest.TestLoader().loadTestsFromTestCase(TestCase2) suite = unittest.TestSuite([suite1, suite2]) unittest.TextTestRunner(verbosity=2).run(suite)\n\n\nTestCase的用法源文件widget.py，也即我们要进行单元测试的文件。很简单的一个类，该类可以设置长宽，并且能够获取这两个值。1234567891011121314# /usr/bin/python# encoding:utf-8 class Widget:     def __init__(self, size=(40, 40)):         self._size = size     def get_size(self):         return self._size     def resize(self, width, height):         if width &lt; 0 or height &lt; 0:             raise ValueError, 'illegal size'             self._size = (width, height)if __name__ == '__main__':    widget = Widget()    # /usr/bin/python# encoding:utf-8 class Widget:     def __init__(self, size=(40, 40)):         self._size = size     def get_size(self):         return self._size     def resize(self, width, height):         if width &lt; 0 or height &lt; 0:             raise ValueError, 'illegal size'             self._size = (width, height)if __name__ == '__main__':    widget = Widget()    print widget.get_size()\n因此，我们可以撰写的单元测试代码文件widgettest.py如下：\n\n1234567891011121314151617181920212223242526# /usr/bin/python# encoding:utf-8from widget import Widgetimport unittestclass WidgetTestCase(unittest.TestCase):# 对象的初始化工作可以在setUp()方法中完成    def setUp(self):        self.widget = Widget()# 对象的资源的释放则可以在tearDown()方法中完成    def tearDown(self):        self.widget.dispose()        self.widget = None# 对应widget类中的get_size函数测试    def test_size(self):        self.assertEqual(self.widget.get_size(), (40, 40))# 对应widget类中resize函数的测试    def test_Resize(self):        self.widget.resize(100, 100)        self.assertEqual(self.widget.get_size(), (100, 100))if __name__ == # /usr/bin/python# encoding:utf-8from widget import Widgetimport unittestclass WidgetTestCase(unittest.TestCase):# 对象的初始化工作可以在setUp()方法中完成    def setUp(self):        self.widget = Widget()# 对象的资源的释放则可以在tearDown()方法中完成    def tearDown(self):        self.widget.dispose()        self.widget = None# 对应widget类中的get_size函数测试    def test_size(self):        self.assertEqual(self.widget.get_size(), (40, 40))# 对应widget类中resize函数的测试    def test_Resize(self):        self.widget.resize(100, 100)        self.assertEqual(self.widget.get_size(), (100, 100))if __name__ == \"__main__\":    unittest.main()\n\n其中有两个测试用例，分别为test_size, test_Resize， 在每个测试用例执行的过程中会首先执行setUp，然后执行测试用例，最后执行tearDown操作。每个测试用例的执行遵循相同的模式。其中要注意的是setUp和tearDown两个，又称为测试装置，setUp完成对象的初始化动作，而tearDown则完成资源的释放之类的操作。在实际工作中，最常见的实践仍是写一个测试类继承自unittest.TestCase，然后让每一个测试用例名称以test开头，在运行测试集合时使用unittest.main（）函数即可。自动化测试便是建立在这样的基础上。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/unittest-mo-kuai/","content":"可以在一个独立的文件里提供一个更全面的测试集\n123456789101112import unittestclass TestStatisticalFunctions(unittest.TestCase):    def test_average(self):        self.assertEqual(average([20, 30, 70]), 40.0)        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)        self.assertRaises(ZeroDivisionError, average, [])        self.assertRaises(TypeError, average, 20, 30, 70)unittest.main()  import unittestclass TestStatisticalFunctions(unittest.TestCase):    def test_average(self):        self.assertEqual(average([20, 30, 70]), 40.0)        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)        self.assertRaises(ZeroDivisionError, average, [])        self.assertRaises(TypeError, average, 20, 30, 70)unittest.main()  # Calling from the command line invokes all tests\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"yaml","url":"https://bubbleboy11.github.io/2020/08/21/yaml/","content":"yaml文本文件常用于一些定义好不常修改的内容，如服务配置文件pip install --index-url https://pypi.tuna.tsinghua.edu.cn/simple/ pyyaml不规定某一种文件或者key它对应的数据类型，从python的角度来说是字符串，但不需要加引号，当我们进行load的时候，python会对它进行额外的数据类型分析yaml文件在读取后得到的是字典类型的数据\n注意格式\n12345678910111213141516171819# key-valueurl:  https://www.imooc.com/# 列表types:  - 前沿  - 前端  - 后端  - 移动端  - 云计算  - 运维  - ui# 字典python:  web: django  spader: bs5a: 1b: 2c: [a, b, # key-valueurl:  https://www.imooc.com/# 列表types:  - 前沿  - 前端  - 后端  - 移动端  - 云计算  - 运维  - ui# 字典python:  web: django  spader: bs5a: 1b: 2c: [a, b, c]\n\n1234567891011121314151617muke.yamlurl:  https://www.imooc.com/types:  - 前沿  - 前端  - 后端  - 移动端  - 云计算  - 运维  - uipython:  web: django  spader: bs5a: 1b: muke.yamlurl:  https://www.imooc.com/types:  - 前沿  - 前端  - 后端  - 移动端  - 云计算  - 运维  - uipython:  web: django  spader: bs5a: 1b: 2c: [a, b, c]\n\n12345678910111213141516import yamldef read(path):    with open(path, 'r', encoding='utf-8') as f:        data = f.read()    result = yaml.load(data, Loader=yaml.FullLoader)    return resultif __name__ == '__main__':    result = read('muke.yaml')  # 传递相对路径    print(result)    # {'url': 'https://www.imooc.com/', 'types': ['前沿', '前端', '后端', '移动端', '云计算', '运维', 'ui'], 'python': {'web': 'django', 'spader': 'bs5'}, 'a': 1, 'b': 2, 'c': ['a', 'b', 'c']}     print(type(result))    import yamldef read(path):    with open(path, 'r', encoding='utf-8') as f:        data = f.read()    result = yaml.load(data, Loader=yaml.FullLoader)    return resultif __name__ == '__main__':    result = read('muke.yaml')  # 传递相对路径    print(result)    # {'url': 'https://www.imooc.com/', 'types': ['前沿', '前端', '后端', '移动端', '云计算', '运维', 'ui'], 'python': {'web': 'django', 'spader': 'bs5'}, 'a': 1, 'b': 2, 'c': ['a', 'b', 'c']}     print(type(result))    # \n\n\n12print(dir(yaml))print(dir(yaml))# ['AliasEvent', 'AliasToken', 'AnchorToken', 'BaseDumper', 'BaseLoader', 'BlockEndToken', 'BlockEntryToken', 'BlockMappingStartToken', 'BlockSequenceStartToken', 'CBaseDumper', 'CBaseLoader', 'CDumper', 'CFullLoader', 'CLoader', 'CSafeDumper', 'CSafeLoader', 'CUnsafeLoader', 'CollectionEndEvent', 'CollectionNode', 'CollectionStartEvent', 'DirectiveToken', 'DocumentEndEvent', 'DocumentEndToken', 'DocumentStartEvent', 'DocumentStartToken', 'Dumper', 'Event', 'FlowEntryToken', 'FlowMappingEndToken', 'FlowMappingStartToken', 'FlowSequenceEndToken', 'FlowSequenceStartToken', 'FullLoader', 'KeyToken', 'Loader', 'MappingEndEvent', 'MappingNode', 'MappingStartEvent', 'Mark', 'MarkedYAMLError', 'Node', 'NodeEvent', 'SafeDumper', 'SafeLoader', 'ScalarEvent', 'ScalarNode', 'ScalarToken', 'SequenceEndEvent', 'SequenceNode', 'SequenceStartEvent', 'StreamEndEvent', 'StreamEndToken', 'StreamStartEvent', 'StreamStartToken', 'TagToken', 'Token', 'UnsafeLoader', 'ValueToken', 'YAMLError', 'YAMLLoadWarning', 'YAMLObject', 'YAMLObjectMetaclass', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', '__with_libyaml__', '_warnings_enabled', 'add_constructor', 'add_implicit_resolver', 'add_multi_constructor', 'add_multi_representer', 'add_path_resolver', 'add_representer', 'compose', 'compose_all', 'composer', 'constructor', 'cyaml', 'dump', 'dump_all', 'dumper', 'emit', 'emitter', 'error', 'events', 'full_load', 'full_load_all', 'io', 'load', 'load_all', 'load_warning', 'loader', 'nodes', 'parse', 'parser', 'reader', 'representer', 'resolver', 'safe_dump', 'safe_dump_all', 'safe_load', 'safe_load_all', 'scan', 'scanner', 'serialize', 'serialize_all', 'serializer', 'tokens', 'unsafe_load', 'unsafe_load_all', 'warnings']\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"三元表达式","url":"https://bubbleboy11.github.io/2020/08/21/san-yuan-biao-da-shi/","content":"用简单的一行快速判断，而不是使用复杂的多行if语句。condition_is_true if condition else condition_is_false如果a&gt;b的结果为真，h=”变量1”,如果为假，h=”变量2”\n1234567891011121314151617a = 1b = 2h = \"\"print(\"变量1\" if a &gt; b else \"变量2\")  # 变量2print(\"True\" if a &gt; b else \"False\")  # Falseprint(True if a &gt; b else False)  # Falseprint(a &gt; b)  # Falsea = 1b = 2h = \"\"h = a - b if a &gt; b else a + bprint(h)  # 3is_fat = Truestate = \"fat\" if is_fat else \"not fat\"print(state)  a = 1b = 2h = \"\"print(\"变量1\" if a &gt; b else \"变量2\")  # 变量2print(\"True\" if a &gt; b else \"False\")  # Falseprint(True if a &gt; b else False)  # Falseprint(a &gt; b)  # Falsea = 1b = 2h = \"\"h = a - b if a &gt; b else a + bprint(h)  # 3is_fat = Truestate = \"fat\" if is_fat else \"not fat\"print(state)  # fat\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/shi-wu/","content":"Relational Database Management System 关系数据库管理系统RDBMS=SQL语句+事务(ACID)\n事务transaction：\n\n是数据库并发控制的基本单位\n是一个或者多个sql语句、数据库逻辑操作组成的集合\n\n默认，mysql执行每条sql语句都会自动开启和提交事务为了让多条sql语句纳入到一个事务之下，可以手动管理事务START TRANSACTION;\n例子转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n原子性(Atomicity)事务是最小的执行单位，不允许分割。一个事务中所有操作要么全部完成，要么全部失败。事务执行后，不允许停留在中间某个状态， \n一致性(consistency)：事务开始和结束之后数据完整性没有被破坏，执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n隔离性(Isolation)：允许多个事务同时对数据库修改和读写，事务不受其他并发事务的影响，如同在给定的时间内，该事务时数据库唯一运行的事务，各并发事务之间数据库是独立的；\n持久性(Durability):事务一旦提交，它对数据库中数据的改变是持久的。即便发生宕机数据库发生故障也不应该对其有任何影响，仍然可以依靠事务日志完成数据的持久化\n\n事务与回滚：COMMIT； 让redo日志与数据文件同步，事务的所有操作都会被持久化到数据库里面，提交了就会把事务操作下的结果同步ROLLBACK;把该事务所有的数据都打上标记，这些数据全都不会同步到数据文件里面，不存在中间状态的数据回滚：多个逻辑中某个操作出错，回到初始状态，一旦执行失败需要回滚操作来保持之前数据库的完整性）rollback就是数据库里做修改后&nbsp;（update，insert，delete）未commit&nbsp;之前，使用rollback可以恢复数据到修改之前\n事务处理MySQL提供事务处理的表引擎, InnoDB服务器层不管理事务，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱。比如在操纵两张表时候做一个事务，不能是一张表InnoDB另一张表MyISAM，这样事务是做不成功的。需要两张表都是InnoDB。\n在非事务的表上执行事务操作 MySQL不会发出提醒，也不会报错，如：在MyISAM表上做事务处理。\n举例说明数据库事务的使用场景以及注意事项在操纵(增删改)重要数据时，如：钱款等。需要开启事务。注意事项：事务的隔离级别越高安全性就越高，但并发就越低，这就需要选择合适的隔离级别。\n事务的并发控制可能产生哪些问题在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，如果不对事务进行并发控制,可能会产生四种异常情况\n\n幻读(phantom read):在同一个事务第二次查出现第一次没有的结果，说明别的事务已经插入一些数据幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，\n\n非重复读( nonrepeatable read):一个事务重复读两次得到不同结果，说明读取操作结果是不可重复的。指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n\n脏读(dirty read):一个事务读取到另一个事务没有提交的修改，就是当另一个事务它还没有提交修改一个事务就读取到了修改。当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n\n丢失修改(lost update)：并发写入造成其中一些修改丢失。指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n\nTransaction 示例：Python的ORM框架SQLALchemy代码\n12345678910session.begin()try:    item1 =session.query(Item).get(1)    item2 =session.query(Item).get(2)    item1.foo = 'bar'    item2.bar = 'foo'    session.commit()except:    session.rollback()    session.begin()try:    item1 =session.query(Item).get(1)    item2 =session.query(Item).get(2)    item1.foo = 'bar'    item2.bar = 'foo'    session.commit()except:    session.rollback()    raise\n\n把10部门中manager员工调往20部门，其他岗位的员工调往30部门，然后删除10部门 \n为了解决并发控制可能产生的异常问题，数据库定义了四种事务的隔离级别\n\n读未提交(read uncommitted)：别的事务可以读取到未提交改变\n\n读已提交(read committed)：只能读取已经提交的数据\n\n可重复读(repeatable read)：同一个事务先后查询结果一样，Mysql InnoDB默认实现可重复读级别。\n\n可串行化(Serializable)：事务完全串行化的执行，隔离级别最高，执行效率最低。相当于把数据库在一个事务执行的时候完全锁住，等它执行完才能执行下一个。\n  ① 读取未提交( Read Uncommitted )\n   读未提交是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。\n\n ② 读取已提交( Read Committed )\n  在 Read Committed 隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。\n\n③ 可重复读取( Repeatable Read )\n  在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。\n\n④ 可串行化、序列化( Serializable )\n  Serializable 是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。\n\n 虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。\n\n  默认隔离级别：如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用 InnoDB，默认的隔离级别是Repeatable Read。\n\n\n\nset SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;读取其他事务未提交的数据\nset SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;只能读取其他事务提交的数据\nset SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;事务在执行中反复读取数据，得到的结果是一致的，不会受其他事务影响\nSTART TRANSACTION;UPDATE t_emp set sal=1;COMMIT;set SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\nset SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;START TRANSACTION;SELECT empno, ename, sal FROM t_emp;COMMIT;ROLLBACK;\nset SESSION TRANSACTION ISOLATION LEVEL live SERIALIZABLE;由于事务并发执行所带来的各种问题，前三种隔离级别只适用在某些业务场景中，但是序列化的隔离性，让事务逐一执行，就不会产生上述问题了。\n如何解决高并发场景下的插入重复高并发场景下，写入数据库会有数据重复问题\n\n使用数据库的唯一索引，就是不允许某些字段重复，如果重复数据库就会抛出一个异常出来，这样就知道那些数据重复了，直接把这个异常忽略掉就可以，这样就可以实现非重复插入。虽然好用但有些场景没有办法实现，如已经做了分库分表，这个时候就要使用队列去执行一个异步写入。\n\n使用队列异步写入，其实很多高并发问题都可以通过缓存和队列去解决。\n\n使用 redis 等实现分布式锁，这样就可以在插入的时候持有这个锁，插入完成之后再去释放这个锁。\n\n\n并发控制也是通过行锁或者表锁实现的。通过事务再读取或者写入的时候加入一些表锁或者行锁就可以实现不同并发控制的等级。\n悲观锁是先获取锁再进行操作。一锁二查三更新 select for update\n乐观锁是先修改，更新的时候发现数据已经变了就回滚(check and set)，乐观锁一般通过版本号或者时间戳实现\n使需要根据响应速度、冲突频率、重试代价来判断使用哪一种\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/wei-yun-suan/","content":"位运算符是把数字看作二进制来进行计算的\n按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为012```pyprint(0b110 & 0b011)   # 2，即0b010\n\n\n按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。123```pyprint(0b110 | 0b101)  # 7,即0b111print(-0b001 | 0b101)  # -1\n\n按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1，包括符号位123456- 正数各位取反变为负数，显示时转化为其补码- 负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位取反```pyprint(~0b101)  # 2，即0b010print(~5)  # -6\n\n5 的二进制为 0101，~5 正数取反\n\n（1）各位取反，1010，最高位为1是负数\n（2）负数转化为其补码符号位保持不变，各位取反 1101，再加1，1110，也即 -6\n\n12345678910111213141516171819202122232425262728print(~-3)  # 2print(~(-3))  # 2print(~(-5))  # 4``` -3 10...011，负数存储的是其补码：- -3 的补码是：11...101- ~(-5)将其各位取反（包括符号位），也即 00...010（2）-5的原码是    10...011-5的反码是    11...100           + 00...001 -5的补码    = 11...101对其补码取反 = 00...010（2）-5 10...101，负数存储的是其补码：- -5 的补码是：1011- ~(-5)将其各位取反（包括符号位），也即 00...100（4）-5的原码是    10...101-5的反码是    11...010           + 00...001 -5的补码    = 11...011对其补码取反 = 00...100（4）```^``` 按位异或运算符：当两对应的二进位相异时，结果为1```pyprint(0b111 ^ 0b111)  # 0print(0b100 ^ 0b111)  # 3print(0b1010 ^ 0b1111)  print(~-3)  # 2print(~(-3))  # 2print(~(-5))  # 4``` -3 10...011，负数存储的是其补码：- -3 的补码是：11...101- ~(-5)将其各位取反（包括符号位），也即 00...010（2）-5的原码是    10...011-5的反码是    11...100           + 00...001 -5的补码    = 11...101对其补码取反 = 00...010（2）-5 10...101，负数存储的是其补码：- -5 的补码是：1011- ~(-5)将其各位取反（包括符号位），也即 00...100（4）-5的原码是    10...101-5的反码是    11...010           + 00...001 -5的补码    = 11...011对其补码取反 = 00...100（4）```^``` 按位异或运算符：当两对应的二进位相异时，结果为1```pyprint(0b111 ^ 0b111)  # 0print(0b100 ^ 0b111)  # 3print(0b1010 ^ 0b1111)  # 5，即0b0101\n\n左移运算符：运算数的各二进位全部左移若干位，1234567<pre class=\" language-hljs <<code class=\"language-hljs <    由\"<<\"右边的数指定移动的位数，高位丢弃，低位补0。左移操作相当于乘以2**n负数的左移 ```pyprint(0b11 << 2)  # 12, 即0b1100print(-2 << 2)  # -8\n-2的原码是  10000000000000000000000000000010（32位系统），-2的反码是  11111111111111111111111111111101，其补码为    11111111111111111111111111111110，左移2位变为 11111111111111111111111111111000，再转化为原码 10000000000000000000000000001000，也就是-8，也就是-2*(2**2)=-8\n1print(5 &lt;&lt; 3)  print(5 &lt;&lt; 3)  # 40\n相当于5(2*3)=40。\n右移运算符：把\"&gt;&gt;\"左边的运算数的各二进位全部右移若干位，12345678>```\">>```\">   \">>\"右边的数指定移动的位数相当于除以2**n，如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1；```pyprint(0b11 >> 1)  # 1, 即0b1print(5 >> 1)  # 2，即0b10print(-8 >> 3)  # -1 \n先转化为补码再进行计算，以-8 &gt;&gt; 3为例，-8的原码为10…01000,-8的反码为11…10111,-8的补码为11…11000,右移3位变为11…11111,相应的原码为10…01，即-1。8/(2**3)=1\n-1的源码10…01-1的反码11…10-1的补码11…11\n假如n=10转换二进制为0000 1010，1的二进制为0000 0001把n转换成二进制，然后看n二进制的最后一位，如果最后一位为1的话，结果就是1，如果最后一位是0的话，那就是0。&amp; 相当于AND因为2的倍数的二进制最后一位都是0，\n\n所以n &amp; 0x1表达式跟n%2都能判断n是为奇数还是偶数\n\n变换符号位 ~n + 1\na = 60  # 60 = 0011 1100\nb = 13  # 13 = 0000 1101\n\nprint(a &amp; b)  # 12 = 0000 1100\nprint(a | b)  # 61 = 0011 1101\nprint(a ^ b)  # 49 = 0011 0001\nprint(~a)  # -61 = 1100 0011\nprint(a &lt;&lt; 2)  # 240 = 1111 0000  向左移动两位\nprint(a >> 2)  # 15 = 0000 1111\nprint(b &lt;&lt; 2)  # 52 = 0011 0100  向左移动两位\nprint(b >> 2)  # 3 = 0000 0011\n```\n\n\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/yuan-lei-he-shi-yong-chang-jing/","content":"元类 (Meta Class)是创建类的类。元类创建类，然后类再去创建实例。\n元类允许我们控制类的生成，比如修改类的属性等\n使用 type 来定义一个元类\n元类最常见的一个使用场景就是 ORM 框架。\n\n\ntype的等价使用\n\n（1）没有方法时type等价使用\n12class x:    a = class x:    a = 1    \n等价于类的名字x, 类的基类object，类的属性dict\n1x = type('x', (object,), dict(a=1))  x = type('x', (object,), dict(a=1))  # 类的属性保存在字典里面因此这里用dict\n\n12345678class Base:    pass class Child(Base):  # 继承Base    pass    # 等价定义，注意Base后加上逗号，否则就不是tuple了SameChild == type(class Base:    pass class Child(Base):  # 继承Base    pass    # 等价定义，注意Base后加上逗号，否则就不是tuple了SameChild == type('Child', (Base,), {})\n\n（2）有方法的type等价使用\n123456789101112131415161718class Base:    pass    # 加上方法class ChildWithMethod(Base):    bar = True        def hello(self):        print('hello')        def hello():     print('hello')``` ```python # 等价定义，方法用的类外面hello方法ChildWithMethod = type(          'ChildWithMethod', (Base,), {'bar':True, class Base:    pass    # 加上方法class ChildWithMethod(Base):    bar = True        def hello(self):        print('hello')        def hello():     print('hello')``` ```python # 等价定义，方法用的类外面hello方法ChildWithMethod = type(          'ChildWithMethod', (Base,), {'bar':True, 'hello':hello})\n\n\n元类 作用 控制类生成实例之前就把里面的属性变成小写,   Python中 new 生成实例，init 初始化实例12345678910111213141516171819202122# 元类继承自 typeclass LowercaseMeta(type):    ''' 修改类的属性名称为小写的元类 '''    def __new__(mcs, name, bases, attrs):    # 生成实例        lower_attrs = {}    # 定义字典        for k, v in attrs.items():   # 遍历类所有属性，把非内置方法(魔术方法)都改成小写            if not k.startswith('__'):   # 排除magic method魔术方法                lower_attrs[k.lower()] = v  # 方法名变成小写            else:                lower_attrs[k] = v            # 当前类mcs,名称name,基类bases,当前属性lower_attrs        return type.__new__(mcs, name, bases, lower_attrs)            class LowercaseClass(metaclass=LowercaseMeta): # py3    BAR = True        def HELLO(self):        print('hello')    print(dir(LowercaseClass))  # 你会发现“BAR”和“HELLO”都变小了# 元类继承自 typeclass LowercaseMeta(type):    ''' 修改类的属性名称为小写的元类 '''    def __new__(mcs, name, bases, attrs):    # 生成实例        lower_attrs = {}    # 定义字典        for k, v in attrs.items():   # 遍历类所有属性，把非内置方法(魔术方法)都改成小写            if not k.startswith('__'):   # 排除magic method魔术方法                lower_attrs[k.lower()] = v  # 方法名变成小写            else:                lower_attrs[k] = v            # 当前类mcs,名称name,基类bases,当前属性lower_attrs        return type.__new__(mcs, name, bases, lower_attrs)            class LowercaseClass(metaclass=LowercaseMeta): # py3    BAR = True        def HELLO(self):        print('hello')    print(dir(LowercaseClass))  # 你会发现“BAR”和“HELLO”都变小了# 用一个类的实例调用hello方法，修改了类定义时候的属性名称！！！LowercaseClass().hello()\n\n\n\n输出结果：\n123456# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__',# '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__',# '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',# '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',# 'bar', 'hello']# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__',# '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__',# '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',# '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',# 'bar', 'hello']# hello\nmetaclass一般翻译成“元类”，但也有人认为应该更关注元类“超越变形”的能力，应该翻译成超越类之类的。但是个人觉得“元类”比较顺口，其“本元”的含义也是实打实存在的，故本文用元类作为metaclass的中文翻译。\nmetaclass(元类)可以理解成是类的抽象、本元。类元编程即使用自定义metaclass获取极强灵活性的一种编程方式。\n不过，在多处都有提到的需要注意的是：如果不是开发框架，不要使用元类，除非只是为了寻找乐趣：）。\n什么是本元？首先还是要搞清楚什么是本元？这个概念很抽象，必须弄清楚。\n本元可以理解成一种更高程度的抽象。首先，类（class）是对象（object）的抽象，对象是类的实例。因此可以说类是对象的本元。而在python中，所有类都是type类的实例，也就是说type是所有类的抽象，所以你可以理解type就是那个元类。\ntype一般我们会常用type(obj)来获取obj对象的类型。但type也可以用来创建新类型。这时需要传入三个参数：类名、父类tuple、属性字典。\nclass MyClass: … 等价于MyClass = type(classname, superclasses, attributedict)\nclass SuperCls:    def init(self):        print(“init in super class.”)\nclass A(SuperCls):    pass\nB = type(“B”, (SuperCls, ), {})\na = A()\n输出“””init in super class.“””\nb = B()\n输出“””init in super class.“””\nprint(A.mro())\n输出“””[&lt;class ‘__main__.A’&gt;, &lt;class ‘__main__.SuperCls’&gt;, &lt;class ‘object’&gt;]“””\nprint(B.mro())\n输出“””[&lt;class ‘__main__.B’&gt;, &lt;class ‘__main__.SuperCls’&gt;, &lt;class ‘object’&gt;]“””上面类对象的mro()方法代表Method Resolution Order，即方法解析顺序，可以看到这个类的继承顺序。\n通过上面的代码可以看出，使用type来动态创建类和你自己写代码创建一个类是完全一样的。\n还有个问题，当我们使用type的时候，它自己是个type类还是type对象？如果你直接在解释器中输入print(type)会得到返回&lt;class ‘type’&gt;，因此可以认为你使用的就是type类。\nMetaClassOK，搞清楚了什么是“本元”和type，我们再来看metaclass。\n自定义metaclassclass MyMeta(type):    def call(self, args, **kwargs):        print(“call in MyMeta”)        return super().call(*args, *kwargs)\ndef __init__(cls, what, bases=None, dict=None):\n    print(\"__init__ in MyMeta\")\n    super().__init__(what, bases, dict)\n\ndef __new__(*args, **kwargs):\n    print(\"__new__ in MyMeta\")\n    return type.__new__(*args, **kwargs)\n\nclass SuperCls:    pass\n使用metaclass方法1：类定义代码中指定class MyClass(SuperCls, metaclass=MyMeta):    pass\n输出“””new in MyMetainit in MyMeta“””\n使用metaclass方法2：直接像调用type那样调用MyMetaMyClass = MyMeta(“MyClass”, (SuperCls, ), {})\n输出“””new in MyMetainit in MyMeta“””\n实例化my_obj = MyClass()\n输出“””call in MyMeta“””看，我们的元类继承自type类。你在使用这个元类去定义一个新的类时，会调用元类的__new__和__init__；当你用这个新类去实例化一个新对象时又会调用元类的__new__。\n因此，你可以可以重载type的这三个方法来修改type的行为，但要理清这几个方法被调用的时机：\ninit(cls, what, bases=None, dict=None)new(args, **kwargs)call(self, *args, *kwargs)典型案例来看几个类元编程的典型案例。\nSingleton单例模式class SingletonMeta(type):    instance = None    def call(cls, args, **kwargs):        if cls.instance is None:            cls.instance = super(SingletonMeta, cls).call(*args, *kwargs)        return cls.instance\nclass CurrentUser(object, metaclass=SingletonMeta):    def init(self, name=None):        super(CurrentUser, self).init()        self.name = name\ndef __str__(self):\n    return repr(self) + \":\" + repr(self.name)\n\nif name == ‘main‘:    u = CurrentUser(“liu”)    print(u)    u2 = CurrentUser()    u2.name = “xin”    print(u2)    print(u)    assert u is u2注：代码来自 https://github.com/Meteorix/python-design-patterns 。\n这里重载的是type的__call__方法。改变了用户类实例化的行为，使其只能得到唯一的实例。\n简易ORM框架class Field(object):    def init(self, name, column_type):        self.name = name        self.column_type = column_type\ndef __str__(self):\n    return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)\n\nclass StringField(Field):    def init(self, name):        super().init(name, ‘varchar(100)’)\nclass IntegerField(Field):    def init(self, name):        super().init(name, ‘bigint’)\nclass ModelMetaclass(type):    def new(cls, name, bases, attrs):        if name == ‘Model’:            return type.new(cls, name, bases, attrs)        print(‘Found model: %s’ % name)        mappings = dict()        for k, v in attrs.items():            if isinstance(v, Field):                print(‘Found mapping: %s ==&gt; %s’ % (k, v))                mappings[k] = v        for k in mappings.keys():            attrs.pop(k)        attrs[‘mappings‘] = mappings  # 保存属性和列的映射关系        attrs[‘table‘] = name  # 假设表名和类名一致        return type.new(cls, name, bases, attrs)\nclass Model(dict, metaclass=ModelMetaclass):    def init(self, **kw):        super(Model, self).init(**kw)\ndef __getattr__(self, key):\n    try:\n        return self[key]\n    except KeyError:\n        raise AttributeError(r\"'Model' object has no attribute '%s'\" % key)\n\ndef __setattr__(self, key, value):\n    self[key] = value\n\ndef save(self):\n    fields = []\n    params = []\n    args = []\n    for k, v in self.__mappings__.items():\n        fields.append(v.name)\n        params.append('?')\n        args.append(getattr(self, k, None))\n    sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))\n    print('SQL: %s' % sql)\n    print('ARGS: %s' % str(args))\n\nclass User(Model):    # 定义类的属性到列的映射：    id = IntegerField(‘id’)    name = StringField(‘username’)    email = StringField(‘email’)    password = StringField(‘password’)\n创建一个实例：u = User(id=12345, name=’Michael’, email=’test@orm.org’, password=’my-pwd’)\n保存到数据库：u.save()\n输出“””Found model: UserFound mapping: id ==&gt; IntegerField:idFound mapping: name ==&gt; StringField:usernameFound mapping: email ==&gt; StringField:emailFound mapping: password ==&gt; StringField:passwordSQL: insert into User (id,username,email,password) values (?,?,?,?)ARGS: [12345, ‘Michael’, ‘test@orm.org’, ‘my-pwd’]“””注：代码来自 https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072\n这里重载的是type的__new__方法，因此改变的是用户类在定义时的行为。这里用户类是一个数据模型，元类编程做的是在用户定义一个数据模型类的时候，把所有是Field类型的属性收集起来，统一放到mapping属性中。这样基类的方法save可以直接通过mapping属性来保存需要保存的Field属性们。\nYAMLObjectclass YAMLObjectMetaclass(type):  def init(cls, name, bases, kwds):    super(YAMLObjectMetaclass, cls).init(name, bases, kwds)    if ‘yaml_tag’ in kwds and kwds[‘yaml_tag’] is not None:      cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)\n省略其余定义class YAMLObject(metaclass=YAMLObjectMetaclass):    yaml_loader = Loader\n使用class Monster(yaml.YAMLObject):  yaml_tag = u’!Monster’  def init(self, name, hp, ac, attacks):    self.name = name    self.hp = hp    self.ac = ac    self.attacks = attacks  def repr(self):    return “%s(name=%r, hp=%r, ac=%r, attacks=%r)” % (       self.class.name, self.name, self.hp, self.ac,       self.attacks)\nyaml.load(“””— !Monstername: Cave spiderhp: [2,6]    # 2d6ac: 16attacks: [BITE, HURT]“””)\nMonster(name=’Cave spider’, hp=[2, 6], ac=16, attacks=[‘BITE’, ‘HURT’])\nprint yaml.dump(Monster(    name=’Cave lizard’, hp=[3,6], ac=16, attacks=[‘BITE’,’HURT’]))\n输出“””!Monsterac: 16attacks: [BITE, HURT]hp: [3, 6]name: Cave lizard“””这里重载的是type的__init__方法，因此改变的是用户类在定义时的行为。在定义了用户类Monster时，便通过cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)将Monster类注册到系统。\nPyTextclass ComponentMeta(type):    def new(metacls, typename, bases, namespace):        if “Config” not in namespace:            # We need to dynamically create a new Config class per            # instance rather than inheriting a single empty config class            # because components are registered uniquely by config class.            # If a parent class specifies a config class, inherit from it.            parent_config = next(                (base.Config for base in bases if hasattr(base, “Config”)), None            )            if parent_config is not None:\n            class Config(parent_config):\n                pass\n\n        else:\n\n            class Config(ConfigBase):\n                pass\n\n        namespace[\"Config\"] = Config\n\n    component_type = next(\n        (\n            base.__COMPONENT_TYPE__\n            for base in bases\n            if hasattr(base, \"__COMPONENT_TYPE__\")\n        ),\n        namespace.get(\"__COMPONENT_TYPE__\"),\n    )\n    new_cls = super().__new__(metacls, typename, bases, namespace)\n\n    new_cls.Config.__COMPONENT_TYPE__ = component_type\n    new_cls.Config.__name__ = f\"{typename}.Config\"\n    new_cls.Config.__COMPONENT__ = new_cls\n    new_cls.Config.__EXPANSIBLE__ = namespace.get(\"__EXPANSIBLE__\")\n    if component_type:\n        Registry.add(component_type, new_cls, new_cls.Config)\n    return new_cls\n\n注：代码来自 https://github.com/facebookresearch/pytext/blob/351a060b479cbfe1db46b74f1fc975a5b6523122/pytext/config/component.py#L87\n这里重载的是type的__new__方法，因此改变的是用户类在定义时的行为。在定义了用户组件类时，便通过Registry.add(component_type, new_cls, new_cls.Config)将该组件类注册到系统。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import yamlclass Monster(yaml.YAMLObject):    yaml_tag = \"Monster\"    def __init__(self, name, hp, ac, attacks):        self.name = name        self.hp = hp        self.ac = ac        self.attacks = attacks    def __repr__(self):        return \"{}(name = {}, hp = {}, ac = {}, attacks = {}\".format(self.__class__.__name__, self.name, self.hp, self.ac, self.attacks)if __name__ == \"__main__\":    Monster(name = \"zym\", hp = [2, 6], ac = 16, attacks = [\"BITE\", \"HURT\"])    print(yaml.dump(Monster(name = \"zym2\", hp = [3, 6], ac = 18, attacks = [\"BITE\", \"HURT\"])))    # 所有用户自定义类，是type的实例    class MyClass:        pass    instance = MyClass()    print(type(instance))    print(type(MyClass))    # 用户自定义类，是type类的__call__运算符重载    class MyClass2:        data = 1    instance = MyClass2()    print(MyClass2, instance, instance.data)    MyClass = type(\"MyClass\", (), {\"data\":1})    instance = MyClass()    print(MyClass, instance, instance.data)    # 网友的例子    class MyMeta(type):        def __init__(self, name, bases, dic):            super().__init__(name, bases, dic)            print(\"===&gt;MyMeta.__init__\")            print(self.__name__)            print(dic)            print(self.yaml_tag)        def __new__(cls, *args, **kwargs):            print(\"===&gt;MyMeta.__new__\")            print(cls.__name__)            return type.__new__(cls, *args, **kwargs)        def __call__(cls, *args, **kwargs):            print(\"===&gt;MyMeta.__call__\")            obj = cls.__new__(cls)            cls.__init__(cls, *args, **kwargs)            return obj    class Foo(metaclass=MyMeta):        yaml_tag = \"!Foo\"        def __init__(self, name):            print(\"Foo.__init__\")            self.name = name        def __new__(cls, *args, **kwargs):            print(\"Foo.__new__\")            return object.__new__(cls)    foo = Foo(import yamlclass Monster(yaml.YAMLObject):    yaml_tag = \"Monster\"    def __init__(self, name, hp, ac, attacks):        self.name = name        self.hp = hp        self.ac = ac        self.attacks = attacks    def __repr__(self):        return \"{}(name = {}, hp = {}, ac = {}, attacks = {}\".format(self.__class__.__name__, self.name, self.hp, self.ac, self.attacks)if __name__ == \"__main__\":    Monster(name = \"zym\", hp = [2, 6], ac = 16, attacks = [\"BITE\", \"HURT\"])    print(yaml.dump(Monster(name = \"zym2\", hp = [3, 6], ac = 18, attacks = [\"BITE\", \"HURT\"])))    # 所有用户自定义类，是type的实例    class MyClass:        pass    instance = MyClass()    print(type(instance))    print(type(MyClass))    # 用户自定义类，是type类的__call__运算符重载    class MyClass2:        data = 1    instance = MyClass2()    print(MyClass2, instance, instance.data)    MyClass = type(\"MyClass\", (), {\"data\":1})    instance = MyClass()    print(MyClass, instance, instance.data)    # 网友的例子    class MyMeta(type):        def __init__(self, name, bases, dic):            super().__init__(name, bases, dic)            print(\"===&gt;MyMeta.__init__\")            print(self.__name__)            print(dic)            print(self.yaml_tag)        def __new__(cls, *args, **kwargs):            print(\"===&gt;MyMeta.__new__\")            print(cls.__name__)            return type.__new__(cls, *args, **kwargs)        def __call__(cls, *args, **kwargs):            print(\"===&gt;MyMeta.__call__\")            obj = cls.__new__(cls)            cls.__init__(cls, *args, **kwargs)            return obj    class Foo(metaclass=MyMeta):        yaml_tag = \"!Foo\"        def __init__(self, name):            print(\"Foo.__init__\")            self.name = name        def __new__(cls, *args, **kwargs):            print(\"Foo.__new__\")            return object.__new__(cls)    foo = Foo(\"foo\")\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/han-shu-shi-bian-cheng-filter/","content":"filter()函数应用filter(function or None, iterable) –&gt; filter object\nfunction or None：函数或者为None。iterable：可迭代对象。\nfilter就是把每个function应用到可迭代对象上，如果为True就返回。功能：过滤序列注意：参数函数返回值必须为真值或假值返回值：迭代器对象\n12345678910f = filter(lambda x: True if x!=0 else False , [1, 0, 2, 0, 5, 0, 0])print(list(f))  # [1, 2, 5]# 返回所有的偶数&gt;&gt;&gt; list(filter(lambda x: x%2==0, range(10)))[0, 2, 4, 6, 8] # 使用列表推导式实现&gt;&gt;&gt; [i for i in range(10) if i % 2==0][0, 2, 4, 6, f = filter(lambda x: True if x!=0 else False , [1, 0, 2, 0, 5, 0, 0])print(list(f))  # [1, 2, 5]# 返回所有的偶数&gt;&gt;&gt; list(filter(lambda x: x%2==0, range(10)))[0, 2, 4, 6, 8] # 使用列表推导式实现&gt;&gt;&gt; [i for i in range(10) if i % 2==0][0, 2, 4, 6, 8]\n\n123456789101112#  计算200内所有奇数的平分根是整数，需要使用filter函数# filter 函数传入两个参数，第一个参入的是lambda函数，第二个参数是一到两百的列表f2 = filter(lambda x: not x &amp; 1 and pow(int(x**0.5), 2) == x, range(1, 201))# not x&amp;1 计算出一到两百所有奇数# x**0.5计算平分根# print(pow(3, 2) == 3**2 == 9)  # True# pow(int(x**0.5), 2) 计算平分根的正整数的平方# pow(int(x**0.5), 2) == x  平分根的正整数的平方是否等于自己x,x&gt;0,平方根不是整数平方后都变小x = 2print(pow(int(x**0.5), 2) == x)  # False 平分根的正整数的平方是否等于自己xprint(f2)  # &lt;filter object at 0x000001C27B350B80&gt;print(list(f2))  #  计算200内所有奇数的平分根是整数，需要使用filter函数# filter 函数传入两个参数，第一个参入的是lambda函数，第二个参数是一到两百的列表f2 = filter(lambda x: not x &amp; 1 and pow(int(x**0.5), 2) == x, range(1, 201))# not x&amp;1 计算出一到两百所有奇数# x**0.5计算平分根# print(pow(3, 2) == 3**2 == 9)  # True# pow(int(x**0.5), 2) 计算平分根的正整数的平方# pow(int(x**0.5), 2) == x  平分根的正整数的平方是否等于自己x,x&gt;0,平方根不是整数平方后都变小x = 2print(pow(int(x**0.5), 2) == x)  # False 平分根的正整数的平方是否等于自己xprint(f2)  # &lt;filter object at 0x000001C27B350B80&gt;print(list(f2))  # [4, 16, 36, 64, 100, 144, 196]\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/han-shu-shi-bian-cheng-map/","content":"Python支持部分函数式编程特性\n把电脑的运算视作数学上的函数计算（lambda 演算）\n高阶函数：map / reduce / filter\n无副作用，相同的参数调用始终产生同样的结果，可以减少代码出错的几率\n推荐尽量使用列表推导式代替函数式编程\n\nmap()函数应用map(function, iterable, …) –&gt; map objectfunc：表示函数。以参数序列中的每一个元素调用 function 函数，*iterables：可以多个可迭代对象。\nmap含义就是让每一个可迭代对象都去应用一下func函数根据提供的函数对指定序列做映射。python2.x版本返回的是列表，而python3.x返回的是迭代器。\n1234567&gt;&gt;&gt; map(lambda x:x*2, range(10))&lt;map object at 0x0000029809EAB400&gt;&gt;&gt;&gt; list(map(lambda x:x*2, range(10)))   # 每个元素乘以2[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]# 推荐列表推导代理 map&gt;&gt;&gt; [i*2 for i in range(10)][0, 2, 4, 6, 8, 10, 12, 14, 16, &gt;&gt;&gt; map(lambda x:x*2, range(10))&lt;map object at 0x0000029809EAB400&gt;&gt;&gt;&gt; list(map(lambda x:x*2, range(10)))   # 每个元素乘以2[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]# 推荐列表推导代理 map&gt;&gt;&gt; [i*2 for i in range(10)][0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def test(num):    return num * numres = map(test, [1, 23])print(list(res))  # [1, 529]# map最终得到结果的元素个数，取决于此三者最短长度list_x = [1, 2, 3, 4, 5]list_y = [2, 4, 6, 8, 9]list_z = [2, 4, 6, 8, 9]# def函数def square(x, y, z):    return x * x + y + z# map函数m1 = map(square, list_x, list_y, list_z)# 匿名函数m2 = map(lambda x, y, z: x * x + y + z, list_x, list_y, list_z)print(list(m1))  # [5, 12, 21, 32]print(list(m2))  # [5, 12, 21, 32]# 使用map函数将[1，2，3，4]处理成[1,0,1,0]a1 = list(map(lambda x: x % 2, [1, 2, 3, 4]))  # 取余数print(a1)  # [1, 0, 1, 0]# 请将列表[1,2,3,4,5]转变成[1,4,9,16,25]。然后提取大于10的数，最终输出[16,25]a = [1, 2, 3, 4, 5]print('-------')# 方法一b = list()c = list()for i in a:    b.append(i * i)print(b)  # [1, 4, 9, 16, 25]  # 第一步for i in b:    if i &gt; 10:        c.append(i)print(c)  # [16, 25]  # 第二步# 方法二x = list(map(lambda x: x * x, a))  # 第一步 [1, 4, 9, 16, 25]print(x)y = [i for i in map(lambda x: x * x, a) if i &gt; 10]print(y)  # [6]: [16, 25]  # 第二步# 方法三print('---方法三----')print([x**2 for x in [1, 2, 3, 4, 5] if x**2 &gt; 10])print([i**2 for i in [1, 2, 3, 4, 5] if i**2 &gt; 10])# 方法四def fn(x):    return x**2print('==方法四===')res = map(fn, a)# for x in res:#     print(x)res = [i for i in res if i &gt; 10]print(res)# 方法五print('----')a = list(map(lambda x: pow(x, 2), a))  # 第一步print(a)  # [1, 4, 9, 16, 25]b = [i for i in map(lambda x: pow(x, 2), a) if i &gt; 10]print(b)  def test(num):    return num * numres = map(test, [1, 23])print(list(res))  # [1, 529]# map最终得到结果的元素个数，取决于此三者最短长度list_x = [1, 2, 3, 4, 5]list_y = [2, 4, 6, 8, 9]list_z = [2, 4, 6, 8, 9]# def函数def square(x, y, z):    return x * x + y + z# map函数m1 = map(square, list_x, list_y, list_z)# 匿名函数m2 = map(lambda x, y, z: x * x + y + z, list_x, list_y, list_z)print(list(m1))  # [5, 12, 21, 32]print(list(m2))  # [5, 12, 21, 32]# 使用map函数将[1，2，3，4]处理成[1,0,1,0]a1 = list(map(lambda x: x % 2, [1, 2, 3, 4]))  # 取余数print(a1)  # [1, 0, 1, 0]# 请将列表[1,2,3,4,5]转变成[1,4,9,16,25]。然后提取大于10的数，最终输出[16,25]a = [1, 2, 3, 4, 5]print('-------')# 方法一b = list()c = list()for i in a:    b.append(i * i)print(b)  # [1, 4, 9, 16, 25]  # 第一步for i in b:    if i &gt; 10:        c.append(i)print(c)  # [16, 25]  # 第二步# 方法二x = list(map(lambda x: x * x, a))  # 第一步 [1, 4, 9, 16, 25]print(x)y = [i for i in map(lambda x: x * x, a) if i &gt; 10]print(y)  # [6]: [16, 25]  # 第二步# 方法三print('---方法三----')print([x**2 for x in [1, 2, 3, 4, 5] if x**2 &gt; 10])print([i**2 for i in [1, 2, 3, 4, 5] if i**2 &gt; 10])# 方法四def fn(x):    return x**2print('==方法四===')res = map(fn, a)# for x in res:#     print(x)res = [i for i in res if i &gt; 10]print(res)# 方法五print('----')a = list(map(lambda x: pow(x, 2), a))  # 第一步print(a)  # [1, 4, 9, 16, 25]b = [i for i in map(lambda x: pow(x, 2), a) if i &gt; 10]print(b)  # [16, 25]  # 第二步\n\n\n\n1\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/han-shu-shi-bian-cheng-reduce/","content":"reduce()函数应用reduce(function, sequence[, initial]) -&gt; value 归约，前面的结果每次都应用到后面去。function：函数。sequence：序列。initial：初始值。\npy2中是自带函数，py3转移到functools里面\n功能：对参数序列中元素进行累积注意：参数函数应至少有两个参数reduce把一个函数作用在一个序列[x1, x2, x3, …]上，reduce把结果继续和序列的下一个元素做累积计算给mul传入参数的过程是这样的。先从有序列表中取前两个，传入函数进行计算，会得到一个结果，这时再从列表中取出一个还未计算过的值与这个函数的计算结果，再次传入函数计算。重复此过程，直到所有的列表元素都参与计算，以此来完成类似累加累乘这样的操作,函数可以大大减少代码量\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from functools import reduce DIGITS = {    '0': 0,    '1': 1,    '2': 2,    '3': 3,    '4': 4,    '5': 5,    '6': 6,    '7': 7,    '8': 8,    '9': 9}def char2num(s):    return DIGITS[s]def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))s = '67373'print(type(map(char2num, s)))  # &lt;class 'map'&gt;print(list(map(char2num, s)))  # [6, 7, 3, 7, 3]print(str2int(s))  # 67373print(type(str2int(s)))  # &lt;class 'int'&gt;list_x = ['1', '2', '3', '4', '5']print(reduce(lambda x, y: x + y, list_x))  # 12345 字符串相加，不是数字相加# x = '1' # y = '2'# return '12'# x = 'hello1' # y = '2'# return 'hello11'print(type(reduce(lambda x, y: x + y, list_x)))  # &lt;class 'str'&gt;print(reduce(lambda x, y: x + y, list_x, 'hello'))  # hello12345# x = 'hello' # y = '1'# return 'hello1'# x = 'hello1' # y = '2'# return 'hello11'print(type(reduce(lambda x, y: x + y, list_x, 'hello')))  # &lt;class 'str'&gt;list_y = [1, 2, 3, 4, 5]print(reduce(lambda x, y: x + y, list_y))  # 15 数字相加 ((((1+2)+3)+4)+5)，最后把和返回print(type(reduce(lambda x, y: x + y, list_y)))  from functools import reduce DIGITS = {    '0': 0,    '1': 1,    '2': 2,    '3': 3,    '4': 4,    '5': 5,    '6': 6,    '7': 7,    '8': 8,    '9': 9}def char2num(s):    return DIGITS[s]def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))s = '67373'print(type(map(char2num, s)))  # &lt;class 'map'&gt;print(list(map(char2num, s)))  # [6, 7, 3, 7, 3]print(str2int(s))  # 67373print(type(str2int(s)))  # &lt;class 'int'&gt;list_x = ['1', '2', '3', '4', '5']print(reduce(lambda x, y: x + y, list_x))  # 12345 字符串相加，不是数字相加# x = '1' # y = '2'# return '12'# x = 'hello1' # y = '2'# return 'hello11'print(type(reduce(lambda x, y: x + y, list_x)))  # &lt;class 'str'&gt;print(reduce(lambda x, y: x + y, list_x, 'hello'))  # hello12345# x = 'hello' # y = '1'# return 'hello1'# x = 'hello1' # y = '2'# return 'hello11'print(type(reduce(lambda x, y: x + y, list_x, 'hello')))  # &lt;class 'str'&gt;list_y = [1, 2, 3, 4, 5]print(reduce(lambda x, y: x + y, list_y))  # 15 数字相加 ((((1+2)+3)+4)+5)，最后把和返回print(type(reduce(lambda x, y: x + y, list_y)))  # \n\n模拟计算器，整数计算的整数，小数计算得小数\n12345678910111213141516171819from functools import reducedef str2num(s):    return eval(s)def calc(exp):    ss = exp.split('+')    ns = map(str2num, ss)    return reduce(lambda acc, x: acc + x, ns)r = calc('100 + 200 + 345')print('100 + 200 + 345 =', r)# 100 + 200 + 345 = 645r = calc('99 + 88 + 7.6')print('99 + 88 + 7.6 =', r)from functools import reducedef str2num(s):    return eval(s)def calc(exp):    ss = exp.split('+')    ns = map(str2num, ss)    return reduce(lambda acc, x: acc + x, ns)r = calc('100 + 200 + 345')print('100 + 200 + 345 =', r)# 100 + 200 + 345 = 645r = calc('99 + 88 + 7.6')print('99 + 88 + 7.6 =', r)# 99 + 88 + 7.6 = 194.6\n\n123456789101112131415161718192021222324from functools import reducedef str2num(s):    try:        return int(s)    except:        return float(s)def calc(exp):    ss = exp.split('+')    ns = map(str2num, ss)    return reduce(lambda acc, x: acc + x, ns)def main():    r = calc('100 + 200 + 345')    print('100 + 200 + 345 =', r)    r = calc('99 + 88 + 7.6')    print(from functools import reducedef str2num(s):    try:        return int(s)    except:        return float(s)def calc(exp):    ss = exp.split('+')    ns = map(str2num, ss)    return reduce(lambda acc, x: acc + x, ns)def main():    r = calc('100 + 200 + 345')    print('100 + 200 + 345 =', r)    r = calc('99 + 88 + 7.6')    print('99 + 88 + 7.6 =', r)main()\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/qie-pian/","content":"切片 冒号适用于列表、字符串切片[][1:3]还是list[起始位置，长度]；截取从起始位置，长度个字符；长度负数表示删除从字符串末尾往前数的字符个数；长度省略表示到末尾； 长度要是超过可截取的位数，以可截取的位数为标准；单一的字符串索引操作得到的是字符串，但是一个列表的切片操作得到的是一个列表\na=range（100）range(start, end, step)，start：起始值；end：终值；step：步长，默认为1。a：0、1、2、3、4、5、……99。所以，正索引范围为：a[0] -a[end-1]，即 a[0] = 0，a[1] = 1，……，依次类推；负索引范围为：a[-1] -a[-end]，即 a[-1] = 99，a[-2] = 98，……，依次类推。\n12345678910111213141516171819202122232425262728293031323334353637383940414243a = range(100)print(a[-3])  # 97 a[-3]倒数第三个数print(a[2 - 3])  # 倒数第一个数 99print(a[-1])  # 倒数第一个数 99print(a[::3])  # range(0, 100, 3) start0 end99 step3 依次是0 3 6 9一直到99 步长为3print(a[2:13])  # range(2, 13) 从a[2]到a[12] 不包括13，前闭后开a = [0, 1, 2, 3, 4, 5]# 有1位print(a[-1])  # 5 读取倒数第一个元素# 有2位print(a[:1])  # [0] print(a[-1:])  # [5]print(a[-3:])  # [3, 4, 5]print(a[-3:-1])  # [3, 4]print(a[:-1])  # [0, 1, 2, 3, 4]# 有第三位，正号从左到右，符号从右到左，绝对值是跳的间隔print(a[::2])  # [0, 2, 4]print(a[::-1])  # [5, 4, 3, 2, 1, 0]print(a[:3:-1])  # [5, 4]print(a[3::-1])  # [3, 2, 1, 0] 从下标为3（从0开始）的元素开始翻转读取print(a[3:1:-1])  # [3, 2]print(a[3:1:-2])  # [3]s = '123.456'# print(s[4:0:-1])# print(s[5:0:-1])# print(s[:1:-1])print(s[:2:-1])print(s[:3:-1])print(s[:4:-1])print(s[:5:-1])output = [[1,2,3],          [4,5,6],          [2, 5, 6]]print(output[-1])  * [2, 5, 6]s='123.456'print(s[:2:-1])a = range(100)print(a[-3])  # 97 a[-3]倒数第三个数print(a[2 - 3])  # 倒数第一个数 99print(a[-1])  # 倒数第一个数 99print(a[::3])  # range(0, 100, 3) start0 end99 step3 依次是0 3 6 9一直到99 步长为3print(a[2:13])  # range(2, 13) 从a[2]到a[12] 不包括13，前闭后开a = [0, 1, 2, 3, 4, 5]# 有1位print(a[-1])  # 5 读取倒数第一个元素# 有2位print(a[:1])  # [0] print(a[-1:])  # [5]print(a[-3:])  # [3, 4, 5]print(a[-3:-1])  # [3, 4]print(a[:-1])  # [0, 1, 2, 3, 4]# 有第三位，正号从左到右，符号从右到左，绝对值是跳的间隔print(a[::2])  # [0, 2, 4]print(a[::-1])  # [5, 4, 3, 2, 1, 0]print(a[:3:-1])  # [5, 4]print(a[3::-1])  # [3, 2, 1, 0] 从下标为3（从0开始）的元素开始翻转读取print(a[3:1:-1])  # [3, 2]print(a[3:1:-2])  # [3]s = '123.456'# print(s[4:0:-1])# print(s[5:0:-1])# print(s[:1:-1])print(s[:2:-1])print(s[:3:-1])print(s[:4:-1])print(s[:5:-1])output = [[1,2,3],          [4,5,6],          [2, 5, 6]]print(output[-1])  * [2, 5, 6]s='123.456'print(s[:2:-1])654.\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"列表推导式","url":"https://bubbleboy11.github.io/2020/08/21/lie-biao-tui-dao-shi/","content":"列表/元组/字典 推导式 Comprehension\n一种快速生成list/dict/set的方式。 用来替代map/filter等提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。\n\n1[操作 for 语句 [操作 for 语句 if 语句]\n\n1234567891011121314151617181920# 将两个列表合为字典a = ['a', 'b', 'c']b = [4, 5, 6]# 方法一：普通方法d = {}for i in range(len(a)):    d[a[i]] = b[i]print(d)  # {'a': 4, 'b': 5, 'c': 6}# 方法二：普通方法d1 = {}for i, x in enumerate(a):    d1[x] = b[i]print(d1)  # {'a': 4, 'b': 5, 'c': 6}# 方法二：使用字典推导# 使用zip函数成对迭代a和bd = {k: v for k, v in zip(a, b)}print(d)  # 将两个列表合为字典a = ['a', 'b', 'c']b = [4, 5, 6]# 方法一：普通方法d = {}for i in range(len(a)):    d[a[i]] = b[i]print(d)  # {'a': 4, 'b': 5, 'c': 6}# 方法二：普通方法d1 = {}for i, x in enumerate(a):    d1[x] = b[i]print(d1)  # {'a': 4, 'b': 5, 'c': 6}# 方法二：使用字典推导# 使用zip函数成对迭代a和bd = {k: v for k, v in zip(a, b)}print(d)  # {'a': 4, 'b': 5, 'c': 6}\n\n12345678910111213141516# 列表推导式l = [i for i in range(5)]print(l) # 输出结果:[0, 1, 2, 3, 4] # 生成器推导式l1 = (i for i in range(10))print(type(l1)) # 输出结果：&lt;class 'generator'&gt; for i in l1:    print(i) # 输出结果： # 0# 1# 2# 3# 列表推导式l = [i for i in range(5)]print(l) # 输出结果:[0, 1, 2, 3, 4] # 生成器推导式l1 = (i for i in range(10))print(type(l1)) # 输出结果：&lt;class 'generator'&gt; for i in l1:    print(i) # 输出结果： # 0# 1# 2# 3# 4\n\n12345678910111213141516171819202122232425262728293031323334353637dp = [0 for item in range(3)]print(dp)  # [0, 0, 0]dp = [1 for item in range(3)]print(dp)  # [1, 1, 1]dp = [2 for item in range(3)]print(dp)  # [2, 2, 2]# 遍历list/tuple/sets = [x for x in range(5)]  # listprint(s)  # [0, 1, 2, 3, 4] 存储在列表，在打印for x in s:    print(x)# 0# 1# 2# 3# 4# 将列表中每个数值乘三，获得一个新的列表：print([3 * x for x in s])  # [0, 3, 6, 9, 12]print([[x, x ** 2] for x in s])# [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16]]print([3 * x for x in s if x &gt; 3])# [12]print([3 * x for x in s if x &lt; 2])# [0, 3]vec1 = [2, 4, 6]vec2 = [4, 3, -9]print([x * y for x in vec1 for y in vec2])# [8, 6, -18, 16, 12, -36, 24, 18, -54]print([x + y for x in vec1 for y in vec2])# [6, 5, -7, 8, 7, -5, 10, 9, -3]print([vec1[i] * vec2[i] for i in range(len(vec1))])dp = [0 for item in range(3)]print(dp)  # [0, 0, 0]dp = [1 for item in range(3)]print(dp)  # [1, 1, 1]dp = [2 for item in range(3)]print(dp)  # [2, 2, 2]# 遍历list/tuple/sets = [x for x in range(5)]  # listprint(s)  # [0, 1, 2, 3, 4] 存储在列表，在打印for x in s:    print(x)# 0# 1# 2# 3# 4# 将列表中每个数值乘三，获得一个新的列表：print([3 * x for x in s])  # [0, 3, 6, 9, 12]print([[x, x ** 2] for x in s])# [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16]]print([3 * x for x in s if x &gt; 3])# [12]print([3 * x for x in s if x &lt; 2])# [0, 3]vec1 = [2, 4, 6]vec2 = [4, 3, -9]print([x * y for x in vec1 for y in vec2])# [8, 6, -18, 16, 12, -36, 24, 18, -54]print([x + y for x in vec1 for y in vec2])# [6, 5, -7, 8, 7, -5, 10, 9, -3]print([vec1[i] * vec2[i] for i in range(len(vec1))])# [8, 12, -54]\n\n把要生成的元素放到前面，然后有零到多个 for 或 if 子句，在一个列表生成式中，for前面的if … else是表达式，而for后面的if是过滤筛选条件，不能在最后的if加上else：返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。\nif写在for前面必须加else，否则报错：\n12345&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]  File \"&lt;stdin&gt;\", line 1    [x if x % 2 == 0 for x in range(1, &gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)]  File \"&lt;stdin&gt;\", line 1    [x if x % 2 == 0 for x in range(1, 11)]                       ^SyntaxError: invalid syntax\n\n\n因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：\n12&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, &gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]\nfor前面的表达式x if x % 2 == 0 else -x 才能根据x计算出确定的结果。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455a = [1, 2, 3, 4, 5, 6]c = (1, 2, 3, 4, 5, 6)b = [i ** 2 for i in a if i &lt;= 5]print(b)  # [1, 4, 9, 16, 25]d = (i ** 2 for i in c if i &lt;= 5)  print(d)  # &lt;generator object &lt;genexpr&gt;# 可以通过for遍历，获得generator的下一个返回值，比next()简单for x in d:    print(x)# 1# 4# 9# 16# 25print(list(range(5)))print(list(range(0, 5)))print(list(range(0, 10, 2)))print(list(range(10, 0, -2)))L = []for x in range(0, 5):    L.append(x * x)print(L)print([x * x for x in range(1, 11)])# print([x * x for x in range(1, 11) if x % 2 == 0])  # 筛选出仅偶数的平方# 两层循环，可以生成全排列print([m + n for m in 'ABC' for n in 'XYZ'])  # AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']# 最后把一个list中所有的字符串变成小写：L = ['Hello', 'World', 18, 'Apple', None]L2=[s.lower() for s in L if isinstance(s,str)]print(L2)# ['hello', 'world', 'apple']:# 对序列里每一个元素逐个调用某方法：freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']print([weapon.strip() for weapon in freshfruit])# ['banana', 'loganberry', 'passion fruit']print([str(round(355 / 113, i)) for i in range(1, 6)])# ['3.1', '3.14', '3.142', '3.1416', '3.14159']# 列表生成式也可以使用两个变量来生成list：d = {'x': 'A', 'y': 'B', 'z': 'C' }print([k + '=' + v for k, v in d.items()])a = [1, 2, 3, 4, 5, 6]c = (1, 2, 3, 4, 5, 6)b = [i ** 2 for i in a if i &lt;= 5]print(b)  # [1, 4, 9, 16, 25]d = (i ** 2 for i in c if i &lt;= 5)  print(d)  # &lt;generator object &lt;genexpr&gt;# 可以通过for遍历，获得generator的下一个返回值，比next()简单for x in d:    print(x)# 1# 4# 9# 16# 25print(list(range(5)))print(list(range(0, 5)))print(list(range(0, 10, 2)))print(list(range(10, 0, -2)))L = []for x in range(0, 5):    L.append(x * x)print(L)print([x * x for x in range(1, 11)])# print([x * x for x in range(1, 11) if x % 2 == 0])  # 筛选出仅偶数的平方# 两层循环，可以生成全排列print([m + n for m in 'ABC' for n in 'XYZ'])  # AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']# 最后把一个list中所有的字符串变成小写：L = ['Hello', 'World', 18, 'Apple', None]L2=[s.lower() for s in L if isinstance(s,str)]print(L2)# ['hello', 'world', 'apple']:# 对序列里每一个元素逐个调用某方法：freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']print([weapon.strip() for weapon in freshfruit])# ['banana', 'loganberry', 'passion fruit']print([str(round(355 / 113, i)) for i in range(1, 6)])# ['3.1', '3.14', '3.142', '3.1416', '3.14159']# 列表生成式也可以使用两个变量来生成list：d = {'x': 'A', 'y': 'B', 'z': 'C' }print([k + '=' + v for k, v in d.items()])# ['y=B', 'x=A', 'z=C']\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/chuang-jian-xing-mo-shi-zhi-dan-li-mo-shi-yu-yuan-xing-mo-shi/","content":"单例模式单例模式的实现有多种方式\n\n一个类创建出来的对象都是同一个\nPython的模块其实就是单例的，只会导入一次，如：在模块里定义的全局变量其实就是单例的\n使用共享同一个实例的方式来创建单例模式\n\n\n使用__new__方法实现123456789101112131415# 使用__new__方法，通过共享实例方式创建单例模式class Singleton:  # 单例的类    def __new__(cls, *args, **kwargs):    # __new__方法是用来创建实例        if not hasattr(cls, '_instance'):  # '_instance'表示所有的共享实例，如果没有该属性就创建一个            _instance = super().__new__(cls, *args, **kwargs)            cls._instance = _instance  # 赋值给当前的类        return cls._instance        class MyClass(Singleton):   # 继承单例类    pass # 创建两个实例，通过比较ID是否一样来判断是不是同一个实例c1 = MyClass()c2 = MyClass()print(c1 is c2)   # 使用__new__方法，通过共享实例方式创建单例模式class Singleton:  # 单例的类    def __new__(cls, *args, **kwargs):    # __new__方法是用来创建实例        if not hasattr(cls, '_instance'):  # '_instance'表示所有的共享实例，如果没有该属性就创建一个            _instance = super().__new__(cls, *args, **kwargs)            cls._instance = _instance  # 赋值给当前的类        return cls._instance        class MyClass(Singleton):   # 继承单例类    pass # 创建两个实例，通过比较ID是否一样来判断是不是同一个实例c1 = MyClass()c2 = MyClass()print(c1 is c2)   # 输出为True，单例的，c1 c2同一个实例\n这样每次去创建一个新的实例的时候，就会使用 _instance 来共享实例。\n\n\n\n（1） new 和 init 的区别\n① new 是一个静态方法，而 init 是实例方法 。\n② new 方法会返回一个创建的实例，而init 什么都不返回 。\n③ 只有在new 返回一个cls的实例时，才会调用 __init__进行初始化实例 。\n④ 当创建一个新实例时调用 new__，初始化一个实例时用 __init 。\n12345678910111213141516171819class Singleton(type):    def __init__(cls, name, bases, dict):        super(Singleton, cls).__init__(name, bases, dict)        cls._instance = None    def __call__(cls, *args, **kw):        if cls.instance is None:            cls.instance = super(Singleton, cls).__call__(*args, **kw)        return cls.instancedef MyClass(object):    __metaclass__ ＝ Singletonif __name__ == class Singleton(type):    def __init__(cls, name, bases, dict):        super(Singleton, cls).__init__(name, bases, dict)        cls._instance = None    def __call__(cls, *args, **kw):        if cls.instance is None:            cls.instance = super(Singleton, cls).__call__(*args, **kw)        return cls.instancedef MyClass(object):    __metaclass__ ＝ Singletonif __name__ == \"__main__\":    s1 = MyClass()    s2 = MyClass()    print(s1)    print(s2)\n\n\n\n\n使用装饰器实现123456789101112131415161718192021class Singleton:    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper     def __new__(self, *args, **kwargs):        if not hasattr(self, '_instance'):            self._instance = super().__new__(self, *args, **kwargs)        return self._instance @Singleton()def MyClass():    time.sleep(1) if __name__ == \"__main__\":    s1 = MyClass()    s2 = MyClass()    print(id(s1), id(s2))    print(s1 class Singleton:    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper     def __new__(self, *args, **kwargs):        if not hasattr(self, '_instance'):            self._instance = super().__new__(self, *args, **kwargs)        return self._instance @Singleton()def MyClass():    time.sleep(1) if __name__ == \"__main__\":    s1 = MyClass()    s2 = MyClass()    print(id(s1), id(s2))    print(s1 is s2)\n\n\n\n\n原型模式(Prototype)\n通过克隆原型来创建新的实例\n\n可以使用相同的原型，通过修改部分属性来创建新的实例\n\n用途：对于一些创建实例开销比较高的地方可以用原型模式\n1234567891011121314151617181920212223242526class Singleton(type):    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper     def __new__(self, *args, **kwargs):        if not hasattr(self, '_instance'):            self._instance = super().__new__(self, *args, **kwargs)        return self._instance @Singleton()def MyClass():    time.sleep(1) if __name__ == \"__main__\":    s1 = MyClass()    s2 = MyClass()    print(id(s1), id(s2))    print(s1 class Singleton(type):    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper    def __call__(self, func):        def wrapper(*args, **kwargs):            res = func(*args, **kwargs)            return res        return wrapper     def __new__(self, *args, **kwargs):        if not hasattr(self, '_instance'):            self._instance = super().__new__(self, *args, **kwargs)        return self._instance @Singleton()def MyClass():    time.sleep(1) if __name__ == \"__main__\":    s1 = MyClass()    s2 = MyClass()    print(id(s1), id(s2))    print(s1 is s2)\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/qian-hou-duan-fen-chi/","content":"传统的web开发框架里面都是使用MVC模式，需要后端去渲染模板，渲染完HTML之后再去返回给浏览器让浏览器去展示。这个阶段的开发方式你会发现前端和后端开发人员经常会同时去修改模板文件，这样可能会导致经常会有冲突，而且前端和后端基本上同时在一个项目仓库，然后基本上同时去部署。项目比较大的时候就会显得代码仓库比较臃肿也比较乱。后来就逐渐演变出来前后分离的开发方式。\n前后端分离后端只负责提供数据接口，不在做渲染模板，前端获取数据并做模板渲染呈现给用户。\n\n前后端解耦，接口复用（前端和客户端公用接口），减少开发量\n各司其职，前后端同步开发，提高工作效率。定义好接口规范\n更有利于调试(mock)、测试和运维部署。\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/jia-mi-fang-shi/","content":"加解密算法，是对源数据 进行运算产生加密数据，以及反向过程，对加密数据反算出 源数据。\n加解密算法 和 hash算法 不同点有：\n\n加解密算法 是可逆的，hash算法是不可逆的。\nhash算法可以对很大的数据产生比较小的哈希值，而加密算法源数据很大，加密后的数据也会很大\n\n加密方式\n\n对称加密：加密和解密的密钥是相同的，速度快，一般对文件，AES, RC4, DES, 3DES, IDEA \n非对称加密：公钥加密——私钥解密，私钥加密——公钥解密，强度高速度慢，互联网 RSA (Rivest–Shamir–Adleman)  DSA ECC证书密钥加密\n\npip install cryptography\n12345678910111213141516171819from cryptography.fernet import Fernet# 产生密钥， 密钥是加密解密必须的key = Fernet.generate_key()f = Fernet(key)src = \"白月黑羽网站学习Python真好啊\"# 源信息，必须是字节串对象# 字符串对象需要encode一下srcBytes = src.encode()# 生成加密字节串token = f.encrypt(srcBytes)print(token)from cryptography.fernet import Fernet# 产生密钥， 密钥是加密解密必须的key = Fernet.generate_key()f = Fernet(key)src = \"白月黑羽网站学习Python真好啊\"# 源信息，必须是字节串对象# 字符串对象需要encode一下srcBytes = src.encode()# 生成加密字节串token = f.encrypt(srcBytes)print(token)# 解密，返回值是字节串对象sb = f.decrypt(token)print(sb.decode())\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/zhan-wei-ge-shi-hua/","content":"format(value[, format_spec])将 value 转换为 format_spec 控制的“格式化”表示。format_spec 的解释取决于 value 实参的类型，但是大多数内置类型使用标准格式化语法：格式规格迷你语言。\n默认的 format_spec 是一个空字符串，它通常和调用 str(value) 的结果相同。\n调用 format(value, format_spec) 会转换成 type(value).format(value, format_spec) ，所以实例字典中的 format() 方法将不会调用。如果搜索到 object 有这个方法但 format_spec 不为空，format_spec 或返回值不是字符串，会触发 TypeError 异常。\n在 3.4 版更改: 当 format_spec 不是空字符串时， object().format(format_spec) 会触发 TypeError。\n占位符，表示这个位置先占着，待会儿要有数据填入到这里。\n%s 是一种格式化符号、占位符Python 解释器 看到 %s ，就会调用内置函数 str()，并将对应的 格式化对象 作为 参数传入，返回的结果字符串填入对应占位符。%s 位置填入的结果，就是调用str函数的返回值。%s 为占位符， 对应的格式化对象，不仅仅是字符串，还可以是整数、浮点数、列表、元组 等\n12345678910111213141516参数 可以是任何类型的对象，比如：字符串、 整数、 浮点数、列表、元组等。可以指定编码。```str(123)='123'``` 表示格化式一个对象为字符```pystr1 = '我会唱跳rap'str2 = '打篮球'# 拼接成一个字符串print(str1 + str2)# 我会唱跳rap打篮球print('%s%s' % (str1, str2))# 我会唱跳rap打篮球print('{}{}'.format(str1, str2))# 我会唱跳rap打篮球print(f'{str1}{str2}')# 我会唱跳rap打篮球\n\n格式化字符串里面占位符的个数 必须 和 后面对应的格式化对象个数相同，\n123456789101112131415161718192021222324252627282930313233343536373839404142id = 123name = 'Xiaoming'hegiht = 1.7print('User[%s]: %s %sm ' % (id, name, hegiht))# User[123]: Xiaoming 1.7mprint('User[%(id)s]: %(name)s %(height)sm' % {    'id': 123,    'name': 'Xiaoming',    'height': 1.7})# User[123]: Xiaoming 1.7mstring = \"hello\"print(\"string=%s!\" % (string, ))  # string=hello!# 只有一个格式化对象的情况下，可以直接就用格式化对象，不需要放到元组里面print(\"string=%s!\" % string)  # string=hello!#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印print(\"string=%2s!\" % string)  # string=hello!# %7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，右边对齐print(\"string=%7s!\" % string)  # string=  hello!# %-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，左边对齐print(\"string=%-7s!\" % string)  # string=hello  !# %.2s意思是截取字符串的前2个字符print(\"string=%.2s!\" % string)  # string=he!# %.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身# 所以%.7s的打印结果是helloprint(\"string=%.7s!\" % string)  # string=hello!# %a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，# 当截取的字符串长度小于a时，还需要在其左侧补空格print(\"string=%7.2s!\" % string)  # string=     he!print(\"string=%2.7s!\" % string)  # string=hello!print(\"string=%10.7s!\" % string)  # string=     hello!# 用%*.*s来表示精度，两个*的值分别在后面小括号的前两位数值指定print(\"string=%*.*s!\" % (7, 2, string))  id = 123name = 'Xiaoming'hegiht = 1.7print('User[%s]: %s %sm ' % (id, name, hegiht))# User[123]: Xiaoming 1.7mprint('User[%(id)s]: %(name)s %(height)sm' % {    'id': 123,    'name': 'Xiaoming',    'height': 1.7})# User[123]: Xiaoming 1.7mstring = \"hello\"print(\"string=%s!\" % (string, ))  # string=hello!# 只有一个格式化对象的情况下，可以直接就用格式化对象，不需要放到元组里面print(\"string=%s!\" % string)  # string=hello!#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印print(\"string=%2s!\" % string)  # string=hello!# %7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，右边对齐print(\"string=%7s!\" % string)  # string=  hello!# %-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，左边对齐print(\"string=%-7s!\" % string)  # string=hello  !# %.2s意思是截取字符串的前2个字符print(\"string=%.2s!\" % string)  # string=he!# %.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身# 所以%.7s的打印结果是helloprint(\"string=%.7s!\" % string)  # string=hello!# %a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，# 当截取的字符串长度小于a时，还需要在其左侧补空格print(\"string=%7.2s!\" % string)  # string=     he!print(\"string=%2.7s!\" % string)  # string=hello!print(\"string=%10.7s!\" % string)  # string=     hello!# 用%*.*s来表示精度，两个*的值分别在后面小括号的前两位数值指定print(\"string=%*.*s!\" % (7, 2, string))  # string=     he!\n\n%符号，就是格式化的输出，当变量是那种类型，那么%后面接的类型也是那一种。\ndec 十进制 用在 格式化对象 是 整数的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546```%o``` —— oct 八进制```%x``` —— hex 十六进制```%f``` 用在 格式化对象 是 浮点数的情况指定宽度，而且希望不足宽度补零或者补空格```pynum = 14print(\"num=%om\" % num)  # num=16mprint(\"num=%xm\" % num)  # num=emprint(\"num=%dm\" % num)  # num=14m# %1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印print(\"num=%1dm\" % num)  # num=14m# %3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格print(\"num=%3dm\" % num)  # num= 14m# %-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格print(\"num=%-3dm\" % num)  # num=14 m# %03d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补0print(\"num=%03dm\" % num)  # num=014m# %.3d小数点后面的3意思是打印结果为3位整数，# 当整数的位数不够3位时，在整数左侧补0print(\"num=%.3dm\" % num)  # num=014m# %.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，# 当整数的位数不够3位时，在整数左侧补0print(\"num=%.0003dm\" % num)  # num=014mprint('---')# %5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，# 还是不够5位时，再在左侧补空格，# 规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是  014print(\"num=%5.3dm\" % num)  # num=  014m# %05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，# 由于是05，再在左侧补0，最终的长度选数值较大的那个print(\"num=%05.3dm\" % num)  # num=00014m# %*.*d来表示精度，两个*的值分别在后面小括号的前两位数值指定# 不过这种方式5就失去补0的功能，只能补空格，只有小数点后面的3才能补0print(\"num=%*.*dm\" % (5, 3, num))  # num=  014m\n\n12345678910111213141516171819202122232425262728293031323334353637import math# %f时表示原值，默认是小数点后6位数print(\"PI=%f\" % 3.14)  # PI=3.140000print(\"PI=%010f\" % 3.14)  # PI=003.140000print(\"PI=%f\" % math.pi)  # PI=3.141593# %a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度# %9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格print(\"PI=%9f\" % math.pi)  # PI= 3.141593print(\"PI=%09f\" % math.pi)  # PI=03.141593print(\"PI=%010f\" % math.pi)  # PI=003.141593print(\"PI=%03f\" % math.pi)  # PI=3.141593# 只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补空格print(\"PI=%3.f\" % math.pi)  # PI=  3# 只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0print(\"PI=%03.f\" % math.pi)  # PI=003# %.1f表示一个浮点数，小数点后保留1位有效数字print(\"PI=%.1f\" % math.pi)  # PI=3.1# %.3f表示一个浮点数，小数点后保留3位有效数字print(\"PI=%.3f\" % math.pi)  # PI=3.142# %6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格print(\"PI=%6.3f\" % math.pi)  # PI= 3.142# %-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格print(\"PI=%-6.3f\" % math.pi)  # PI=3.142# %*.*f来表示精度，两个*的值分别在后面小括号的前两位数值指定# 如下，不过这种方式6就失去补0的功能，只能补空格print(\"PI=%*.*f\" % (6, 3, math.pi))  import math# %f时表示原值，默认是小数点后6位数print(\"PI=%f\" % 3.14)  # PI=3.140000print(\"PI=%010f\" % 3.14)  # PI=003.140000print(\"PI=%f\" % math.pi)  # PI=3.141593# %a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度# %9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格print(\"PI=%9f\" % math.pi)  # PI= 3.141593print(\"PI=%09f\" % math.pi)  # PI=03.141593print(\"PI=%010f\" % math.pi)  # PI=003.141593print(\"PI=%03f\" % math.pi)  # PI=3.141593# 只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补空格print(\"PI=%3.f\" % math.pi)  # PI=  3# 只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0print(\"PI=%03.f\" % math.pi)  # PI=003# %.1f表示一个浮点数，小数点后保留1位有效数字print(\"PI=%.1f\" % math.pi)  # PI=3.1# %.3f表示一个浮点数，小数点后保留3位有效数字print(\"PI=%.3f\" % math.pi)  # PI=3.142# %6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格print(\"PI=%6.3f\" % math.pi)  # PI= 3.142# %-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格print(\"PI=%-6.3f\" % math.pi)  # PI=3.142# %*.*f来表示精度，两个*的值分别在后面小括号的前两位数值指定# 如下，不过这种方式6就失去补0的功能，只能补空格print(\"PI=%*.*f\" % (6, 3, math.pi))  # PI= 3.142\n\nf-string 格式化在字符串模板前面加上f，然后占位符使用{}，里面直接放入对应的数据对象。指定填入的字符串的宽度：在括号里面的变量后面加上 :宽度值左对齐，可以在括号里使用 &lt; 符号\n123456789101112salary = input('请输入薪资：')# 计算出缴税额，存入变量taxtax = int(salary) * 25 / 100# 计算出税后工资，存入变量aftertaxaftertax = int(salary) * 75 / 100print(f'税前薪资是：{salary}元， 缴税：{tax}元， 税后薪资是：{aftertax}元')# 请输入薪资：10000# 税前薪资是：10000元， 缴税：2500.0元， salary = input('请输入薪资：')# 计算出缴税额，存入变量taxtax = int(salary) * 25 / 100# 计算出税后工资，存入变量aftertaxaftertax = int(salary) * 75 / 100print(f'税前薪资是：{salary}元， 缴税：{tax}元， 税后薪资是：{aftertax}元')# 请输入薪资：10000# 税前薪资是：10000元， 缴税：2500.0元， # 税后薪资是：7500.0元\n\n\n12345salary = 10000tax = int(salary) * 25 / 100aftertax = int(salary) * 75 / 100print(f'税前薪资是：{salary:8}元， 缴税：{tax:8}元， 税后薪资是：{aftertax:8}元')salary = 10000tax = int(salary) * 25 / 100aftertax = int(salary) * 75 / 100print(f'税前薪资是：{salary:8}元， 缴税：{tax:8}元， 税后薪资是：{aftertax:8}元')# 税前薪资是：   10000元， 缴税：  2500.0元， 税后薪资是：  7500.0元\n\n\n12345678def calcTax(salary):    tax = int(salary) * 25 / 100    aftertax = int(salary) * 75 / 100    print(f'税前薪资是：{salary:&lt;8}元， 缴税：{tax:&lt;8}元， 税后薪资是：{aftertax:&lt;8}元')calcTax(10000)def calcTax(salary):    tax = int(salary) * 25 / 100    aftertax = int(salary) * 75 / 100    print(f'税前薪资是：{salary:&lt;8}元， 缴税：{tax:&lt;8}元， 税后薪资是：{aftertax:&lt;8}元')calcTax(10000)# 税前薪资是：10000   元， 缴税：2500.0  元， 税后薪资是 ：7500.0  元\n\n123456789101112import math# .3f就表示小数点后面保留1位print(f'The value of pi is approximately {math.pi:.3f}.')# The value of pi is approximately 3.142.print(f'The value of pi is approximately {math.pi:2.3f}.')# The value of pi is approximately 3.142.print(f'The value of pi is approximately {math.pi:6.3f}.')import math# .3f就表示小数点后面保留1位print(f'The value of pi is approximately {math.pi:.3f}.')# The value of pi is approximately 3.142.print(f'The value of pi is approximately {math.pi:2.3f}.')# The value of pi is approximately 3.142.print(f'The value of pi is approximately {math.pi:6.3f}.')# The value of pi is approximately  3.142.\n\n对数字不足指定宽度的时候补数字012345678def calcTax(salary):    tax = int(salary) * 25 / 100    aftertax = int(salary) * 75 / 100    print(f'税前薪资是：{salary:08}元， 缴税：{tax:08.1f}元， 税后薪资是：{aftertax:08.1f}元')calcTax(10000)def calcTax(salary):    tax = int(salary) * 25 / 100    aftertax = int(salary) * 75 / 100    print(f'税前薪资是：{salary:08}元， 缴税：{tax:08.1f}元， 税后薪资是：{aftertax:08.1f}元')calcTax(10000)# 税前薪资是：00010000元， 缴税：002500.0元， 税后薪资是 ：007500.0元\n\n<a href=\"#对-字符串-不足补零，用符号-lt-或者-gt-同时指定左右对齐方式。\" class=\"headerlink\" title=\"对 字符串 不足补零，用符号  同时指定左右对齐方式。\">对 字符串 不足补零，用符号 &lt; 或者 &gt; 同时指定左右对齐方式。1234567891011var = '34324'print(f'{var:8}')# 34324# print(f'{var:08}')# ValueError: '=' alignment not allowed in string format specifierprint(f'{var:&lt;08}')# 34324000print(f'{var:&gt;08}')var = '34324'print(f'{var:8}')# 34324# print(f'{var:08}')# ValueError: '=' alignment not allowed in string format specifierprint(f'{var:&lt;08}')# 34324000print(f'{var:&gt;08}')# 00034324\n\n16进制格式化数字1234567# 用 x 表示格式化为16进制，并采用小写格式print(f'数字12的16进制表示为：{12:x}')# 数字12的16进制表示为：c# 用 X 表示格式化为16进制，并采用大写格式print(f'数字12的16进制表示为：{12:X}')# 用 x 表示格式化为16进制，并采用小写格式print(f'数字12的16进制表示为：{12:x}')# 数字12的16进制表示为：c# 用 X 表示格式化为16进制，并采用大写格式print(f'数字12的16进制表示为：{12:X}')# 数字12的16进制表示为：C\n\n字符串内容里有花括号采用 f-string 方式格式化的 字符串内容本身就有 { 或者 } 符号，一定要 双写 进行转义，否则会被当成是 格式化占位符。\n123456times1 = 1000times2 = 2000print(f'文章中 {{ 符号 出现了 {times1} 次')# 文章中 { 符号 出现了 1000 次print(f'文章中 }} 符号 出现了 {times2} 次')times1 = 1000times2 = 2000print(f'文章中 {{ 符号 出现了 {times1} 次')# 文章中 { 符号 出现了 1000 次print(f'文章中 }} 符号 出现了 {times2} 次')# 文章中 } 符号 出现了 2000 次\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344salary = 10000# 指定了 宽度为10 个字符， 如果填入的字符串不足10个字符，就在前面加上空格，右边对齐print(f'{salary:10}')  #      10000 table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}for name, phone in table.items():    print(f'{name:10} ==&gt; {phone:10d}')# Sjoerd     ==&gt;       4127# Jack       ==&gt;       4098# Dcab       ==&gt;       7678print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '      ''      'Dcab: {0[Dcab]:d}'.format(table))# Jack: 4098; Sjoerd: 4127; Dcab: 8637678animals = 'eels'print(f'My hovercraft is full of {animals}.')# My hovercraft is full of eels.print(f'My hovercraft is full of {animals!r}.')# My hovercraft is full of 'eels'.print(\"The sum of 1 + 2 is {0}\".format(1 + 2))# The sum of 1 + 2 is 3print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))# We are the knights who say \"Ni!\"print('We are the {people} who say \"{hi}!\"'.format(people='knights', hi='Ni'))# We are the knights who say \"Ni!\"print('{0} and {1}'.format('spam', 'eggs'))# spam and eggsprint('{1} and {0}'.format('spam', 'eggs'))# eggs and spamprint('The story of {0}, {1}, and {other}.'.format('Bill',                                                   'Manfred',                                                   other='Georg'))# The story of Bill, Manfred, and Georg.coord = (3, 5)print('X: {0[0]};  Y: {0[1]}'.format(coord))salary = 10000# 指定了 宽度为10 个字符， 如果填入的字符串不足10个字符，就在前面加上空格，右边对齐print(f'{salary:10}')  #      10000 table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}for name, phone in table.items():    print(f'{name:10} ==&gt; {phone:10d}')# Sjoerd     ==&gt;       4127# Jack       ==&gt;       4098# Dcab       ==&gt;       7678print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '      ''      'Dcab: {0[Dcab]:d}'.format(table))# Jack: 4098; Sjoerd: 4127; Dcab: 8637678animals = 'eels'print(f'My hovercraft is full of {animals}.')# My hovercraft is full of eels.print(f'My hovercraft is full of {animals!r}.')# My hovercraft is full of 'eels'.print(\"The sum of 1 + 2 is {0}\".format(1 + 2))# The sum of 1 + 2 is 3print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))# We are the knights who say \"Ni!\"print('We are the {people} who say \"{hi}!\"'.format(people='knights', hi='Ni'))# We are the knights who say \"Ni!\"print('{0} and {1}'.format('spam', 'eggs'))# spam and eggsprint('{1} and {0}'.format('spam', 'eggs'))# eggs and spamprint('The story of {0}, {1}, and {other}.'.format('Bill',                                                   'Manfred',                                                   other='Georg'))# The story of Bill, Manfred, and Georg.coord = (3, 5)print('X: {0[0]};  Y: {0[1]}'.format(coord))# 'X: 3;  Y: 5\n\n123456789101112131415info = [['user1', 345.6, 12, '黄金'], ['user2', 2345.6, 8, '白银'],        ['user3555', 55345.6, 22, '钻石']]print(    f'用户：{info[0][0]:&gt;10}， 积分：{info[0][1]:7}， 等级：{info[0][2]:2}， 头衔：{info[0][3]}')print(    f'用户：{info[1][0]:&gt;10}， 积分：{info[1][1]:7}， 等级：{info[1][2]:2}， 头衔：{info[1][3]}')print(    f'用户：{info[2][0]:&gt;10}， 积分：{info[2][1]:7}， 等级：{info[2][2]:2}， 头衔：{info[2][3]}')# 用户：     user1， 积分：  345.6， 等级：12， 头衔：黄金# 用户：     user2， 积分： 2345.6， 等级： 8， 头衔：白银info = [['user1', 345.6, 12, '黄金'], ['user2', 2345.6, 8, '白银'],        ['user3555', 55345.6, 22, '钻石']]print(    f'用户：{info[0][0]:&gt;10}， 积分：{info[0][1]:7}， 等级：{info[0][2]:2}， 头衔：{info[0][3]}')print(    f'用户：{info[1][0]:&gt;10}， 积分：{info[1][1]:7}， 等级：{info[1][2]:2}， 头衔：{info[1][3]}')print(    f'用户：{info[2][0]:&gt;10}， 积分：{info[2][1]:7}， 等级：{info[2][2]:2}， 头衔：{info[2][3]}')# 用户：     user1， 积分：  345.6， 等级：12， 头衔：黄金# 用户：     user2， 积分： 2345.6， 等级： 8， 头衔：白银# 用户：  user3555， 积分：55345.6， 等级：22， 头衔：钻石\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"可变参数","url":"https://bubbleboy11.github.io/2020/08/21/ke-bian-can-shu/","content":"函数传递中 *args, **kwargs 含义是什么\n用来处理可变参数允许定义的函数接受任意数目的参数。在函数被调用前并不知道也不限制将来函数可以接收的参数数量，将不定数量的参数传递给一个函数。\n可变参数 *args 被打包成 tuple 元组\n关键字可变参数 **kwargs 被打包成 dict 字典\n\n而写成args&nbsp;和**kwargs只是一个通俗的命名约定,主要用于函数定义。其实并不是必须写成args&nbsp;和kwargs。只有变量前面的&nbsp;才是必须的.你也可以写成var&nbsp;和vars. \n可变参数 *args 实例：在参数前面加了一个*，定义可变参数和定义一个list或tuple参数相比，*args表示把args这个list的所有元素作为可变参数传给可变参数\n可变参数既可以直接传入：func(1, 2, 3)，\n再通过args传入：func((1, 2, 3))；\n12345678910111213141516171819def print_multiple_args(*args):  # 可以传递任意个    print(type(args), args)    for idx, val in enumerate(args):  # enumerate()枚举函数        print(idx, val)# 可变参数既可以直接传入print_multiple_args('a', 'b', 'c')# &lt;class 'tuple'&gt; ('a', 'b', 'c')# 0 a# 1 b# 2 c# 通过将列表前加*打包成关键字参数，组装list或tuple，接收值参数必须是*argsprint_multiple_args(*['a', 'b', 'c'])# &lt;class 'tuple'&gt; ('a', 'b', 'c')# 0 a# 1 bdef print_multiple_args(*args):  # 可以传递任意个    print(type(args), args)    for idx, val in enumerate(args):  # enumerate()枚举函数        print(idx, val)# 可变参数既可以直接传入print_multiple_args('a', 'b', 'c')# &lt;class 'tuple'&gt; ('a', 'b', 'c')# 0 a# 1 b# 2 c# 通过将列表前加*打包成关键字参数，组装list或tuple，接收值参数必须是*argsprint_multiple_args(*['a', 'b', 'c'])# &lt;class 'tuple'&gt; ('a', 'b', 'c')# 0 a# 1 b# 2 c\n\n参数定义的顺序：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。some_func(fargs, *args, **kwargs)\n关键字可变参数 kwargs 实例：在参数前面加了两个*，extra表示把extra这个dict的所有key-value用关键字参数传入到函数的kw参数，kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n12345678910111213141516171819202122def print_kwargs(**kwargs):    print(type(kwargs), kwargs)    for k, v in kwargs.items():        print('{}: {}'.format(k, v))# 关键字参数既可以直接传入，print_kwargs(a=1, b=2)# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1# b: 2# 给字典前加**打包成关键字参数，组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。print_kwargs(**dict(a=1, b=2))# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1# b: 2print_kwargs(**{'a': 1, 'b': 2})# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1def print_kwargs(**kwargs):    print(type(kwargs), kwargs)    for k, v in kwargs.items():        print('{}: {}'.format(k, v))# 关键字参数既可以直接传入，print_kwargs(a=1, b=2)# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1# b: 2# 给字典前加**打包成关键字参数，组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。print_kwargs(**dict(a=1, b=2))# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1# b: 2print_kwargs(**{'a': 1, 'b': 2})# &lt;class 'dict'&gt; {'a': 1, 'b': 2}# a: 1# b: 2\n\n可变参数和不可变参数混用实例12345678910111213141516171819202122232425262728293031323334353637def print_all(a, *args, **kwargs):    print(a)    if args:        print(args)    if kwargs:        print(kwargs)print_all('hello', 'world', name='Ashe')# 输出结果：# hello# ('world',)# {'name': 'Ashe'}print_all(100, *\"ASHE\", name=\"Ashe\", age=18)# 100# ('A', 'S', 'H', 'E')# {'name': 'Ashe', 'age': 18}print('--')print_all(1, 2, 3, 4)# 1# (2, 3, 4)print_all(1, b=2, c=3)# 1# {'b': 2, 'c': 3}print_all(1, 2, 3, 4, b=2, c=3)# 1# (2, 3, 4)# {'b': 2, 'c': 3}print_all('a', 1, None, b='2', c=3)# a# (1, None)def print_all(a, *args, **kwargs):    print(a)    if args:        print(args)    if kwargs:        print(kwargs)print_all('hello', 'world', name='Ashe')# 输出结果：# hello# ('world',)# {'name': 'Ashe'}print_all(100, *\"ASHE\", name=\"Ashe\", age=18)# 100# ('A', 'S', 'H', 'E')# {'name': 'Ashe', 'age': 18}print('--')print_all(1, 2, 3, 4)# 1# (2, 3, 4)print_all(1, b=2, c=3)# 1# {'b': 2, 'c': 3}print_all(1, 2, 3, 4, b=2, c=3)# 1# (2, 3, 4)# {'b': 2, 'c': 3}print_all('a', 1, None, b='2', c=3)# a# (1, None)# {'b': '2', 'c': 3}\n\n123456789101112131415161718192021222324def normal_func(arg4, arg5, arg6):    print(\"arg4: \" + arg4)    print(\"arg5: \" + arg5)    print(\"arg6: \" + arg6)normal_func(\"python\", '1', '3')# arg4: python# arg5: 1# arg6: 3# 使用*argsargs_tuple = (\"python\", '1', '3')normal_func(*args_tuple)# arg4: python# arg5: 1# arg6: 3# 使用**kwargskwargs_dict = {\"arg4\": '4', \"arg5\": \"python\", \"arg6\": '1'}normal_func(**kwargs_dict)# arg4: 4# arg5: pythondef normal_func(arg4, arg5, arg6):    print(\"arg4: \" + arg4)    print(\"arg5: \" + arg5)    print(\"arg6: \" + arg6)normal_func(\"python\", '1', '3')# arg4: python# arg5: 1# arg6: 3# 使用*argsargs_tuple = (\"python\", '1', '3')normal_func(*args_tuple)# arg4: python# arg5: 1# arg6: 3# 使用**kwargskwargs_dict = {\"arg4\": '4', \"arg5\": \"python\", \"arg6\": '1'}normal_func(**kwargs_dict)# arg4: 4# arg5: python# arg6: 1\n\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。和位置参数不同，命名关键字参数必须传入参数名 city job\n12345678def person(name, age, *, city, job):    print(name, age, city, job)person('Jack', 24, city='Beijing', job='Engineer')# Jack 24 Beijing Engineerperson('Jack', 24, 'Beijing', 'Engineer')def person(name, age, *, city, job):    print(name, age, city, job)person('Jack', 24, city='Beijing', job='Engineer')# Jack 24 Beijing Engineerperson('Jack', 24, 'Beijing', 'Engineer')# TypeError: person() takes 2 positional arguments but 4 were given\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"哈希hashlib MD5","url":"https://bubbleboy11.github.io/2020/08/21/ha-xi-hashlib-md5/","content":"摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据（字节串）转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n在python3的标准库中，已经移除了md5模块，而关于hash加密算法都放在hashlib这个标准库中，如SHA1、SHA224、SHA256、SHA384、SHA512和MD5算法等。\nMD5消息摘要算法（Message Digest Algorithm 5），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的 哈希值（hash value）或者 摘要(digests)），用于确保信息传输完整一致。通常用一个32位的16进制字符串表示。\n哈希计算的特点是：\n\n相同的 源数据， 采用 相同的哈希算法， 计算出来的哈希值 一定相同\n不管 源数据 有多大，相同的哈希算法，计算出来的哈希值长度 都是一样长的。 \n\n算法    计算结果长度MD5        16字节SHA1    20字节SHA224    28字节SHA256    32字节SHA384    48字节SHA512    64字节\n\n算法不可逆。不能通过 哈希值 反过来计算出 源数据。 所以哈希和我们常说的加密解密不同。\n不同的源数据 使用同样的哈希算法，可能会产生相同的 哈希值，这被称之为碰撞率（collision rate）\n\n使用hashlib库要计算的源数据必须是字节串格式字符串对象需要encode()转化为字节串对象方法一： \n1234import hashlibmd5str = hashlib.md5('hello'.encode()).hexdigest()print(md5str)import hashlibmd5str = hashlib.md5('hello'.encode()).hexdigest()print(md5str)# 5d41402abc4b2a76b9719d911017c592\n\n方法二\n1234567891011121314151617import hashlibm = hashlib.md5()m.update(\"hello\".encode())print(m)# &lt;md5 HASH object @ 0x000001AD94827B90&gt;# 产生哈希值对应的bytes对象resultBytes = m.digest()print(resultBytes)# b']A@*\\xbcK*v\\xb9q\\x9d\\x91\\x10\\x17\\xc5\\x92'# 产生哈希值的十六进制表示resultHex = m.hexdigest()print(resultHex)import hashlibm = hashlib.md5()m.update(\"hello\".encode())print(m)# &lt;md5 HASH object @ 0x000001AD94827B90&gt;# 产生哈希值对应的bytes对象resultBytes = m.digest()print(resultBytes)# b']A@*\\xbcK*v\\xb9q\\x9d\\x91\\x10\\x17\\xc5\\x92'# 产生哈希值的十六进制表示resultHex = m.hexdigest()print(resultHex)# 5d41402abc4b2a76b9719d911017c592\n\n对于英文加密，可以使用b' '前缀。如果要对中文加密，使用b' '前缀来写会报错，原因在于字符转码问题，b' '在python中只能对ASCII字符进行转码。\n中文不同的encode编码，md5加密得到的结果是不一样的\n12345import hashlibmd5str = hashlib.md5('中文'.encode(encoding='UTF-8')).hexdigest()print(md5str)  #a 7bac2239fcdcb3a067903d8077c4a07md5str2 = hashlib.md5('中文'.encode(encoding='GBK')).hexdigest()print(md5str2)  import hashlibmd5str = hashlib.md5('中文'.encode(encoding='UTF-8')).hexdigest()print(md5str)  #a 7bac2239fcdcb3a067903d8077c4a07md5str2 = hashlib.md5('中文'.encode(encoding='GBK')).hexdigest()print(md5str2)  # bcce109775e8e1972e9f5fcda3e12895\n\n使用别的哈希算法，比如， sha256 算法，只需要修改为对应的函数 sha256()即可\n12import hashlibm = hashlib.sha256()\n其它都不用变。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["加密","MD5"]},{"title":"回溯算法","url":"https://bubbleboy11.github.io/2020/08/21/hui-su/","content":"回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，\n回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。\n回溯算法建立在DFS基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。而满足回溯条件的某个状态的点称为 “回溯点”。\nDFS是一个劲的往某一个方向搜索，\n因此回溯算法与DFS的区别就是有无状态重置\n** 当问题需要”回头”，以此来查找出所有的解的时候 **，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。\n①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※②根据题意，确立结束条件③找准选择列表(与函数参数相关),与第一步紧密关联※④判断是否需要剪枝⑤作出选择，递归调用，进入下一层⑥撤销选择\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"在python和django中使用redis","url":"https://bubbleboy11.github.io/2020/08/21/zai-python-he-django-zhong-shi-yong-redis/","content":"在python中使用redis12345678&gt;&gt;&gt; import redis  # 引入redis库&gt;&gt;&gt; PASSWORD = 'password'  # redis服务端密码&gt;&gt;&gt; res = redis.Redis(host='localhost', port=6379, password=PASSWORD)# host后的IP是需要连接的ip，本地是127.0.0.1或者localhost，prot后需要填写Redis默认端口号\"6379\"&gt;&gt;&gt; res.set('data','bind')True&gt;&gt;&gt; print(res.get('data'))&gt;&gt;&gt; import redis  # 引入redis库&gt;&gt;&gt; PASSWORD = 'password'  # redis服务端密码&gt;&gt;&gt; res = redis.Redis(host='localhost', port=6379, password=PASSWORD)# host后的IP是需要连接的ip，本地是127.0.0.1或者localhost，prot后需要填写Redis默认端口号\"6379\"&gt;&gt;&gt; res.set('data','bind')True&gt;&gt;&gt; print(res.get('data'))b'bind'\n\n动态的首页是如何呈现给用户的？有什么规律？客户端\n\n通过URL规则找到对应的视图函数\n查询数据库\n生成响应数据\n返回给浏览器展示\n\n在django中使用redis\n第一步，安装\n1>> pip install django-redis\n\n第二步，配置settings.py\n12345678910CACHES = {    \"default\": {        \"BACKEND\": \"django_redis.cache.RedisCache\",        \"LOCATION\": \"redis://127.0.0.1:6379/1\",        \"OPTIONS\": {            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",            \"PASSWORD\": CACHES = {    \"default\": {        \"BACKEND\": \"django_redis.cache.RedisCache\",        \"LOCATION\": \"redis://127.0.0.1:6379/1\",        \"OPTIONS\": {            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",            \"PASSWORD\": \"\"        }    }}\n\n第三步，存取\n123456```pyfrom django.core.cache import cache# 存储cache.set(key, value, timeout=None)# 查询cache.get(key)\n\n\n\nsystem/urls.py\n1234urlpatterns = [    path('cache/set/', views.cache_set, name=\"cache_set\"),    path('cache/get/', views.cache_get, name=urlpatterns = [    path('cache/set/', views.cache_set, name=\"cache_set\"),    path('cache/get/', views.cache_get, name=\"cache_get\"),]\n\nsystem/views.py\n12345678910111213from django.core.cache import cachedef cache_set(request):    \"\"\" 写缓存 \"\"\"    cache.set('username', 'lisi')    # timeout=5 5之后自动删除    cache.set('password', 'password', timeout=5)    return HttpResponse('ok')def cache_get(request):    \"\"\" 读缓存 \"\"\"    value = cache.get('username')    from django.core.cache import cachedef cache_set(request):    \"\"\" 写缓存 \"\"\"    cache.set('username', 'lisi')    # timeout=5 5之后自动删除    cache.set('password', 'password', timeout=5)    return HttpResponse('ok')def cache_get(request):    \"\"\" 读缓存 \"\"\"    value = cache.get('username')    return HttpResponse(value)\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["django"],"tags":["django","redis"]},{"title":"垃圾回收","url":"https://bubbleboy11.github.io/2020/08/21/la-ji-hui-shou/","content":"Python的垃圾回收机制原理\n\n引用计数为主（缺点：循环引用无法解决）\n引入标记清除和分代回收解决引用计数问题\n引用计数为主+标记清除和分代回收（收集）为辅\n\n引用计数（reference count）\n\n每个对象都有存有指向该对象的引用总数\n查看某个对象的引用计数 sys.getrefcount()\n可以使用del关键字删除某个引用，减少对象引用计数，并不是销毁对象，释放已创建的变量（已占用的资源）。\n\n① 什么时候对象的引用计数加1呢？    -  对象创建 a = 1,\n-   对象被引用 b = a\n\n-  对象作为参数传递 func(a)\n\n-   对象存储在容器中 l = [a]\n\n② 什么时候引用计数会减1呢？\n-  显示使用 del a \n\n-  引用指向了别的对象 b=None\n\n-  离开的对象的作用域（比如函数执行结束）\n\n-  从一个容器移除对象或者销毁容器\n\n③ 当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，python虚拟机就会去把对象占用的内存回收掉，将其内存释放掉。\n值(number\\str)类型先随机 分配一个内存从一个随机数开始，\npython里面一切皆对象，比如创建一个列表 [1]，这个一个list对象。实际上Python的C语言实现中对于每个对象它都有几个字段，如它是什么类型以及引用计数即 ref 的值等，引用计数ref 就是C语言实现里面一个int值，用来计算有多少个变量在引用它。\n1234a = [1]   # [1]对象引用计数增加1，ref=1b = a     # [1]对象引用计数增加1，ref=2b = None  # [1]对象引用计数减少1，ref=1del a     # [1]对象引用计数减少1，ref=a = [1]   # [1]对象引用计数增加1，ref=1b = a     # [1]对象引用计数增加1，ref=2b = None  # [1]对象引用计数减少1，ref=1del a     # [1]对象引用计数减少1，ref=0\n\na = [1],当把列表 [1] 赋值给 a 的时候，它的引用计数就会增加1，此时列表 [1] 对象的引用计数ref=1 ； b = a 又把 a 赋值给 b ，a和b 同时引用了列表[1]对象，ref又增加1，此时 ref =2。继续执行 b = None， 让b指向None，这个时候它就不会指向原来的列表[1]对象，列表[1]对象的引入计数就会减少1，又变成ref=1。执行del a ，引用计数就会减少1，这个时候 ref = 0。当对象的引用计数为0就可以回收掉，\n什么时候引用计数减少，比如让b 不在指向[ 1],这时候引用计数就会减少，还可以使用Python的del 操作符，del a 也会减少对象[1]引用计数。\n1234// object.hstruct _object {    Py_ssize_t ob_refcnt;   // object.hstruct _object {    Py_ssize_t ob_refcnt;   # 引用计数值}PyObject;\n\n12345678&gt;&gt;&gt; import sys&gt;&gt;&gt; a = [1,2]&gt;&gt;&gt; sys.getrefcount(a)   # 查看a的引用计数2   # 创建对象，a引用增加1，调用函数也会增加引用计数，因此这里是2&gt;&gt;&gt; b = 1&gt;&gt;&gt; sys.getrefcount(1)   189  # 跟python底层实现有关，小整数对象池，不只是b引用1，内部实现有很多引用它&gt;&gt;&gt; import sys&gt;&gt;&gt; a = [1,2]&gt;&gt;&gt; sys.getrefcount(a)   # 查看a的引用计数2   # 创建对象，a引用增加1，调用函数也会增加引用计数，因此这里是2&gt;&gt;&gt; b = 1&gt;&gt;&gt; sys.getrefcount(1)   189  # 跟python底层实现有关，小整数对象池，不只是b引用1，内部实现有很多引用它# 所以结果和你想的不太一样\n\n优点：引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。\n缺点：循环引用的问题，引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的，这显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。\n（2）引用计数无法解决循环引用问题只关注那些可能会产生循环引用的对象，显然，像是PyIntObject、PyStringObject这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。Python中的循环引用总是发生在container对象之间，也就是能够在内部持有其它对象的对象，比如list、dict、class等等。这也使得该方法带来的开销只依赖于container对象的的数量循环引用解决不了可能会造成内存泄漏致命问题，因为循环引用致命的缺陷导致Python还需要别的机制来去增强它的垃圾回收功能。\n循环引用，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存始终都不会被释放掉。\n1234567a = [1]    # 对象[1]引用计数增加1，ref=1b = [2]    # 对象[2]引用计数增加1，ref=1a.append(b)  # b被a引用，对象[2]引用计数增加1，ref=2b.append(a)  # a又被b引用，对象[1]引用计数增加1，ref=2del a     # 对象[1]引用计数减少1，ref=1del b     # 对象[2]引用计数减少1，ref=a = [1]    # 对象[1]引用计数增加1，ref=1b = [2]    # 对象[2]引用计数增加1，ref=1a.append(b)  # b被a引用，对象[2]引用计数增加1，ref=2b.append(a)  # a又被b引用，对象[1]引用计数增加1，ref=2del a     # 对象[1]引用计数减少1，ref=1del b     # 对象[2]引用计数减少1，ref=1# 两个对象互相引用之后引用计数无法归零\n  a = [1]，[1]赋值给a, a指向[1]对象,此时 [1] 的引用计数为 ref=1,然后执行 b = [2], b指向了[2]列表对象, 此时 [2] 的引用计数为 ref=1。执行操作 a.append(b) ，这个时候 b被 a 引用，此时 [2] 对象的引用计数 ref=2，在执行b.append(a), 这时候 a 又被b引用，此时 [1] 对象的引用计数 ref=2。这时候会出现互相引用即循环引用。\n\n  执行del a 和del b 这时候把 a 和 b去掉，对象[1] 和 [2] 的引用计数都变成 ref=1,发现最后引用计数都没有变成0，而且两个对象出现互相引用这就出现了循环引用的问题之后引用计数无法归零，并且始终没有办法销毁 [1]和 [2] 这两个列表对象。循环引用的问题导致这两个对象始终没有办法去回收。\n\n标记清除（Mark and Sweep）图解：标记清除的原理就是\n\n从垃圾回收的根对象(GC root object 标记为红色的点) 寻找跟对象的集合作为垃圾检测动作的起点，跟对象也就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的；\n沿着root object集合中的每一个引用，开始不断查找可达对象。如左边图可达对象其实就是一个有向图，线表示引用关系，从图中可以看到有三个蓝色点是从根节点不可达的点(孤立点)，分别是被四个点包裹的中间点和左下角的两个相连的点。如右图标记清除就是把不可达的点标灰，凡是标灰的点就认为没有对象去引用它就可以把它清除掉，如果能够到达某个对象，则说明这个对象是可达的标绿，那么就不会被删除，这个过程就是垃圾检测阶段；\n当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的对象连接在一起）标记和清除的过程效率不高\n\n垃圾回收\n\n满足特定条件，自动启动垃圾回收\n当Python运行时，会记录其中分配对象（object allocation）和取消分配对象（object deallocation）的次数\n当两者的差值高于某个阈值时，垃圾回收才会启动\n查看阈值gc.get threshold()Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记－清除”解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。\n\n分代回收\n\nPython把对象的生命周期分为三代，分别是第0代、第1代、第2代。\n每一代使用双向链表来标记这些对象\nPython把一开始创建的新建对象称为第0代，比如 a ↔ b ↔ c ↔ d。每隔一定时间Python就会执行一个操作对第0、1、2代分别执行标记回收。每一代都会有预值，每隔多少时间就会清除第0代，每隔多少时间就会清除第1代，每隔多少时间就会清除第2代。\n每一代执行完标记回收之后剩下的对象没有回收的就会换移到下一代。 当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象123&gt;&gt;&gt; import gc&gt;&gt;&gt; gc.get_threshold()(700, 10, 10)  &gt;&gt;&gt; import gc&gt;&gt;&gt; gc.get_threshold()(700, 10, 10)  # 第一个700为第0代预值，第二个10为第1代预值，第三个10为第2代预值\nget_threshold() -&gt; (threshold0, threshold1, threshold2)当每一代达到预值，就会触发GC操作，如第0代链表长度达到700个对象触发一次GC操作，也就是把第0代执行一次分代回收。\n\n原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，Python默认定义了三代对象集合，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。\n手动回收\n\ngc.collect()手动执行垃圾回收garbagecollector\nobjgraph模块中的count()记录当前类产生的实例对象的个数\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import osimport psutilimport sysimport gcimport objgraphdef show_memory_info(hint):    pid = os.getpid()    p = psutil.Process(pid)    info = p.memory_full_info()    memory = info.uss / 1024. / 1024    print(\"{}内存使用了{}MB\".format(hint, memory))def func():    show_memory_info(\"局部变量初始化\")    a = [i for i in range(10000000)]    show_memory_info(\"局部变量创建后\")    return adef func2():    show_memory_info(\"全局变量初始化\")    global a    a = [i for i in range(10000000)]    show_memory_info(\"全局变量创建后\")# python内部引用计数def jishu():    a = []    print(sys.getrefcount(a))    def func(a):        print(sys.getrefcount(a))    func(a)    print(sys.getrefcount(a))# 循环引用def func3():    show_memory_info(\"循环引用初始化\")    a = [i for i in range(10000000)]    b = [i for i in range(10000000)]    show_memory_info(\"ab创建完成\")    a.append(b)    b.append(a)if __name__ == \"__main__\":    pass     func()    show_memory_info(\"局部变量完成后\")    func2()    show_memory_info(\"全局变量完成后\")    l = func()    show_memory_info(\"列表变量完成后\")    jishu()    print(\"手动回收垃圾\")    show_memory_info(\"初始化前\")    a = [i for i in range(10000000)]    show_memory_info(\"初始化后\")    del a    gc.collect()    show_memory_info(\"完成\")    # print(a)    # 循环引用    func3()    show_memory_info(\"循环引用完成\")    gc.collect()    show_memory_info(\"手动垃圾回收完成\")    # objgraph    a = [1,2,3]    b = [4,5,6]    a.append(b)    b.append(a)    objgraph.show_refs([a], filename = \"objref.png\")    objgraph.show_backrefs([a], filename = import osimport psutilimport sysimport gcimport objgraphdef show_memory_info(hint):    pid = os.getpid()    p = psutil.Process(pid)    info = p.memory_full_info()    memory = info.uss / 1024. / 1024    print(\"{}内存使用了{}MB\".format(hint, memory))def func():    show_memory_info(\"局部变量初始化\")    a = [i for i in range(10000000)]    show_memory_info(\"局部变量创建后\")    return adef func2():    show_memory_info(\"全局变量初始化\")    global a    a = [i for i in range(10000000)]    show_memory_info(\"全局变量创建后\")# python内部引用计数def jishu():    a = []    print(sys.getrefcount(a))    def func(a):        print(sys.getrefcount(a))    func(a)    print(sys.getrefcount(a))# 循环引用def func3():    show_memory_info(\"循环引用初始化\")    a = [i for i in range(10000000)]    b = [i for i in range(10000000)]    show_memory_info(\"ab创建完成\")    a.append(b)    b.append(a)if __name__ == \"__main__\":    pass     func()    show_memory_info(\"局部变量完成后\")    func2()    show_memory_info(\"全局变量完成后\")    l = func()    show_memory_info(\"列表变量完成后\")    jishu()    print(\"手动回收垃圾\")    show_memory_info(\"初始化前\")    a = [i for i in range(10000000)]    show_memory_info(\"初始化后\")    del a    gc.collect()    show_memory_info(\"完成\")    # print(a)    # 循环引用    func3()    show_memory_info(\"循环引用完成\")    gc.collect()    show_memory_info(\"手动垃圾回收完成\")    # objgraph    a = [1,2,3]    b = [4,5,6]    a.append(b)    b.append(a)    objgraph.show_refs([a], filename = \"objref.png\")    objgraph.show_backrefs([a], filename = \"backref.png\" )\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/ji-yu-sheng-cheng-qi-de-xie-cheng/","content":"协程 ：协同多任务\n协程在一个进程或者是一个线程中执行程序员调度，分解一个线程成为多个 “微线程”。例如：程序需要非常高并发。\n不需要锁机制\n对多核CPU的利用——多进程+协程\n\n协程的注意点\n协程需要使用 send（None）或者 next（coroutine）来预激（prime）才能启动\n在 yield处协程会暂定执行\n单独yield value 会产出值给调用方\n可以单独coroutine.send(value) 来给协程发送值，发送的值会赋值给&nbsp;yield表达式左边的变量\n协程执行完后（没有遇到下一个yield语句）会抛出StopIteratio异常\n\n协程的实现基于生成器的协程python3.5之前没有原生协程，python2是基于生成器（yield）来实现的协程。\n\npep 342(Coroutines via Enhanced Generator)增强生成器功能\n生成器可以通过yield暂停执行和产出数据\n同时支持send()向生成器发送数据和throw()向生成器抛异常\n\nGenerator Based Coroutine 基于生成器的协程 示例：\n12345678910111213def coro():    a1 = yield 'hello'  # yield关键字在=右边作为表达式，可以被send值    yield a1c = coro()  # 生成一个协程print(type(c))  # &lt;class 'generator'&gt;# 输出 'hello'，这里调用next产出第一个值’hello',之后函数暂停 print(next(c))  # helloprint(c.send('world'))  # world# 如果yield在表达式=的右边，就可以向该函数调用 send() 发送一个值，此时a1被赋值为'world'，然后yield产出a1变量的值'world',然后函数又暂停# 之后协程结束，后续再send值会抛出异常 StopIterationdef coro():    a1 = yield 'hello'  # yield关键字在=右边作为表达式，可以被send值    yield a1c = coro()  # 生成一个协程print(type(c))  # &lt;class 'generator'&gt;# 输出 'hello'，这里调用next产出第一个值’hello',之后函数暂停 print(next(c))  # helloprint(c.send('world'))  # world# 如果yield在表达式=的右边，就可以向该函数调用 send() 发送一个值，此时a1被赋值为'world'，然后yield产出a1变量的值'world',然后函数又暂停# 之后协程结束，后续再send值会抛出异常 StopIteration# print(c.send('None'))  # StopIteration  \n\n实际上基于生成器的协程主要是 可以在调用者方通过send给生成器发送一个值。\n3.Python3.5 引入 async / await 支持原生协程（native coroutine）\n◆定义特殊函数async def async_():    pass◆当被调用时，不执行里面的代码，而是返回一个协程对象◆在事件循环中调度其执行前，协程对象不执行任何操作\nawait关键字·等待协程执行完成当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程\nasyncio模块◆get_event_loop()获得事件循环队列run_until_complete() 注册任务到队列◆在事件循环中调度其执行前，协程对象不执行任何操作asyncio模块用于事件循环\n12345678910111213141516171819import asyncioimport datetimeimport randomasync def display_date(num, loop):    end_time = loop.time() + 50.0    while True:        print(\"Loop: {} Time: {}\".format(num, datetime.datetime.now()))        if (loop.time() + 1.0) &gt;= end_time:            break        await asyncio.sleep(random.randint(0, 5))if __name__ == \"__main__\":    loop = asyncio.get_event_loop()    asyncio.ensure_future(display_date(1, loop))    asyncio.ensure_future(display_date(import asyncioimport datetimeimport randomasync def display_date(num, loop):    end_time = loop.time() + 50.0    while True:        print(\"Loop: {} Time: {}\".format(num, datetime.datetime.now()))        if (loop.time() + 1.0) &gt;= end_time:            break        await asyncio.sleep(random.randint(0, 5))if __name__ == \"__main__\":    loop = asyncio.get_event_loop()    asyncio.ensure_future(display_date(1, loop))    asyncio.ensure_future(display_date(2, loop))    loop.run_forever()\n\n协程之间的数据通信嵌套调用：在一个协程函数中，有一些业务逻辑代码依赖于另外的协程函数的返回协程装饰器      避免每次都要用 send 预激它\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/zi-dian-qu-dai-switch/","content":"12345678910111213141516171819202122232425262728def sunday():    print('俺是星期天')def monday():    print('俺是星期一')def tuesday():    print('俺是星期二')def default():    print('俺是default')switcher = {  # 注意：()如果直接写在键值中，会导致所有函数都执行    0: sunday,    1: monday,    2: tuesday}day = 8day1 = 1day_name = switcher.get(day, default)()  # 加上括号执行函数day_name = switcher.get(day1, default)()  # 加上括号执行函数def sunday():    print('俺是星期天')def monday():    print('俺是星期一')def tuesday():    print('俺是星期二')def default():    print('俺是default')switcher = {  # 注意：()如果直接写在键值中，会导致所有函数都执行    0: sunday,    1: monday,    2: tuesday}day = 8day1 = 1day_name = switcher.get(day, default)()  # 加上括号执行函数day_name = switcher.get(day1, default)()  # 加上括号执行函数# 俺是default\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"如何剖析程序性能","url":"https://bubbleboy11.github.io/2020/08/21/ru-he-pou-xi-cheng-xu-xing-neng/","content":"使用各种profile工具（内置或第三方）\n二八定律，大部分时间消耗时在少量代码操作上。\n使用内置 profile / cprofile 等工具来衡量代码的运行时间\n对于web应用来说可以使用 pyflame( uber 开源)的火焰图工具分析程序性能。\n\n服务端性能优化措施web应用一般语言不会成为瓶颈\n\n数据结构和算法优化（高效的算法或者数据结构能带来性能提升非常大）\n\n数据库层：索引优化，慢查询消除，批量操作减少IO，通过引入NoSQL提升系统性能\n\n网络IO：批量操作，通过pipeline管道操作，减少数据库IO请求次数。\n\n缓存：使用内存数据库 redis / memcached。(内存读取时间远高于磁盘读取，使用内存数据库抗一些并发比较高的请求)\n\n异步：asyncio , celery (使用一些异步框架或者异步库)\n\n并发： gevent / 多线程 （并发相关请求）\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["面试"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/fu-bi-jiao/","content":"other)``` less than1234567891011121314151617181920212223242526272829303132333435363738394041424344454647```object.__le__(self, other)``` less than or equal  ```object.__eq__(self, other)``` equal  ```object.__ne__(self, other)``` not equal  ```object.__gt__(self, other)``` great than  ```object.__ge__(self, other)``` great than or equal  以上这些被称为“富比较”方法。运算符号与方法名称的对应关系如下：```x<y``` 调用 ```x.__lt__(y)```、```x<=y``` 调用 ```x.__le__(y)```、```x==y``` 调用 ```x.__eq__(y)```、```x!=y``` 调用 ```x.__ne__(y)```、```x>y``` 调用 ```x.__gt__(y)```、```x>=y``` 调用 ```x.__ge__(y)```。如果指定的参数对没有相应的实现，富比较方法可能会返回单例对象 NotImplemented。按照惯例，成功的比较会返回 False 或 True。不过实际上这些方法可以返回任意值，因此如果比较运算符是要用于布尔值判断（例如作为 if 语句的条件），Python 会对返回值调用 bool() 以确定结果为真还是假。在默认情况下，object 通过使用 is 来实现 __eq__()，并在比较结果为假值时返回 NotImplemented: True if x is y else NotImplemented。 对于 __ne__()，默认会委托给 __eq__() 并对结果取反，除非结果为 NotImplemented。 比较运算符之间没有其他隐含关系或默认实现；例如，(x<y or x==y) 为真并不意味着 x<=y。 要根据单根运算自动生成排序操作，请参看 functools.total_ordering()。请查看 __hash__() 的相关段落，了解创建可支持自定义比较运算并可用作字典键的 hashable 对象时要注意的一些事项。这些方法并没有对调参数版本（在左边参数不支持该操作但右边参数支持时使用）；而是 __lt__() 和 __gt__() 互为对方的反射， __le__() 和 __ge__() 互为对方的反射，而 __eq__() 和 __ne__() 则是它们自己的反射。如果两个操作数的类型不同，且右操作数类型是左操作数类型的直接或间接子类，则优先选择右操作数的反射方法，否则优先选择左操作数的方法。虚拟子类不会被考虑。1. 当自定义类中两个方法都定义了__lt__和__gt__方法，“”分别调用__lt__和__gt__方法```pyclass Test:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value < other.value    def __gt__(self, other):        return self.value > other.valueif __name__ == \"__main__\":    test1 = Test(1)    test2 = Test(2)    print(test1 < test2)  # True    print(test1 > test2)  # False\n\n故意在__lt__和__gt__方法里设置了逻辑矛盾的两个比较原则，看最终输出结果也印证了这两个方法分别被调用了，从而获得了逻辑矛盾的两个结果。在一个类里面重载__lt__、__gt__方法后，\n12345678910111213141516class Test:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value &lt; other.value    def __gt__(self, other):        return self.value &lt; other.valueif __name__ == \"__main__\":    test1 = Test(1)    test2 = Test(2)    print(test1 &lt; test2)  # True    print(test1 &gt; test2)  class Test:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value &lt; other.value    def __gt__(self, other):        return self.value &lt; other.valueif __name__ == \"__main__\":    test1 = Test(1)    test2 = Test(2)    print(test1 &lt; test2)  # True    print(test1 &gt; test2)  # True\n\n\n\n当自定义类中只定义了__lt__方法，未定义__gt__方法时，在计算car1 &lt; car2时，触发了比较函数__lt__，从而得到了结果True，进行”&gt;”比较也是调用__lt__方法，只是对调用值求反。在没有定义__gt__方法时，car1 &gt; car2也会调用__lt__方法，依次传入参数为car2和car1。\n\n1234567891011121314151617181920class Car():    def __init__(self, carname, oilcp100km, price):        self.carname, self.oilcp100km, self.price = carname, oilcp100km, price    def __lt__(self, other):        print(\"execute __lt__\")        return self.price &lt; other.pricecar1 = Car('爱丽舍', 8, 10)car2 = Car('凯美瑞', 7, 27)car3 = Car('爱丽舍', 8, 10)car4 = Car('途观', 12, 27)print(car1 &gt; car2)# execute __lt__# Falseprint(car1 &lt; car2)# execute __lt__class Car():    def __init__(self, carname, oilcp100km, price):        self.carname, self.oilcp100km, self.price = carname, oilcp100km, price    def __lt__(self, other):        print(\"execute __lt__\")        return self.price &lt; other.pricecar1 = Car('爱丽舍', 8, 10)car2 = Car('凯美瑞', 7, 27)car3 = Car('爱丽舍', 8, 10)car4 = Car('途观', 12, 27)print(car1 &gt; car2)# execute __lt__# Falseprint(car1 &lt; car2)# execute __lt__# True\n\n\n当自定义类中定义了__gt__方法，未定义__lt__方法时，进行”&lt;”比较也是调用__gt__方法，只是对调用值求反。1234567891011121314151617181920class Car():    def __init__(self, carname, oilcp100km, price):        self.carname, self.oilcp100km, self.price = carname, oilcp100km, price    def __gt__(self, other):        print(\"execute __gt__\")        return self.price &gt; other.pricecar1 = Car('爱丽舍', 8, 10)car2 = Car('凯美瑞', 7, 27)car3 = Car('爱丽舍', 8, 10)car4 = Car('途观', 12, 27)print(car1 &lt; car2)# execute __gt__# Trueprint(car1 &gt; car2)# execute __gt__class Car():    def __init__(self, carname, oilcp100km, price):        self.carname, self.oilcp100km, self.price = carname, oilcp100km, price    def __gt__(self, other):        print(\"execute __gt__\")        return self.price &gt; other.pricecar1 = Car('爱丽舍', 8, 10)car2 = Car('凯美瑞', 7, 27)car3 = Car('爱丽舍', 8, 10)car4 = Car('途观', 12, 27)print(car1 &lt; car2)# execute __gt__# Trueprint(car1 &gt; car2)# execute __gt__# False\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xiao-zhi/","content":"\ntitle: 寻找旋转排列数组中的最小值date: 2020-08-20 16:21:41author: 外心人Dtoc: truemathjax: falsesummary: 爱编程categories: Markdowntags:\n\nLeetcode\n剑指offer\n\n\nGo\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"工厂模式","url":"https://bubbleboy11.github.io/2020/08/21/gong-han-mo-shi/","content":"工厂模式(Factory)\n解决对象的创建问题（对象创建的一个工厂）\n解耦对象的创建和使用\n包括工厂方法和抽象工厂\n工厂模式会返回一个实例\n\n1234567891011121314151617# 一个工厂方法的例子class DogToy:  # 狗玩具类    def speak(self):        print(\"wang wang\")class CatToy:  # 猫玩具类    def speak(self):        print(\"miao miao\")# 定义工厂方法，传入一个类型def toy_factory(toy_type):    if toy_type == 'dog':  # 类型是dog返回DogToy狗玩具实例        return DogToy()    elif toy_type == 'cat':  # 类型是cat返回CatToy狗玩具实例        # 一个工厂方法的例子class DogToy:  # 狗玩具类    def speak(self):        print(\"wang wang\")class CatToy:  # 猫玩具类    def speak(self):        print(\"miao miao\")# 定义工厂方法，传入一个类型def toy_factory(toy_type):    if toy_type == 'dog':  # 类型是dog返回DogToy狗玩具实例        return DogToy()    elif toy_type == 'cat':  # 类型是cat返回CatToy狗玩具实例        return CatToy()\n\n构建者模式(Builder)\n用来控制复杂对象的构造，分步骤每一步创建单独的组件\n创建和表示分离。\n比如你要买电脑，\n工厂模式直接给你需要的电脑\n构造模式允许你自定义电脑的配置，组装完成后给你\n\n\n\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 一个构造模式的例子class Computer:    def __init__(self, serial_number):        self.serial = serial_number        self.memory = None  # in gigabytes        self.hdd = None  # in gigabytes        self.gpu = None    def __str__(self):        info = ('Memory: {}GB'.format(self.memory),                'Hard Disk: {}GB'.format(self.hdd),                'Graphics Card: {}'.format(self.gpu))        return '\\n'.join(info)class ComputerBuilder:    def __init__(self):        self.computer = Computer('AG23385193')  # 初始化Computer对象    def configure_memory(self, amount):  # 配置内存        self.computer.memory = amount    def configure_hdd(self, amount):        self.computer.hdd = amount    def configure_gpu(self, gpu_model):  # 配置GPU        self.computer.gpu = gpu_modelclass HardwareEngineer:  # 硬件组装的工程师    def __init__(self):        self.builder = None    def construct_computer(self, memory, hdd, gpu):  # 组装电脑，给内存硬件等        self.builder = ComputerBuilder()        [            step for step in (self.builder.configure_memory(memory),                              self.builder.configure_hdd(hdd),                              self.builder.configure_gpu(gpu))        ]    @property    def computer(self):        return self.builder.computer  # 返回构造的电脑# 使用builder，可以创建多个builder类实现不同的组装方式engineer = HardwareEngineer()engineer.construct_computer(hdd=500, memory=8, gpu='GeForce GTX 650 Ti')print(engineer.computer)# 输出结果：# Memory: 8GB# Hard Disk: 500GB# 一个构造模式的例子class Computer:    def __init__(self, serial_number):        self.serial = serial_number        self.memory = None  # in gigabytes        self.hdd = None  # in gigabytes        self.gpu = None    def __str__(self):        info = ('Memory: {}GB'.format(self.memory),                'Hard Disk: {}GB'.format(self.hdd),                'Graphics Card: {}'.format(self.gpu))        return '\\n'.join(info)class ComputerBuilder:    def __init__(self):        self.computer = Computer('AG23385193')  # 初始化Computer对象    def configure_memory(self, amount):  # 配置内存        self.computer.memory = amount    def configure_hdd(self, amount):        self.computer.hdd = amount    def configure_gpu(self, gpu_model):  # 配置GPU        self.computer.gpu = gpu_modelclass HardwareEngineer:  # 硬件组装的工程师    def __init__(self):        self.builder = None    def construct_computer(self, memory, hdd, gpu):  # 组装电脑，给内存硬件等        self.builder = ComputerBuilder()        [            step for step in (self.builder.configure_memory(memory),                              self.builder.configure_hdd(hdd),                              self.builder.configure_gpu(gpu))        ]    @property    def computer(self):        return self.builder.computer  # 返回构造的电脑# 使用builder，可以创建多个builder类实现不同的组装方式engineer = HardwareEngineer()engineer.construct_computer(hdd=500, memory=8, gpu='GeForce GTX 650 Ti')print(engineer.computer)# 输出结果：# Memory: 8GB# Hard Disk: 500GB# Graphics Card: GeForce GTX 650 Ti\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"常用排序算法的时间空间复杂度","url":"https://bubbleboy11.github.io/2020/08/21/chang-yong-pai-xu-suan-fa-de-shi-jian-kong-jian-fu-za-du/","content":"\n\n\n排序算法\n最差时间分析\n平均时间复杂度\n稳定度\n空间复杂度\n\n\n\n冒泡排序\nO(n^2)\nO(n^2)\n稳定\nO(1)\n\n\n选择排序\nO(n^2)\nO(n^2)\n不稳定\nO(1)\n\n\n插入排序\nO(n^2)\nO(n^2)\n稳定\nO(1)\n\n\n二叉树排序\nO(n^2)\nO(n*log2n)\n不一顶\nO(n)\n\n\n快速排序\nO(n^2)\nO(n*log2n)\n不稳定\nO(log2n)~O(n)\n\n\n堆排序\nO(n*log2n)\nO(n*log2n)\n不稳定\nO(1)\n\n\n注释：n*log2n 是 n 乘以 log 以 2 为底 n 的对数，也可以简写成nlogn。默认情况下2可以去掉。\n  平均时间复杂度：冒泡、选择、插入都不是分支法平均时间复杂的都是O(n^2)，基于分支法的快速排序和堆排序都是O(n*log2n)。\n\n   空间复杂度：不需要额外空间的冒泡、选择、插入、堆排序空间复杂度都是O(1)，需要额外空间快速排序空间复杂度是O(log2n)-O(n)。\n\n排序算法的稳定性？相同大小的元素在排序之后依然保持相对位置不变，就是稳定性\nr[i] = r[j] 且 r[i] 在 r[j] 之前，排序之后 r[i] 依然在 r[j] 之前 , 就是一个稳定排序算法\n稳定性对于排序一个复杂结构，并且需要保持原有排序才有意义。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","数据结构与算法"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/bing-fa-wang-luo-ku/","content":"并发网络库 Tornado vs Gevent vs Asyncio\nTornado 并发网络库和同时也是一个web微框架\nGevent 绿色线程(greenlet)实现并发，猴子补丁修改内置 socket\nAsyncio Python3 内置的并发网络库，基于原生协程\n2.Tornado框架   Tornado 使用于微服务，实现 Restful 接口\n\n底层基于 Linux 多路复用\n可以通过协程或者回调实现异步编程\n不过生态不完善，相应的异步框架比如ORM不完善12345678910111213141516171819202122# tornado_demo.pyimport tornado.ioloopimport tornado.webfrom tornado.httpclient import AsyncHTTPClient class APIHandler(tornado.web.RequestHandler):    async def get(self):        url = 'http://httpbin.org/get'        http_client = AsyncHTTPClient()        resp = await http_client.fetch(url)   # 异步发送请求            print(resp.body)        return resp.body def make_app():    return tornado.web.Application([        (r\"/api\", APIHandler)    ]) if __name__ == \"__main__\":    app = make_app()    app.listen(# tornado_demo.pyimport tornado.ioloopimport tornado.webfrom tornado.httpclient import AsyncHTTPClient class APIHandler(tornado.web.RequestHandler):    async def get(self):        url = 'http://httpbin.org/get'        http_client = AsyncHTTPClient()        resp = await http_client.fetch(url)   # 异步发送请求            print(resp.body)        return resp.body def make_app():    return tornado.web.Application([        (r\"/api\", APIHandler)    ]) if __name__ == \"__main__\":    app = make_app()    app.listen(6666)    tornado.ioloop.IOLoop.current().start()\n运行代码后，在终端发送 1curl http://localhost:6666/api\n获得返回的网页内容如下：123# b'{\\n \"args\": {}, \\n \"headers\": {\\n \"Accept-Encoding\": \"gzip\", \\n \"Host\": \"htt# pbin.org\"\\n }, \\n \"origin\": \"223.72.75.28, 223.72.75.28\", \\n \"url\": \"https://httpbi# b'{\\n \"args\": {}, \\n \"headers\": {\\n \"Accept-Encoding\": \"gzip\", \\n \"Host\": \"htt# pbin.org\"\\n }, \\n \"origin\": \"223.72.75.28, 223.72.75.28\", \\n \"url\": \"https://httpbi# n.org/get\"\\n}\\n'\n\n\n\n2.Gevent  高性能的并发网络库\n基于轻量级绿色线程( greenlet )实现并发，底层是用C语言实现的需要注意 monkey patch， gevent 修改了内置的 socket 改为非阻塞\n配合 gunicorn 和 gevent 部署作为 wsgi server\n示例：用gevent实现并发爬虫\n123456789101112131415161718192021222324252627282930313233import gevent.monkeygevent.monkey.patch_all()  # 修改内置库变成非阻塞import geventimport requestsdef fetch(i):    url = 'http://httpbin.org/get'    resp = requests.get(url)    print(len(resp.text), i)  # 返回结果长度，以及序号def asynchronous():    threads = []    for i in range(1, 10):  # 添加10个线程        threads.append(gevent.spawn(fetch, i))    gevent.joinall(threads)print('Asynchronous:')asynchronous()# 输出结果：# Asynchronous:# 307 5# 307 1# 307 9# 307 2# 307 7# 307 4# 307 6# 307 3import gevent.monkeygevent.monkey.patch_all()  # 修改内置库变成非阻塞import geventimport requestsdef fetch(i):    url = 'http://httpbin.org/get'    resp = requests.get(url)    print(len(resp.text), i)  # 返回结果长度，以及序号def asynchronous():    threads = []    for i in range(1, 10):  # 添加10个线程        threads.append(gevent.spawn(fetch, i))    gevent.joinall(threads)print('Asynchronous:')asynchronous()# 输出结果：# Asynchronous:# 307 5# 307 1# 307 9# 307 2# 307 7# 307 4# 307 6# 307 3# 307 8\n可以看到输出的序号顺序是不一致的，说明使用gevent并发的发的请求，而不是顺序去执行，从而大大提升了请求的效率。\n\nAsyncio Python3 引入到内置库，基于协程实现的内置并发网络库，协程+事件循环事件循环框架可以进行异步编程协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序。从技术的角度来说，“协程就是你可以暂停执行的函数”\n\n协程在Python3.5里使用async/await语法来声明，用于编写asyncio应用程序协程通常表示两种不同的概念。1是用async def修饰的协程函数，2是调用协程函数后返回的对象，用来表示最终将会结束的计算或者是io操作\n生态不够完善，没有大规模生产环境检验目前应用不够广泛，基于 Aiohttp 可以实现一些小的服务\n12345678910111213141516import asyncioasync def main():    print('hello')    await asyncio.sleep(1)    print('world')# loop是事件循环loop = asyncio.get_event_loop()loop.run_until_complete(main())loop.close()# helloimport asyncioasync def main():    print('hello')    await asyncio.sleep(1)    print('world')# loop是事件循环loop = asyncio.get_event_loop()loop.run_until_complete(main())loop.close()# hello# world 隔1秒\n\n示例：基于asyncio实现的异步http客户端 aiohttp\n12345678910111213141516171819202122232425262728293031323334# 基于 aiohttp 并发请求import asynciofrom aiohttp import ClientSession async def fetch(url, session):    async with session.get(url) as response:        return await response.read()        async def run(r=10):    url = \"http://httpbin.org/get\"    tasks = []        async with ClientSession() as session:        for i in range(r):            task = asyncio.ensure_future(fetch(url, session))            tasks.append(task)        responses = await asyncio.gather(*tasks)        for resp_body in responses:            print(len(resp_body))            loop = asyncio.get_event_loop()  # 获取事件循环future = asyncio.ensure_future(run())loop.run_until_complete(future)  # 在事件循环里执行任务# 输出结果：# 254# 254# 254# 254# 254# 254# 254# 254# 254# 基于 aiohttp 并发请求import asynciofrom aiohttp import ClientSession async def fetch(url, session):    async with session.get(url) as response:        return await response.read()        async def run(r=10):    url = \"http://httpbin.org/get\"    tasks = []        async with ClientSession() as session:        for i in range(r):            task = asyncio.ensure_future(fetch(url, session))            tasks.append(task)        responses = await asyncio.gather(*tasks)        for resp_body in responses:            print(len(resp_body))            loop = asyncio.get_event_loop()  # 获取事件循环future = asyncio.ensure_future(run())loop.run_until_complete(future)  # 在事件循环里执行任务# 输出结果：# 254# 254# 254# 254# 254# 254# 254# 254# 254# 254\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/ying-yong-fu-wu-qi-de-you-hua-ji-zhu/","content":"使用缓存技术使用异步使用集群优化代码\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/yi-chang/","content":"异常是class即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。大多数的异常都不会被程序处理，都以错误信息的形式展现在这里\n捕获一个错误就是捕获到该class的一个实例每个异常都是某个类的实例发生了异常如果不捕获，则程序将终止执行\nPython内置的异常类 （有些语言使用错误码）\nBaseException 所有异常的父类\nExceptionException    常规错误的基类\nAttributeError    对象没有这个属性\n不过有时报错显示的位置是有问题的，\n并列跟系统相关异常： SystemExit 解释器请求退出、KeyboardInterrupt    用户中断执行(通常是输入^C)、GeneratorExit    生成器(generator)发生异常来通知退出、OSError    操作系统错误\n\n这种情况通常的原因都是前面某一行的括号或者引号有问题，而导致后面的代码错乱，试着往前看一看。\n使用异常的常见场景什么时候需要捕获处理异常呢？看Python 内置异常类型\n\n网络请求（超时、链接错误等）\n资源访问（权限问题、资源不存在）\n代码逻辑（越界访问、KeyError等）\n\n123456789101112131415161718192021# python异常处理几个关键字try:    # func  # 可能会抛出异常的代码，如果执行出错，那么 try 子句余下的部分将被忽略不会继续执行except (Exception1, Exception2) as e:      # 可以捕获多个异常并处理，如果异常的类型和 except 之后的名称相符    # 异常处理的代码    # 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它捕获，    # 那么这个异常会在 finally 子句执行后被抛出，那么它会一层一层的往上传递，程序将终止执行    # 如果不想在异常发生时结束你的程序，只需在try里捕获它，可以跨越多层调用    # 一个 try 语句可能包含多个except子句，分别来处理、捕获不同的特定的异常。    # 最多只有一个分支会被执行。    # 处理程序将只针对对应的 try 子句中的异常进行处理，    # 而不是其他的 try 的处理程序中的异常。else:    pass  # 异常没有发生的时候代码逻辑    # 使用 else 子句比把所有的语句都放在 try 子句里面要好，    # 可以避免一些意想不到，而 except 又无法捕获的异常。    # 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，    # 而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。finally:    pass  # python异常处理几个关键字try:    # func  # 可能会抛出异常的代码，如果执行出错，那么 try 子句余下的部分将被忽略不会继续执行except (Exception1, Exception2) as e:      # 可以捕获多个异常并处理，如果异常的类型和 except 之后的名称相符    # 异常处理的代码    # 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它捕获，    # 那么这个异常会在 finally 子句执行后被抛出，那么它会一层一层的往上传递，程序将终止执行    # 如果不想在异常发生时结束你的程序，只需在try里捕获它，可以跨越多层调用    # 一个 try 语句可能包含多个except子句，分别来处理、捕获不同的特定的异常。    # 最多只有一个分支会被执行。    # 处理程序将只针对对应的 try 子句中的异常进行处理，    # 而不是其他的 try 的处理程序中的异常。else:    pass  # 异常没有发生的时候代码逻辑    # 使用 else 子句比把所有的语句都放在 try 子句里面要好，    # 可以避免一些意想不到，而 except 又无法捕获的异常。    # 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，    # 而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。finally:    pass  # 无论异常有没有发生都会执行的代码，一般处理资源的关闭和释放 \n\n如何自定义自己的异常？ 为什么需要定义自己的异常？\n异常类继承自 Exception 类实现自定义异常，可以直接继承，或者间接继承，( 为什么不是BaseException,如果继承了像KeyboardInterrupt这个异常,那么捕获的时候,Ctrl+c就会被作为异常捕获，就结束不了了）\n给异常加上一些附加信息（比如代码业务相关信息等）\n创建一个新的异常类来拥有自己的异常。（raise MyException）大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。12345678910class MyException(Exception):    pass  try:    raise MyException('my exception')  # raise显示引发异常# except MyException as e:      # 继承自定义异常except Exception as e: # 捕获一个父类异常时候，所有的子类异常都在捕获之内。    print(e)class MyException(Exception):    pass  try:    raise MyException('my exception')  # raise显示引发异常# except MyException as e:      # 继承自定义异常except Exception as e: # 捕获一个父类异常时候，所有的子类异常都在捕获之内。    print(e)# 输出结果：my exception\n\n\n\n1234567891011121314151617181920212223def divide(x, y):    try:        result = x / y    except ZeroDivisionError:        print(\"division by zero!\")    else:        print(\"result is\", result)    finally:        print(\"executing finally clause\")divide(2, 1)# result is 2.0# executing finally clausedivide(2, 0)# division by zero!# executing finally clausedivide(\"2\", \"1\")# executing finally clause# Traceback(most recent call last):# File \"&lt;stdin&gt;\", line 18, in &lt;module&gt; divide(\"2\",\"1\")# File \"&lt;stdin&gt;\", line 3, in divide result = x / ydef divide(x, y):    try:        result = x / y    except ZeroDivisionError:        print(\"division by zero!\")    else:        print(\"result is\", result)    finally:        print(\"executing finally clause\")divide(2, 1)# result is 2.0# executing finally clausedivide(2, 0)# division by zero!# executing finally clausedivide(\"2\", \"1\")# executing finally clause# Traceback(most recent call last):# File \"&lt;stdin&gt;\", line 18, in &lt;module&gt; divide(\"2\",\"1\")# File \"&lt;stdin&gt;\", line 3, in divide result = x / y# TypeError: unsupported operand type(s) for /: 'str' and 'str'\n\n如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，用raise语句抛出一个指定的异常。raise语句如果不带参数，就会把当前错误原样抛出。raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。\n在except中raise一个Error，还可以把一种类型的错误转化成另一种类型\n123456789101112131415161718def div(num1, num2):    \"\"\" 当除数为0时 \"\"\"    return num1 / num2if __name__ == '__main__':    try:        # rest = test_div(5, 0)        rest = div(5, \"s\")        print(rest)    except (ZeroDivisionError, TypeError) as err:        print('反正就是报错了')        print(err)    except TypeError:        print('报错了，请输入数字')    # rest = test_div(5, 's')    def div(num1, num2):    \"\"\" 当除数为0时 \"\"\"    return num1 / num2if __name__ == '__main__':    try:        # rest = test_div(5, 0)        rest = div(5, \"s\")        print(rest)    except (ZeroDivisionError, TypeError) as err:        print('反正就是报错了')        print(err)    except TypeError:        print('报错了，请输入数字')    # rest = test_div(5, 's')    # print(rest)\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"接口测试","url":"https://bubbleboy11.github.io/2020/08/21/jie-kou-ce-shi/","content":"接口的由来：连接前端后端及移动端\n为什么要做接口测试? \n\n不同端的工作进度不同\n需要对最开始出来的接口进行接口测试\n很多系统关联都是基于接口来实现，接口测试可以将复杂的系统关联进行筒化。\n接口功能比较单一，能够比较好的进行测试覆盖，也相对容易实现自动化持续集成。\n接口相对于界面功能，会更底层一些，测试覆盖会更容易。\n\n接口测试可以①节约时间，缩短项目周期  ②提高工作效率 ③提高系统健壮性\n软件开发生命周期接口测试在软件开发生命周期的位置：接口测试在单元测试之后，UI测试之前；接口测试可以获得较高的投资回报。\n接口测试又称为 API 测试 Application Programming Interface\n接口测试是测试系统组件间接口的一种测试。重点关注数据传递。\n接口测试一般会用于多系统间交互开发，或者拥有多个子系统的应用系统开发的测试。\n为什么要设计测试用例\n1、理清思路，避免漏测\n2、提高测试效率\n3、跟进测试进度\n4、告诉领导做过\n5、跟进重复性工作\n用例设计\n1、功能\n2、逻辑业务\n3、异常\n4、安全\n用例设计-功能用例设计\n①功能是否正常\n②功能是否按照接口文档实现;代码接口参数名应该和接口文档统一\n用例设计-逻辑用例设计①是否依赖业务\n用例设计-异常测试用例设计①参数异常：\n.关键字参数java,python,mysql这些，可以用键改为关键字进行测试。.参数为空.参数 多一个或少一个.参数错误\n用例设计-异常测试用例设计①数据异常：关键字数据，数据为空，长度不一致，错误数据\n用例设计-安全测试用例设计①cookie②header，移动端需要特别测试header③唯一识别码\n手动测试测试方法：\n\n借助工具完成\n拼接参数执行请求\n\n自动化测试测试方法：\n\n编写自动化脚本实现\n一劳永逸，加入回归测试集合\n需要一定编码经验\n\n功能测试：测试覆盖：\n\n业务流程 \n边界值，特殊字符\n参数类型，必选项，可选项等\n\n性能测试：测试覆盖：\n\n并发数，同一时间发送请求的用户数量，采用逐步加压的方式来找到系统能够支持的最大\n吞吐量，tps\n出错率等\n\n安全性测试测试覆盖：\n\n敏感数据加密\n恶意攻击等\n\n测试步骤了解接口格式 –&gt; 编写测试用例 –&gt; 测试用例评审 –&gt; 开始测试 –&gt; 完成测试报告 –&gt; 结束 （在没有达到测试退出之前 ，比如测试报告里 级别高的bug较多，需要让开发修复后，再次进行测试，直到满足退出条件 后 结束）\n业务流程 - GET\n正向用例：返回所有对象和返回某一个对象\n负向用例：\n一个不存在的 id\nURL 输入不正确 \n\n\n\n业务流程 - POST:\n正向用例：输入正确参数新加一个对象（特殊字符，中文等）\n负向用例：\n参数 name 为空/重复\n参数 age 为 0/-1/100/101/字符串/null/空\n参数 salary 为整数/带小数/负数/null/\n\n\n\n业务流程 - PUT:\n正向用例：输入正确参数修改一个对象（特殊字符，中文等）\n负向用例：\n参数 id 为空/无效值\n参数 name 为空/重复\n参数 age 为 0/-1/100/101/字符串/null 空\n参数 salary 为整数/带小数/负数/null 空\n\n\n\n业务流程 - DELETE\n正向用例：删除所有对象和删除某一个对象\n负向用例：\n一个不存在的 id\nURL 输入不正确\n\n\n\nRest API实践一个测试实例需求描述\nGET: http://localhost:8080/mywebsite/user/\n\n\nHeader: Content-type = application/json\nBody: 空\nResponse: 返回所有 User 对象\nStatus code: 200\n\n\nGET: http://localhost:8080/mywebsite/user/{id}\n\n\nHeader: Content-type = application/json\nBody: 空\nResponse: 返回指定 id 的 User 对象\nStatus code: 200\n\n\nPOST: http://localhost:8080/mywebsite/user/\n\n\nHeader: Content-type = application/json\nBody: name (String 类型，不为空不可重复）, age (int 类型，在 0 和 100 之间）, salary (double 类型）\nResponse: 新加 User 对象\nStatus code: 201\n\n\nPUT: http://localhost:8080/mywebsite/user/{id}\n\n\nHeader: Content-type = application/json\nBody: name (String 类型，不为空不可重复）, age (int 类型，在 0 和 100 之间）, salary (double 类型）\nResponse: 修改 User 对象\nStatus code: 200\n\n\nDELETE: http://localhost:8080/mywebsite/user/{id}\n\n\nHeader: Content-type = application/json\nBody: 空\nResponse: 删除 id 的 User 对象\nStatus code: 204\n\n\nDELETE: http://localhost:8080/mywebsite/user/\n\n\nHeader: Content-type = application/json\nBody: 空\nResponse: 删除所有 User 对象\nStatus code: 204\n\n\n错误返回\n\n\nCode: 4 Message：找不到指定 id 对象\nCode: 5 Message：对象已经存在\nCode: 6 Message：参数不匹配\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/","content":"TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。\nTCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。\nTCP提供了一种可靠、面向连接、字节流、传输层的服务，\nTCP服务模型一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。\n当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。\n一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。\n序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。\nTCP头部源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。\n当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。\n头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。\n当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。\nTCP的三次握手建立一个连接和四次挥手来关闭一个连接第一状态转换，第二就是发包的内容。\nSYN：同步序列编号（Synchronize Sequence Numbers）。同步标志位，用于初如化一个连接的序列号。 是TCP/IP建立连接时使用的握手信号。SYN_SENT 同步已发送状态\nACK (Acknowledgement Number) 确认标志位，使得确认号有效，SYN_RECV 同步收到状态，\nESTABLISHED 已建立连接状态CLOSED 关闭状态LISTEH 收听状态RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。FIN —— 该报文段的发送方已经结束向对方发送数据。\nISN(Initial Sequence Number),三次握手的一个重要功能是客户端和服务端交换isn 以便让对方知道接下来接收数据的时候如何按序列号组装数据。\n如果ISN是固定的，攻击者很容易猜出后续的确认号。ISN = M + F(localhost, localport, remotehost, remoteport)M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。\nTCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户( client )。被动等待连接建立的应用进程叫做服务器( server )。最初两端的TCP进程都处于 CLOSED(关闭)状态，client 端主动打开链接，而 server 端被动打开链接。\n服务器端准备接受连接请求后进入到 LISTEN(收听状态)，等待客户端连接请求。客户端需要建立连接时向服务器端发送请求，请求内容包括同步位 SYN=1 和初始序号 seq =J 即ISN(c)，这时客户端进入SYN_SENT(同步已发送)状态。\n服务器接收到请求后作出响应，向客户端发送确认信息，确认信息包括同步位 SYN=1、确认位ACK=1ISN(s)、确认号 ack=J+1 和自己初始序号 seq=K，这时服务端进入 SYN_RECV(同步收到)状态。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。\n客户端收到服务器端发过来的确认信息后，先进行验证确认号 ack=J + 1，此时还需向服务器端发送确认信息，确认信息包括确认位 ACK=1 和 确认号ack=K+1，这时TCP连接已经建立，客户端进入 ESTABLISHED状态。服务器端接收到确认后，也进入到established状态。\n客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。\n第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。\n第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。\n经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。\n每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？\n而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。\n3次握手就跟早期打电话时的情况一样：1、听得到吗？2、听得到，你呢？3、我也听到了。然后才开始真正对话 4次挥手是：1、老师，下课了。2、好，我知道了，我说完这点。3、好了，说完了，下课吧。4、谢谢老师，老师再见\n\nTCP四次挥手，状态转换\n主动方可以是服务器端也可以是客户端。\nFIN(FINbit) 终止标志位   |   FIN_WAIT_1 终止等待1状态    |    FIN_WAIT_2 终止等待2状态\nACK(ACKbit) 确认标志位 |   CLOSE_WAIT 关闭等待状态  |    LAST_ACK 最后确认状态\nESTABLISHED 已建立连接状态    |    TIME_WAIT 时间等待状态    |    CLOSED 关闭状态\n数据传输结束后，通信的双方都可以释放连接。最初客户端和服务器端都处于extablished状态。例如：客户端主动发起连接释放。\n客户端向服务器端发送连接释放请求，主动关闭TCP连接，请求内容包括终止控制位 FIN=1 和 希望接收者看到的自己当前的序列号 seq=x，这时客户端进入 FIN_WAIT_1(终止等待1)状态，等待服务器端的确认。\n服务器端收到连接释放请求后即发出确认信息，确认信息包括 确认位 ACK=1 和 确认号ack(ACKnum) = x+1，表明收到了上一个包，上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作进入到CLOSE_WAIT(关闭等待)状态，此时客户端已没有数据发送了，但服务器端还可以向客服端发送数据，服务器端到客户端这个方向的连接并未关闭。客户端收到确认请求后，就进入到 FIN_WAIT_2 ( 终止等待2 )状态。\n当服务器端已经没有向客户端要发送的数据时候，会向客户端发送连接释放请求，请求内容包括 终止控制位 FIN=1 、序号seq=y 和 上次已经发送过的确认号 ack(ACKnum) = x+1，这时服务器进入 LAST_ACK(最后确认)状态，等待客户端的确认。\n客户端收到连接释放请求，必须给服务器端发送确认，确认信息包括 确认位 ACK=1、确认号ack(ACKnum) = y+1，这时客户端进入TIME_WAIT(时间等待)状态，这时TCP连接还没释放掉，必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，客户端才进入到 CLOSED(关闭)状态。服务器端收到确认后，就进入closed(关闭)状态。\nTCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。\n“三次握手，四次挥手”怎么完成？其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。\n3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。\nHTTP请求过程（http是一种无状态协议，即不建立持久的连接）一、一个完整的HTTP请求，通常有7个步骤：1、建立TCP连接；2、web浏览器向web服务器发送请求命令；3、浏览器发送请求头信息；4、服务器应答；5、服务器发送应答头信息；6、服务器向浏览器发送数据；7、服务器关闭TCP连接。\n二、一个HTTP请求由四部分组成：1、HTTP请求方法或动作，如：GET或POST；2、正在请求的URL；3、请求头，包含一些客户端环境信息、身份验证信息；4、请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。\n三、一个HTTP响应一般由三个部分组成：1、一个数字和文字组成的状态码，用来显示请求成功还是失败；2、响应头，包含许多有用的信息，如：服务器类型、日期时间、内容类型和长度；3、响应体，即响应正文。\n四、readyState属性(返回请求的当前状态)：0：请求未初始化，open还没有调用；1：服务器连接已建立，open已经调用；2：请求已接收，即，接收到头部信息了；3：请求处理中，即，接收到响应体了；4：请求已完成，且响应已就绪，即，响应完成了。\n五、HTTP状态码（返回请求结果）由3位数字构成：1XX:信息性状态码，接收的请求正在处理；2XX:成功状态码，请求正常处理完毕；3XX:重定向状态码，需要进行附加操作已完成请求；4XX:客户端错误状态码，服务器无法处理请求；5XX:服务器错误状态码，服务器处理请求出错。\n六、TCP三次握手、四次回收策略（TCP的标志为：SYN/ACK）1、三次握手（1）发送端——-数据包（SYN）————-&gt;接收端（2）接收端————–数据包（SYN/ACK)——&gt;发送端（3）发送端——-数据包（ACK）————-&gt;接收端\n2、四次挥手（1）主动关闭方——TIN（关闭数据传送）—————–&gt;被动关闭方；（2）被动关闭方————ACK（确认序号为收到序号+1）————–&gt;主动关闭方；（3）被动关闭方————FIN（关闭数据传送）———————-&gt;主动关闭方；（4）主动关闭方——ACK（确认序号为收到序号+1）———-&gt;被动关闭方。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"操作系统的内存管理机制--分页和分段 及 分页和分段的区别","url":"https://bubbleboy11.github.io/2020/08/21/cao-zuo-xi-tong-de-nei-cun-guan-li-ji-zhi-fen-ye-he-fen-duan-ji-fen-ye-he-fen-duan-de-qu-bie/","content":"操作系统的内存管理机制分页机制操作系统为了高效管理内存，减少内存碎片，所以采用分页机制逻辑地址和物理地址分离的内存分配管理方案\n\n逻辑地址划分为固定大小的页(Page)\n物理地址划分为同样大小的帧(Frame)\n通过页表对应逻辑地址和物理地址\n\n图解：左边是用户程序，对于用户程序关心的是逻辑地址，通过页表来获取物理地址。页表里面映射了逻辑地址和物理地址的对应关系，通过中间和右边图，可以看出逻辑地址对应的物理地址不一定是连续的。\n分段机制分段是为了满足代码的一些逻辑需求\n\n数据共享，数据保护，动态链接等\n通过段表实现逻辑地址和物理地址的映射关系\n每个段内部是连续内存分配，段和段之间是离散分配的\n\n图解：段表里面主要保存的是段号、段长和起始地址(基址)，通过这三个就可以确定每个段，它从那个地方开始并且它的长度是多少，段表可以把段号跟内存空间真实的物理地址对应起来。\n3.分页和分段的区别\n\n页是出于内存利用率的角度提出的离散分配机制\n段是出于用户角度，用于数据保护，数据隔离等用途的管理机制\n页的大小是固定的，操作系统决定；段大小不确定，用户程序决定\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["Linux","操作系统"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/shu-ju-ya-suo/","content":"1234567891011import zlibs = b'witch which has which witches wrist watch'print(len(s))# 41t = zlib.compress(s)print(len(t))# 37print(zlib.decompress(t))# b'witch which has which witches wrist watch'print(zlib.crc32(s))import zlibs = b'witch which has which witches wrist watch'print(len(s))# 41t = zlib.compress(s)print(len(t))# 37print(zlib.decompress(t))# b'witch which has which witches wrist watch'print(zlib.crc32(s))# 226805979\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"旅游网下单支付前端页面","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-xia-dan-zhi-fu-qian-duan-ye-mian/","content":"开发步骤\n前端页面开发\n后端接口开发\n接口联调\n代码优化\n\n提交订单页实现步骤\n第一步，配置路由规则，新建组件src\\router\\index.js12345678910import OrderSubmit from '../views/order/Submit.vue'const routes = [  // 提交订单  {    path: '/order/submit/:id',    name: import OrderSubmit from '../views/order/Submit.vue'const routes = [  // 提交订单  {    path: '/order/submit/:id',    name: 'OrderSubmit',    component: OrderSubmit  }]\n第二步，查找Vant中可以使用的组件\n第三步，实现组件模板部分\n\nsrc\\views\\order\\Submit.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117            <van-nav-bar title=\"填写订单\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"/>                      门票标题        23:00前可定明日                              明日可定                                条件退                                      ￥{{ price }}/张        <van-button plain hairline type=\"info\"          size=\"mini\"          @click=\"showPopup=true\">预订须知        <van-popup          v-model=\"showPopup\"          closeable          position=\"bottom\"          :style=\"{ height: '80%' }\"        />                                    <van-cell title=\"选择出行日期\"          :value=\"form.play_date\"          @click=\"showCalendar = true\" />                                                                  <van-field          v-model=\"form.to_user\"          type=\"text\"          label=\"收件人\"          placeholder=\"输入收件人\"          :rules=\"[{ required: true, message: '请输入收件人' }]\"        />        <van-field          v-model=\"form.to_phone\"          type=\"text\"          label=\"手机号码\"          placeholder=\"输入手机号码\"          :rules=\"[{ required: true, message: '请输入手机号码' }]\"        />                      export default {  data () {    return {      // 预订须知弹框显示      showPopup: false,      // 日期选择弹框      showCalendar: false,      price: 98,      form: {        play_date: '',        buy_count: 1,        to_user: '',        to_phone: ''      }    }  },  computed: {    /**     * 计算总价     */    totalPrice () {      return this.price * this.form.buy_count * 100    }  },  methods: {    onSubmit () {      console.log('提交表单')    },    formatDate (date) {      return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`    },    /**     * 选择日期     */    onConfirm (date) {      // 隐藏日历弹框      this.showCalendar = false      // 保存数据      this.form.play_date = this.formatDate(date)    },    goBack () {      this.$router.go(-1)    }  }}\n\n\n第四步，模拟数据，实现效果\n\n支付页面开发实现步骤\n第一步，配置路由规则，新建组件src\\router\\index.js\n123456789import OrderPay from '../views/order/Pay.vue'const routes = [  // 确认订单并支付  {    path: '/order/pay/:sn',    name: import OrderPay from '../views/order/Pay.vue'const routes = [  // 确认订单并支付  {    path: '/order/pay/:sn',    name: 'OrderPay',    component: OrderPay  }]\n\n第二步，查找Vant中可以使用的组件\n\n第三步，实现组件模板部分src\\views\\order\\Pay.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778            <van-nav-bar      title=\"订单支付\"      left-text=\"返回\"      right-text=\"取消订单\"      left-arrow      @click-left=\"goBack\"      @click-right=\"onCancelOrder\"    />        <van-cell title=\"订单号\" value=\"订单号的内容\"      :title-style=\"{'text-align': 'left'}\" />                      门票的信息         2020-9-13        短信接收                                            export default {  data () {    return {      // 总价格      totalPrice: 25000    }  },  methods: {    /**     * 确认支付     */    onSubmit () {      this.$dialog.confirm({        title: '温馨提示',        message: `确认支付${this.totalPrice / 100}吗？`      }).then(() => {        // on confirm      })    },    /**     * 后退     */    goBack () {      this.$dialog.confirm({        title: '温馨提示',        message: '您还没有支付，确认放弃支付吗？'      }).then(() => {        this.$router.go(-1)        // on confirm      })    },    /**     * 取消订单     */    onCancelOrder () {      this.$dialog.confirm({        title: '温馨提示',        message: '确认取消该订单？'      }).then(() => {        // TODO 调用接口on confirm        this.$router.go(-1)      })    }  }}\n第四步，模拟数据，实现效果\n\n\n我的订单列表页面开发实现步骤\n第一步，配置路由规则，新建组件src\\router\\index.js12345678910import OrderList from '../views/order/List.vue'const routes = [  // 我的订单列表  {    path: '/order/list/:status',    name: import OrderList from '../views/order/List.vue'const routes = [  // 我的订单列表  {    path: '/order/list/:status',    name: 'OrderList',    component: OrderList  }]\n\n\n\nsrc\\utils\\constants.js\n1234567891011121314// 订单状态export const ORDER_STATUS_ALL = 0// 待支付export const ORDER_STATUS_PAY = 11// 已完成export const ORDER_STATUS_DONE = 12// 已取消export const ORDER_STATUS_CANCEL = 13export const ORDER_STATUS = {  [ORDER_STATUS_ALL]: '全部',  [ORDER_STATUS_PAY]: '待支付',  [ORDER_STATUS_DONE]: '已完成',  [ORDER_STATUS_CANCEL]: // 订单状态export const ORDER_STATUS_ALL = 0// 待支付export const ORDER_STATUS_PAY = 11// 已完成export const ORDER_STATUS_DONE = 12// 已取消export const ORDER_STATUS_CANCEL = 13export const ORDER_STATUS = {  [ORDER_STATUS_ALL]: '全部',  [ORDER_STATUS_PAY]: '待支付',  [ORDER_STATUS_DONE]: '已完成',  [ORDER_STATUS_CANCEL]: '已取消'}\n\n\n第二步，查找Vant中可以使用的组件\n\n第三步，实现组件模板部分src\\views\\order\\List.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657            <van-nav-bar title=\"我的订单\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"/>              <van-tab        v-for=\"(value, key, index) in constants.ORDER_STATUS\"        :title=\"value\"        :name=\"key\"        :key=\"index\">                                    订单号：12312312          已取消                                                                      门票的标题            相关的描述                                    总共2件商品 合计 ￥198          删除订单          订单详情                    import * as constants from '@/utils/constants'export default {  data () {    return {      status: 0,      constants    }  },  methods: {    goBack () {      this.$router.go(-1)    }  }}\n\n第四步，模拟数据，实现效果\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"个人中心页面开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-ge-ren-zhong-xin-ye-mian-kai-fa/","content":"个人中心页面开发实现步骤\n第一步，查找Vant中可以使用的组件\n第二步，实现组件模板部分src\\views\\Mine.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091                                                      欢迎您，张三        退出登录                                                    全部订单                                                待支付                                                已完成                                                已取消                            import TripFooter from '@/components/common/Footer'export default {  components: {    TripFooter  }}.page-mine {  .van-nav-bar--fixed {    background-color: transparent;  }  .van-nav-bar__title {    color: #fff;  }  .user-header {    background: url(/static/mine/bg.jpg) no-repeat center;    background-size: 100% auto;    color: #fff;    height: 200px;    display: flex;    flex-direction: column;    justify-content: center;    .avatar img {      width: 80px;      height: 80px;    }  }  .user-links {    padding: 15px 0;    font-size: 12px;    text-align: center;    background-color: #fff;    .van-icon {      display: block;      font-size: 24px;    }  }  .btn-link {    color: #fff;  }}\n\n\n\nsrc\\router\\index.js\n123456789101112import Mine from '../views/Mine.vue'Vue.use(VueRouter)const routes = [  // 个人中心  {    path: '/mine',    name: import Mine from '../views/Mine.vue'Vue.use(VueRouter)const routes = [  // 个人中心  {    path: '/mine',    name: 'Mine',    component: Mine  },]\n\nsrc\\components\\common\\Footer.vue\n12345678              我的      \n\n第三步，模型层准备数据\n第四步，模拟数据，实现效果\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["vue"],"tags":["vue"]},{"title":"旅游网删除订单接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-shan-chu-ding-dan-jie-kou-kai-fa/","content":"删除订单接口开发开发步骤\n\n第一步，设计接口返回内容及字段order\\views.py\n123456789101112131415161718192021222324252627282930@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    def delete(self, request, *args, **kwargs):        \"\"\" DELETE: 订单删除 \"\"\"        # 1. 获取订单对象        order_obj = self.get_object()        # 2. 验证数据（已支付、已取消才可删除订单）        if order_obj.status == OrderStatus.CANCELED or order_obj.status == OrderStatus.PAID:            # 3. 是否已经删除过了            if order_obj.is_valid:                order_obj.is_valid = False                order_obj.save()                return http.HttpResponse('', status=201)            else:                # 此处不用写，因为get_object已经触发了404                pass        return http.HttpResponse('', status=@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    def delete(self, request, *args, **kwargs):        \"\"\" DELETE: 订单删除 \"\"\"        # 1. 获取订单对象        order_obj = self.get_object()        # 2. 验证数据（已支付、已取消才可删除订单）        if order_obj.status == OrderStatus.CANCELED or order_obj.status == OrderStatus.PAID:            # 3. 是否已经删除过了            if order_obj.is_valid:                order_obj.is_valid = False                order_obj.save()                return http.HttpResponse('', status=201)            else:                # 此处不用写，因为get_object已经触发了404                pass        return http.HttpResponse('', status=200)\n\n第二步，编写接口代码\n\n第三步，模拟HTTP请求，测试验证接口\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网取消订单接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-qu-xiao-ding-dan-jie-kou-kai-fa/","content":"取消订单接口开发开发步骤\n\n第一步，设计接口返回内容及字段order\\views.py\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from django.db.models import F@method_decorator(login_required, name='dispatch')class TicketOrderSubmitView(FormView):    \"\"\" 3.1 门票订单提交接口 \"\"\"    form_class = SubmitTicketOrderForm    http_method_names = ['post']    def form_invalid(self, form):        \"\"\" 表单未通过验证 \"\"\"        err = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err)    def form_valid(self, form):        obj = form.save(user=self.request.user)        return http.JsonResponse({'sn': obj.sn}, status=201)@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        \"\"\" GET: 订单详情 \"\"\"        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    @transaction.atomic    def put(self, request, *args, **kwargs):        \"\"\" PUT： 取消订单 \"\"\"        # 1. 获取订单对象        order_obj = self.get_object()        # 2. 数据验证，状态判断        if order_obj.status == OrderStatus.SUBMIT:            # 3. 改变状态            order_obj.status = OrderStatus.CANCELED            order_obj.save()            items = order_obj.order_items.filter(status=OrderStatus.SUBMIT)            # 4. 加回已经扣减的库存            for item in items:                obj = item.content_object                obj.remain_stock = F('remain_stock') + item.count                obj.save()            items.update(status=OrderStatus.CANCELED)            return http.HttpResponse('', status=201)        return http.HttpResponse('', status=from django.db.models import F@method_decorator(login_required, name='dispatch')class TicketOrderSubmitView(FormView):    \"\"\" 3.1 门票订单提交接口 \"\"\"    form_class = SubmitTicketOrderForm    http_method_names = ['post']    def form_invalid(self, form):        \"\"\" 表单未通过验证 \"\"\"        err = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err)    def form_valid(self, form):        obj = form.save(user=self.request.user)        return http.JsonResponse({'sn': obj.sn}, status=201)@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        \"\"\" GET: 订单详情 \"\"\"        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    @transaction.atomic    def put(self, request, *args, **kwargs):        \"\"\" PUT： 取消订单 \"\"\"        # 1. 获取订单对象        order_obj = self.get_object()        # 2. 数据验证，状态判断        if order_obj.status == OrderStatus.SUBMIT:            # 3. 改变状态            order_obj.status = OrderStatus.CANCELED            order_obj.save()            items = order_obj.order_items.filter(status=OrderStatus.SUBMIT)            # 4. 加回已经扣减的库存            for item in items:                obj = item.content_object                obj.remain_stock = F('remain_stock') + item.count                obj.save()            items.update(status=OrderStatus.CANCELED)            return http.HttpResponse('', status=201)        return http.HttpResponse('', status=200)\n\n第二步，编写接口代码\n\n第三步，模拟HTTP请求，测试验证接口\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网我的订单列表接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-wo-de-ding-dan-lie-biao-jie-kou-kai-fa/","content":"我的订单列表接口开发\n\n第一步，设计接口返回内容及字段order\\urls.py12345678from django.urls import pathfrom order import viewsurlpatterns = [    # 3.3 我的订单列表    path('order/list/', views.OrderListView.as_view(), name=from django.urls import pathfrom order import viewsurlpatterns = [    # 3.3 我的订单列表    path('order/list/', views.OrderListView.as_view(), name=\"order_list\"),]\n\n\n\norder\\serializers.py\n1234567891011121314151617181920212223242526272829303132333435363738from utils.serializers import BaseSerializer, BaseListPageSerializerclass OrderItemSerializer(BaseSerializer):    \"\"\" 订单明细 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'flash_name': obj.flash_name,            'flash_img': obj.flash_img.url,            'flash_price': obj.flash_price,            'flash_origin_price': obj.flash_origin_price,            'flash_discount': obj.flash_discount,            'count': obj.count,            'amount': obj.amount,            'remark': obj.remark,            'object_id': obj.object_id,            'app_label': obj.content_type.app_label,            'model': obj.content_type.model,        }class OrderListSerializer(BaseListPageSerializer):    \"\"\" 订单列表 \"\"\"    def get_object(self, obj):        item_first_obj = obj.order_items.first()        item_first = OrderItemSerializer(item_first_obj).to_dict()        return {            'sn': obj.sn,            'buy_amount': obj.buy_amount,            'buy_count': obj.buy_count,            'types': obj.types,            'status': obj.status,            'remark': obj.remark,            'created_at': obj.created_at,            from utils.serializers import BaseSerializer, BaseListPageSerializerclass OrderItemSerializer(BaseSerializer):    \"\"\" 订单明细 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'flash_name': obj.flash_name,            'flash_img': obj.flash_img.url,            'flash_price': obj.flash_price,            'flash_origin_price': obj.flash_origin_price,            'flash_discount': obj.flash_discount,            'count': obj.count,            'amount': obj.amount,            'remark': obj.remark,            'object_id': obj.object_id,            'app_label': obj.content_type.app_label,            'model': obj.content_type.model,        }class OrderListSerializer(BaseListPageSerializer):    \"\"\" 订单列表 \"\"\"    def get_object(self, obj):        item_first_obj = obj.order_items.first()        item_first = OrderItemSerializer(item_first_obj).to_dict()        return {            'sn': obj.sn,            'buy_amount': obj.buy_amount,            'buy_count': obj.buy_count,            'types': obj.types,            'status': obj.status,            'remark': obj.remark,            'created_at': obj.created_at,            'item_first': item_first        }\n\norder\\views.py\n123456789101112131415161718192021222324252627282930from django.db.models import Qfrom django.views.generic import ListViewfrom django.views.generic.detail import BaseDetailView@method_decorator(login_required, name='dispatch')class OrderListView(ListView):    \"\"\" 3.3 我的订单列表 \"\"\"    paginate_by = 10  # 每页放10条数据    def get_queryset(self):        user = self.request.user        query = Q(is_valid=True, user=user)        # 按状态查询        status = self.request.GET.get('status', None)        if status and status != '0':            query = query &amp; Q(status=status)        return Order.objects.filter(query)    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回，返回json \"\"\"        page_obj = context['page_obj']        if page_obj:            data = serializers.OrderListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()    def get_paginate_by(self, queryset):        \"\"\" 根据接口参数limit来控制分页的大小 \"\"\"        page_size = self.request.GET.get('limit', None)        return page_size from django.db.models import Qfrom django.views.generic import ListViewfrom django.views.generic.detail import BaseDetailView@method_decorator(login_required, name='dispatch')class OrderListView(ListView):    \"\"\" 3.3 我的订单列表 \"\"\"    paginate_by = 10  # 每页放10条数据    def get_queryset(self):        user = self.request.user        query = Q(is_valid=True, user=user)        # 按状态查询        status = self.request.GET.get('status', None)        if status and status != '0':            query = query &amp; Q(status=status)        return Order.objects.filter(query)    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回，返回json \"\"\"        page_obj = context['page_obj']        if page_obj:            data = serializers.OrderListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()    def get_paginate_by(self, queryset):        \"\"\" 根据接口参数limit来控制分页的大小 \"\"\"        page_size = self.request.GET.get('limit', None)        return page_size or self.paginate_by\n\n\n第二步，编写接口代码\n第三步，模拟HTTP请求，测试验证接口\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网用户注册接口联调","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-yong-hu-zhu-ce-jie-kou-lian-diao/","content":"用户注册接口联调实现步骤\n第一步，阅读接口文档\n第二步，配置接口地址\n\nsrc\\utils\\ajax.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import axios from 'axios'import qs from 'qs'export const ajax = axios.create({  headers: {    source: 'h5',    icode: 'acbd',    'Content-Type': 'application/x-www-form-urlencoded'  },  /***   * 对请求的参数进行格式化处理   */  transformRequest: function (data, headers) {    return qs.stringify(data)  },  // 携带cookie  withCredentials: true})ajax.interceptors.request.use(function (config) {  // 在发送请求之前做些什么  console.log('请求拦截到了')  window.app.$toast.loading({    message: '加载中...',    forbidClick: true,    loadingType: 'spinner'  })  return config}, function (error) {  // 对请求错误做些什么  window.app.$toast.clear()  return Promise.reject(error)})ajax.interceptors.response.use(function (response) {  // 对响应数据做点什么  console.log('响应拦截到了')  window.app.$toast.clear()  return response}, function (error) {  // 对响应错误做点什么  if (error.response) {    if (error.response.status === 401) {      window.app.$notify({        message: '未登录，即将跳转到登录页面',        type: 'danger'      })      window.app.$router.replace({name: 'AccountLogin'})      // window.alert('未登录，即将跳转到登录页面')    } else if (error.response.status === 500) {      window.app.$notify({        message: '服务器正忙，请稍后重试',        type: 'danger'      })      // window.alert('服务器正忙，请稍后重试')    } else if (error.response.status === 400) {      // data      const data = error.response.data      let msg = data.error_msg ? data.error_msg : '参数错误'      if (data.error_list) {        const keys = Object.keys(data.error_list)        const errObj = data.error_list[keys[0]][0]        msg = `${errObj.message}, ${errObj.code}`        window.app.$notify(msg)      }    }  }  window.app.$toast.clear()  return import axios from 'axios'import qs from 'qs'export const ajax = axios.create({  headers: {    source: 'h5',    icode: 'acbd',    'Content-Type': 'application/x-www-form-urlencoded'  },  /***   * 对请求的参数进行格式化处理   */  transformRequest: function (data, headers) {    return qs.stringify(data)  },  // 携带cookie  withCredentials: true})ajax.interceptors.request.use(function (config) {  // 在发送请求之前做些什么  console.log('请求拦截到了')  window.app.$toast.loading({    message: '加载中...',    forbidClick: true,    loadingType: 'spinner'  })  return config}, function (error) {  // 对请求错误做些什么  window.app.$toast.clear()  return Promise.reject(error)})ajax.interceptors.response.use(function (response) {  // 对响应数据做点什么  console.log('响应拦截到了')  window.app.$toast.clear()  return response}, function (error) {  // 对响应错误做点什么  if (error.response) {    if (error.response.status === 401) {      window.app.$notify({        message: '未登录，即将跳转到登录页面',        type: 'danger'      })      window.app.$router.replace({name: 'AccountLogin'})      // window.alert('未登录，即将跳转到登录页面')    } else if (error.response.status === 500) {      window.app.$notify({        message: '服务器正忙，请稍后重试',        type: 'danger'      })      // window.alert('服务器正忙，请稍后重试')    } else if (error.response.status === 400) {      // data      const data = error.response.data      let msg = data.error_msg ? data.error_msg : '参数错误'      if (data.error_list) {        const keys = Object.keys(data.error_list)        const errObj = data.error_list[keys[0]][0]        msg = `${errObj.message}, ${errObj.code}`        window.app.$notify(msg)      }    }  }  window.app.$toast.clear()  return Promise.reject(error)})\n\nsrc\\utils\\apis.js\n123456789101112/** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  // 用户注册  registerUrl: apiHost + /** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  // 用户注册  registerUrl: apiHost + '/accounts/user/api/register/'}\n\nsrc\\store\\mutation-types.js\n1234// 修改用户信息export const UPDATE_USER_INFO = 'updateUserInfo'// 删除用户信息export const DELETE_USER_INFO = // 修改用户信息export const UPDATE_USER_INFO = 'updateUserInfo'// 删除用户信息export const DELETE_USER_INFO = 'deleteUserInfo'\n\n\n第三步，使用axios获取数据src\\views\\accounts\\Register.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import { ajax } from '@/utils/ajax'import { AccountsApis } from '@/utils/apis'import * as types from '@/store/mutation-types'import Copyright from '@/components/common/Copyright'import SendSmsCode from '@/components/common/SendSmsCode'export default {  components: {    Copyright,    SendSmsCode  },  data () {    return {      // 用户名的验证规则      ruleName: [{        required: true,        message: '请填写用户名'      }, {        pattern: /1\\d{10}/,        message: '请填写正确的手机号'      }],      // 重复密码验证      rulePassword: [        {          required: true,          message: '请重复一次密码'        }, {          validator: () => this.form.password === this.form.passwordRepeat,          message: '两次密码输入不一致'        }],      form: {        username: '',        nickname: '',        sms_code: '',        password: '',        passwordRepeat: ''      }    }  },  methods: {    /**     * 手机号变化时，重置验证码组件状态     */    onPhoneChange () {      this.$refs.refSms.reset()    },    onSubmit () {      // 提交表单      // 1. 调用接口      ajax.post(AccountsApis.registerUrl, {        username: this.form.username,        password: this.form.passwordRepeat,        sms_code: this.form.sms_code,        nickname: this.form.nickname      }).then(({ data }) => {        // 2. 成功返回结果, 用户信息写入vuex        this.$store.commit(types.UPDATE_USER_INFO, data)        // 3. 提示用户        this.$notify({          message: '注册成功',          type: 'success'        })        // 4. 跳转到个人中心页面        this.$router.replace({ name: 'Mine' })      })    },    goBack () {      this.$router.go(-1)    }  }}\n\n第四步，将数据设置到模型\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":[]},{"title":"旅游网用户登录注册页面开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-yong-hu-deng-lu-zhu-ce-ye-mian-kai-fa/","content":"用户登录页面开发实现步骤\n\n第一步，查找Vant中可以使用的组件\n第二步，实现组件模板部分src\\views\\accounts\\Login.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475            <van-nav-bar title=\"用户登录\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"/>              <van-field        v-model=\"username\"        label=\"用户名\"        placeholder=\"用户名\"        type=\"tel\"        maxlength=\"11\"        clearable        :rules=\"ruleName\"      />      <van-field        v-model=\"password\"        type=\"password\"        name=\"密码\"        label=\"密码\"        placeholder=\"密码\"        :rules=\"[{ required: true, message: '请填写密码' }]\"      />                        提交                                    登录表示同意 用户使用协议及隐私条款              没有账号？ 点击注册>>              import Copyright from '@/components/common/Copyright'export default {  components: {    Copyright  },  data () {    return {      // 用户名的验证规则      ruleName: [{        required: true,        message: '请填写用户名'      }, {        pattern: /1\\d{10}/,        message: '请填写正确的手机号'      }],      username: '',      password: ''    }  },  methods: {    onSubmit () {      // 提交表单    },    goBack () {      this.$router.go(-1)    }  }}\n\n\n\nsrc\\components\\common\\Copyright.vue&amp;copy转义为@\n1234567891011121314151617      copyright 旅游网 &copy; 2021  .copyright {  position: fixed;  bottom: 0;  padding: 10px;  color: #999;  width: 100%;  text-align: center;  font-size: 12px;}\n\nsrc\\router\\index.js\n12345678910import AccountLogin from '../views/accounts/Login.vue'const routes = [  // 用户登录  {    path: '/account/login',    name: import AccountLogin from '../views/accounts/Login.vue'const routes = [  // 用户登录  {    path: '/account/login',    name: 'AccountLogin',    component: AccountLogin  }]\n\n\n第三步，模型层准备数据\n第四步，模拟数据，实现效果\n\n用户注册页面开发实现步骤\n\n第一步，查找Vant中可以使用的组件\n第二步，实现组件模板部分src\\components\\common\\SendSmsCode.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960    <van-button    size=\"small\"    type=\"primary\"    @click.prevent=\"sendSmsCode()\"    :disabled=\"isSmsSend\"    >{{ sendBtnText }}export default {  props: ['phoneNum'],  data () {    return {      // 是否已经发送了验证码，不能再点击发送验证码      isSmsSend: false,      sendBtnText: '点击发送验证码',      timer: null,      counter: 60    }  },  methods: {    reset () {      this.isSmsSend = false      this.sendBtnText = '点击发送验证码'      if (this.timer) {        clearInterval(this.timer)        this.counter = 60        this.timer = null      }    },    /**     * 倒计时     */    countDown () {      this.timer = setInterval(() => {        this.sendBtnText = `(${this.counter}秒)后重新发送`        this.counter--        if (this.counter < 0) {          this.reset()        }      }, 1000)    },    /**     * 发送验证码     */    sendSmsCode () {      // 判断手机号是否已经输入      if (!this.phoneNum) {        this.$notify('请输入手机号')        return false // 不在执行后面的逻辑      }      // TODO 调用接口，发送短信验证码      this.isSmsSend = true      // 开启倒计时, 60s之后才能再次点击      this.countDown()    }  }}\n\n\n\nsrc\\views\\accounts\\Register.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124            <van-nav-bar title=\"用户注册\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"/>              <van-field        v-model=\"form.username\"        label=\"手机号码\"        placeholder=\"手机号码\"        type=\"tel\"        maxlength=\"11\"        clearable        :rules=\"ruleName\"        @input=\"onPhoneChange\"      />      <van-field        v-model=\"form.sms_code\"        center        clearable        label=\"短信验证码\"        placeholder=\"短信验证码\"        :rules=\"[{ required: true, message: '请输入短信验证码' }]\"      >                                      <van-field        v-model=\"form.nickname\"        label=\"用户昵称\"        placeholder=\"用户昵称\"        maxlength=\"32\"        clearable        :rules=\"[{ required: true, message: '请输入用户昵称' }]\"      />      <van-field        v-model=\"form.password\"        type=\"password\"        label=\"密码\"        placeholder=\"密码\"        :rules=\"[{ required: true, message: '请填写密码' }]\"      />      <van-field        v-model=\"form.passwordRepeat\"        type=\"password\"        label=\"确认密码\"        placeholder=\"确认密码\"        :rules=\"rulePassword\"      />                        提交                                    注册表示同意 用户使用协议及隐私条款              已有账号？ 点击登录>>              import Copyright from '@/components/common/Copyright'import SendSmsCode from '@/components/common/SendSmsCode'export default {  components: {    Copyright,    SendSmsCode  },  data () {    return {      // 用户名的验证规则      ruleName: [{        required: true,        message: '请填写用户名'      }, {        pattern: /1\\d{10}/,        message: '请填写正确的手机号'      }],      // 重复密码验证      rulePassword: [        {          required: true,          message: '请重复一次密码'        }, {          validator: () => this.form.password === this.form.passwordRepeat,          message: '两次密码输入不一致'        }],      form: {        username: '',        nickname: '',        sms_code: '',        password: '',        passwordRepeat: ''      }    }  },  methods: {    /**     * 手机号变化时，重置验证码组件状态     */    onPhoneChange () {      this.$refs.refSms.reset()    },    onSubmit () {      // 提交表单    },    goBack () {      this.$router.go(-1)    }  }}\n\nsrc\\router\\index.js\n123456789101112import AccountRegister from '../views/accounts/Register.vue'Vue.use(VueRouter)const routes = [  // 用户注册  {    path: '/account/register',    name: import AccountRegister from '../views/accounts/Register.vue'Vue.use(VueRouter)const routes = [  // 用户注册  {    path: '/account/register',    name: 'AccountRegister',    component: AccountRegister  }]\n\n\n第三步，实现验证码组件\n第四步，实现登录注册页面间的跳转\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":[]},{"title":"用户登录接口联调","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-yong-hu-deng-lu-jie-kou-lian-diao/","content":"用户登录接口联调实现步骤\n第一步，在登录组件调用登录接口\n第二步，设置用户信息到 Vuex\n第三步，在个人中心显示用户信息，昵称和头像\n第四步，刷新个人中心，清空vuex里面的数据，重新调用个人信息接口设置到vuex\n\nsrc\\utils\\apis.js\n12345678910111213141516/** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  // 用户登录  loginUrl: apiHost + '/accounts/user/api/login/',  // 用户退出登录  logoutUrl: apiHost + '/accounts/user/api/logout/',  // 用户信息  userInfoUrl: apiHost + /** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  // 用户登录  loginUrl: apiHost + '/accounts/user/api/login/',  // 用户退出登录  logoutUrl: apiHost + '/accounts/user/api/logout/',  // 用户信息  userInfoUrl: apiHost + '/accounts/user/api/info/',}\n\nsrc\\utils\\ajax.js\n123456789101112import qs from 'qs'export const ajax = axios.create({  /***   * 对请求的参数进行格式化处理   */  transformRequest: function (data, headers) {    return qs.stringify(data)  },  // 默认携带上次的cookie  withCredentials: import qs from 'qs'export const ajax = axios.create({  /***   * 对请求的参数进行格式化处理   */  transformRequest: function (data, headers) {    return qs.stringify(data)  },  // 默认携带上次的cookie  withCredentials: true})\n\nsrc\\store\\mutation-types.js\n1234// 修改用户信息export const UPDATE_USER_INFO = 'updateUserInfo'// 删除用户信息export const DELETE_USER_INFO = // 修改用户信息export const UPDATE_USER_INFO = 'updateUserInfo'// 删除用户信息export const DELETE_USER_INFO = 'deleteUserInfo'\n\nsrc\\store\\index.js\n12345678910111213141516171819202122232425262728293031323334353637383940import Vue from 'vue'import Vuex from 'vuex'import * as types from './mutation-types'Vue.use(Vuex)export default new Vuex.Store({  state: {    user: {    },    profile: {    }  },  mutations: {    /**     * 设置用户信息     */    [types.UPDATE_USER_INFO] (state, { user, profile }) {      state.user = {        ...state.user,        ...user      }      state.profile = {        ...state.profile,        ...profile      }    },    /**     * 删除用户信息import Vue from 'vue'import Vuex from 'vuex'import * as types from './mutation-types'Vue.use(Vuex)export default new Vuex.Store({  state: {    user: {    },    profile: {    }  },  mutations: {    /**     * 设置用户信息     */    [types.UPDATE_USER_INFO] (state, { user, profile }) {      state.user = {        ...state.user,        ...user      }      state.profile = {        ...state.profile,        ...profile      }    },    /**     * 删除用户信息     */    [types.DELETE_USER_INFO] (state) {      state.user = {}      state.profile = {}    }  },  actions: {  },  modules: {  }})\n\nsrc\\views\\accounts\\Login.vue\n12345678910111213141516171819202122232425import { AccountsApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'export default {  methods: {    onSubmit () {      // 提交表单      // 1. 调用接口      ajax.post(AccountsApis.loginUrl, {        username: this.username,        password: this.password      }).then(({ data }) => {        // 2. 拿到用户信息，存储到vuex        this.$store.commit(types.UPDATE_USER_INFO, data)        this.$toast('登录成功')        this.$router.replace({name: 'Mine'})      }).catch(({ response: { data } }) => {        // 3. 如果出现了异常，需要给用户提示异常信息        console.log(data)        this.$toast(`${data.error_code},${data.error_msg}`)      })    }  }}\n\nsrc\\views\\Mine.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354                欢迎您，{{ user.nickname }}        退出登录            import { mapState } from 'vuex'import { AccountsApis } from '@/utils/apis'import * as types from '@/store/mutation-types'import { ajax } from '@/utils/ajax'import TripFooter from '@/components/common/Footer'export default {  components: {    TripFooter  },  methods: {    /**     * 查询用户信息     */    getUserInfo () {      ajax.get(AccountsApis.userInfoUrl).then(({ data }) => {        console.log('Mine-getUserInfo', data)        this.$store.commit(types.UPDATE_USER_INFO, data)      })    },    /**     * 退出登录     */    logout () {      // 1. 调用接口，退出登录      ajax.get(AccountsApis.logoutUrl).then(() => {        // 2. 提示用户        this.$notify({          message: '欢迎下次再来',          type: 'success'        })        // 3. 删除用户登录的信息        this.$store.commit(types.DELETE_USER_INFO))        // 4. 跳转到首页去        this.$router.push({name: 'Home'})      })    }  },  computed: mapState(['user']),  mounted () {    this.getUserInfo()  }}\n\n\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":[]},{"title":"旅游网订单模块ORM模型设计","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-ding-dan-mo-kuai-orm-mo-xing-she-ji/","content":"订单模块ORM模型设计1python manage.py startapp\n\n\norder\\models.py\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from django.contrib.contenttypes.fields import GenericForeignKeyfrom django.contrib.contenttypes.models import ContentTypefrom django.db import modelsfrom accounts.models import Userfrom order.choices import OrderStatus, OrderTypesfrom utils.models import CommonModelclass Order(CommonModel):    \"\"\" 订单 \"\"\"    sn = models.CharField('订单编号', max_length=32)    user = models.ForeignKey(User, related_name='orders', on_delete=models.PROTECT)    buy_count = models.IntegerField('购买数量', default=1)    buy_amount = models.FloatField('总价')    to_user = models.CharField('收货人', max_length=32)    to_area = models.CharField('省市区', max_length=32, default='')    to_address = models.CharField('详细地址', max_length=256, default='')    to_phone = models.CharField('手机号码', max_length=32)    remark = models.CharField('备注', max_length=255, null=True, blank=True)    # 快递信息    express_type = models.CharField('快递', max_length=32, null=True, blank=True)    express_no = models.CharField('单号', max_length=32, null=True, blank=True)    status = models.SmallIntegerField('订单状态',                                      choices=OrderStatus.choices,                                      default=OrderStatus.SUBMIT)    types = models.SmallIntegerField('订单类型',                                     choices=OrderTypes.choices,                                     default=OrderTypes.SIGHT_TICKET)    class Meta:        db_table = 'order'class OrderItem(CommonModel):    \"\"\" 订单明细 \"\"\"    user = models.ForeignKey(User, related_name='order_items',                             on_delete=models.CASCADE)    order = models.ForeignKey(Order, verbose_name='订单',                              related_name='order_items',                              null=True,                              on_delete=models.CASCADE)    # 商品快照    flash_name = models.CharField('商品名称', max_length=128)    flash_img = models.ImageField('商品的主图')    flash_price = models.FloatField('兑换价格')    flash_origin_price = models.FloatField('原价')    flash_discount = models.FloatField('折扣')    count = models.PositiveIntegerField('购买数量')    amount = models.FloatField('总额')    status = models.SmallIntegerField('状态',                                      choices=OrderStatus.choices,                                      default=OrderStatus.SUBMIT)    remark = models.CharField('备注', max_length=255, null=True, blank=True)    # 复合关联    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)    object_id = models.PositiveIntegerField()    content_object = GenericForeignKey('content_type', 'object_id')    class Meta:        db_table = 'order_item'class Payment(CommonModel):    \"\"\" 支付凭证 \"\"\"    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payments')    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='payments')    amount = models.FloatField('金额', help_text='支付实际的金额')    sn = models.CharField('流水号', max_length=32)    third_sn = models.CharField('第三方订单号', max_length=128, null=True, blank=True)    status = models.SmallIntegerField('支付状态', default=1)    meta = models.CharField('其他数据', max_length=128, null=True, blank=True)    remark = models.CharField('备注信息', max_length=128, null=True, blank=True)    class Meta:        db_table = from django.contrib.contenttypes.fields import GenericForeignKeyfrom django.contrib.contenttypes.models import ContentTypefrom django.db import modelsfrom accounts.models import Userfrom order.choices import OrderStatus, OrderTypesfrom utils.models import CommonModelclass Order(CommonModel):    \"\"\" 订单 \"\"\"    sn = models.CharField('订单编号', max_length=32)    user = models.ForeignKey(User, related_name='orders', on_delete=models.PROTECT)    buy_count = models.IntegerField('购买数量', default=1)    buy_amount = models.FloatField('总价')    to_user = models.CharField('收货人', max_length=32)    to_area = models.CharField('省市区', max_length=32, default='')    to_address = models.CharField('详细地址', max_length=256, default='')    to_phone = models.CharField('手机号码', max_length=32)    remark = models.CharField('备注', max_length=255, null=True, blank=True)    # 快递信息    express_type = models.CharField('快递', max_length=32, null=True, blank=True)    express_no = models.CharField('单号', max_length=32, null=True, blank=True)    status = models.SmallIntegerField('订单状态',                                      choices=OrderStatus.choices,                                      default=OrderStatus.SUBMIT)    types = models.SmallIntegerField('订单类型',                                     choices=OrderTypes.choices,                                     default=OrderTypes.SIGHT_TICKET)    class Meta:        db_table = 'order'class OrderItem(CommonModel):    \"\"\" 订单明细 \"\"\"    user = models.ForeignKey(User, related_name='order_items',                             on_delete=models.CASCADE)    order = models.ForeignKey(Order, verbose_name='订单',                              related_name='order_items',                              null=True,                              on_delete=models.CASCADE)    # 商品快照    flash_name = models.CharField('商品名称', max_length=128)    flash_img = models.ImageField('商品的主图')    flash_price = models.FloatField('兑换价格')    flash_origin_price = models.FloatField('原价')    flash_discount = models.FloatField('折扣')    count = models.PositiveIntegerField('购买数量')    amount = models.FloatField('总额')    status = models.SmallIntegerField('状态',                                      choices=OrderStatus.choices,                                      default=OrderStatus.SUBMIT)    remark = models.CharField('备注', max_length=255, null=True, blank=True)    # 复合关联    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)    object_id = models.PositiveIntegerField()    content_object = GenericForeignKey('content_type', 'object_id')    class Meta:        db_table = 'order_item'class Payment(CommonModel):    \"\"\" 支付凭证 \"\"\"    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payments')    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='payments')    amount = models.FloatField('金额', help_text='支付实际的金额')    sn = models.CharField('流水号', max_length=32)    third_sn = models.CharField('第三方订单号', max_length=128, null=True, blank=True)    status = models.SmallIntegerField('支付状态', default=1)    meta = models.CharField('其他数据', max_length=128, null=True, blank=True)    remark = models.CharField('备注信息', max_length=128, null=True, blank=True)    class Meta:        db_table = 'order_payment'\n\ntrip\\settings.py\n1234INSTALLED_APPS = [    # 订单模块    INSTALLED_APPS = [    # 订单模块    'order.apps.OrderConfig']\norder\\choices.py\n1234567891011121314from django.db import modelsclass OrderStatus(models.IntegerChoices):    \"\"\" 订单状态 \"\"\"    SUBMIT = 11, '待支付'    PAID = 12, '已支付'    CANCELED = 13, '已取消'class OrderTypes(models.IntegerChoices):    \"\"\" 订单类型 \"\"\"    SIGHT_TICKET = 10, '门票'    HOTEL = 11, from django.db import modelsclass OrderStatus(models.IntegerChoices):    \"\"\" 订单状态 \"\"\"    SUBMIT = 11, '待支付'    PAID = 12, '已支付'    CANCELED = 13, '已取消'class OrderTypes(models.IntegerChoices):    \"\"\" 订单类型 \"\"\"    SIGHT_TICKET = 10, '门票'    HOTEL = 11, '酒店'\n\n\n123python manage.py checkpython manage.py makemigrationspython manage.py migrate\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网订单详情接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-ding-dan-xiang-qing-jie-kou-kai-fa/","content":"订单详情接口开发开发步骤\n\n第一步，设计接口返回内容及字段order\\serializers.py\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from utils.serializers import BaseSerializerclass OrderItemSerializer(BaseSerializer):    \"\"\" 订单明细 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'flash_name': obj.flash_name,            'flash_img': obj.flash_img.url,            'flash_price': obj.flash_price,            'flash_origin_price': obj.flash_origin_price,            'flash_discount': obj.flash_discount,            'count': obj.count,            'amount': obj.amount,            'remark': obj.remark,            'object_id': obj.object_id,            'app_label': obj.content_type.app_label,            'model': obj.content_type.model,        }class OrderDetailSerializer(BaseSerializer):    \"\"\" 订单详细信息 \"\"\"    def to_dict(self):        obj = self.obj        items = []        for item in obj.order_items.all():            items.append(OrderItemSerializer(item).to_dict())        return {            'sn': obj.sn,            'buy_amount': obj.buy_amount,            'buy_count': obj.buy_count,            'types': obj.types,            'status': obj.status,            'created_at': obj.created_at,            'remark': obj.remark,            'to_user': obj.to_user,            'to_area': obj.to_area,            'to_address': obj.to_address,            'to_phone': obj.to_phone,            'express_type': obj.express_type,            'express_no': obj.express_no,            from utils.serializers import BaseSerializerclass OrderItemSerializer(BaseSerializer):    \"\"\" 订单明细 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'flash_name': obj.flash_name,            'flash_img': obj.flash_img.url,            'flash_price': obj.flash_price,            'flash_origin_price': obj.flash_origin_price,            'flash_discount': obj.flash_discount,            'count': obj.count,            'amount': obj.amount,            'remark': obj.remark,            'object_id': obj.object_id,            'app_label': obj.content_type.app_label,            'model': obj.content_type.model,        }class OrderDetailSerializer(BaseSerializer):    \"\"\" 订单详细信息 \"\"\"    def to_dict(self):        obj = self.obj        items = []        for item in obj.order_items.all():            items.append(OrderItemSerializer(item).to_dict())        return {            'sn': obj.sn,            'buy_amount': obj.buy_amount,            'buy_count': obj.buy_count,            'types': obj.types,            'status': obj.status,            'created_at': obj.created_at,            'remark': obj.remark,            'to_user': obj.to_user,            'to_area': obj.to_area,            'to_address': obj.to_address,            'to_phone': obj.to_phone,            'express_type': obj.express_type,            'express_no': obj.express_no,            'items': items        }\n\n第二步，编写接口代码order\\urls.py\n12345678from django.urls import pathfrom order import viewsurlpatterns = [    # 3.2 订单详情(支付、取消订单、删除订单)    path('order/detail/&lt;int:sn&gt;/', views.OrderDetail.as_view(), name=from django.urls import pathfrom order import viewsurlpatterns = [    # 3.2 订单详情(支付、取消订单、删除订单)    path('order/detail/&lt;int:sn&gt;/', views.OrderDetail.as_view(), name=\"order_detail\"),]\n\n\n\norder\\views.py\n123456789101112131415161718from django.views.generic.detail import BaseDetailViewfrom order.models import Order@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        from django.views.generic.detail import BaseDetailViewfrom order.models import Order@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)\n\n\n第三步，模拟HTTP请求，测试验证接口\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网门票下单接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-men-piao-xia-dan-jie-kou-kai-fa/","content":"门票下单接口开发开发步骤\n\n第一步，设计接口返回内容及字段order\\urls.py12345678from django.urls import pathfrom order import viewsurlpatterns = [    # 3.1 订单提交接口    path('ticket/submit/', views.TicketOrderSubmitView.as_view(), name=from django.urls import pathfrom order import viewsurlpatterns = [    # 3.1 订单提交接口    path('ticket/submit/', views.TicketOrderSubmitView.as_view(), name=\"ticket_submit\"),]\n\n\n\ntrip\\urls.py\n1234urlpatterns = [    # 订单模块    path('order/', include(urlpatterns = [    # 订单模块    path('order/', include('order.urls')),]\n\nutils\\views.py\n123456789101112131415from functools import wrapsfrom utils.response import UnauthorizedJsonResponsedef login_required(view_func):    \"\"\" 登录校验：如果用户没有登录，直接返回401 \"\"\"    @wraps(view_func)    def _wrapped_view(request, *args, **kwargs):        user = request.user        if not user.is_authenticated:            return UnauthorizedJsonResponse()        return view_func(request, *args, **kwargs)    from functools import wrapsfrom utils.response import UnauthorizedJsonResponsedef login_required(view_func):    \"\"\" 登录校验：如果用户没有登录，直接返回401 \"\"\"    @wraps(view_func)    def _wrapped_view(request, *args, **kwargs):        user = request.user        if not user.is_authenticated:            return UnauthorizedJsonResponse()        return view_func(request, *args, **kwargs)    return  _wrapped_view\n\nutils\\tools.py\n123456789101112import randomfrom django.utils.timezone import nowdef gen_trans_id(date=None):    \"\"\" 生成交易流水号 \"\"\"    if not date:        date = now()    str_date = date.strftime('%Y%m%d%H%M%S%f')    str_random = random.randint(1000, 9999)    return import randomfrom django.utils.timezone import nowdef gen_trans_id(date=None):    \"\"\" 生成交易流水号 \"\"\"    if not date:        date = now()    str_date = date.strftime('%Y%m%d%H%M%S%f')    str_random = random.randint(1000, 9999)    return '{}{}'.format(str_date, str_random)\n\n\n第二步，编写接口代码order\\forms.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from django import formsfrom django.contrib.contenttypes.models import ContentTypefrom django.db import transactionfrom django.db.models import Ffrom order.models import Order, OrderItemfrom sight.models import Ticketfrom utils import toolsclass SubmitTicketOrderForm(forms.ModelForm):    \"\"\" 门票订单提交表单 \"\"\"    ticket_id = forms.IntegerField(label='门票ID', required=True)    play_date = forms.DateField(label='出行的时间', required=True)    class Meta:        model = Order        fields = ('to_user', 'to_phone', 'buy_count',)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.ticket = None    def clean_ticket_id(self):        ticket_id = self.cleaned_data['ticket_id']        ticket = Ticket.objects.select_related('sight').filter(is_valid=True, pk=ticket_id).first()        if not ticket:            raise forms.ValidationError('门票信息不存在')        else:            if ticket.remain_stock &lt;= 0:                raise forms.ValidationError('当日门票已经售完')        self.ticket = ticket        return ticket_id    @transaction.atomic    def save(self, user, commit=False):        obj = super().save(commit=commit)        obj.user = user        # 生成订单号        obj.sn = tools.gen_trans_id()        # 计算价格        buy_count = self.cleaned_data['buy_count']        buy_amount = self.ticket.sell_price * buy_count        obj.buy_amount = buy_amount        obj.save()        # 扣减库存        self.ticket.remain_stock = F('remain_stock') - buy_count        self.ticket.save()        # 关联订单明细，保存快照        ctype = ContentType.objects.get_for_model(Ticket)        OrderItem.objects.create(            user=user,            order=obj,            flash_name=self.ticket.name,            flash_img=self.ticket.sight.main_img,            flash_price=self.ticket.sell_price,            flash_origin_price=self.ticket.price,            flash_discount=self.ticket.discount,            count=buy_count,            amount=buy_amount,            content_type=ctype,            object_id=self.ticket.id,            remark='出行时间:{}'.format(self.cleaned_data['play_date'])        )        from django import formsfrom django.contrib.contenttypes.models import ContentTypefrom django.db import transactionfrom django.db.models import Ffrom order.models import Order, OrderItemfrom sight.models import Ticketfrom utils import toolsclass SubmitTicketOrderForm(forms.ModelForm):    \"\"\" 门票订单提交表单 \"\"\"    ticket_id = forms.IntegerField(label='门票ID', required=True)    play_date = forms.DateField(label='出行的时间', required=True)    class Meta:        model = Order        fields = ('to_user', 'to_phone', 'buy_count',)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.ticket = None    def clean_ticket_id(self):        ticket_id = self.cleaned_data['ticket_id']        ticket = Ticket.objects.select_related('sight').filter(is_valid=True, pk=ticket_id).first()        if not ticket:            raise forms.ValidationError('门票信息不存在')        else:            if ticket.remain_stock &lt;= 0:                raise forms.ValidationError('当日门票已经售完')        self.ticket = ticket        return ticket_id    @transaction.atomic    def save(self, user, commit=False):        obj = super().save(commit=commit)        obj.user = user        # 生成订单号        obj.sn = tools.gen_trans_id()        # 计算价格        buy_count = self.cleaned_data['buy_count']        buy_amount = self.ticket.sell_price * buy_count        obj.buy_amount = buy_amount        obj.save()        # 扣减库存        self.ticket.remain_stock = F('remain_stock') - buy_count        self.ticket.save()        # 关联订单明细，保存快照        ctype = ContentType.objects.get_for_model(Ticket)        OrderItem.objects.create(            user=user,            order=obj,            flash_name=self.ticket.name,            flash_img=self.ticket.sight.main_img,            flash_price=self.ticket.sell_price,            flash_origin_price=self.ticket.price,            flash_discount=self.ticket.discount,            count=buy_count,            amount=buy_amount,            content_type=ctype,            object_id=self.ticket.id,            remark='出行时间:{}'.format(self.cleaned_data['play_date'])        )        return obj\n\n\n\norder\\views.py\n1234567891011121314151617181920212223242526272829303132333435363738import jsonfrom django import httpfrom django.shortcuts import renderfrom django.utils.decorators import method_decoratorfrom django.views.generic import FormViewfrom order.forms import SubmitTicketOrderFormfrom utils.response import BadRequestJsonResponsefrom utils.views import login_requireddef ticket_submit(request):    \"\"\"\"\"\"    # 0. 验证用户是否已经登录    # 1. 获取post数据    # 2. 数据的验证（手机号、门票ID、库存）    # 3. 关联用户、生成订单号、计算购买总价、生成订单(ORDER)    # 4. 返回内容：订单ID    pass@method_decorator(login_required, name='dispatch')class TicketOrderSubmitView(FormView):    \"\"\" 3.1 门票订单提交接口 \"\"\"    form_class = SubmitTicketOrderForm    http_method_names = ['post']    def form_invalid(self, form):        \"\"\" 表单未通过验证 \"\"\"        err = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err)    def form_valid(self, form):        obj = form.save(user=self.request.user)        return http.JsonResponse({            'sn': obj.sn        }, status=import jsonfrom django import httpfrom django.shortcuts import renderfrom django.utils.decorators import method_decoratorfrom django.views.generic import FormViewfrom order.forms import SubmitTicketOrderFormfrom utils.response import BadRequestJsonResponsefrom utils.views import login_requireddef ticket_submit(request):    \"\"\"\"\"\"    # 0. 验证用户是否已经登录    # 1. 获取post数据    # 2. 数据的验证（手机号、门票ID、库存）    # 3. 关联用户、生成订单号、计算购买总价、生成订单(ORDER)    # 4. 返回内容：订单ID    pass@method_decorator(login_required, name='dispatch')class TicketOrderSubmitView(FormView):    \"\"\" 3.1 门票订单提交接口 \"\"\"    form_class = SubmitTicketOrderForm    http_method_names = ['post']    def form_invalid(self, form):        \"\"\" 表单未通过验证 \"\"\"        err = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err)    def form_valid(self, form):        obj = form.save(user=self.request.user)        return http.JsonResponse({            'sn': obj.sn        }, status=201)\n\n\n第三步，模拟HTTP请求，测试验证接口\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网门票下单接口联调","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-men-piao-xia-dan-jie-kou-lian-diao/","content":"门票下单接口联调实现步骤\n\n第一步，完成页面间的跳转，点击预订按钮跳转到填写订单页面，收件人和手机号码读取vuex当前登录的用户信息，提交按钮调用门票下单接口，如果用户没有登录点击提交订单跳转到登录页面src\\views\\sight\\SightDetail.vue\n1234567891011121314151617                                                      预定                                  \n\n第二步，配置接口地址及请求参数src\\utils\\apis.js\n12345678910const OrderApis = {  // 订单列表  // 订单详情、订单支付、订单删除、订单取消  // 提交订单  ticketSubmitUrl: apiHost + '/order/ticket/submit/'}const OrderApis = {  // 订单列表  // 订单详情、订单支付、订单删除、订单取消  // 提交订单  ticketSubmitUrl: apiHost + '/order/ticket/submit/'}export {  OrderApis}\n\n\n\n\n\n第三步，处理数据返回src\\views\\order\\Submit.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import { OrderApis } from '@/utils/apis'import { ajax } from '@/utils/ajax'import { mapState } from 'vuex'export default {  data () {    return {      // 门票ID      id: '',      // 预订须知弹框显示      showPopup: false,      // 日期选择弹框      showCalendar: false,      price: 98,      form: {        play_date: '',        buy_count: 1,        to_user: '',        to_phone: ''      }    }  },  computed: {    /**     * 从vuex读取手机号码     */    ...mapState({      phoneNum: state => state.user.username,      nickname: state => state.user.nickname    })  },  methods: {    onSubmit () {      console.log('提交表单')      // ajax接口的调用      ajax.post(OrderApis.ticketSubmitUrl, {        ticket_id: this.id,        ...this.form      }).then(({ data }) => {        // 提示用户        this.$notify({          type: 'success',          message: '提交成功，请支付'        })        // 跳转到待支付的页面，防止点击后退的时候再去重复提交一个相同的订单        this.$router.replace({ name: 'OrderPay', params: { sn: data.sn } })      })    }  },  created () {    // 门票ID    this.id = this.$route.params.id    this.form.to_user = this.nickname || ''    this.form.to_phone = this.phoneNum || ''  }}\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网门票支付接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-men-piao-zhi-fu-jie-kou-kai-fa/","content":"门票支付接口开发开发步骤\n\n第一步，设计接口返回内容及字段通过url传递的参数sn查询到订单的对象order\\views.py\n123456789101112131415161718192021222324252627282930313233343536373839from django.db import transaction@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    @transaction.atomic    def post(self, request, *args, **kwargs):        \"\"\" POST: 订单支付 \"\"\"        # 1. 选择支付方式：支付宝、微信        # 2. 数据验证        order_obj = self.get_object()        if order_obj.status == OrderStatus.SUBMIT:            # 3. 调用真实的支付（暂时省略）            # 4. 改变订单状态            order_obj.status = OrderStatus.PAID            order_obj.save()            order_obj.order_items.update(status=OrderStatus.PAID)            return http.HttpResponse('', status=201)        return http.HttpResponse('', status=200)    def delete(self, request, *args, **kwargs):        \"\"\" DELETE: 订单删除 \"\"\"        return http.JsonResponse({'result': 'delete'})    def put(self, request, *args, **kwargs):        \"\"\" PUT： 取消订单 \"\"\"        return http.JsonResponse({'result': from django.db import transaction@method_decorator(login_required, name='dispatch')class OrderDetail(BaseDetailView):    slug_field = 'sn'    slug_url_kwarg = 'sn'    def get_queryset(self):        user = self.request.user        return Order.objects.filter(user=user, is_valid=True)    def get(self, request, *args, **kwargs):        \"\"\" GET: 订单详情 \"\"\"        order_obj = self.get_object()        data = serializers.OrderDetailSerializer(order_obj).to_dict()        return http.JsonResponse(data)    @transaction.atomic    def post(self, request, *args, **kwargs):        \"\"\" POST: 订单支付 \"\"\"        # 1. 选择支付方式：支付宝、微信        # 2. 数据验证        order_obj = self.get_object()        if order_obj.status == OrderStatus.SUBMIT:            # 3. 调用真实的支付（暂时省略）            # 4. 改变订单状态            order_obj.status = OrderStatus.PAID            order_obj.save()            order_obj.order_items.update(status=OrderStatus.PAID)            return http.HttpResponse('', status=201)        return http.HttpResponse('', status=200)    def delete(self, request, *args, **kwargs):        \"\"\" DELETE: 订单删除 \"\"\"        return http.JsonResponse({'result': 'delete'})    def put(self, request, *args, **kwargs):        \"\"\" PUT： 取消订单 \"\"\"        return http.JsonResponse({'result': 'put'})\n\n第二步，编写接口代码\n\n第三步，模拟HTTP请求，测试验证接口\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"旅游网门票详细信息接口开发","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-men-piao-xiang-xi-xin-xi-jie-kou-kai-fa/","content":"门票详细信息接口开发实现步骤\n\n第一步，设计接口返回内容及字段sight\\urls.py1234urlpatterns = [    # 2.6 门票详情    path('ticket/detail/&lt;int:pk&gt;/', views.TicketDetailView.as_view(), name=urlpatterns = [    # 2.6 门票详情    path('ticket/detail/&lt;int:pk&gt;/', views.TicketDetailView.as_view(), name=\"ticket_detail\"),]\n\n\n\nsight\\serializers.py\n1234567891011121314151617181920class TicketDetailSerializer(BaseSerializer):    \"\"\" 门票详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'sell_price': obj.sell_price,            'discount': obj.discount,            'expire_date': obj.expire_date,            'return_policy': obj.return_policy,            'has_invoice': obj.has_invoice,            'entry_way': obj.get_entry_way_display(),            'tips': obj.tips,            class TicketDetailSerializer(BaseSerializer):    \"\"\" 门票详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'sell_price': obj.sell_price,            'discount': obj.discount,            'expire_date': obj.expire_date,            'return_policy': obj.return_policy,            'has_invoice': obj.has_invoice,            'entry_way': obj.get_entry_way_display(),            'tips': obj.tips,            'remark': obj.remark        }\n\n\nsight\\views.py\n123456789101112class TicketDetailView(DetailView):    \"\"\" 2.6 门票详情 \"\"\"    def get_queryset(self):        return Ticket.objects.filter(is_valid=True)    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            data = serializers.TicketDetailSerializer(page_obj).to_dict()            return http.JsonResponse(data)        class TicketDetailView(DetailView):    \"\"\" 2.6 门票详情 \"\"\"    def get_queryset(self):        return Ticket.objects.filter(is_valid=True)    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            data = serializers.TicketDetailSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()\n\n\n\n第二步，编写接口代码\n第三步，模拟HTTP请求，测试验证接口\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/shi-jian-fu-za-du/","content":"复杂度用来衡量一个算法的质量，一般两个指标执行时间和执行所需内存.撇开输入规模的影响，用相对执行时间=执行时间/输入规模来表示时间，为了表示更简便，O（1）代表的并不是输入规模和执行时间的比率是1，而是假定输入规模为n，然后算法执行时间是多少，符号代数吧，n代表输入规模，O(1)表示和输入规模无关，O(n)表示这个线性比的关系，输入规模为N，执行时间 &lt; cn，c 为任意常数。空间复杂度也类似，这个题就是那个字符集的大小(字符集中不同字符的个数）可能比字符串的长度更大，所以是O(n+字符集的大小）。\n算法的执行次数 用 输入大小n 的函数 表示，即 T(n) 。算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。\n时间复杂度是为了 估算算法需要的运行时间 的最大量级既然是为了估算，那就不需要准确，不是代码执行的实际时间所以我们用同一个量级的典型函数来表示就行了。并不需要纠结谁大一点，谁小一点的问题。\n“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。\n时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)\n时间复杂度的几条基本计算规则1.基本操作，即只有常数项，认为其时间复杂度为O(1) 当 T(n) = c，c 为一个常数的时候，2.顺序结构，时间复杂度按加法进行计算3.循环结构，时间复杂度按乘法进行计算4.分支结构，时间复杂度取最大值5.判断一个算法的效率时，往往只需要关注操作数量的最高次项，忽略与最高阶系数。其它次要项和常数项可以忽略在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度\n此时算法的时间复杂度就是 O(f(n))从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。\n只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n1.对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。\n12345void aFunc(int n) {    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        printf(\"Hello, World!\\n\");      void aFunc(int n) {    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)    }}\n此时时间复杂度为 O(n × 1)，即 O(n)。\n2.对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。\n1234567void aFunc(int n) {    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        for(int j = 0; j &lt; n; j++) {       // 循环次数为 n            printf(\"Hello, World!\\n\");      void aFunc(int n) {    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        for(int j = 0; j &lt; n; j++) {       // 循环次数为 n            printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)        }    }}\nk层关于n的循环 n^k此时时间复杂度为 O(n × n × 1)，即 O(n^2)。n × (1 + n)=n^2+2~n^2\n12345for a in range(0, 1001):    for b in range(0, 1001):        for c in range(0, 1001):            if a**2 + b**2 == c**2 and a+b+c == 1000:                print(for a in range(0, 1001):    for b in range(0, 1001):        for c in range(0, 1001):            if a**2 + b**2 == c**2 and a+b+c == 1000:                print(\"a, b, c: %d, %d, %d\" % (a, b, c))\n时间复杂度： O(nnn) = O(n^3)\n12345for a in range(0, 1001):    for b in range(0, 1001-a):        c = 1000 - a - b        if a**2 + b**2 == c**2:            print(for a in range(0, 1001):    for b in range(0, 1001-a):        c = 1000 - a - b        if a**2 + b**2 == c**2:            print(\"a, b, c: %d, %d, %d\" % (a, b, c))\nT(n) = O(nn(1+1)) = O(n*n) = O(n2)\n3.对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。\n123456789101112void aFunc(int n) {    // 第一部分时间复杂度为 O(n^2)    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        for(int j = 0; j &lt; n; j++) {         // 循环次数为 n            printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)        }    }    // 第二部分时间复杂度为 O(n)    for(int j = 0; j &lt; n; j++) {         // 循环次数为 n        printf(\"Hello, World!\\n\");      void aFunc(int n) {    // 第一部分时间复杂度为 O(n^2)    for(int i = 0; i &lt; n; i++) {         // 循环次数为 n        for(int j = 0; j &lt; n; j++) {         // 循环次数为 n            printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)        }    }    // 第二部分时间复杂度为 O(n)    for(int j = 0; j &lt; n; j++) {         // 循环次数为 n        printf(\"Hello, World!\\n\");      // 循环体时间复杂度为 O(1)    }}\n此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。\n4.对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。\n123456789101112131415void aFunc(int n) {    if (n &gt;= 0) {        // 第一条路径时间复杂度为 O(n^2)        for(int i = 0; i &lt; n; i++) {            for(int j = 0; j &lt; n; j++) {                printf(\"输入数据大于等于零\\n\");            }        }    } else {        // 第二条路径时间复杂度为 O(n)        for(int j = 0; j &lt; n; j++) {            printf(void aFunc(int n) {    if (n &gt;= 0) {        // 第一条路径时间复杂度为 O(n^2)        for(int i = 0; i &lt; n; i++) {            for(int j = 0; j &lt; n; j++) {                printf(\"输入数据大于等于零\\n\");            }        }    } else {        // 第二条路径时间复杂度为 O(n)        for(int j = 0; j &lt; n; j++) {            printf(\"输入数据小于零\\n\");        }    }}\n此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)\n1234567void aFunc(int n) {    for (int i = 0; i &lt; n; i++) {         // 循环次数为 n        for (int j = i; j &lt; n; j++) {         // 循环次数为分别为 n,n-1,n-2..             printf(\"Hello World\\n\");      void aFunc(int n) {    for (int i = 0; i &lt; n; i++) {         // 循环次数为 n        for (int j = i; j &lt; n; j++) {         // 循环次数为分别为 n,n-1,n-2..             printf(\"Hello World\\n\");      // 循环体时间复杂度为 O(1)        }    }}\n当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。此时时间复杂度为 O(n^2)。\n123456void aFunc(int n) {    for (int i = 2; i &lt; n; i++) {         // 循环次数为 n        i *= 2;      // 循环体2次执行次数时间复杂度为 O(1)        printf(void aFunc(int n) {    for (int i = 2; i &lt; n; i++) {         // 循环次数为 n        i *= 2;      // 循环体2次执行次数时间复杂度为 O(1)        printf(\"%i\\n\", i);    }}\ni=2 i =4 i=8 i=16假设循环次数为 t，则循环条件满足 2^t &lt; n。每次循环乘以2，当大于n时，循环结束，则 2^t = n 停止，t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。在这里并不关心底数（这里是 2）是多少，因为即使是不同的底数，通过换底公式转换也只是常数倍数倍的差别。\n循环减半\n123while n &gt; 1:    print(n)    n = n // while n &gt; 1:    print(n)    n = n // 2\n当n=64 -32 16 8 4 2 执行次数6次2^6=64 6 = log(2)(64)\n12345678long aFunc(int n) {// 第一条路径时间复杂度为 O(n^2)    if (n &lt;= 1) {        return 1;    } else {        return aFunc(n - 1) + aFunc(n - long aFunc(int n) {// 第一条路径时间复杂度为 O(n^2)    if (n &lt;= 1) {        return 1;    } else {        return aFunc(n - 1) + aFunc(n - 2);    }}\n显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。\n第二条路径时间复杂度为 O(n^2)显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。可见这个方法所需的运行时间是以指数的速度增长\n空间复杂度:用来评估算法内存占用大小的式子空间复杂度的表示方式与时间复杂度完全一样算法使用了几个变量:O(1)算法使用了长度为n的一维列表:O(n)算法使用了m行n列的二维列表:O(mn)“空间换时间”，时间越快越好\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/you-xiao-de-gua-hao/","content":"\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/shu-de-bian-li-di-gui-he-fei-di-gui-6-chong/","content":"\ntitle: HTMLdate: 2020-08-20 16:21:41author: 外心人Dtoc: truemathjax: falsesummary: 爱编程categories: Markdowntags:\n\nLeetcode\n剑指offer\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# -*- coding:utf-8 -*-class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = None# 1.深度优先# 2.广度优先'''对于深度优先来说：    1.先序遍历（根、左、右）    2.中序遍历（左、根、右）    3.后序遍历（左、右、根）    注意：先序、中序后序都是对应于根节点来说的，左右节点都是先左后右'''# 递归# 前序法def preOrderRecusive(root):    if root == None:        return None    print('[%2d]' %root.val, end=' ')    preOrderRecusive(root.left)    preOrderRecusive(root.right)# 中序法def midOrderRecusive(root):    if root == None:        return None    midOrderRecusive(root.left)    print('[%2d]' %root.val, end=' ')    midOrderRecusive(root.right)# 后序法def latOrderRecusive(root):    if root == None:        return None    latOrderRecusive(root.left)    latOrderRecusive(root.right)    print('[%2d]' %root.val, end=' ')# 非递归的形式，先根，中根，后跟# 前序法def preOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            print(tmpNode.val)            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack.pop()        tmpNode = node.right# 中序法def midOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack.pop()        print(node.val)        tmpNode = node.right# 后序法def latOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack[-1]        tmpNode = node.right        if node.right == None:            print(node.val)            node = stack.pop()            while stack and node == stack[-1].right:                node = stack.pop()                print(node.val)if __name__ == '__main__':    t1 = TreeNode(1)    t2 = TreeNode(2)    t3 = TreeNode(3)    t4 = TreeNode(4)    t5 = TreeNode(5)    t6 = TreeNode(6)    t7 = TreeNode(7)    t8 = TreeNode(8)    t1.left = t2    t1.right = t3    t2.left = t4    t2.right = t5    t3.left = t6    t3.right = t7    t6.right = t8    # preOrderRecusive(t1)    # midOrderRecusive(t1)    # latOrderRecusive(t1)    # preOrder(t1)    # -*- coding:utf-8 -*-class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = None# 1.深度优先# 2.广度优先'''对于深度优先来说：    1.先序遍历（根、左、右）    2.中序遍历（左、根、右）    3.后序遍历（左、右、根）    注意：先序、中序后序都是对应于根节点来说的，左右节点都是先左后右'''# 递归# 前序法def preOrderRecusive(root):    if root == None:        return None    print('[%2d]' %root.val, end=' ')    preOrderRecusive(root.left)    preOrderRecusive(root.right)# 中序法def midOrderRecusive(root):    if root == None:        return None    midOrderRecusive(root.left)    print('[%2d]' %root.val, end=' ')    midOrderRecusive(root.right)# 后序法def latOrderRecusive(root):    if root == None:        return None    latOrderRecusive(root.left)    latOrderRecusive(root.right)    print('[%2d]' %root.val, end=' ')# 非递归的形式，先根，中根，后跟# 前序法def preOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            print(tmpNode.val)            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack.pop()        tmpNode = node.right# 中序法def midOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack.pop()        print(node.val)        tmpNode = node.right# 后序法def latOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack:        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack[-1]        tmpNode = node.right        if node.right == None:            print(node.val)            node = stack.pop()            while stack and node == stack[-1].right:                node = stack.pop()                print(node.val)if __name__ == '__main__':    t1 = TreeNode(1)    t2 = TreeNode(2)    t3 = TreeNode(3)    t4 = TreeNode(4)    t5 = TreeNode(5)    t6 = TreeNode(6)    t7 = TreeNode(7)    t8 = TreeNode(8)    t1.left = t2    t1.right = t3    t2.left = t4    t2.right = t5    t3.left = t6    t3.right = t7    t6.right = t8    # preOrderRecusive(t1)    # midOrderRecusive(t1)    # latOrderRecusive(t1)    # preOrder(t1)    # midOrder(t1)    latOrder(t1)\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"比较函数cmp_to_key","url":"https://bubbleboy11.github.io/2020/08/21/bi-jiao-han-shu-cmp-to-key/","content":"3.8 新版功能123456789101112131415161718192021222324252627282930将(旧式的)（old-style comparison function）比较函数转换为新式的关键函数 key function . 在类似于 ```sorted()``` ， ```min()``` ， ```max()``` ， ```heapq.nlargest()``` ， ```heapq.nsmallest()``` ， ```itertools.groupby()``` 等函数的 ```key``` 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。将用户自定义的 ```cmp``` 函数转化为可以被可选参数```key```接收的对象。源码如下，实际上就是定义了一个内部类K，通过传入的用户自定比较函数mycmp重写了K的各个比较方法：```pydef cmp_to_key(mycmp):    \"\"\"Convert a cmp= function into a key= function\"\"\"    class K(object):        __slots__ = ['obj']        def __init__(self, obj):            self.obj = obj        def __lt__(self, other):            return mycmp(self.obj, other.obj) < 0        def __gt__(self, other):            return mycmp(self.obj, other.obj) > 0        def __eq__(self, other):            return mycmp(self.obj, other.obj) == 0        def __le__(self, other):            return mycmp(self.obj, other.obj) <= 0        def __ge__(self, other):            return mycmp(self.obj, other.obj) >= 0        __hash__ = None    return Ktry:    from _functools import cmp_to_keyexcept ImportError:    pass\n\n123456from functools import cmp_to_keynums = [3, 30, 34, 5, 9]nums.sort(key=cmp_to_key(lambda x,y: int(str(x) + str(y)) - int(str(y) + str(x))))print(nums)from functools import cmp_to_keynums = [3, 30, 34, 5, 9]nums.sort(key=cmp_to_key(lambda x,y: int(str(x) + str(y)) - int(str(y) + str(x))))print(nums)# [30, 3, 34, 5, 9]\n\n对字符串排序，要求把开头为’x’的排到前面，然后再以字典序排。\n12345678910111213141516171819202122from functools import cmp_to_keydef cmp(s1, s2):    if s1[0] == 'x' and s2[0] != 'x':        return 1    if s2[0] == 'x' and s1[0] != 'x':        return -1    if s1 &gt; s2:        return -1    if s1 &lt; s2:        return 1    return 0def front_x(words):    t = sorted(words, key=cmp_to_key(cmp), reverse=1)    return tprint(front_x(['mix', 'xyz', 'apple', 'xanadu', 'aardvark']))from functools import cmp_to_keydef cmp(s1, s2):    if s1[0] == 'x' and s2[0] != 'x':        return 1    if s2[0] == 'x' and s1[0] != 'x':        return -1    if s1 &gt; s2:        return -1    if s1 &lt; s2:        return 1    return 0def front_x(words):    t = sorted(words, key=cmp_to_key(cmp), reverse=1)    return tprint(front_x(['mix', 'xyz', 'apple', 'xanadu', 'aardvark']))# 输出:['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["python"]},{"title":"测试工具","url":"https://bubbleboy11.github.io/2020/08/21/ce-shi-gong-ju/","content":"接口测试三剑客抓包工具fiddler,接口测试工具postman,Python开发测试工具。\nfiddlerhttp协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间http通讯，设置断点，查看所有的“进出”fiddler的数据。\nfiddler的工作原理：在电脑端设置一个代理，电脑发起的所有http请求都会经过这个代理，fiddler代理把收到的请求后再将这个请求发给服务器，服务器收fiddler的请求处理后在返回给fiddler，fiddler收到服务端返回的数据同样再返回给我们的电脑\n默认端口8888，逍遥模拟器wifi端口改成8888\nfiddler的运用：\n\n查看接口请求方式\n查看请求数据、响应数据：请求方式测试请求方式为post，提交数据添加header,cookie，body;请求方式为get：接口地址？多个请求数据用&amp;连接 前为key，后面数参数数据，添加也是在header里面添加键、值，\n接口返回状态\n设置代理（用于移动端抓包）\nheader和cookie\n设置断点\n添加筛选\nfiddler进行接口测试\n\nrules- automatic breakpoint -before request上不了网络 disable正常上网\n快捷键删除全部请求：Ctrl+X保留选中请求，删除其他：Shift+Del\nPostman自动反复测试一个需要携带header的post请求，并且对针对线上、测试环境同一个数据进行测试。并对实际结果做比较，以作为测试结果关键字：自动 反复 线上  线下\nPostman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟get或者post或者其他方式的请求来调试接口\n使用Postman如果通过自己拼接url，自己造数据，是非常麻烦的。因此选择Postman+Postman interceptor，使用Postman interceptor可以拦截到网页请求，同时传到postman的history列表中，然后我们只需要在postman中修改一下url就可以直接send了。\n主要功能包括\n\n模拟各种 HTTP requests\n\nCollection 功能（测试集合）栏保存有常用的接口，可以按接口类型或者业务类型放在不同的文件夹下。把接口放到collections里同一个文件夹下可以进行接口的批量执行，需要把所有要测试的接口放在一个文件夹下，点击右边的三角形，然后点击run，进行运行iteration：迭代次数\n\npost的headers旁边的body里有内容，get会把数据都放到url中，body不可以点击。\n\n\n需要header或者cookie时候，则要填写header才可以成功请求，cookie的值也是填写到header中，添加cookie和header之后添加入参到Body中\n\n人性化的 Response 整理\n\n内置测试脚本语言，点击右边的code，可以选择自己熟悉的代码，选择之后，根据选择生成接口测试的代码。 生成对应语言的http请求的代码。\n\n设定变量与环境 enviroment：右上角的设置按钮，选择manage environment，输入环境名称和url如设置线上和测试环境的地址名称，这样可以自由地切换不同的测试环境来执行接口测试。\n\n通过tests栏设置相关内容可以判断测试结果是pass还是fail。在返回数据查uid，如果查到了就说明接口是成功的tests[\"Body matches string\"]=responseBody.has（\"uid\"）;\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["测试"]},{"title":"浏览器访问url","url":"https://bubbleboy11.github.io/2020/08/21/liu-lan-qi-fang-wen-url/","content":"电脑是如何访问百度的？浏览器输入一个网址url并发送请求到服务器，再到服务器返回浏览器发生了哪些事情？\n可以从以下角度回答问题中间涉及到了哪些过程每个过程包含哪些网络协议每个协议都干了什么？\n知道什么说什么，不要把自己带坑里，熟悉到哪一层协议就说到哪一层）\n&nbsp; DNS查询—》TCP握手—》HTTP请求—》反向代理Nginx—》uwsgi / gunicom—》web app 响应—》TCP握手。&nbsp; &nbsp; &nbsp; &nbsp;当浏览器发起请求的时候其实一开始并不会做DNS查询，而是先去看有没有DNS缓存，如果不在DNS缓存里面并且hosts文件里面也没有的时候，它就会向本地DNS服务器发起一个DNS查询，如果本地DNS没有查到的时候(DNS 查询是一个递归查询)它就会向上层继续查询，一直向域名服务器和根服务器继续进行递归查询。一直到查询完之后返回给我们对应的IP地址，比如：输入www.aliyun.com阿里云就会返回对应的IP地址：106.11.62.15。&nbsp; &nbsp; &nbsp; &nbsp;DNS查询完之后就获取到IP地址，当拿到IP地址之后浏览器就可以调用Socket函数来去发起TCP请求，通过三次握手与并等待服务器的确认。在服务器响应请求后，建立TCP连接。&nbsp; &nbsp; &nbsp; &nbsp;建立起连接之后，发起应用层协议HTTP请求，发起的HTTP请求并不是一开始打到web框架，而是打到Nginx反向代理，很多访问量比较高的网站都会使用nginx来作为反向代理和负载均衡，通过nginx转发到多台服务器上。&nbsp; &nbsp; &nbsp; &nbsp;Nginx反向代理之后就到 WSGI服务器这一层，uwsgi / gunicom作用就是主要兼容web应用(flask/django/tornado)。通过uwsgi 再把请求转发到web应用层(web app响应)也就是web框架层。在web应用层一般就是做一些数据库的增删改查或者发一条消息等，最后把请求response，通过TCP发送给用户。&nbsp; &nbsp; &nbsp; 如果没有其它数据传输的时候，就会执行TCP的四次挥手。\n然后，浏览器向服务器发送HTTP请求，服务器收到请求并返回包含HTML代码的HTTP Response。然后浏览器获取到了HTML，并进行HTML内资源请求，比如里面的CSS,JS，图片等资源。最后浏览器将渲染界面，呈现给用户。\n一、精简回答1.DNS：domain name server，域名解析 用于将域名转化成ip地址的服务器。 就像是查号台、地址簿，会告诉互联网该如何去解读IP地址，譬如将38.160.150.31转换成人能读懂的网址，比如bbc.co.uk，并指出哪条途径可以到达存有这个IP地址的服务器。域名：www.baidu.comDNS服务端：119.29.29.29通过DNS服务器解析119.29.29.29，解析http://www.baidu.com2.访问百度的IP百度IP地址：14.215.177.38通过浏览器方位14.215.177.38:443端口\n二、详细回答\n\n如何到达DNS地址：119.29.29.29\n未知的IP地址我们会发送给网关：192.168.30.254\n如何发送给网关，需要知道网关的MAC地址；\n已知网关的IP地址，如何知道网关的MAC地址。\nARP解析，IP地址→MAC地址192.168.30.254 00-23-05-43-3f-42\nARP解析过程1）发送ARP广播包，同一个广播域内的所有设备都会接收到。2）需要解析的IP地址的MAC设备会进行回应。IP→MAC3）电脑段接收到ARP信息保存到arp表\n之后要发送给网关都是通过arp表中的192.168.30.254 00-23-05-43-3f-42\n电脑发送DNS解析请求目的为119.29.29.29地址给网关，网关进行三层路由查询，转发给出口，出口源地址NAT转发给运营商……\nDNS服务器响应的DNS解析请求，返回给百度的IP为14.215.177.38\n浏览器访问14.215.177.38:443（百度）到这个IP的请求；\n14.215.177.38:443（百度）发送页面信息给电脑。\n\n内网公网地址切换，分布式服务器，网关处理\n再浏览器打开网址或者CMD ping \n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["计算机网络"],"tags":["剑指offer","Leetcode"]},{"title":"深浅拷贝","url":"https://bubbleboy11.github.io/2020/08/21/shen-qian-kao-bei/","content":"\n浅拷贝(shallow copy)：b = a.copy()、b = copy.copy(a)、slicingb = a[:]  list(path)\n\n不可变对象只能使用copy模块的copy()方法，不能用 object.copy()\n当创建一个对象a，然后把它赋给另一个变量b的时候，在另一块地址中创建一个新的变量b或容器b，但是容器b内的元素的地址均是源对象a的元素的地址（引用）的拷贝，即他们的子对象还是指向同一地址（引用），共享同一块内存，只复制指向源对象中元素的地址，而不复制对象本身和内部的子对象。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。\nid() 函数：返回对象的唯一标识，可以类比成该对象在内存中的地址。\n123456789101112131415161718192021222324252627282930313233a = ['hello', [1, 2, 3], 1]b = a[:]  # b = a.copy() = copy.copy(a)print(a is b)  # Falseprint(id(a))  # 1766718196416print(id(b))  # 1766718196480 容器是新的，a 和 b 是一个独立的对象print([id(x) for x in a])# [1760365870320, 1760360341312, 140725884393120]print([id(x) for x in b])# [1760365870320, 1760360341312, 140725884393120]a[0] = 'world'a[1].append(4)a[2] = 233print(a)  # ['world', [1, 2, 3, 4], 233]print(b)  # ['hello', [1, 2, 3, 4], 1]print([id(x) for x in a])# [1760365870384, 1760360341312, 140725884400544]print([id(x) for x in b])# [1760365870320, 1760360341312, 140725884393120]]# 浅拷贝后未修改前，a和b中元素的地址都是相同的，a和b的地址不同 # 不可变的hello和可变的list地址都一样，# 说明浅拷贝只是将容器内的元素的地址复制了一份。# 修改后，# b中字符串和数字没改变，对源对象的不可变元素不能修改，每一次赋值的时候会创建新的对象，原来的形参指向新对象，会开辟新的内存，就有新的引用，而浅拷贝是指向的修改前的引用# 但是list元素随着a相应改变得到验证，num = [2]  # num不是源对象的元素a.append(num)  # 修改对象aprint(a)  # ['world', [1, 2, 3, 4], 233, [2]]print(b)  # ['hello', [1, 2, 3, 4], 1]  #　浅拷贝的源对象的元素的索引print(id(num) == id(a[3]))  a = ['hello', [1, 2, 3], 1]b = a[:]  # b = a.copy() = copy.copy(a)print(a is b)  # Falseprint(id(a))  # 1766718196416print(id(b))  # 1766718196480 容器是新的，a 和 b 是一个独立的对象print([id(x) for x in a])# [1760365870320, 1760360341312, 140725884393120]print([id(x) for x in b])# [1760365870320, 1760360341312, 140725884393120]a[0] = 'world'a[1].append(4)a[2] = 233print(a)  # ['world', [1, 2, 3, 4], 233]print(b)  # ['hello', [1, 2, 3, 4], 1]print([id(x) for x in a])# [1760365870384, 1760360341312, 140725884400544]print([id(x) for x in b])# [1760365870320, 1760360341312, 140725884393120]]# 浅拷贝后未修改前，a和b中元素的地址都是相同的，a和b的地址不同 # 不可变的hello和可变的list地址都一样，# 说明浅拷贝只是将容器内的元素的地址复制了一份。# 修改后，# b中字符串和数字没改变，对源对象的不可变元素不能修改，每一次赋值的时候会创建新的对象，原来的形参指向新对象，会开辟新的内存，就有新的引用，而浅拷贝是指向的修改前的引用# 但是list元素随着a相应改变得到验证，num = [2]  # num不是源对象的元素a.append(num)  # 修改对象aprint(a)  # ['world', [1, 2, 3, 4], 233, [2]]print(b)  # ['hello', [1, 2, 3, 4], 1]  #　浅拷贝的源对象的元素的索引print(id(num) == id(a[3]))  # True [2]引用了a原本内存以外的地址，所以b不受影响\n\n\n深拷贝(deep copy)：引入copy 模块的 deepcopy 方法，是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，新对象跟原对象不共享内存，仅仅是值相同而已，完全拷贝了一个副本，容器内部元素地址都不一样。修改新对象不会改到原对象。（ 新瓶装新酒 ）\n\n1234567891011121314151617import copya = ['hello', [1, 2, 3]]b = copy.deepcopy(a)print(id(a))  # 1766718196416print(id(b))  # 1766718196480print([id(x) for x in a])# [55792504, 55645000]print([id(x) for x in b])# [55792504, 58338824]a[0] = 'world'  # 修改对象a中的'hello'对象a[1].append(4)  # 修改对象a中的[1, 2, 3]数组对象print(a)# ['world', [1, 2, 3, 4]]print(b)import copya = ['hello', [1, 2, 3]]b = copy.deepcopy(a)print(id(a))  # 1766718196416print(id(b))  # 1766718196480print([id(x) for x in a])# [55792504, 55645000]print([id(x) for x in b])# [55792504, 58338824]a[0] = 'world'  # 修改对象a中的'hello'对象a[1].append(4)  # 修改对象a中的[1, 2, 3]数组对象print(a)# ['world', [1, 2, 3, 4]]print(b)# ['hello', [1, 2, 3]]\n深拷贝后，a和b的地址以及a和b中的元素地址均不同，这是完全拷贝的一个副本，修改a后，发现b没有发生任何改变，因为b是一个完全的副本，元素地址与a均不同，a修改不影响b。。深拷贝ab的不可变对象字符串时地址显示一样，因为 字符串str的intern驻留机制，\n在pycharm和VScode中，只要是同一个字符串不超过20个字符，都为True，在shell中示例，并非全部的字符串都会采用intern机制。仅仅包括下划线、数字、字母的字符串才会被intern，当然不能超过20个字符。因为如果超过20个字符的话，解释器认为这个字符串不常用，不用放入字符串池中。\n提个建议，a[0] 的 ‘hello’ 应该更换为一个长度大于 20 的字符串，这样会更直观。因为 str.length &lt; 20 会被缓存，相当于 [-5,256] 的小整数对象一样，所以深拷贝的时候 a[0] 的 地址是一样的，但是我们很清楚的知道，深拷贝是完全拷贝。\n1234567891011121314151617181920212223242526import copya = [[10], 20]b = a[:]c = list(a)d = a * 1e = copy.copy(a)f = copy.deepcopy(a)a.append(21)a[0].append(11)print(id(a), a)# 30553152 [[10, 11], 20, 21]print(id(b), b)# 44969816 [[10, 11], 20]print(id(c), c)# 44855664 [[10, 11], 20]print(id(d), d)# 44971832 [[10, 11], 20]print(id(e), e)# 44833088 [[10, 11], 20]print(id(f), f)# 44834648 [[10], 20]# 使用 a[:], list(a), a*1, copy.copy(a)四种方式复制列表结果都可以得到一个新的列表，# 但是如果列表中含有列表，# 所有b, c, d, e四个新列表的子列表都是指引到同一个对象上。import copya = [[10], 20]b = a[:]c = list(a)d = a * 1e = copy.copy(a)f = copy.deepcopy(a)a.append(21)a[0].append(11)print(id(a), a)# 30553152 [[10, 11], 20, 21]print(id(b), b)# 44969816 [[10, 11], 20]print(id(c), c)# 44855664 [[10, 11], 20]print(id(d), d)# 44971832 [[10, 11], 20]print(id(e), e)# 44833088 [[10, 11], 20]print(id(f), f)# 44834648 [[10], 20]# 使用 a[:], list(a), a*1, copy.copy(a)四种方式复制列表结果都可以得到一个新的列表，# 但是如果列表中含有列表，# 所有b, c, d, e四个新列表的子列表都是指引到同一个对象上。# 只有使用copy.deepcopy(a)方法得到的新列表f才是包括子列表在内的完全复制。\n\n\n12345678&gt;&gt;&gt; s3 = \"hello!\"&gt;&gt;&gt; s4 = \"hello!\"&gt;&gt;&gt; s3 is s4False&gt;&gt;&gt; id(s3)80325968L&gt;&gt;&gt; id(s4)&gt;&gt;&gt; s3 = \"hello!\"&gt;&gt;&gt; s4 = \"hello!\"&gt;&gt;&gt; s3 is s4False&gt;&gt;&gt; id(s3)80325968L&gt;&gt;&gt; id(s4)80326048L\ns3 和 s4 虽然值是一样的，但确确实实是两个不同的字符串对象，Python 会为它们俩各自分配一段内存空间，假设程序中存在大量值相同的字符串，系统就不得不为每个字符串重复地分配内存空间，显然，对系统来说是一种无谓的资源浪费。为了解决这种问题，Python 引入了 intern 机制。\n12345678&gt;&gt;&gt; s3 = intern('hello!')&gt;&gt;&gt; s4 = intern('hello!')&gt;&gt;&gt; s3 is s4True&gt;&gt;&gt; id(s3)80325968L&gt;&gt;&gt; id(s4)&gt;&gt;&gt; s3 = intern('hello!')&gt;&gt;&gt; s4 = intern('hello!')&gt;&gt;&gt; s3 is s4True&gt;&gt;&gt; id(s3)80325968L&gt;&gt;&gt; id(s4)80325968L\nintern 是 Python 中的一个内建函数，该函数的作用就是对字符串进行 intern 机制处理，处理后返回字符串对象。我们发现但凡是值相同的字符串经过 intern 机制处理之后，返回的都是同一个字符串对象，这种方式在处理大数据的时候无疑能节省更多的内存空间，系统无需为相同的字符串重复分配内存，对于值相同的字符串共用一个对象即可。\n实现 Intern 机制的方式:通过维护一个字符串储蓄池，这个池子是一个字典结构，如果字符串已经存在于池子中了就不再去创建新的字符串，直接返回之前创建好的字符串对象，如果之前还没有加入到该池子中，则先构造一个字符串对象，并把这个对象加入到池子中去，方便下一次获取，用伪代码就可以描述为：\n123456789intern_pool = {}def intern(s):    if s in intern_pool:        return intern_pool[s]    else:        obj = PyStringObject(s)        intern_pool[s] = obj        intern_pool = {}def intern(s):    if s in intern_pool:        return intern_pool[s]    else:        obj = PyStringObject(s)        intern_pool[s] = obj        return obj\n\n在主流面向对象的编程语言中intern 机制对于处理字符串已经成为一种标配，通过 intern 机制可以提高字符串的处理效率，当然，解释器内部很对 intern 机制的使用策略是有考究的，有些场景会自动使用 intern ，有些地方需要通过手动方式才能启动。比如：\n12345678&gt;&gt;&gt; s1 = \"hello\"&gt;&gt;&gt; s2 = \"hello\"&gt;&gt;&gt; s1 is s2True&gt;&gt;&gt; id(s1)72320704L&gt;&gt;&gt; id(s2)&gt;&gt;&gt; s1 = \"hello\"&gt;&gt;&gt; s2 = \"hello\"&gt;&gt;&gt; s1 is s2True&gt;&gt;&gt; id(s1)72320704L&gt;&gt;&gt; id(s2)72320704L\n这段代码就是 Python自动使用了intern机制的结果。\n对一个list后面用 乘号 再加上 数字 的方法来初始化一个list，实际上是对这个list进行了浅拷贝（shallow copy）\n123456789101112a = (1, 2, 3)print(a * 3)  # (1, 2, 3, 1, 2, 3, 1, 2, 3)返回的是个新元祖list0 = [1, 2, 3]list1 = list0 * 3print(list1)  # [1, 2, 3, 1, 2, 3, 1, 2, 3] 创建了 1,2,3 的三个浅拷贝 直接乘3，相当于把a1中元素乘3# 此时我们修改某个1，不会影响其他的，因为这是int不可变元素，不是子对象list1[0] = 0print(list1)  # [0, 2, 3, 1, 2, 3, 1, 2, 3]print([list0] * 3)  # 加上[], 将list0对象整体作为列表一个元素乘3[[1, 2, 3], [1, 2, 3], [1, 2, a = (1, 2, 3)print(a * 3)  # (1, 2, 3, 1, 2, 3, 1, 2, 3)返回的是个新元祖list0 = [1, 2, 3]list1 = list0 * 3print(list1)  # [1, 2, 3, 1, 2, 3, 1, 2, 3] 创建了 1,2,3 的三个浅拷贝 直接乘3，相当于把a1中元素乘3# 此时我们修改某个1，不会影响其他的，因为这是int不可变元素，不是子对象list1[0] = 0print(list1)  # [0, 2, 3, 1, 2, 3, 1, 2, 3]print([list0] * 3)  # 加上[], 将list0对象整体作为列表一个元素乘3[[1, 2, 3], [1, 2, 3], [1, 2, 3]]\n\n二维数组也就是矩阵的初始化是这样的 m, n = 3, 4 其中m，n分别是行数和列数。\n1234567list2 = [[1] * 3] * 4print(list2)  # [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]# 创建了list列表[1,1,1]的四个浅拷贝，# 这里得到的list是以list为可变类型的，因此改变一个就会影响其他list2[0][0] = 0print(list2)list2 = [[1] * 3] * 4print(list2)  # [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]# 创建了list列表[1,1,1]的四个浅拷贝，# 这里得到的list是以list为可变类型的，因此改变一个就会影响其他list2[0][0] = 0print(list2)# [[0, 1, 1], [0, 1, 1], [0, 1, 1], [0, 1, 1]]\n\n改用如下方式初始化数组，(1)间接定义(推荐使用)，就可以得到一个可以通过二维下标访问的矩阵了。\n1doublearr = [[0 for i in range(3)] for i in range(doublearr = [[0 for i in range(3)] for i in range(4)]\n(2)直接定义\n1doublearr = [[0, 0, 0], [0, 0, 0], [0, 0, doublearr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n(3)使用循环定义\n123doublearr = []for i in range(3):    doublearr.append([0] * doublearr = []for i in range(3):    doublearr.append([0] * 3)\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"牛客","url":"https://bubbleboy11.github.io/2020/08/21/niu-ke/","content":"python牛客网做题总结一、题目提示有多个case 或者 输出‘空，检查是否输入多个case’\n1234567while True：    try：    # your code    except:        while True：    try：    # your code    except:        break\n\n二、题目提示多组同时输入或加入while循环超时\n123import sysfor line import sysfor line in sys.stdin:    N = line.strip()\n\n提高通过率技巧\n时间复杂度问题：增加条件break或continue出循环，能break尽量break；减少不必要的判断条件（比如在不在字典中）；做一些排序来减少后期的工作量\n边界条件：某些数据是不是始终存在\n\n测试用例通过但0%的原因：1.没有理解题意\n输入而可以考虑用input\n123Input=input().split(' ')a=int(Input[0])b=int(Input[Input=input().split(' ')a=int(Input[0])b=int(Input[1])\n输入进去的都是string类型\n输出一般逐行打印\n123for i for i in result:    print(i)\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"目录结构","url":"https://bubbleboy11.github.io/2020/08/21/mu-lu-jie-gou/","content":"目录结构weixin-spider│ manage.py （web服务启动文件）│ README.md （项目说明文档）│ requirements.txt （项目安装包）│ wx_monitor.py （任务调度中心）│├─api│ │ crawlerapi.py （爬虫文件）│ │ init.py│ │├─exceptions (异常捕获目录)│├─tools│ │ addons.py （mitm配置）│ │ handle.py （自动化操作）│ │ keys.py （redis-keys管理）│ │ proxy.py （本地代理）│├─webapp│ │ models.py （数据库表模型）│ │ init.py│ ├─static （静态资源目录）│ ├─templates（html文件目录）│ ││ ├─wxapp│ │ │ selffilter.py (过滤器)│ │ │ views.py (视图文件、接口)\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"相对路径绝对路径","url":"https://bubbleboy11.github.io/2020/08/21/xiang-dui-lu-jing-jue-dui-lu-jing/","content":"绝对路径绝对的，不因当前目录而改变的一个路径表示法不管我们当前位于哪个目录，绝对路径的使用都是一样的从硬盘的根目录(盘符)开始，进行一级级目录指向文件。linux从根目录”/“开始windows从C:开始，文件右键安全对象名称\n相对路径  ’/‘相对于当前文件夹目录路径为参照物 ，其实就是你编写的这个py文件所放的文件夹路径！也就是说你写的相对路径必须是当前文件夹A里的文件a或者A里的文件夹B里的文件才可以open。相对路径相对的不是当前py文件，而是工作路径（working directory），一般默认工作路径就是当前执行的py文件\n网页网址和linux、unix系统下一般都用’/‘\n当前目录路径，可省略1234567891011```..```上一级目录 父目录```~```当前用户家目录=```/root```标准库 lib 目录下（home 目录/pythonXX.XX/lib）```__file__```表示显示文件当前的位置没有__file__属性的python库无法使用此方法查询```pyimport unittestprint(unittest.__file__)# C:\\Users\\rose\\AppData\\Local\\Programs\\Python\\Python38\\lib\\unittest\\__init__.py\n\n在 lib 下的 site-packages 目录下home 目录/pythonXX.XX/lib/site-packages/若python包是使用pip进行安装的\n1234567891011pip show djangoName: DjangoVersion: 3.0.7Summary: A high-level Python Web framework that encourages rapid development and clean, pragmatic design.Home-page: https://www.djangoproject.com/Author: Django Software FoundationAuthor-email: foundation@djangoproject.comLicense: BSDLocation: c:\\users\\rose\\appdata\\local\\programs\\python\\python38\\lib\\site-packagesRequires: asgiref, pytz, sqlparseRequired-by: xadmin2, django-reversion, django-pip show djangoName: DjangoVersion: 3.0.7Summary: A high-level Python Web framework that encourages rapid development and clean, pragmatic design.Home-page: https://www.djangoproject.com/Author: Django Software FoundationAuthor-email: foundation@djangoproject.comLicense: BSDLocation: c:\\users\\rose\\appdata\\local\\programs\\python\\python38\\lib\\site-packagesRequires: asgiref, pytz, sqlparseRequired-by: xadmin2, django-reversion, django-import-export, django-formtools\n\nWindows 的根目录的直属子目录Windows 的 C 盘这个根目录下一般都会找到一些相同的子目录 program Files 和Windows 和Documents and Settings\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/duan-wang-zhi-xi-tong-she-ji-yu-shi-xian/","content":"短网址系统 TinyUrl Service\n把一个长网址转成短网址的服务\n\n比如比较出名 https://bitly.com/ ,缩短网址的网站。比如把一个长链接粘贴进去它会自动帮你生成一个较短网址。\n\n转换之后网址后缀不超过7位（字符或者数字）\n\n粘贴进去长网址http://mirrors.163.com/.help/CentOS7-Base-163.repo 点击Shorten按钮 生成 一个短网址 https://bit.ly/304LlY9。 可以看到短网址后面一共有7位数 304LlY9，7位里面既包含大写字母也包含小写字母同时也包含数字。比如：像国外的Twitter网站默认使用 bitly 作为短网址服务，实际上短网址服务的兴起就是因为Twitter一开始只允许发140个字，比较长的网址就特别占用空间，所以才出现短网址这种服务。\n\n\n场景和限制  使用场景：提供短网址服务为公司其他各业务服务\n\n功能：一个长网址转成短网址并存储；根据短网址还原长 url\n要求短网址的后缀不超过7位(大小写字母和数字)\n估计峰值假设插入请求数量级：数百；查询请求数量级：数千\n\n数据存储设计   根据需求设计数据存储方式\n\n使用Mysql即可满足\n需要的字段有哪些？根据需求来看实际上只需要 ID、存储生成之后的短网址、原网址、创建时间这四个字段就可以满足需求。\n\nMysql 数据表\n1id     token(索引)    url(原网址)    id     token(索引)    url(原网址)    created_at\ntoken:不存储整个短网址，希望前边的主机名可以随意的去替换\n如何根据查询设计索引？只有一个需求就是根据短网址还原原网址，直接给token加上索引就可以。\n算法实现设计  短网址生成算法有哪些？对比优缺点选择适合业务的方法\n\n\n两个 API：long2short_url 把长的url转换成短网址，short2long_url 根据短网址查询出长网址\n\n常用算法：hash 算法截取； 自增序列算法\n对比多钟算法，采取自增序列算法实现\n短网址生成算法：CHARS=“abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789”对每个长网址从```里面生成一个不超过7位长度的一个短网址token\n① md5摘要算法：接收任意长度的字节然后生成一个定长的字符，经常用在下载文件的时候会与md5校验值用来检查文件是不是修改了。\n12345678&gt;&gt;&gt; import hashlib&gt;&gt;&gt; url = 'http://mirrors.163.com/.help/CentOS7-Base-163.repo'&gt;&gt;&gt; hashlib.md5(url.encode())    # 对url使用摘要算法得到的值&lt;md5 HASH object @ 0x000002BE328342D8&gt;&gt;&gt;&gt; hashlib.md5(url.encode()).hexdigest()  # 转化成一个16进制串'60dc55352afeb63b4d91a75c9c4ff287'&gt;&gt;&gt; len(hashlib.md5(url.encode()).hexdigest())32                                    &gt;&gt;&gt; import hashlib&gt;&gt;&gt; url = 'http://mirrors.163.com/.help/CentOS7-Base-163.repo'&gt;&gt;&gt; hashlib.md5(url.encode())    # 对url使用摘要算法得到的值&lt;md5 HASH object @ 0x000002BE328342D8&gt;&gt;&gt;&gt; hashlib.md5(url.encode()).hexdigest()  # 转化成一个16进制串'60dc55352afeb63b4d91a75c9c4ff287'&gt;&gt;&gt; len(hashlib.md5(url.encode()).hexdigest())32                                    # 是一个定长的32位字符串\n因为我们需要一个不超过7位的字符串而md5摘要算法是32位的。可能会想到截断只取前7个字符。但是有个问题可能会有一定概率的冲突。一旦有冲突就需要在插入时候去数据库检查一下是不是有冲突。实际上这样在高并发的插入场景下是特别不友好的。\n② 把对应的每个ID给它生成一个不重复的短网址token。\n1234567891011121314151617181920212223一共七个位置每个位置有62种选项，62**7是一个非常大的数字，万亿规模的数字，对短网址token来说有万亿规模肯定就够用了字符集类似于62进制的数字。对于二进制数字来说它的可选项是0,1；十六进制 0-9 a-f 。可以把自增ID十进制把它转换成字符集这种62进制的，十进制 -> 62进制，这样就实现十进制的ID跟六十二进制数字的一个映射。这里并不是严格的62进制的数字，不过从0到61每个位置上都有一个字符与之对应。  现在就知道如何来解决这个问题了，就是根据自增的ID来去给每个长网址生成一个62进制的短网址。        如何把十进制的ID转换成62进制的短网址？进制转换10进制 ->2进制 ，不断取余，倒序输出```py>>> bin(10)    # 将10进制转换成2进制  '0b1010'  >>> help(divmod)   # 查看divmod函数使用Help on built-in function divmod in module builtins:divmod(x, y, /)    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.>>> divmod(10, 2)   # 返回一个tuple，一个是整除的商，x对y取模求余数(5, 0)\n\n1). 10进制转换成2进制函数实现\n1234567891011121314151617181920212223242526def mybin(num):  # 10进制 -&gt; 2进制    if num == 0:        return 0    res = []  # 保存2进制串的列表    while num:        num, rem = divmod(num, 2)        res.append(str(rem))    return ''.join(reversed(res))  # 倒序输出转换成字符串print(mybin(10))  # 1010# num = 10# res = []# num = num // 2 = 10 // 2 = 5# rem = num % 2 = 10 % 2 = 0# res= ['0']# num = num // 2 = 5 // 2 = 2# rem = num % 2 = 5 % 2 = 1# res= ['0', '1']# num = num // 2 = 2 // 2 = 1# rem = num % 2 = 2 % 2 = 0# res = ['0', '1', '0']# num = num // 2 = 1 // 2 = 0# rem = num % 2 = 1 % 2 = 1# res = ['0', '1', '0', '1']def mybin(num):  # 10进制 -&gt; 2进制    if num == 0:        return 0    res = []  # 保存2进制串的列表    while num:        num, rem = divmod(num, 2)        res.append(str(rem))    return ''.join(reversed(res))  # 倒序输出转换成字符串print(mybin(10))  # 1010# num = 10# res = []# num = num // 2 = 10 // 2 = 5# rem = num % 2 = 10 % 2 = 0# res= ['0']# num = num // 2 = 5 // 2 = 2# rem = num % 2 = 5 % 2 = 1# res= ['0', '1']# num = num // 2 = 2 // 2 = 1# rem = num % 2 = 2 % 2 = 0# res = ['0', '1', '0']# num = num // 2 = 1 // 2 = 0# rem = num % 2 = 1 % 2 = 1# res = ['0', '1', '0', '1']# ''.join(reversed(res) = '1010'\n\n2). 10进制到62进制串的转化（递增序列算法）\n1234567891011121314151617181920212223242526CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"def encode(num):    if num == 0:        return CHARS[0]    res = []    while num:        num, rem = divmod(num, len(CHARS))  # len(CHARS) = 62        res.append(CHARS[rem])    return ''.join(reversed(res))print(encode(0))  # aprint(encode(61))  # 9print(encode(62))  # ba# num = 62# len(CHARS) = 62# num = num // len(CHARS) = 62 // 62 = 1# rem = num % len(CHARS) = 62 % 62 = 0# res= res.append(CHARS[rem]) # rews = res.append(CHARS[0]) = ['a']# num = num // len(CHARS) = 1 // 62 = 0# rem = num % len(CHARS) = 1 % 62 = 1# rews = res.append(CHARS[1]) = ['a', 'b']CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"def encode(num):    if num == 0:        return CHARS[0]    res = []    while num:        num, rem = divmod(num, len(CHARS))  # len(CHARS) = 62        res.append(CHARS[rem])    return ''.join(reversed(res))print(encode(0))  # aprint(encode(61))  # 9print(encode(62))  # ba# num = 62# len(CHARS) = 62# num = num // len(CHARS) = 62 // 62 = 1# rem = num % len(CHARS) = 62 % 62 = 0# res= res.append(CHARS[rem]) # rews = res.append(CHARS[0]) = ['a']# num = num // len(CHARS) = 1 // 62 = 0# rem = num % len(CHARS) = 1 % 62 = 1# rews = res.append(CHARS[1]) = ['a', 'b']# ''.join(reversed(res) = ['b', 'a']\n\n自增 id 问题？数据库只有在插入时候才会有自增ID，所以这里还需要一个全局计数器，用来生成自增ID，这样就可以根据ID生成62进制串。使用 Redis incr可以非常容易实现一个计数器。\n5.生成短网址的过程request -&gt; redis incr的值 index -&gt; encode(index) -&gt; save mysql如果一个请求(request)过来时候，先去Redis 拿到 incr 值比如叫index, 然后把index转换成index串。最后把得到的值存储到数据库里面。\n.短网址服务的编码实现首先需要你安装MySQL数据库，只安装服务器端就行，安装的时候可以选择。安装Redis 非关系型数据库接下来是一些需要的Python插件安装： \n1234567891011121314151617181920212223# 安装flask(python3) C:\\Users\\allar\\system_design&gt;pip  install  -i  https://pypi.doubanio.com/simple/  --trusted-host pypi.doubanio.com  flask # 安装flask_mysqldb(python3) C:\\Users\\allar\\system_design&gt;pip install flask_mysqldb # 安装flask_redis(python3) C:\\Users\\allar\\system_design&gt;pip install flask-redis # 安装flask(python3) C:\\Users\\allar\\system_design&gt;pip  install  -i  https://pypi.doubanio.com/simple/  --trusted-host pypi.doubanio.com  flask # 安装flask_mysqldb(python3) C:\\Users\\allar\\system_design&gt;pip install flask_mysqldb # 安装flask_redis(python3) C:\\Users\\allar\\system_design&gt;pip install flask-redis # 安装requests(python3) C:\\Users\\allar\\system_design>pip install requests``` （1） 在数据库里面创建一个 short_url 表```sqlCREATE TABLE short_url (    id bigint unsigned NOT NULL AUTO_INCREMENT,    token varchar(10),    url varchar(2048),    created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,    PRIMARY KEY (`id`),    KEY `idx_token` (`token`));\n（2）使用 Flask 框架演示本系统实现\n代码里实现了短网址生成算法\n数据库使用 Mysql\n计数器使用 Redis\n代码实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import osfrom flask import Flask, jsonify, render_template, requestfrom flask_mysqldb import MySQL# from flask.ext.redis import FlaskRedisfrom flask_redis import FlaskRedisapp = Flask(__name__)app.config['MYSQL_USER'] = 'root'app.config['MYSQL_PASSWORD'] = '123456'app.config['MYSQL_DB'] = 'test'app.config['MYSQL_CUESORCLASS'] = 'DictCursor'mysql = MySQL(app)redis_store = FlaskRedis(app)CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"def encode(num):    '''10进制转化成62进制串'''    if num == 0:        return CHARS[0]    res = []    while num:        num, rem = divmod(num, len(CHARS))        res.append(CHARS[rem])    return ''.join(reversed(res))@app.route('/shorten', methods=['POST'])def shorten_url():    '''视图函数'''    # 获取页面长的url    long_url = request.json['url']    # 从Redis获取自增的index    index = int(redis_store.incr('SHORT_CNT'))    # 生成一个token，把一个index10进制数转化成62进制串    token = encode(index)    sql = \"INSERT INTO short_url(token, url) VALUES(%s, %s)\"    # 获取mysql连接    cur = mysql.connection.cursor()    cur.execute(sql, (token, long_url))    mysql.connection.commit()    # 构造短网址    short_url = 'https://short.com/' + token    return jsonify(url=short_url)  # 返回短网址的json数据@app.route('/')def index():    return render_template('index.html')if __name__ == '__main__':    app.run(debug=import osfrom flask import Flask, jsonify, render_template, requestfrom flask_mysqldb import MySQL# from flask.ext.redis import FlaskRedisfrom flask_redis import FlaskRedisapp = Flask(__name__)app.config['MYSQL_USER'] = 'root'app.config['MYSQL_PASSWORD'] = '123456'app.config['MYSQL_DB'] = 'test'app.config['MYSQL_CUESORCLASS'] = 'DictCursor'mysql = MySQL(app)redis_store = FlaskRedis(app)CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"def encode(num):    '''10进制转化成62进制串'''    if num == 0:        return CHARS[0]    res = []    while num:        num, rem = divmod(num, len(CHARS))        res.append(CHARS[rem])    return ''.join(reversed(res))@app.route('/shorten', methods=['POST'])def shorten_url():    '''视图函数'''    # 获取页面长的url    long_url = request.json['url']    # 从Redis获取自增的index    index = int(redis_store.incr('SHORT_CNT'))    # 生成一个token，把一个index10进制数转化成62进制串    token = encode(index)    sql = \"INSERT INTO short_url(token, url) VALUES(%s, %s)\"    # 获取mysql连接    cur = mysql.connection.cursor()    cur.execute(sql, (token, long_url))    mysql.connection.commit()    # 构造短网址    short_url = 'https://short.com/' + token    return jsonify(url=short_url)  # 返回短网址的json数据@app.route('/')def index():    return render_template('index.html')if __name__ == '__main__':    app.run(debug=1)\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"笔记本鲁大师","url":"https://bubbleboy11.github.io/2020/08/21/bi-ji-ben-lu-da-shi/","content":"——鲁大师 Build V5.1021.1300.108——\n电脑型号: 戴尔 Vostro 5370 笔记本电脑操作系统: Windows 10 64位\n  处理器: 英特尔 Core i5-8250U @ 1.60GHz 四核    主板: 戴尔 08X87Y    内存: 8 GB ( 海力士 DDR4 2400MHz )  主硬盘:  SK hynix SC311 SATA 256GB ( 256 GB / 固态硬盘 )    显卡: 英特尔 UHD Graphics 620 ( 128 MB / 戴尔 )  显示器: 奇美 CMN1371 ( 13.3 英寸  )    声卡: 瑞昱  @ 英特尔 High Definition Audio 控制器    网卡: 英特尔 Dual Band Wireless-AC 3165\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":[],"tags":[]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/kong-1/","content":"只有当破解所需的预期成本远远超出破解之后所获得的预期的时候，你的加密才是真正安全的。\n GPL 协议要求所有衍生作品以相同协议继续开源， MIT 协议则允许任意形式的使用，但是原作者不承担任何责任。同时，公开的源代码使得任何人都可以参与项目并作出贡献，为项目添砖加瓦。\n在我参与开源项目的过程中，我觉得我学到的最主要的内容就是团队协作的技巧。例如，版本管理工具 Git 的使用、统一的代码风格和良好的文档注释的意义、持续整合 (Continuous Integration, CI) 的意义与使用，以及与人交流沟通的技巧等。\n\n参与开源项目的方法与技巧Permalink在参与开源项目之前，首先要理解一点，开源项目是一个【项目】，所以参与方式是多种多样的。\n\n对于开源软件来说，最容易想到的方式自然是提交代码，比如 bug 修复、功能改进，或者代码中的测试项目；另一个，为项目完善文档和教程等也是一种非常有价值的贡献；同时，将项目资料翻译成其他语言可以帮助更多人参与进来。Transifex 是一个有名的开放协作翻译的平台，很多软件和网站都在利用它给用户提供参与翻译的机会；最后，如果你对前面几项都不感兴趣，你也可以为项目贡献一些周边资料，例如为其他用户解答问题，为项目反馈问题或提出建议等。这些都是开源项目常见的参与方式。\n那么，在参与开源项目的过程中，我们能为自己收获什么？\n最直接的，你获得了参与真实项目的实践经验；其次，你在项目中可以锻炼技能，也可以学到新的技能；参与开源项目的过程中，你可以学习到各种各样的宝贵知识；你可以很容易地向别人展示你的成果，就像我前面展示的一样；由于上面那个原因，参与开源项目的经历可以使你在人群中脱颖而出。很显然，如果你面对的 HR 或导师能够真真实实地看到你的作品或劳动成果，那么你就更容易获得他们给的机会。\n例如，我能得到今天在这里演讲的机会，就是因为我参与各种开源项目的经历，主办方可以真实看到并做出评价。\n参与开源项目能得到的收获看起来很诱人对不对？那么下面我就介绍一下具体的参与方式。\n发现自己的长处Permalink在准备参与之前，第一件事是看看自己擅长哪方面的事，有哪方面的技能。比如说，你很擅长将你的想法转化成代码；或者你擅长折腾软件，找出意想不到的 bug；或者你擅长把复杂的东西解释清楚；或者你对艺术和设计有自己独到的见解；或者你去过西方的很多国家，精通八国语言；或者你对于某些东西有不错的了解，能够帮助别人答疑解惑……\n找到自己的兴趣Permalink其次，你要找到一个你感兴趣的项目来参与。寻找的方向也有几种，比如\n你日常使用的软件；某天你意外看到的一个有趣的项目，比如 GitHub 首页右边栏随机推送的三个项目；网络上还会时不时的有一些号召大家参与开源项目的活动，比如 Hacktoberfest，以及另一个长期举行的 Up For Grabs；如果你有一个好点子，你也可以自己开始一个新项目。如果你决定加入一个现有项目的话，我建议先对这个项目做一些背景调查。\n首先最重要的一点，开源软件一定要有协议。同时由于开源项目的开放特性，如果有一份行为准则，那就更好了；其次你要判断项目的活跃程度，比如最近一次提交时间，以及项目维护者的提交频率；如果项目有一个活跃的社区，那绝对是一个加分项。活跃的社区通常会产生大量的 Issues 和 Pull Requests，所以这些活动你可以考虑也检查一下；最后，一个友好的社区和交流环境会让人在参与的过程中感到舒适。高效沟通Permalink在你参与项目的过程中，发生的最频繁的事件就是与其他人交流。为了提升交流效率，有几点值得注意：\n你应该自己做足够的研究，例如提问时不要问 “怎么写 1+1 的代码”，而 “1+1 为什么出来 3” 甚至都可能是个好点的问题；如果你真的要问 “1+1 为什么出来 3” 这样的问题，那么你最好能提供足够的信息让别人可以判断你的问题出在哪。同样对于其他讨论，也要确保别人有足够信息来复现你说的内容；在保证信息完整的时候尽可能保持简练，比如 “这个 1+1 等于 3 的代码是我下午在码头搬完砖后去星巴克喝咖啡的时候写的” 这样的信息最好就别提供了 :)对于公开的项目，最好能够保证讨论也是在公开的环境下进行的，除非有特别的保密需求，例如反馈安全方面的漏洞；如果你的观点和其他人不一致，请尊重他们。提交你的贡献之后Permalink当你提交了你的贡献之后，就是等待项目的维护者来检查和进行下一步处理了。这里也有几种情况\n没人理你，你的 Issue 或 PR 就那么挂在那里。这时候要么多等一会，要么再检查一下这个项目，是不是还在活跃维护的状态；如果有人对你的贡献提出了改进意见，说明你的提交有人来花时间看过了。你应该尊重别人，尽早响应别人提出的意见；也许有时候，项目维护者或者社区不认可你的提交，这时候也不要气馁，看看别人给出的评价和理由，作为自己的经验；如果你的贡献被采纳了，那么祝贺你。\n系统输入两个数字M、N，M为1-9的数字，N为系数。eg:输入 1 3，则需计算 1 11 111 的总和，即 123分析 1 = 1 * 10^0分析 11 = 1 + 1 * 10^1分析 111 = 1 + 1 * 10^1 + 1 * 10^2分析 2 = 2 * 10^0分析 22 = 2 + 2 * 10^1分析 222 = 2 + 22 + 2 * 10^2\n123456789101112131415161718192021222324def func():    M, N = map(int, input().split())    # input 1 3    sum_number = number = 0    for i in range(N):        number += M * 10 ** i        sum_number += number    print(sum_number)# M是1--9之间的数字，所以先入为主的将M定义为了数字，# 但其实如果将M认为是字符串。# 那么2 --&gt; 222 可以理解为int('2'*3)！这样思考后，题目是否变得更为简单了。def func2():    M, N = input().split()    print(sum([int(M * i) for i in range(1, int(N) + 1)]))if __name__ == '__main__':    func()    # input: 1 3    # output: 123    def func():    M, N = map(int, input().split())    # input 1 3    sum_number = number = 0    for i in range(N):        number += M * 10 ** i        sum_number += number    print(sum_number)# M是1--9之间的数字，所以先入为主的将M定义为了数字，# 但其实如果将M认为是字符串。# 那么2 --&gt; 222 可以理解为int('2'*3)！这样思考后，题目是否变得更为简单了。def func2():    M, N = input().split()    print(sum([int(M * i) for i in range(1, int(N) + 1)]))if __name__ == '__main__':    func()    # input: 1 3    # output: 123    # func2()\n\n\n1234567891011121314151617M = 1N = 3number = 0i = 0number = number + M * 10 ** inumber = 0 + 1 * 10 ** 0 = 1sum_number = sum_number + number sum_number = 0 + 1 = 1i = 1number = 1 + 1 * 10 ** 1 = 11sum_number = 1 + 11 = 12i = 2number = 11 + 1 * 10 ** 2 = 111sum_number = 12 + 111 = M = 1N = 3number = 0i = 0number = number + M * 10 ** inumber = 0 + 1 * 10 ** 0 = 1sum_number = sum_number + number sum_number = 0 + 1 = 1i = 1number = 1 + 1 * 10 ** 1 = 11sum_number = 1 + 11 = 12i = 2number = 11 + 1 * 10 ** 2 = 111sum_number = 12 + 111 = 123\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"系统设计","url":"https://bubbleboy11.github.io/2020/08/21/xi-tong-she-ji/","content":"系统设计(System Design)\n系统设计是一个定义系统架构、模块、接口和数据满足特定需求的过程。\n比如设计一个短网址服务、评论服务、Feed流系统、抢红包系统。\n微服务架构很多系统被按照业务拆分，需要单独设计一个系统服务。比如短网址服务一开始由于推特只能发140个字，然后很多时候贴一个很长网址就直接快把字符给沾满了，所以因为这个需求才诞生短网址服务，就是根据一个长度来生成一个短地址。现在很多网站如: 头条、微博、知乎都能见到类似形式的短网址。   \n\n在一个公司可能有很多不同部门不同的业务，不可能每个业务需要短网址服务就开发一套。这个时候就需要公司里提供一个供其它所有业务使用的一个短网址服务。\n系统设计的难点\n中高级工程师必经之路\n需要具有相关领域、算法的经验，有一定的架构设计能力。(Feed流推拉模型)\n熟悉后端技术组件，比如消息队列、缓存、数据库、各种Web框架等，需要熟悉这些组件使用场景甚至底层原理。\n具备文档撰写、流程图绘制、架构设计、编码实现等综合能力\n\n系统设计怎么答？\n完全没有思路的（很多毕业生对这种问题完全手足无措）\n有一定思路，但是回答没有重点\n能回答上来重点，但是思路不够清楚\n\n系统设计的要素\n使用场景和限制条件\n数据存储设计\n算法模块设计\n\n③ 如何回答系统设计题目？\n\n按照三个要素来回答\n问面试官：什么场景和条件下使用？（经常会遇到面试官上来就抛一句：如何设计一个短网址系统。问题虽然经典但其实他问的比较宽泛，就是你根本不知道在什么场景下什么条件下去使用，所以第一个要素就是需要搞清场景和使用条件）\n设计数据存储系统\n设计算法相关模块\n\n\n要素之一：场景和限制\n\n\n这个系统是在什么地方使用的？比如短网址系统提供给站内各种服务生成短网址\n限制条件：用户估计有多少？至少要能支撑多少用户（服务）\n估算并发 qps：峰值 qps 是多少？平均 qps 是多少？（qps就是每秒的查询请求量）\n\n\n要素二：数据存储设计数据库的选型，选型数据库以及怎么来去设计存储\n\n\n按照需求设计数据表，需要哪些字段，使用什么类型？数据增长规模\n数据库选型：是否需要持久化？使用关系型还是 NoSQL？\n如何优化？如何设计索引？是否可以使用缓存？\n\n\n要素之三：算法模块设计 算法解决问题的核心。\n\n\n需要哪些接口？接口如何设计\n使用什么算法或者模型？\n不同实现方式之间的优劣对比，如何取舍？比如有些方式是牺牲时间去换空间，有些可能牺牲空间换时间，这个时候就需要根据系统本身做权衡。\n\n4.针对中高级工程师，可能会问一些深入的问题（如何扩展、容错）\n\n用户多了，qps 高了如何处理？\n数据存储多了不够存了如何处理？\n故障如何处理？单点失败、多点失败、雪崩问题\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/suo-yin/","content":"索引是数据表中一个或者多个列进行排序的数据结构\n为什么需要索引？索引类似于书籍的目录，要想找到一本数的某个特定主题，需要先查找书的目录，定位对应的页码索引结构、存储引擎使用类似的方式进行数据查询，先去索引当中找到对应的值，然后根据匹配的索引找到对应的数据行\n为什么加了索引就查询快了没有加索引就是全表查询，加了索引，索引底层是保存在数据结构中，有二叉树，红黑树，hash表，B-Tree.我们现在的数据库里使用的索引底层的数据结构是B-tree比如我们想要将一个表里面的某一个字段作为索引，如果底层是二叉搜索树，那么字段是键，数据地址是值，以键值对的形式保存在二叉搜索树里面，以后拿键里面的值搜索的时候，直接从二叉搜索树里面找，找到以后就有地址了，拿地址从表里面找，那么就可以找到了。二叉搜索树的右边是比左边大，所以很快的。\n但是如果二叉树是极端的，不是平衡二叉树，是在一段排列的，所以即使是从索引里面获取，性能还是比较的低。\n红黑树的话，有自旋，所以不会出现极端，但是数据多的话，红黑树的高度是比较的高，不是我们想要的。我们希望高度是固定的，但是我们要放的数据可以全部的放进去。\n哈希表的话，在查找范围的时候是不可以执行的，所以还是不选择\nB+Tree是比较的好的，存储的数据比较多，高度是可以限定的，可以查找范围。\n索引对性能的影响大大减少服务器需要扫描的数据量，帮助服务器避免排序和临时表将随机I/O变顺序I/O大大提高查询检索速度，不良影响降低写的速度、占用磁盘\n索引的使用场景对于非常小的表，大部分情况下全表扫描效率更高中到大型表，索引非常有效特大型的表，建立和使用索引的代价将随之增长，可以使用分区技术来解决\nMysql的索引 每一个表里面都有一个聚簇索引，如果表里面有主键的话，根据主键生成索引，如果你没有设置主键，那么会根据unique的字段生成索引，或者都没有的话，那么就会根据行id生成索引\n索引的类型都是实现在存储引擎层的普通索引:最基本的索引，没有任何约束限制（CREATE INDEX）唯一索引:（CREATE UNIQUE INDEX）与普通索引类似，但是不同的是唯一索引有唯一性约束，要求索引列的值必须唯一、所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值,\n多列索引，使用多个列去创建索引，多列索引反应在B+Tree里面其实就是相当于B+Tree的key是由多个列的值组成的。主键索引（PRIMARY KEY），一个表只能有一个，特殊的唯一索引，不允许有空值，(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性、和实现级联操作（基本不用）。全文索引（FULLTEXT INDEX）：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索 （基本不用），InnoDB 不支持\n唯一索引与主键索引的区别一个表只能有一个主键索引，可以有多个唯一索引主键索引一定是唯一索引，唯一索引不是主键索引主键可以与外键构成参照完整性约束，防止数据不一致\n联合索引 组合索引也叫复合索引：将多个列组合在一起创建索引，可以覆盖多个列。*遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。同时作用于abc的组合，效果：缩短查询范围 where时的条件要按照建立索引的时候字段的排序方式\n12345678KEY(a, b, c)WHERE a = 1 AND b = 2 AND c = 3WHERE a = 1 AND b = 2WHERE a = 1#以上SQL语句可以用到索引WHERE b = 2 AND c = 3WHERE a = 1 AND c = 3KEY(a, b, c)WHERE a = 1 AND b = 2 AND c = 3WHERE a = 1 AND b = 2WHERE a = 1#以上SQL语句可以用到索引WHERE b = 2 AND c = 3WHERE a = 1 AND c = 3#以上SQL语句用不到索引，不能跳过前面的，没有连续\n\nMySQL索引的创建原则\n\n最适合索引的列是出现在经常被用作检索条件的字段上面，在 WHERE或ON子句中的列，连接子句中的列、经常用作表连接的字段经常出现在 order by， group by 之后的字段而不是出现在 SELECT关键字后的列，\n索引列的数据量很大，而且经常被查询的数据表，数据区分度越高\n对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间\n根据情况创建复合索引，复合索引可以提高查询效率\n避免创建过多索引，索引会额外占用磁盘空间，降低写操作效率\n主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用，提高查询效率\n\nNOT NULL 非空字段注意事项\n\ncolumn is null 列值为空可以使用索引，Mysql 很难对空值作查询优化。反应在B+树结构里面就是空值无法去作比较这个时候索引就利用不上了。（很多互联网公司的建表规范要求索引字段有默认值）\n区分度高，离散度大，作为索引的字段值尽量不要有大量相同的值。反应在B+树里面就是当很多字段是一样的时候说明B+树里面很多key是相同的，所以需要大量的去比较这样效率就比较低。（一般不推荐枚举值就几个字段去建索引）\n索引的长度不要太长(比较好费时间)，作为索引的时候在B+树里面作为一个key来存在的，主键索引一般使用自增的int值，因为int值很容易去比较，如果是字符串的时候去比较不同树之间结点key的时候，就需要做一个很长的比较。如果在字符串类型上面去做索引的话就一定要指定长度不能太长否则比较的时候就会耗费时间。索引什么时候失效？经常在编写代码时候出现慢查询问题，这说明很多时候索引没有使用对。记忆口诀：模糊匹配、类型隐转、最左匹配，这三种情况可能导致索引会失效。\n\n以%开头的LIKE语句，模糊搜索。索引没有办法去利用，因为B+树的key没有办法再去直接比较，可以使用全文索引出现隐式类型转换，需要注意参数类型跟SQL查询时候类型是不是一样的，因为两个类型不同没法比较（在 Python 这种动态语言查询中需要注意）没有满足最左前缀原则（想想为什么是最左匹配？最左前缀原则，如果是多列索引的时候需要满足最左前缀才能利用上索引。\n对于InnoDB引擎它的辅助索引，它的叶结点存储的是主键的值。然后再通过主键找到对应的数据。其实这是两个过程，这就是为什么在InnoDB引擎里面使用辅助索引要比直接使用主键索引慢一些的原因。辅助索引先找到主键以后再根据主键找到数据\n例如：多列索引有三个值a, b, c三个字段，如(a, b, c)。有两个key值(1, 2, 3) 和 (1, 2, 4)作比较，先比较第一个都是1相等，再比交第二个都是2相等，最后比较第三个3小于4 ，这时候就知道二叉树往哪个方向。假如不满足最左匹配就没有办法直接比较，如 (a,b,c), (a,b), (a)，这三种情况下都是可以使用索引的，但是(b,c)就不可以，因为连第一个比较的基准都没有，根本没有办法再往后比较了）三种情况总结成一句话，当Mysql B+树的key没有办法去比较的时候，索引就会失效。\n\n如果 MySQL估计使用索引比全表扫描更慢，会放弃使用索引例如：表中只有100条数据左右。对于SQL语句WHERE id &gt; 1 AND id &lt; 100，MySQL会优先考虑全表扫描。\n\n如果or前的条件中的列有索引，后面的没有，索引都不会被用到\n\n列类型是字符串，查询时一定要给值加引号，否则索引失效例如：列name varchar(16)，存储了字符串”100”WHERE name = 100;以上SQL语句能搜到，但无法用到索引。\n\n\n创建索引的语法：首先创建一个表：\n12345create table 表名(    ….    create table 表名(    ….    index [索引名] (字段名)    ….);\n\n索引名一般是：表名_字段名创建单个索引的语法：法一：\n1create index 索引名 create index 索引名 on 表名 (字段);\n法二：\n1alter table 表名 add alter table 表名 add index [索引名] (字段);\n\n给id创建索引：\n1CREATE INDEX table_id on table(CREATE INDEX table_id on table(id);\n\n创建联合索引的语法：\n1CREATE INDEX 索引名 on 表名（字段名1，字段名CREATE INDEX 索引名 on 表名（字段名1，字段名2）\n\n其中index还可以替换成unique，primary key，分别代表唯一索引和主键索引\nshow index from  表名;\n删除索引：\n1drop index 索引名 drop index 索引名 on 表名;\n\n\n\n聚集还是非聚集指的是B+Tree 叶结点存的是指针还是数据记录\n\nMyISAM索引和数据分离，使用的是非聚集索引在叶结点里面存储的是指向数据的指针，如叶结点5中存储的0x6A，指针指向的数据的表文件也就是数据文件，这里myisam_table.MYD数据文件和myisam_table.MYI索引文件是两个文件\n1234CREATE TABLE myisam_table (    `id` INTEGER PRIMARY KEY,     title VARCHAR(80)) CREATE TABLE myisam_table (    `id` INTEGER PRIMARY KEY,     title VARCHAR(80)) ENGINE = MYISAM;   \n\nInnoDB引擎 数据文件就是索引文件，数据和索引存储在同一个文件innodb_table.idb的b+tree上面，Innodb中的主键索引就是聚集索引\n叶结点即存储 主键 同时也存储 数据表里面的内容，如叶结点15, 存储主键34和数据Bob。\n12345CREATE TABLE innodb_table (    `id` INTEGER PRIMARY KEY,    `url_md5` char(32),    KEY `idx_url` (`url_md5`)) ENGINE = CREATE TABLE innodb_table (    `id` INTEGER PRIMARY KEY,    `url_md5` char(32),    KEY `idx_url` (`url_md5`)) ENGINE = InnoDB;\n\nInnodb和myisam的区别InnoDB支持事务，MyISAM不支持. InnoDB支持外键，而MyISAM不支持. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。InnoDB不保存表的具体行数，而MyISAM用一个变量保存了整个表的行数InnoDB不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；5.7 已经支持\n以下语句是否会应用索引？\n123SELECT FROM users WHERE YEAR(adddate) &lt; SELECT FROM users WHERE YEAR(adddate) &lt; 2007;\n不会，因为只要列涉及到运算，MySQL就不会使用索引。\n以下三条sql 如何建索引，只建一条怎么建？1234WHERE a=1 AND b=1WHERE b=1WHERE WHERE a=1 AND b=1WHERE b=1WHERE b=1 ORDER BY time DESC\n以顺序b,a,time建立联合索引，\n1CREATE INDEX table1_b_a_time ON index_test01(b,a,CREATE INDEX table1_b_a_time ON index_test01(b,a,time)。\n\nmysql优化器会自动调整where条件中字段的前后顺序，对于上面的第一条sql，如果建立索引为idx_b_a(b,a)也是可以用到索引的，不过建议where后的字段顺序和联合索引保持一致，养成好习惯。\n考察的是组合索引和索引排序，至少得建两个吧，idx_a_b(a,b)和idx_b_time(b,time)已知存在下例索引  KEY companyIsdelete (companyId,isDelete)我交换顺序后的解析计划如下，还是用到了该索引 \n123456789101112mysql&gt; explain select * from DB_Message9 where isDelete=1 and companyId=1234\\G*************************** 1.row***************************           id: 1  select_type: SIMPLE        table: DB_Message9         type: refpossible_keys: companyIsdelete,companyAnswerUp,customertype,sender,sender2,noAssign          key: companyIsdelete      key_len: 6          ref: const,const         rows: 1        Extra: NULL1 row in set (mysql&gt; explain select * from DB_Message9 where isDelete=1 and companyId=1234\\G*************************** 1.row***************************           id: 1  select_type: SIMPLE        table: DB_Message9         type: refpossible_keys: companyIsdelete,companyAnswerUp,customertype,sender,sender2,noAssign          key: companyIsdelete      key_len: 6          ref: const,const         rows: 1        Extra: NULL1 row in set (0.00 sec)\n\n这三条查询中,b字段的查询频率最高,所以b字段要加入到索引中,多列索引中,索引的列顺序很重\n问题19：有A(id,sex,par,c1,c2),B(id,age,c1,c2)两张表，其中A.id与B.id关联，现在要求写出一条SQL语句，将B中age&gt;50的记录的c1,c2更新到A表中同一记录中的c1,c2字段中考点分析这道题主要考察的是MySQL的关联UPDATE语句延伸考点：\nMySQL的关联查询语句MySQL的关联UPDATE语句针对刚才这道题，答案可以是如下两种形式的写法：\n1UPDATE A,B SET A.c1 = B.c1, A.c2 = B.c2 UPDATE A,B SET A.c1 = B.c1, A.c2 = B.c2 WHERE A.id = B.id\n1UPDATE A INNER JOIN B ON A.id=B.id UPDATE A INNER JOIN B ON A.id=B.id SET A.c1 = B.c1,A.c2=B.c2\n再加上B中age&gt;50的条件：\n1UPDATE A,B set A.c1 = B.c1, A.c2 = B.c2 WHERE A.id = B.id and B.age &gt; UPDATE A,B set A.c1 = B.c1, A.c2 = B.c2 WHERE A.id = B.id and B.age &gt; 50;\n1UPDATE A INNER JOIN B ON A.id = B.id set A.c1 = B.c1,A.c2 = B.c2 WHERE B.age &gt; UPDATE A INNER JOIN B ON A.id = B.id set A.c1 = B.c1,A.c2 = B.c2 WHERE B.age &gt; 50\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"线程进程","url":"https://bubbleboy11.github.io/2020/08/21/xian-cheng-jin-cheng/","content":"进程对运行时程序的封装，是系统资源调度和分配的基本单位，是操作系统的并行机制。\n\n每个进程都拥有独立的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据进程间不共享数据，系统调度例如：PC上QQ程序、Word程序，它们都是独立运行，是两个进程。\n操作系统管理其上所有进程的执行，并为这些进程合理地分配时间\n进程也可通过派生（fork或spawn）新的进程来执行其他任务进程模块介绍\n我们使用multiprocessing实现多进程代码\n用multiprocessing.Process创建进程\nstart）启动进程\njoin）挂起进程\nos.getpid0获得进程的ID\n\n线程线程是进程的子任务，cpu&nbsp;调度和分配的基本单位，执行程序的最小单元，实现进程内并发(或并行)一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存例如：同时建立5个Word文档可以理解为线程，它们之间共享Word资源 ( 内存、CPU和Word程序中提供方法等)一个进程可以有多个线程，多个线程也可以并发执行。\n\n在同一个进程下执行，并共享相同的上下文、共享资源，系统调度\n一个进程中的各个线程与主线程共享同一片数据空间\n线程包括开始、执行顺序和结束三部分\n它可以被抢占（中断）和临时挂起（也称为睡眠）——让步\n\n并发\n\n等同于并行处理？并行和并发区别：·是一种属性——程序、算法或问题的属性·并行只是并发问题的可能方法之一，是真正的多核CPU去执行，对于Python没有办法充分利用多个CPU只能通过并发来执行，就是看似是并行其实是&nbsp;&nbsp;通过CPU的时间片轮转来一个一个切任务，其实还是同一时刻只能执行一个线程，只不过对外面来说它营造了一种同时执行的效果。\n\n如果两个事件互不影响，则两个事件是并发的\n\n\n什么是线程安全？线程是因为共享进程的数据所以才会出现线程安全的问题。多个线程同时去修改数据，比如两个线程都分别去修改数据，一个线程把另一个线程的修改的数据给覆盖，这样就会出现线程安全问题。就是一个线程的修改被另一个线程的修改给覆盖掉了。如果想安全的去访问数据就需要一些机制，如锁机制，当一个进程访问的时候不让别的进程访问这样就安全了。\n Python 哪些操作是线程安全的？\n\n一个操作可以在多线程环境中安全使用，获取正确的结果\n线程安全的操作好比线程是顺序执行而不是并发执行的( i += 1)\n一般如果涉及到 写/修改 操作需要考虑如何让多个线程安全访问数据\n\n2.什么时候要保证线程安全？一般去读数据不会考虑线程安全的问题，一旦涉及到写操作、修改操作就需要保证如何多线程去修改数据并且保证结果是正确的，这个时候就需要保证线程安全。\n3.线程同步的方式 为了保护线程安全，需要了解的同步方式\n\n互斥量(锁)：通过互斥机制防止多个线程同时访问公共资源\n信号量(Semphare)：控制同一时刻多个线程访问同一资源的线程数\n事件(信号)：通过通知的方式保持多个进程同步进程：独立数据空间，进程间不共享数据，系统调度。\n\n线程：执行程序最小单元，进程内线程间共享资源，系统调度。\n（1）线程是调度的基本单位 ，进程是资源分配的基本单位\n（2）进程之间互相独立，通信困难而且消耗资源大，可以使用管道，信号，套接字，共享内存，消息队列等方法通信。线程由于共享同一进程，所以通信简单而且消耗资源少，可以使用读写进程数据段来通信。\n（3）由于进程之间互相独立，进程切换，需要保持上下文的一致，所以切换满；相比较线程由于共享同一线程的上下文，所以要快。\nPython中如何使用多线程实现一个线程\n\n用threading模块代替thread模块\n用threading.Tread 类用来创建线程\n\nThread 对象数据属性name线程名ident线程的标识符daemon 布尔标志，表示这个线程是否是守护线程\nThread 对象方法属性  描述\n实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs123456789101112131415161718192021222324252627282930313233343536```start()```开始执行该线程run() 定义线程功能的方法（通常在子类中被应用开发者重写）join直至启动的线程终止之前一直挂起；除非给出了（timeout=None）timeout（秒），否则会一直阻塞getName（）返回线程名setName（name）设定线程名isAlivel/is alive0布尔标志，表示这个线程是否还存活isDaemon（）如果是守护线程，则返回True；否则，返回FalsesetDaemon() 把线程的守护标志设定为布尔值 daemonic（必须在线程start()之前调用）注意: 多线程中start() 和 join() 要分开,否则join会让原本交替执行的线程变成线程顺序执行即原本是 线程A 和 线程B 抢占执行,但是strat()和join() 一起写就是编程先执行完线程A再执行线程B多线程实现### 为什么有了GIL还要关注线程安全```pythonimport threading n = [0] def foo():    n[0] = n[0] + 1    n[0] = n[0] + 1 threads = []for i in range(5000):    t = threading.Thread(target=foo)    threads.append(t) for t in threads:    t.start() print(n)# 大部分结果：[2 * 5000 = 10000]。但其中出现了[9998]结果# 这段代码并不是线程安全的，有些线程加1还没保存时候，它的这个结果被其他线程给覆盖了。# 说明：python里面也需要关注线程安全的问题。\nPython中什么操作才是原子的？一步到位的执行完的操作。\n一个操作如果是一个字节码指令就可以完成就是原子的\n原子的是可以保证线程安全的\n使用 dis模块的 dis 操作来分析字节码代码一：原子操作12345678910111213141516import dis def update_list(L):    L[0] = 1     # 原子操作！不用担心线程安全问题 dis.dis(update_list) # STORE_SUBSCR 赋值为1操作只有一次字节码操作，单字节码操作\"\"\"  4           0 LOAD_CONST               1 (1)              2 LOAD_FAST                0 (L)              4 LOAD_CONST               2 (0)              6 STORE_SUBSCR             # 单字节码操作，线程安全              8 LOAD_CONST               0 (None)             10 RETURN_VALUEimport dis def update_list(L):    L[0] = 1     # 原子操作！不用担心线程安全问题 dis.dis(update_list) # STORE_SUBSCR 赋值为1操作只有一次字节码操作，单字节码操作\"\"\"  4           0 LOAD_CONST               1 (1)              2 LOAD_FAST                0 (L)              4 LOAD_CONST               2 (0)              6 STORE_SUBSCR             # 单字节码操作，线程安全              8 LOAD_CONST               0 (None)             10 RETURN_VALUE\"\"\"\n代码二：非原子操作不是线程安全的1234567891011121314151617181920import disdef incr_list(L1):    L1[0] += 1   # 线程不安全！！！不是原操作    dis.dis(incr_list) # 需要多个字节码操作如BINARY_SUBSCR、INPLACE_ADD，# 有可能在线程执行过程中切到其它线程''' 19           0 LOAD_FAST                0 (L1)              2 LOAD_CONST               1 (0)              4 DUP_TOP_TWO              6 BINARY_SUBSCR              8 LOAD_CONST               2 (1)             10 INPLACE_ADD             12 ROT_THREE             14 STORE_SUBSCR             16 LOAD_CONST               0 (None)             18 RETURN_VALUEimport disdef incr_list(L1):    L1[0] += 1   # 线程不安全！！！不是原操作    dis.dis(incr_list) # 需要多个字节码操作如BINARY_SUBSCR、INPLACE_ADD，# 有可能在线程执行过程中切到其它线程''' 19           0 LOAD_FAST                0 (L1)              2 LOAD_CONST               1 (0)              4 DUP_TOP_TWO              6 BINARY_SUBSCR              8 LOAD_CONST               2 (1)             10 INPLACE_ADD             12 ROT_THREE             14 STORE_SUBSCR             16 LOAD_CONST               0 (None)             18 RETURN_VALUE'''\n\n3.非原子的操作不是线程安全的，通过加锁来保证线程安全。通过使用GIL这样简单的锁机制可以非常方便去实现多线程情况下保护同一个对象，防止它被多个线程同时去修改。以下是编写线程安全的代码示例：\n\n1234lock = Lock() # 创建一个锁对象lock.acquire()  # 获得锁...lock.release() lock = Lock() # 创建一个锁对象lock.acquire()  # 获得锁...lock.release() # 释放锁\n使用 with 123lock = Lock()lock = Lock()with lock:    ...\n\n\n\n123456789101112131415161718192021import threading lock = threading.Lock()     # 定义锁 n = [0] def foo():    with lock:  # 添加锁，当前锁持有，其他线程不能同时执行操作，保证当前只有一个线程在执行修改操作，保证线程安全        n[0] = n[0] + 1        n[0] = n[0] + 1 threads = []for i in range(5000):    t = threading.Thread(target=foo)    threads.append(t) for t in threads:         t.start() print(n)import threading lock = threading.Lock()     # 定义锁 n = [0] def foo():    with lock:  # 添加锁，当前锁持有，其他线程不能同时执行操作，保证当前只有一个线程在执行修改操作，保证线程安全        n[0] = n[0] + 1        n[0] = n[0] + 1 threads = []for i in range(5000):    t = threading.Thread(target=foo)    threads.append(t) for t in threads:         t.start() print(n)# 输出结果： [10000]\n\n1234567891011121314import threading def show(i):    print(\"This is Thread \", i) for i in range(5):    t = threading.Thread(target=show, args=(i, ))    t.start()# 输出结果：# This is Thread  0# This is Thread  1# This is Thread  2# This is Thread  3import threading def show(i):    print(\"This is Thread \", i) for i in range(5):    t = threading.Thread(target=show, args=(i, ))    t.start()# 输出结果：# This is Thread  0# This is Thread  1# This is Thread  2# This is Thread  3# This is Thread  4\n\n2.Python中如何使用多进程多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大Python有GIL，可以用多进程实现 cpu 密集程序，避免 GIL 的影响multiprocessing 多进程模块Multiprocessing.Process 类实现多进程\n多进程1234567891011121314151617181920import multiprocessing def fib(n):    ''' worker function'''  # 斐波那契数列    if n &lt;= 1:        return 1    return fib(n-1) + fib(n-2) if __name__ == '__main__':    jobs = []    for i in range(10, 20):        p = multiprocessing.Process(target=fib, args=(i,))        jobs.append(p)        p.start()    print(jobs)# 输出结果：# [&lt;Process(Process-1, started)&gt;, &lt;Process(Process-2, started)&gt;, &lt;Process(Process-3, started)&gt;,# &lt;Process(Process-4, started)&gt;, &lt;Process(Process-5, started)&gt;, &lt;Process(Process-6, started)&gt;,# &lt;Process(Process-7, started)&gt;, &lt;Process(Process-8, started)&gt;, &lt;Process(Process-9, started)&gt;,import multiprocessing def fib(n):    ''' worker function'''  # 斐波那契数列    if n &lt;= 1:        return 1    return fib(n-1) + fib(n-2) if __name__ == '__main__':    jobs = []    for i in range(10, 20):        p = multiprocessing.Process(target=fib, args=(i,))        jobs.append(p)        p.start()    print(jobs)# 输出结果：# [&lt;Process(Process-1, started)&gt;, &lt;Process(Process-2, started)&gt;, &lt;Process(Process-3, started)&gt;,# &lt;Process(Process-4, started)&gt;, &lt;Process(Process-5, started)&gt;, &lt;Process(Process-6, started)&gt;,# &lt;Process(Process-7, started)&gt;, &lt;Process(Process-8, started)&gt;, &lt;Process(Process-9, started)&gt;,# ]\n\n123456789101112131415161718from multiprocessing import Process def foo(i):    print(\" This is Process \", i) def main():       for i in range(5):        p=Process(target=foo, args=(i, ))        p.start()    if __name__ == '__main__':    main() # 输出结果：# This is Process  1# This is Process  0# This is Process  2# This is Process  3from multiprocessing import Process def foo(i):    print(\" This is Process \", i) def main():       for i in range(5):        p=Process(target=foo, args=(i, ))        p.start()    if __name__ == '__main__':    main() # 输出结果：# This is Process  1# This is Process  0# This is Process  2# This is Process  3# This is Process  4\n\nPython实现协程\n1234567891011121314151617181920212223# 协程import gevent def foo():    print(\"start_foo\")    gevent.sleep(2)    print(\"end_foo\") def bar():    print(\"start_bar\")    gevent.sleep(0)    print(\"end_bar\") gevent.joinall([    gevent.spawn(foo),    gevent.spawn(bar)])# 输出结果：#       start_foo#              start_bar#              end_bar# 协程import gevent def foo():    print(\"start_foo\")    gevent.sleep(2)    print(\"end_foo\") def bar():    print(\"start_bar\")    gevent.sleep(0)    print(\"end_bar\") gevent.joinall([    gevent.spawn(foo),    gevent.spawn(bar)])# 输出结果：#       start_foo#              start_bar#              end_bar#              end_foo\n\n进程间通信的方式Inter-Process Communication 进程间传递信号或者数据① 管道 / 匿名管道 / 有名管道 (pipe)管道：半双工通信方式，数据单项流动，父子进程间。(类似单向通车道)命名管道：半双工通信方式，无亲缘关系进程间通信。\n② 信号(Signal)：比较复杂的通信方式，通知进程某个事件已经发生。例如：短跑比赛发出的起始枪声。比如用户使用Ctrl + c 产生 SIGINT 程序终止信号。\n③ 消息队列 (Message)：消息链表，存放在内核中由消息队列标识符标识。\n④ 共享内存(share memory)：映射一段能被多个进程可访问的内存。\n⑤ 信号量(Semaphore)：是计数器，锁机制，控制多进程对资源访问。例如：如果其中一个进程A访问资源，那么会对计数进行加1使用完之后就会对计数减1，其它进程看到计数为0就知道可以使用该资源了。\n⑥ 套接字(socket) ：最常用的方式，我们的 web应用都是这种方式\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140'''1.多进程的优势：为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。2.查看线程数：threading.enumerate()函数便可以看到当前线程的数量。3.查看当前线程的名字:threading.current_thread()可以看到当前线程的信息。4.类可以继承 threading.Thread'''# import threading# import time## class CodingThread(threading.Thread):#     def run(self):#         for x in range(3):#             print('正在写脚本:%s'%threading.current_thread())#             time.sleep(1)## class ModelThread(threading.Thread):#     def run(self):#         for x in range(3):#             print('正在创建模型：%s'%threading.current_thread())#             time.sleep(1)## # 主线程入口# def main():#     t1 = CodingThread()#     t2 = ModelThread()##     t1.start()#     t2.start()### if __name__ == '__main__':#     main()# 多线程共享全局变量的问题：'''多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。'''# import threading# VALUES = 0# 全局变量使用线程时,避免数据不出现乱序，则加上锁# gLock = threading.Lock()## def get_ticket():#     global VALUES#     # 加锁#     gLock.acquire()#     for x in range(100000):#         VALUES += 1#     # 解锁#     gLock.release()#     print('VALUES:%d' % VALUES)## def main():#     for x in range(3):#         t = threading.Thread(target=get_ticket)#         t.start()# 应该打印出来是: 100000,200000,300000# 实际打印出来是: 100000,124976,224976# 所有使用到threading.Lock'''加上锁后返回的值：VALUES:100000VALUES:200000VALUES:300000'''# if __name__ == '__main__':#     main()# Lock版本生产者和消费者模式：'''生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。使用threading.Lock锁实现的“生产者与消费者模式”的一个例子：'''import threadingimport randomimport timegMoney = 1000glock = threading.Lock()# 记录生产者生产的次数，达到10次就不再生产gtime = 0# 生产者class Producer(threading.Thread):    def run(self):        global gMoney        global gtime        while True:            Money = random.randint(100,1000)            glock.acquire()            if gtime &gt;= 10:                # 解锁返回                glock.release()                break            gMoney += Money            print('%s存入了%d元钱，还剩%d元钱'%(threading.current_thread(),Money,gMoney))            time.sleep(0.5)            gtime += 1            glock.release()# 消费者class Consumer(threading.Thread):    def run(self):        global gMoney        global gtime        while True:            Money = random.randint(100, 1000)            glock.acquire()            if gMoney &gt; Money:                gMoney -= Money                print('%s消费了%d元钱，还剩%d元钱' % (threading.current_thread(), Money, gMoney))                time.sleep(0.5)            else:                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下                if gtime &gt;= 10:                    glock.release()                    break                print('%s消费了%d元钱，还剩%d元钱，不足！！！' % (threading.current_thread(), Money, gMoney))            glock.release()def main():    for x in range(3):        c1 = Consumer(name='消费者线程数%s'%x)        c1.start()    for x in range(5):        p1 = Producer(name='生产者线程数%s'%x)        p1.start()if __name__ == '''1.多进程的优势：为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。2.查看线程数：threading.enumerate()函数便可以看到当前线程的数量。3.查看当前线程的名字:threading.current_thread()可以看到当前线程的信息。4.类可以继承 threading.Thread'''# import threading# import time## class CodingThread(threading.Thread):#     def run(self):#         for x in range(3):#             print('正在写脚本:%s'%threading.current_thread())#             time.sleep(1)## class ModelThread(threading.Thread):#     def run(self):#         for x in range(3):#             print('正在创建模型：%s'%threading.current_thread())#             time.sleep(1)## # 主线程入口# def main():#     t1 = CodingThread()#     t2 = ModelThread()##     t1.start()#     t2.start()### if __name__ == '__main__':#     main()# 多线程共享全局变量的问题：'''多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。'''# import threading# VALUES = 0# 全局变量使用线程时,避免数据不出现乱序，则加上锁# gLock = threading.Lock()## def get_ticket():#     global VALUES#     # 加锁#     gLock.acquire()#     for x in range(100000):#         VALUES += 1#     # 解锁#     gLock.release()#     print('VALUES:%d' % VALUES)## def main():#     for x in range(3):#         t = threading.Thread(target=get_ticket)#         t.start()# 应该打印出来是: 100000,200000,300000# 实际打印出来是: 100000,124976,224976# 所有使用到threading.Lock'''加上锁后返回的值：VALUES:100000VALUES:200000VALUES:300000'''# if __name__ == '__main__':#     main()# Lock版本生产者和消费者模式：'''生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。使用threading.Lock锁实现的“生产者与消费者模式”的一个例子：'''import threadingimport randomimport timegMoney = 1000glock = threading.Lock()# 记录生产者生产的次数，达到10次就不再生产gtime = 0# 生产者class Producer(threading.Thread):    def run(self):        global gMoney        global gtime        while True:            Money = random.randint(100,1000)            glock.acquire()            if gtime &gt;= 10:                # 解锁返回                glock.release()                break            gMoney += Money            print('%s存入了%d元钱，还剩%d元钱'%(threading.current_thread(),Money,gMoney))            time.sleep(0.5)            gtime += 1            glock.release()# 消费者class Consumer(threading.Thread):    def run(self):        global gMoney        global gtime        while True:            Money = random.randint(100, 1000)            glock.acquire()            if gMoney &gt; Money:                gMoney -= Money                print('%s消费了%d元钱，还剩%d元钱' % (threading.current_thread(), Money, gMoney))                time.sleep(0.5)            else:                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下                if gtime &gt;= 10:                    glock.release()                    break                print('%s消费了%d元钱，还剩%d元钱，不足！！！' % (threading.current_thread(), Money, gMoney))            glock.release()def main():    for x in range(3):        c1 = Consumer(name='消费者线程数%s'%x)        c1.start()    for x in range(5):        p1 = Producer(name='生产者线程数%s'%x)        p1.start()if __name__ == '__main__':    main()\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/zu-he-he-ji-cheng-qu-bie/","content":"优先使用组合而非继承\n\n组合是使用其他的类实例作为自己的一个属性（Has-a 关系）\n\n子类继承父类的属性和方法（Is a 关系）\n\n优先使用组合保持代码简单\n如果给一个类想扩充功能可以通过组合或者继承方式。\n\n\n（1）实现 stack/queue 中就使用到了组合\n1234567891011121314from collections import deque class Stack(object):     # 使用组合的例子    def __init__(self):        self._deque = deque()   # has a deque()             def push(self, value):         return self._deque.append(value)              def pop(self):         return self._deque.pop()               def empty(self):          return len(self._deque) == from collections import deque class Stack(object):     # 使用组合的例子    def __init__(self):        self._deque = deque()   # has a deque()             def push(self, value):         return self._deque.append(value)              def pop(self):         return self._deque.pop()               def empty(self):          return len(self._deque) == 0\n\n2.类变量和实例变量的区别\n\n类变量由所有实例共享\n实例变量由实例单独享有，不同实例之间不影响\n当我们需要在一个类的不同实例之间共享变量的时候使用类变量1234567891011121314151617181920class Person:    Country = 'China'     # 类变量        def __init__(self, name):        self.name = name    # 实例变量/实例属性        def print_name(self):        print(self.name) laozhao = Persion('laozhao')laowang = Persion('laowang')laozhao.print_name()laowang.print_name()print(laozhao.Country)print(laowang.Country)# 输出结果：# laozhao# laowang# Chinaclass Person:    Country = 'China'     # 类变量        def __init__(self, name):        self.name = name    # 实例变量/实例属性        def print_name(self):        print(self.name) laozhao = Persion('laozhao')laowang = Persion('laowang')laozhao.print_name()laowang.print_name()print(laozhao.Country)print(laowang.Country)# 输出结果：# laozhao# laowang# China# China\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"结构型模式之代理模式与适配器模式","url":"https://bubbleboy11.github.io/2020/08/21/jie-gou-xing-mo-shi-zhi-dai-li-mo-shi-yu-gua-pei-qi-mo-shi/","content":"代理模式（Proxy）\n把一个对象的操作代理到另一个对象\n如：实现的 Stack/Queue，把操作代理到 deque\n通常使用 has-a 组合关系1234567891011121314from collections import deque class Stack(object):     # 通过 _deque 代理使用 deque中的方法    def __init__(self):        self._deque = deque()   # has a deque()             def push(self, value):         return self._deque.append(value)              def pop(self):         return self._deque.pop()               def empty(self):          return len(self._deque) == from collections import deque class Stack(object):     # 通过 _deque 代理使用 deque中的方法    def __init__(self):        self._deque = deque()   # has a deque()             def push(self, value):         return self._deque.append(value)              def pop(self):         return self._deque.pop()               def empty(self):          return len(self._deque) == 0\n这里实现栈的时候，有个成员 _deque 它是实例化的 deque()。如：实现push()方法时候，我们把它代理到了 _deque.apeend()方法；实现pop()方法的时候，我们把它代理到 _deque.pop()方法。\n\n适配器模式(Adapter)\n把不同对象的接口适配到同一个接口\n就像一个多功能充电头，可以给不同的电器充电，充当了适配器\n当我们需要给不同的对象统一接口的时候可以使用适配器模式1234567891011121314151617181920212223242526272829303132333435363738394041# 适配器模式的例子class Dog(object):  # 定义Dog类    def __init__(self):        self.name = \"Dog\"    def bark(self):        return \"woof!\"class Cat(object):  # 定义Cat类    def __init__(self):        self.name = \"Cat\"    def meow(self):        return \"meow!\"class Adapter:  # 建立适配器类来统一 Dog和Cat 接口    def __init__(self, obj, **adapted_methods):  # 接收一个适配器方法        \"\"\" 我们在对象的dict中设置适配器方法 \"\"\"        self.obj = obj        self.__dict__.update(adapted_methods)  # 在适配器里面更新传入的方法    def __getattr__(self, attr):        \"\"\" 所有非适配调用都传递给对象 \"\"\"        return getattr(self.obj, attr)objects = []  # 建立对象列表dog = Dog()  # 初始化Dog类# dog对象加上适配器类，make_noise方法设置成狗叫dog.bark方法objects.append(Adapter(dog, make_noise=dog.bark))cat = Cat()# cat对象加上适配器类，make_noise方法设置成猫叫cat.meow方法objects.append(Adapter(cat, make_noise=cat.meow))for obj in objects:    print(\"A {0} goes {1}\".format(obj.name, obj.make_noise()))    # 然后可以使用统一接口为make_noise，如果dog调用狗吠，如果cat调用猫叫# 输出结果：# A Dog goes woof!# 适配器模式的例子class Dog(object):  # 定义Dog类    def __init__(self):        self.name = \"Dog\"    def bark(self):        return \"woof!\"class Cat(object):  # 定义Cat类    def __init__(self):        self.name = \"Cat\"    def meow(self):        return \"meow!\"class Adapter:  # 建立适配器类来统一 Dog和Cat 接口    def __init__(self, obj, **adapted_methods):  # 接收一个适配器方法        \"\"\" 我们在对象的dict中设置适配器方法 \"\"\"        self.obj = obj        self.__dict__.update(adapted_methods)  # 在适配器里面更新传入的方法    def __getattr__(self, attr):        \"\"\" 所有非适配调用都传递给对象 \"\"\"        return getattr(self.obj, attr)objects = []  # 建立对象列表dog = Dog()  # 初始化Dog类# dog对象加上适配器类，make_noise方法设置成狗叫dog.bark方法objects.append(Adapter(dog, make_noise=dog.bark))cat = Cat()# cat对象加上适配器类，make_noise方法设置成猫叫cat.meow方法objects.append(Adapter(cat, make_noise=cat.meow))for obj in objects:    print(\"A {0} goes {1}\".format(obj.name, obj.make_noise()))    # 然后可以使用统一接口为make_noise，如果dog调用狗吠，如果cat调用猫叫# 输出结果：# A Dog goes woof!# A Cat goes meow!\n  无论是狗这个类还是猫这个类，我们都统一使用make_noise方法来去调用它的不同狗吠dog.bark和猫叫cat.meow这种方法。  适配器模式作用：把不同的类型，然后把他们统一成一个接口\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/ji-cheng/","content":"继承可以把父类的所有功能都直接拿过来，不能选择性继承，方法重写、覆盖（override）：如果从父类继承的方法不能满足子类的需求，可以在子类重写你父类的方法\n当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类、派生类（Subclass、derived class），而被继承的class称为基类、父类或超类（Base class、Super class）。\n子类的定义class 子类(父类):    pass建议：一个文件夹只写一个类，那么只需在子类文件上写from 文件 import 父类多继承：一个子类继承多个父类，class 子类(父类1，父类2):注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索，默认调用的是在括号中排前的父类的方法。即方法在子类中未找到时，从左到右查找父类中是否包含方法，\n如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。子类不重写 init__，实例化子类时，会自动调用父类定义的 __init__。如果重写了__init ，实例化子类，默认不会调用父类已经定义的 init__，class 子类(父类1，父类2):    def __init(self,子类形参，父类形参):     父类名1.方法名(self,父类形参1)     父类名2.方法名(self,父类形参2)\n② 父子方法同名问题如果重写了init 时，若想要继承父类的构造方法，若父类和子类具有同名的实例方法，如果想调用父类同名实例方法，需要在定义子类方法时，Python 3 加上super().方法名(不写self,只写父类形参)代替super(子类名,self).方法名(父类形参)def init(self,name,color):    super().init(不写self,只写父类形参) 或者父类名称.init(self,参数1，参数2，…)super() 函数是用于调用父类(超类)的一个方法。super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表\n多态：对不同类型的对象执行相同的操作，得到的确是不同的结果，每当无需知道对象是什么样的就能对其执行操作时必要条件：-满足继承关系-需要方法的重写\n在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行\n调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"缓存","url":"https://bubbleboy11.github.io/2020/08/21/huan-cun/","content":"为什么要使用缓存？\n\n内存缓存（常见的有 Redis 和 Memcached）\n缓解关系数据库(常见的是Mysql)并发访问的压力：热点数据\n减少响应时间：内存IO速度比磁盘块\n提升吞吐量：Redis 等内存数据库单机就可以支撑很大并发\n\n从内存中读取1MB 数据响应时间是微秒级别的，从机械磁盘读取1MB数据响应时间是毫秒级别的。它们有数量级上的差异，所以使用内存型数据库它的速度会非常快。\n主要区别：数据存储类型：Redis支持非常丰富的类型，而Memcached只支持简单的 k-v 结构，从功能特性来说Redis比Memcached要强很多。网络IO模型：Redis是单进程/单线程 ，使用IO多路复用模式，而Memcached 使用多线程方式。持久化支持：Redis支持两种持久化的方式 RDB 和 AOF可以通过修改，Redis 配置实现，而Memcached不支持。内存是一个易失存储器，断电重启之后原来的数据就没了，只能通过一些写入文件方式支持持久化。\n快照方式：把数据快照放在磁盘二进制文件中，dump.rdb文件以RDB结尾，快照的实现方式是指定时间间隔把 Redis 数据库状态保存到一个压缩的二进制文件中。\nAOF(Append Only File)：每一个写命令追加到 appendonly.aof文件中\nRedis事务就是将多个请求打包，一次性、按序执行多个命令的机制。一次性指Redis在执行命令期间不会去执行其他客户端请求。\nRedis 可以通过multi来开始事务然后添加一系列命令，最后来使用exec执行。对于并发控制可以使用watch命令来去实现乐观锁机制。\nPython redis-py pipeline=conn.pipeline(transaction=True)实现事务的功能\n数据库引入事务机制为了防止对数据文件直接操作的时候出现意外宕机，引发数据的错乱undo和redo日志保证了业务操作的原子性\n为了保证事务的一致性，在开启事务之前必须要用WATCH命令监视要操作的记录。WATCH kill num kill user字符串 列表\nMULT  # 开启一个事务redis后的所有操作都不会立即执行，只有执行EXEC命令的时候才会批处理执行\n1234567get num 0watch nummultiincr numincrby num 10execget get num 0watch nummultiincr numincrby num 10execget num\n\n◆Redis并没有事务的回滚机制，所以并不能保证原子性一致性需要使用watch监听key，如果它被修改，当前事务就会执行失败，这样才能保证一致性。\n隔离性，Redis是单线程执行，所以隔离性本身就能实现。\n持久性，虽然Redis它有AOF或RDB这种持久化的机制，但是这两种实现方式并不能严格保证持久化，所以redis并不能完全的实现持久化的机制。\n所以 在使用Redis的事务的时候需要根据业务场景来去决定是不是可以去使用\n◆事务在没有提交执行前，是可以取消事务的。如果事务已经提交执行，就无法取消了\n123redis&gt;MULTIredis&gt;....…redis&gt;redis&gt;MULTIredis&gt;....…redis&gt;DISCARD\n从连接池中获取的连接，不必关闭，垃圾回收的时候，连接会自动被归还到连接池\nRedis如何实现分布式锁？在多线程环境下使用锁来保证线程安全，这种方式只能在一个进程里面实现线程安全。在不同机器不同进程上的线程之间如果想做一个同步，这时候就要使用分布式锁，高性能的Redis就可以作为实现分布式锁的一种比较好的方式。\n\n使用setnx实现加锁，可以同时通过expire添加超时时间\n\n锁的 value 值可以使用一个随机的 uuid 或者特定的命名\n\n释放锁的时候，通过uuid 判断是否是该锁，是则执行delete释放锁\n大体思路就是当一个线程想要持有锁的时候就设置一个Key，如果这个Key已经存在就获取失败，如果想释放锁的时候通过delete去删除这个锁。\n\n\n缓存使用模式\nCache Aside：同时更新缓存和数据库（一般使用该方式）首先去从缓存来获取数据，如果缓存没有的时候再去数据库里面取，从数据库取完之后再去设置缓存的值。 一旦使用到缓存，就涉及到数据库和缓存之间的数据一致性问题。先更新数据库后更新缓存，并发写操作可能导致缓存读取的是脏数据。一般实现方式先更新数据库然后删除缓存，等下次读取的时候没有相关缓存再去重建缓存。而不是先更新数据库再更新缓存导致并发写的时候缓存里面有脏数据。\n\nRead/Write Through：先更新缓存，缓存负责同步更新数据库\n\nWrite Behind Caching：先更新缓存，缓存定期异步更新数据库\n\n\n如何解决缓存穿透问题？\n由于大量缓存查不到就去数据库取，数据库也没有要查的数据。例如：很多无脑爬虫通过自增 id 的方式爬取网站，网站查不到相关 id 的数据。\n\n解决：对于没查到返回为 None 的数据也缓存，这样就可以直接利用缓存返回None这个结果。\n\n插入数据的时候删除相应缓存，或者设置较短的超时时间\n\n\n如何解决缓存击穿问题？某些非常热点的数据 key 过期失效，大量请求打到后端数据库\n\n分布式锁：获取锁的线程从数据库拉数据更新缓存，其它线程等待。对数据库的压力比较大说明有很多线程同时去请求数据库，其实通过锁的方式来限定只有一个线程负责从数据库拉取数据并且更新缓存，其他没有获取的线程就继续等待直到已经有缓存就可以从缓存里面直接去获取，通过这种方式就可以有效减少对后端数据库的压力。\n\n异步后台更新：后台任务针对过期的 key 自动刷新。后台可以写一个脚本定期的去针对快过期的 key 自动去刷新它的数据，然后重新去更新它的过期时间，用这种方式可以实现不让这个热点的数据 key 过期。(一般使用异步后台更新相比来说实现起来会更简单一些)\n\n\n如何解决缓存雪崩问题？缓存不可用 或者 大量缓存key同时失效，大量请求直接打到数据库上\n缓存不可用场景：比如有多个缓存服务器，其中一台或多台挂了，这时候大量请求就落在了少数缓存服务器上面，缓存可能承受不了了直接给打挂了。\n大量的缓存key同时失效场景：设置缓存的时候给它类似的失效时间，这时候就导致短时间内有大量的缓存失效。\n解决方式对症下药：\n\n多级缓存：不同级别的 key 设置不同的超时 时间\n随机超时：key的超时时间随机设置，防止同时超时\n架构层：提升系统可用性。监控、报警完善。\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/bian-ma/","content":"ASCII American Standard Code for Information Interchange美国信息交换标准码，一种规则，表示数据的方式\n\n基于拉丁字母的一套电脑编码系统\n主要用于显示现代英语和其他西欧语言使用7位或8位二进制数组合来表示128或256种可能的字符。 2^8=256\n标准ASCII码使用7位二进制来表示26个字母的大写字母和小写字母，10个数字0-9，标点符号，以及在美式英语种使用的控制字符。\n8位二进制后128个称为扩展ASCII码，用于表示特殊符号、外来语字母和图形符号。\n\n每个字符都对应唯一的一个数字，比如字符A对应的二进制数值是01000001，对应的十进制就是65。ASCII 占1个字节，GB2312 占2个字节，支持6700+汉字GBK 支持21000+汉字\nUnicode Universal Multiple-Octet Coded Character Set 统一码、万国码。如何用字节表示 字符对应的数字 就是 字符编码 规范\nUnicode编码有不同的实现方式，比如：UTF-8、UTF-16等等。这里的Unicode就像英语一样，做为国与国之间交流世界通用的标准，每个国家有自己的语言，他们把标准的英文文档翻译成自己国家的文字，这是实现方式，就像utf-8。\nUTF-8（Unicode Transformation Format）是为unicode编码 设计 的一种 在存储 和传输时节省空间的编码方案。广泛应用于互联网，它是一种变长的字符编码，可以根据具体情况用1-4个字节来表示一个字符。比如英文字符这些原本就可以用ASCII码表示的字符用UTF-8表示时就只需要一个字节的空间，和ASCII是一样的。对于多字节（n个字节）的字符，第一个字节的前n为都设为1，第n+1位设为0，后面字节的前两位都设为10。剩下的二进制位全部用该字符的unicode码填充。\nASCII 这样的 用数字代表文字符号的规范，就被称之为 字符集\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["编码","ASCII","Unicode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/wang-luo/","content":"如何准确的定位到网络上的一台或者多台主机找到主机之后如何进行通信\n \n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/xu-ni-nei-cun-he-nei-cun-dou-dong/","content":"虚拟内存通过把一部分暂时不用的内存信息放到硬盘上\n局部性原理，程序运行时候只有部分必要的信息装入内存（1）局部性分为时间局部性和空间局部性\n\n时间局部性就是如果一块内存被访问的时候，很有可能在不远的将来还会被访问\n空间局部性就是如果一块内存被访问，那么周围的内存也很有可能被访问\n\n内存中暂时不需要的内容放到硬盘上，当需要的时候从新交换回来\n系统似乎提供了比实际内存大得多的容量，称之为虚拟内存\n内存抖动（颠簸）本质是频繁的页调度行为\n\n频繁的页调度，进程不断产生缺页中断\n置换一个页，又不断再次需要这个页\n运行程序太多；页面替换策略不好。通过杀掉一些无关的进程(终止进程)或者增加物理内存解决\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"行为型模式之策略模式","url":"https://bubbleboy11.github.io/2020/08/21/xing-wei-xing-mo-shi-zhi-ce-lue-mo-shi/","content":"策略模式(Strategy)\n根据不同的输入规模采用不同的策略\n比如: 买东西超过10个打八折，超过20个打七折\n对外暴露统一的接口，内部采用不同的策略计算12345678910111213141516171819202122232425262728293031323334353637383940class Order:  # 订单类，根据订单的个数，来去决定哪种折购策略    def __init__(self, price, discount_strategy=None):        self.price = price        self.discount_strategy = discount_strategy    def price_after_discount(self):        if self.discount_strategy:            # 括号里self表示给order参数传入price的值            discount = self.discount_strategy(self)        else:            discount = 0        return self.price - discount    def __repr__(self):        fmt = \"&lt;Price: {}, price after discount: {}&gt;\"        return fmt.format(self.price, self.price_after_discount())def ten_percent_discount(order):  # 打九折    return order.price * 0.1def on_sale_discount(order):  # 打七三折    return order.price * 0.25 + 20def main():    order0 = Order(100)    order1 = Order(100, discount_strategy=ten_percent_discount)    order2 = Order(1000, discount_strategy=on_sale_discount)    print(order0)    print(order1)    print(order2)main()# 输出结果：# &lt;Price: 100, price after discount: 100&gt;# &lt;Price: 100, price after discount: 90.0&gt;class Order:  # 订单类，根据订单的个数，来去决定哪种折购策略    def __init__(self, price, discount_strategy=None):        self.price = price        self.discount_strategy = discount_strategy    def price_after_discount(self):        if self.discount_strategy:            # 括号里self表示给order参数传入price的值            discount = self.discount_strategy(self)        else:            discount = 0        return self.price - discount    def __repr__(self):        fmt = \"&lt;Price: {}, price after discount: {}&gt;\"        return fmt.format(self.price, self.price_after_discount())def ten_percent_discount(order):  # 打九折    return order.price * 0.1def on_sale_discount(order):  # 打七三折    return order.price * 0.25 + 20def main():    order0 = Order(100)    order1 = Order(100, discount_strategy=ten_percent_discount)    order2 = Order(1000, discount_strategy=on_sale_discount)    print(order0)    print(order1)    print(order2)main()# 输出结果：# &lt;Price: 100, price after discount: 100&gt;# &lt;Price: 100, price after discount: 90.0&gt;# \n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"行为型模式之观察者模式","url":"https://bubbleboy11.github.io/2020/08/21/xing-wei-xing-mo-shi-zhi-guan-cha-zhe-mo-shi/","content":"观察者模式\n发布订阅是一种最常见的实现方式\n发布订阅用于解耦逻辑\n可以通过回调等方式实现，当发生事件时，调用相应的回调函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 发布订阅模式，通过在发布者里面加入订阅者，并通过订阅者的回调实现class Publisher:  # 发布者    def __init__(self):        self.observers = []  # 初始化观察者为空列表    def add(self, observer):  # 加入观察者到观察者列表        if observer not in self.observers:            self.observers.append(observer)        else:            print('Failed to add : {}'.format(observer))    def remove(self, observer):  # 从观察者列表移除观察者        try:            self.observers.remove(observer)        except ValueError:            print('Failed to remove : {}'.format(observer))    def notify(self):  # 调用观察者的回调        [o.notify_by(self) for o in self.observers]        # 当发生相应事件时候，通知所有观察者去调用回调函数class Formatter(Publisher):  # 继承自发布者    def __init__(self, name):        super().__init__()        self.name = name        self._data = 0    @property    def data(self):        return self._data    @data.setter    def data(self, new_value):        self._data = int(new_value)        self.notify()  # data 在被合法赋值以后会执行notifyclass BinaryFormatter:    ''' 订阅者 '''    def notify_by(self, publisher):  # 接收一个Publisher类的实例作为参数        print(\"{}: '{}' has now bin data = {}\".format(            type(self).__name__,             publisher.name,             bin(publisher.data))        )df = Formatter('formatter')  # 发布者bf = BinaryFormatter()  # 订阅者df.add(bf)  # 添加订阅者df.data = 3  # 设置的时候调用订阅者的notify_by函数# 输出结果：# 发布订阅模式，通过在发布者里面加入订阅者，并通过订阅者的回调实现class Publisher:  # 发布者    def __init__(self):        self.observers = []  # 初始化观察者为空列表    def add(self, observer):  # 加入观察者到观察者列表        if observer not in self.observers:            self.observers.append(observer)        else:            print('Failed to add : {}'.format(observer))    def remove(self, observer):  # 从观察者列表移除观察者        try:            self.observers.remove(observer)        except ValueError:            print('Failed to remove : {}'.format(observer))    def notify(self):  # 调用观察者的回调        [o.notify_by(self) for o in self.observers]        # 当发生相应事件时候，通知所有观察者去调用回调函数class Formatter(Publisher):  # 继承自发布者    def __init__(self, name):        super().__init__()        self.name = name        self._data = 0    @property    def data(self):        return self._data    @data.setter    def data(self, new_value):        self._data = int(new_value)        self.notify()  # data 在被合法赋值以后会执行notifyclass BinaryFormatter:    ''' 订阅者 '''    def notify_by(self, publisher):  # 接收一个Publisher类的实例作为参数        print(\"{}: '{}' has now bin data = {}\".format(            type(self).__name__,             publisher.name,             bin(publisher.data))        )df = Formatter('formatter')  # 发布者bf = BinaryFormatter()  # 订阅者df.add(bf)  # 添加订阅者df.data = 3  # 设置的时候调用订阅者的notify_by函数# 输出结果：# BinaryFormatter: 'formatter' has now bin data = 0b11\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"行为型模式之策略模式","url":"https://bubbleboy11.github.io/2020/08/21/xing-wei-xing-mo-shi-zhi-die-dai-qi-mo-shi/","content":"迭代器(Iterator)模式\nPython内置对迭代器模式支持\n可作用于for循环的，具备了__iter__或iter()方法的对象，就是可迭代对象 Iterable\n调用对象名.next()时（或next(对象名)）和 iter 对象称为迭代器Iterator每次调用next(g)，就计算出g的下一个元素的值，返回它所记录位置的下一个位置的数据。直到没有数据时抛出StopIteration错误，表示无法继续返回下一个值了。直到计算到最后一个元素，没有可供返回的值\n\nIterator对象表示的是一个数据流、一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\nPython的for循环本质上就是通过不断调用next()函数实现的\nIterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n给定一个list或tuple或字符串，通过for循环来遍历这个list或tuple，称为迭代（Iteration）。dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。\n可以使用isinstance()判断一个对象是否是Iterable对象可以使用isinstance()判断一个对象是否是Iterator对象：\n迭代Iteration 是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象，记录每次迭代访问到的位置，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n重复多次，像循环那样，针对对象\n数据类型有以下几种：一类是集合数据类型，int整型不是iterable，即int整型不是可以迭代的如list、tuple、dict、set、str等是Iterable但不是Iterator，把list、dict、str等Iterable变成Iterator可以使用iter()函数\n法二：    定义一个以 yield 关键字标识返回值的函数；    调用刚刚创建的函数，即可创建一个生成器（generator）。生成器函数就是一个迭代器，返回迭代器Iterator的函数，创建了一个generator后，基本上永远不会调用next()，太麻烦而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\n#普通函数是顺序执行，遇到return语句或者最后一行函数语句就返回。#在调用生成器运行的过程中，遇到yield时函数会返回一个generator对象#并保存当前所有的运行信息，函数冻结#在下一次执行next()方法时从上次返回的yield语句处继续执行。比如[i for i in range(10) if i % 2 == 0]生成器的创建方式也比迭代器简单很多只要把一个列表生成式的方括号[]改成圆括号()就会返回生成器，只保存算法不保存数据，使用生成器推导大大节省内存一边循环一边计算的机制 只能用于迭代操作\nfor i in range(10) if i % 2 12345678910111213141516171819一类是generator，包括生成器和带yield的generator function。为啥会用到生成器？&nbsp; &nbsp;&nbsp;&nbsp;简单举个例子：&nbsp; &nbsp; 列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&nbsp;&nbsp; &nbsp;如果列表元素能按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。实现了延迟求值和惰性求值，也是后面协程实现的基础```pythonimport hellohello.test() # test是hello模块的一个函数变量和函数并没有本质区别，函数名就是变量import hellohello.new_var # new_var是hello模块的一个变量\n\n_是一个合法的标识符，也可以作为一个有效的变量使用，除非明确的知道这个数据需要使用但是定义成下划线就是希望不要被使用无需关注其实际含义的变量可以用_代替，起到的是循环此数的作用,也可以用i，j 等其他字母代替，\n如何让一个对象可迭代\n123456789101112131415161718192021222324252627282930313233from collections import dequeclass Stack(object):  # 使用组合的例子    def __init__(self):        self._deque = deque()  # has a deque()    def push(self, value):        return self._deque.append(value)    def pop(self):        return self._deque.pop()    def empty(self):        return len(self._deque) == 0    def __iter__(self):  # 定义__iter__方法让它支持迭代        # 因为栈是后进先出希望让它从上往下去迭代        res = []        for i in self._deque:  # deque从左往右去遍历的            res.append(i)        for i in reversed(res):  # 需要让res反转，才能实现从上往下迭代            yield is = Stack()s.push(1)s.push(2)for i in s:  # 让自定义Stack实现迭代，通过添加__iter__方法实现迭代    print(i)# 输出结果：# 2from collections import dequeclass Stack(object):  # 使用组合的例子    def __init__(self):        self._deque = deque()  # has a deque()    def push(self, value):        return self._deque.append(value)    def pop(self):        return self._deque.pop()    def empty(self):        return len(self._deque) == 0    def __iter__(self):  # 定义__iter__方法让它支持迭代        # 因为栈是后进先出希望让它从上往下去迭代        res = []        for i in self._deque:  # deque从左往右去遍历的            res.append(i)        for i in reversed(res):  # 需要让res反转，才能实现从上往下迭代            yield is = Stack()s.push(1)s.push(2)for i in s:  # 让自定义Stack实现迭代，通过添加__iter__方法实现迭代    print(i)# 输出结果：# 2# 1\n注意：Stack并不是一个迭代器，它是个可迭代对象Iterable。要区分迭代器(Iterator)。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/she-ji-mo-shi/","content":"常见创建型设计模式（重点单例模式和工厂模式）\n工厂模式(Factory)：解决对象创建问题\n构建者模式(Builder)：控制复杂对象的创建\n原型模式(Prototype)：通过原型的克隆创建新的实例\n单例模式(Borg / Singleton)：一个类只能创建同一个对象\n对象池模式(Pool)：预先分配同一类型的一组实例\n惰性计算模式(Lazy Evalution)：延迟计算(python 的property)，当访问这些属性的时候才做一些相应的计算操作\n\n常见结构型设计模式（重点适配器模式和代理模式和MVC）\n装饰器模式(Decorator)：无需子类化扩展对象功能\n代理模式(Proxy)：把一个对象的操作代理到另一个对象\n适配器模式(Adapter)：通过一个间接层适配同一接口\n外观模式(Facade)：简化复杂对象的访问问题\n享元模式(Flyweight)：通过对象复用(池)改善资源利用，比如连接池\nModel-View_Controller(MVC)：解耦展示逻辑和业务逻辑，如Django 是MTV模式，T 为 template和MVC非常类似。\n\n常见学习行为型设计模式\n迭代器模式(Iterator)：通过统一的接口迭代对象\n观察者模式(Observer)：对象发生改变的时候，观察者执行相应动作\n策略模式(Strategy)：针对不同规模输入使用不同的策略\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"进制","url":"https://bubbleboy11.github.io/2020/08/21/jin-zhi/","content":"python整数类型为Unifying Long Integers，无限长整数类型，没有 32 / 64 位 int long 等不同长度等概念，但肯定是大于 32 位\n八进制：包括0-7的数字\n十六进制表示：包括0-9的数字，及字母a-f，A-F，a表示10\nPython 中浮点数的运算存在误差计算机底层运算的时候操作的是二进制，当带小数点的十进制转换成二进制的时候可能存在小数部分乘不尽的情况\n123456789print(1.2 - 1.0)  # 0.19999999999999996print(0.1 + 0.2)  # 0.30000000000000004print(0.1 + 2)  # 2.1print(0.1 * 2)  # 0.2print(1.2 - 1.0 == 0.2)  # Falseprint(type(2 / 2))  # &lt;class 'float'&gt;print(float(1))   print(1.2 - 1.0)  # 0.19999999999999996print(0.1 + 0.2)  # 0.30000000000000004print(0.1 + 2)  # 2.1print(0.1 * 2)  # 0.2print(1.2 - 1.0 == 0.2)  # Falseprint(type(2 / 2))  # &lt;class 'float'&gt;print(float(1))   # 1.0\n\npython中0b(数字0和小写字母B前缀)代表二进制数字\n12print(0b101)  # 5  print(0b11)  print(0b101)  # 5  print(0b11)  # 3  \n\njava中以0开头代表八进制数字，如：037，056python中0o(数字0和小写字母O前缀)代表八进制数字，\n12print(0o11)  # 9  print(0o110)  print(0o11)  # 9  print(0o110)  # 72  \n\njava中以0x或0X开头代表十六进制数字，如：0x12，0xabcf，0XABCFpython中0x(数字0和小写字母X前缀)代表十六进制数字\n123print(0x101)  # 257   print(0x1F)  # 31print(0x1f)  print(0x101)  # 257   print(0x1F)  # 31print(0x1f)  # 31\n\n代表不同类型数据转换为10进制数字12345678910```oct()```  代表不同类型数据转换为8进制数字```hex(x)```，将不同类型进制整数转换为以“0x”为前缀的小写十六进制数的字符串。如果 x 不是 Python int 对象，则必须定义返回整数的 __index__() 方法。```pythonprint(hex(1))  # 0x1 补码print(hex(-1))  # -0x1 负号 + 原码 （Python 特色，Java 会直接输出补码）print(hex(3), type(hex(3)))  # 0x3 print(hex(0b11))  # 0x3  将2进制数字转换为2=16进制\n\n如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：\n123456789101112131415print('%#x' % 3, '%x' % 3, '%X' % 3, )# 0x3 3 3print(format(3, '#x'), format(3, 'x'), format(3, 'X'))# 0x3 3 3print(f'{3:#x}', f'{3:x}', f'{3:X}')# 0x3 3 3print('%#x' % -3, '%x' % -3, '%X' % -3, )# -0x3 -3 -3print(format(-3, '#x'), format(-3, 'x'), format(-3, 'X'))# -0x3 -3 -3print(f'{-3:#x}', f'{-3:x}', f'{-3:X}')print('%#x' % 3, '%x' % 3, '%X' % 3, )# 0x3 3 3print(format(3, '#x'), format(3, 'x'), format(3, 'X'))# 0x3 3 3print(f'{3:#x}', f'{3:x}', f'{3:X}')# 0x3 3 3print('%#x' % -3, '%x' % -3, '%X' % -3, )# -0x3 -3 -3print(format(-3, '#x'), format(-3, 'x'), format(-3, 'X'))# -0x3 -3 -3print(f'{-3:#x}', f'{-3:x}', f'{-3:X}')# -0x3 -3 -3\n\n将一个不同类型进制整数转变为一个前缀为“0b”的二进制数的字符串。结果是一个合法的 Python 表达式。123456如果 x 不是 Python 的 ```int``` 对象，那它需要定义 ```__index__()``` 方法返回一个整数。bin一个正数（十进制表示），输出的是它的原码的二进制表示bin一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，而不是补码的形式。```pythonprint(bin(3), type(bin(3)))  # 0b11 print(bin(-3))  # -0b11\n\n对数值进行与操作就获得补码形式的二进制表示 \n123456789101112131415161718192021222324252627282930313233343536373839print(bin(-3 &amp; 0b111))  # 0b101print(bin(-3 &amp; 0b1111111111111111))# 0b1111111111111101---title: HTMLdate: 2020-08-20 16:21:41author: 外心人Dtoc: truemathjax: falsesummary: 爱编程categories: Markdowntags:  - Leetcode  - 剑指offer---```pyprint(bin(-5))# -0b101print(bin(-5 &amp; 0b1111))  # 0b1011print(bin(-5 &amp; 0b11111))  # 0b11011print(bin(-5 &amp; 0b1111111111111111))# 0b1111111111111011# bin一个负数（十六进制表示），输出的是对应的二进制表示。print(bin(-3 &amp; 0xffffffff))# 0b11111111111111111111111111111101print(bin(0xfffffffd))# 0b11111111111111111111111111111101print(bin(0o7))  # 0b111 将8进制数字转换为2进制print(bin(0xE))  print(bin(-3 &amp; 0b111))  # 0b101print(bin(-3 &amp; 0b1111111111111111))# 0b1111111111111101---title: HTMLdate: 2020-08-20 16:21:41author: 外心人Dtoc: truemathjax: falsesummary: 爱编程categories: Markdowntags:  - Leetcode  - 剑指offer---```pyprint(bin(-5))# -0b101print(bin(-5 &amp; 0b1111))  # 0b1011print(bin(-5 &amp; 0b11111))  # 0b11011print(bin(-5 &amp; 0b1111111111111111))# 0b1111111111111011# bin一个负数（十六进制表示），输出的是对应的二进制表示。print(bin(-3 &amp; 0xffffffff))# 0b11111111111111111111111111111101print(bin(0xfffffffd))# 0b11111111111111111111111111111101print(bin(0o7))  # 0b111 将8进制数字转换为2进制print(bin(0xE))  # 0b1110 将16进制数字转换为2进制\n\nIf prefix “0b” is desired or not, you can use either of the following ways.如果不一定需要前缀“0b”，还可以使用如下的方法。用format字符串获取一个int的binary表示：\n1234567```f\"{a:030b}\"```：将a转换成binary的str，并在前面补0使其总位数是30。```pyformat(14, '#b'), format(14, 'b')# ('0b1110', '1110')f'{14:#b}', f'{14:b}'# ('0b1110', '1110')\n\n4bit有符号整型， 其数值范围为[-8， 7]-2 + 3 可以通过补码计算 1110 + 0011 =(1) 0001\n1234    1 1 1 0+   0 0 1 1-----------(1) 0 0 0     1 1 1 0+   0 0 1 1-----------(1) 0 0 0 1 # 注意溢出\n\npython 由于不知道符号位具体是第几位，因此需要进行的操作是\n\n将输入数字转化成无符号整数\n计算无符号整数相加并的到结果\n讲结果根据范围判定，映射为有符号整型\n\n转化为4bit无符号整数\n12a &amp;= 0xF # a = a &amp; 0b1111 = 1110 = 14b &amp;= 0xF a &amp;= 0xF # a = a &amp; 0b1111 = 1110 = 14b &amp;= 0xF # b = 0011 = 3\n\n原码：直接将一个数值转化为二进制，其首位代表符号，0 为正， 1 为负正数：原码 = 反码 = 补码负数反码：原码最高位符号位不变，其余为取反负数补码：负数反码+1，即 符号位不变，各位取反再加 1\n补码特性：1、一个负整数（或原码）与其补数（或补码）相加，和为模。2、对一个整数的补码再求补码，等于该整数自身。3、补码的正零与负零表示方法相同\n\nPython 负数的存储：\n获取负数的补码：将整数与 0xffffffff 相与，可理解为该数从 32 位开始到最高位全部置零，最高位为0为正数从无限长度变为一个 32 位内二进制可以表示的正整数一直循环左移并不会存在溢出的现象，模拟其他语言的32位溢出机制。一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码就相当于  n &amp; 0xffffffff高位第一位的数字取决于此数字是正数还是负数，是正数则为 0 ，是负数则为 1\n\n\n\n123print(hex(1 &amp; 0xffffffff))  # 0x1 正数补码print(hex(-1 &amp; 0xffffffff))  # 0xffffffff 负数补码print(-1 &amp; 0xffffffff)  print(hex(1 &amp; 0xffffffff))  # 0x1 正数补码print(hex(-1 &amp; 0xffffffff))  # 0xffffffff 负数补码print(-1 &amp; 0xffffffff)  # 4294967295（Python 将其认为正数）\n\n返回前数字还原 补码转原码：若补码 a 为负数（第 32位是 1），a ^ 0xffffffff 运算将 1 至 32 位按位取反；~ 运算是将所有位的数字会取反；因此， ~(a ^ 0xffffffff) 是将低的 1 至 32 位不变。32 位以上的位取反，即 32位以上所有位全部置 1了，对于32位的数字来说最高位是1则说明此数为负数把这个负数补码恢复到 超过32位的 python 存储负数的形式，\n\n如果不对负数特殊处理，那么负数的前32位里的最高位还可能存在 0，最后输出的是大于32位的正数\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/di-gui/","content":"“””在递归过程中，，函数可能会有多个位置将自身作为子例程调用每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。\n为了确保递归函数不会导致无限循环，它应具有以下属性：\n\n一个简单的基本案例（basic case）（一般情况），能够不使用递归来产生答案的终止方案，必须要有终止条件，\n一组规则，也称作递推关系（recurrence relation），可将所有其他情况拆分到基本案例。不断调用自身，直到遇到终止条件后进行回溯，最终返回答案。\n\n123456789101112131415161718192021def func1(x):    print(x)    func1(x - 1)def func2(x):    if x &gt; 0:        print(x)        func2(x + 1)def func3(x):    if x &gt; 0:        print(x)        func3(x - 1)def func4(x):    if x &gt; 0:        func4(x - def func1(x):    print(x)    func1(x - 1)def func2(x):    if x &gt; 0:        print(x)        func2(x + 1)def func3(x):    if x &gt; 0:        print(x)        func3(x - 1)def func4(x):    if x &gt; 0:        func4(x - 1)        print(x)\nfunc3和func4是递归，x为正整数，func3会连续输出x到1，func4会输出1 到x\n12345def printReverse(str):    if not str:        return    printReverse(str+def printReverse(str):    if not str:        return    printReverse(str+1)    print()\n\n高斯求和\n123456789# 循环def sum_number(n):    total = 0    for i in range(1, n + 1):        total += i    return totalprint(sum_number(10))  # 循环def sum_number(n):    total = 0    for i in range(1, n + 1):        total += i    return totalprint(sum_number(10))  # 5\n12345678# 递归def sum_number(n):    if n &lt;= 0:        return 0    return n + sum_number(n - 1)print(sum_number(10))  # 递归def sum_number(n):    if n &lt;= 0:        return 0    return n + sum_number(n - 1)print(sum_number(10))  # 55\n\n基本情况：sum_number(0) = 0其它情形: sum_number(n) = n + sum_number\nsum_number(n-1)又是一次sum_number函数的调用，不过参数的值变成了n-1，要得sum_number(n)到的值就必须等待sum_number(n-1)的值被计算出来，同样要得到sum_number(n-1)的值必须等待sum_number(n-2)的值，如此一路推算下去，直到sum_number(0)，因为if语句的存在，它不需要等待sum_number(-1)的计算了，而是直接给出结果0。参数值由 10 9 8 7 6 5 4 3 2 1 0sun_number(1)=1+sun_number(0)=1sun_number(2)=2+sun_number(1)=2+1+sun_number(0)=2+1+0=3sun_number(3)=3+sun_number(2)=3+3=6….然后程序一路返回，直到回到最初的sum_number(n)，并给出最终结果。“””\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# 求阶乘def F(n):    if n == 0 or n == 1:        # 对应基本情形        return 1    return F(n - 1) * n  # 对应递归情形print(F(4))  # 24\"\"\" F(0) = 1, F(1) = 1其它情形: F(n) = F(n-1) * n\"\"\"# 计算s=a+aa+aaa+aaaa+aa...a，其中 a是一个数字。# 例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加由键盘控制。# 其中，a 以及 n 由用户输入，但是我们在这里就直接给定了。def sss(a, n):    # 这里我说明一下，直接用input函数得到的就是字符串，除非你已经做了转换    # 所以,我们设定a、n都是字符串    n = int(n)  # 转换    if n == 1:        return int(a)    return sss(a, n - 1) + int(a * n)  # 请思考这里a*n\"\"\"基本情形：sss(a, 1) = asss(a, 2) = a+aa=sss(a, 1)+aa其它情形:sss(a, n) = sss(a, n-1) + a...a(共n项)\"\"\"\"\"print(sss('2', '1'))  # 2print(sss('2', '2'))  # 24print('-----')from functools import reducen = int(input(\"请输入层数n：\"))  # &lt;class 'int'&gt;a = int(input(\"请输入数字a：\"))  # &lt;class 'int'&gt;Tn = 0  # 初始化数字叠加后的值Sn = []  # 创建一个空列表，以便接收叠加后的数值for i in range(n):  # 此处的循环表示，n为几，i就循环几次，    # 也就是，层数为几，下面的循环体就执行几次    Tn = Tn + a  # 将循环的值赋值给Tn    # print(\"数字叠加后值为：\", Tn)  # 打印出数字叠加后的值    Sn.append(Tn)  # 将数字叠加后的值依次添加到Sn这个空的列表中    # print(\"创建的数列为：\", Sn)  # 打印出列表Sn中的所有值    a = a * 10  # 为下一个数做循环准备print(\"创建的数列为：\", Sn)# 法一# sum_ = reduce(lambda x, y: x + y, Sn)  # 计算Sn的值# 法二sum_ = 0for i in Sn:    sum_ += iprint(\"计算的和为：\", sum_)  # 打印出Sn的值a = input(\"a:\")  # &lt;class 'str'&gt;n = int(input(\"n:\"))  # &lt;class 'int'&gt;ls = []for i in range(1, n + 1):    ls.append(i * a)  # 字符串乘一个数sum = 0print(ls)for i in ls:    sum += eval(i)  # 字符串表达式print(sum)def getNum(a, count):    list1 = []    res = 0    a = str(a)    for i in range(1, count + 1):        list1.append(int(a * i))        print(list1[i - 1], end=\" \")        if i &lt; count:            print(\"+\", end=\" \")    for j in list1:        res += j    print(\"=\", res)    return resgetNum(2, 2)  # 求阶乘def F(n):    if n == 0 or n == 1:        # 对应基本情形        return 1    return F(n - 1) * n  # 对应递归情形print(F(4))  # 24\"\"\" F(0) = 1, F(1) = 1其它情形: F(n) = F(n-1) * n\"\"\"# 计算s=a+aa+aaa+aaaa+aa...a，其中 a是一个数字。# 例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加由键盘控制。# 其中，a 以及 n 由用户输入，但是我们在这里就直接给定了。def sss(a, n):    # 这里我说明一下，直接用input函数得到的就是字符串，除非你已经做了转换    # 所以,我们设定a、n都是字符串    n = int(n)  # 转换    if n == 1:        return int(a)    return sss(a, n - 1) + int(a * n)  # 请思考这里a*n\"\"\"基本情形：sss(a, 1) = asss(a, 2) = a+aa=sss(a, 1)+aa其它情形:sss(a, n) = sss(a, n-1) + a...a(共n项)\"\"\"\"\"print(sss('2', '1'))  # 2print(sss('2', '2'))  # 24print('-----')from functools import reducen = int(input(\"请输入层数n：\"))  # &lt;class 'int'&gt;a = int(input(\"请输入数字a：\"))  # &lt;class 'int'&gt;Tn = 0  # 初始化数字叠加后的值Sn = []  # 创建一个空列表，以便接收叠加后的数值for i in range(n):  # 此处的循环表示，n为几，i就循环几次，    # 也就是，层数为几，下面的循环体就执行几次    Tn = Tn + a  # 将循环的值赋值给Tn    # print(\"数字叠加后值为：\", Tn)  # 打印出数字叠加后的值    Sn.append(Tn)  # 将数字叠加后的值依次添加到Sn这个空的列表中    # print(\"创建的数列为：\", Sn)  # 打印出列表Sn中的所有值    a = a * 10  # 为下一个数做循环准备print(\"创建的数列为：\", Sn)# 法一# sum_ = reduce(lambda x, y: x + y, Sn)  # 计算Sn的值# 法二sum_ = 0for i in Sn:    sum_ += iprint(\"计算的和为：\", sum_)  # 打印出Sn的值a = input(\"a:\")  # &lt;class 'str'&gt;n = int(input(\"n:\"))  # &lt;class 'int'&gt;ls = []for i in range(1, n + 1):    ls.append(i * a)  # 字符串乘一个数sum = 0print(ls)for i in ls:    sum += eval(i)  # 字符串表达式print(sum)def getNum(a, count):    list1 = []    res = 0    a = str(a)    for i in range(1, count + 1):        list1.append(int(a * i))        print(list1[i - 1], end=\" \")        if i &lt; count:            print(\"+\", end=\" \")    for j in list1:        res += j    print(\"=\", res)    return resgetNum(2, 2)  # 2 + 22 = 24\n\n判断用户输入的数组的逆序数。定义：OP(seq, n)为序列seq中前n项的逆序数\n基本情形:OP(seq[1…n], 1) = 0，对于只有一个元素的集合，逆序数必然只有0其它情形:OP(seq[1…n], n) = OP(seq[1…n, n-1] + F(n)，其中，F(n)是n关于seq[1…n-1]的逆序数.\n12345678910111213141516171819def OP(seq, n):    if n == 1:        return 0    # 不为0    Fn = 0    for i in range(0, n - 1):        if seq[n - 1] &lt; seq[i]:            Fn += 1    return OP(seq, n - 1) + Fns = [5, 4, 3, 2, 1]print(OP(s, len(s)))  # 10# n=5 n-1-1=3# 当i=0,seq[4]=1&lt;seq[0]=5# 当i=1,seq[4]=1&lt;seq[1]=4# 当i=2,seq[4]=1&lt;seq[2]=3def OP(seq, n):    if n == 1:        return 0    # 不为0    Fn = 0    for i in range(0, n - 1):        if seq[n - 1] &lt; seq[i]:            Fn += 1    return OP(seq, n - 1) + Fns = [5, 4, 3, 2, 1]print(OP(s, len(s)))  # 10# n=5 n-1-1=3# 当i=0,seq[4]=1&lt;seq[0]=5# 当i=1,seq[4]=1&lt;seq[1]=4# 当i=2,seq[4]=1&lt;seq[2]=3# 当i=3,seq[4]=1<seq[3]=2\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/luo-ji-yun-suan-fu/","content":"逻辑运算优先 not&gt;and&gt;or0被认为是False，非0表示True\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485a = 10b = 20# 布尔\"与\" x and y# 如果 x 为 False，返回 False，# x 为 True， 返回 y 的计算值。# 同真取最后一个真，有假取第一个假。if (a and b):  # (a and b) 返回 20    print(\"1.变量 a 和 b 都为 true\")else:    print(\"1.变量 a 和 b 有一个不为 true\")# 1.变量 a 和 b 都为 true# 布尔\"或\"     x or y# 如果x是True，它返回x的值，# x 为False，它返回y的计算值# 同假取最后一个假，有真取第一个真。if (a or b):  # (a or b) 返回 10    print(\"2.变量 a 和 b 都为 true，或其中一个变量为 true\")else:    print(\"2.变量 a 和 b 都不为 true\")# 2.变量 a 和 b 都为 true，或其中一个变量为 trueprint('a' &gt; 'b')# False 'a' 的 ASCII 码比 ‘b’ 小print('a' &gt; 'b' or 'c')  # c# 修改变量 a 的值a = 0if (a and b):    print(\"3.变量 a 和 b 都为 true\")else:    print(\"3.变量 a 和 b 有一个不为 true\")# 3.变量 a 和 b 有一个不为 trueif (a or b):    print(\"4.变量 a 和 b 都为 true，或其中一个变量为 true\")else:    print(\"4.变量 a 和 b 都不为 true\")# 4.变量 a 和 b 都为 true，或其中一个变量为 true# 布尔\"非\" not x ，取反# 如果 x 为 True，返回 False 。# 如果 x 为 False，返回 True。if not (a and b):    print(\"5.变量 a 和 b 都为 false，或其中一个变量为 false\")else:    print(\"5.变量 a 和 b 都为 true\")# 5.变量 a 和 b 都为 false，或其中一个变量为 falsex = Truey = Falsez = Falseif x or y and z:    print(\"yes\")else:    print(\"no\")# yesprint('----')print(not 0.1)  # Falseprint(not '')  # Trueprint(not '0')  # Falseprint(not [])  # Trueprint(not [1, 2])  # Falseprint(bool(None))  # Falsex = Truey = Falsez = Falseif not x or y:    print(1)elif not x or not y and z:    print(2)elif not x or y or not y and x:    print(3)else:    print(4)# not x or y or not y and x就可以这么理解# 假 or 假 or 真 and 真# 假 or 假 or 真# 假 or 真a = 10b = 20# 布尔\"与\" x and y# 如果 x 为 False，返回 False，# x 为 True， 返回 y 的计算值。# 同真取最后一个真，有假取第一个假。if (a and b):  # (a and b) 返回 20    print(\"1.变量 a 和 b 都为 true\")else:    print(\"1.变量 a 和 b 有一个不为 true\")# 1.变量 a 和 b 都为 true# 布尔\"或\"     x or y# 如果x是True，它返回x的值，# x 为False，它返回y的计算值# 同假取最后一个假，有真取第一个真。if (a or b):  # (a or b) 返回 10    print(\"2.变量 a 和 b 都为 true，或其中一个变量为 true\")else:    print(\"2.变量 a 和 b 都不为 true\")# 2.变量 a 和 b 都为 true，或其中一个变量为 trueprint('a' &gt; 'b')# False 'a' 的 ASCII 码比 ‘b’ 小print('a' &gt; 'b' or 'c')  # c# 修改变量 a 的值a = 0if (a and b):    print(\"3.变量 a 和 b 都为 true\")else:    print(\"3.变量 a 和 b 有一个不为 true\")# 3.变量 a 和 b 有一个不为 trueif (a or b):    print(\"4.变量 a 和 b 都为 true，或其中一个变量为 true\")else:    print(\"4.变量 a 和 b 都不为 true\")# 4.变量 a 和 b 都为 true，或其中一个变量为 true# 布尔\"非\" not x ，取反# 如果 x 为 True，返回 False 。# 如果 x 为 False，返回 True。if not (a and b):    print(\"5.变量 a 和 b 都为 false，或其中一个变量为 false\")else:    print(\"5.变量 a 和 b 都为 true\")# 5.变量 a 和 b 都为 false，或其中一个变量为 falsex = Truey = Falsez = Falseif x or y and z:    print(\"yes\")else:    print(\"no\")# yesprint('----')print(not 0.1)  # Falseprint(not '')  # Trueprint(not '0')  # Falseprint(not [])  # Trueprint(not [1, 2])  # Falseprint(bool(None))  # Falsex = Truey = Falsez = Falseif not x or y:    print(1)elif not x or not y and z:    print(2)elif not x or y or not y and x:    print(3)else:    print(4)# not x or y or not y and x就可以这么理解# 假 or 假 or 真 and 真# 假 or 假 or 真# 假 or 真# 真\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"闭包","url":"https://bubbleboy11.github.io/2020/08/21/bi-bao/","content":"闭包 Closure /‘kləʊʒə/\n绑定了外部作用域的变量的函数\n即使程序离开外部作用域，如果闭包仍然可见，绑定变量不会销毁\n每次运行外部函数都会重新创建闭包\n自由变量：不在当前函数定义的变量。\n外函数outer中定义了内函数inner，内部函数inner引用外部函数outer的自由变量，当外部函数outer返回内部函数名inner时，即外函数的返回值是内函数的引用，相关参数和变量都保存在返回的函数中这样就构成了一个闭包。即使外部函数结束了，但只要内部函数还在引用外部函数的变量，外部变量它就依然存在。\n\n外函数返回了内函数的引用：当进行a=1的时候，实际上在内存当中有一个地方存了值1，然后用a这个变量名存了1所在内存位置的引用。引用就好像c语言里的指针，可以把引用理解成地址。a只不过是一个变量名字，a里面存的是1这个数值所在的地址，就是a里面存了数值1的引用。\n相同的道理，在python中定义一个函数def demo():的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。\n对于闭包，在外函数outer中 最后return inner，我们在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来我们再进行demo() 的时候，相当于运行了inner函数。一个函数，如果函数名后紧跟一对括号，相当于现在我就要调用这个函数，如果不跟括号，相当于只是一个函数的名字，里面存了函数所在位置的引用，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。\n2 外函数把临时变量绑定给内函数：一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，临时局部变量都会消失。如果没有在函数中引用全局变量，或者仅引用局部变量，在内函数给局部变量赋值python认为是一个局部变量，不能引用外部函数的环境变量，都不会形成闭包\n但是闭包是一种特殊情况，发现有自己的临时变量将来会在内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量绑定给了内部函数，所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。\npython中一切都是对象，虽然函数我们只定义了一次，但是外函数在运行的时候，实际上是按照里面代码执行的，外函数里创建了一个函数，每次调用外函数，它都创建一个代码、功能一样的内函数，但是却创建了不同的对象，并且把每次传入的临时变量数值绑定给内函数，再把内函数引用返回。\n特性：自由变量会和闭包函数同时存在，即闭包函数和外部变量会同时存在。\n123456789101112131415161718192021222324def outer(a):    # a和b都是外函数的临时变量    b = 10    def inner():        print(a + b)  # 在内函数中 用到了外函数的临时变量    return inner  # 外函数的返回值是内函数的引用和环境变量if __name__ == '__main__':    \"\"\"        调用外函数传入参数5        此时外函数两个临时变量 a是5 b是10 ，        并创建了内函数，然后把内函数的引用返回存给了demo        外函数结束的时候发现内部函数将会用到自己的临时变量，        这两个临时变量就不会释放，会绑定给这个内部函数    \"\"\"    demo = outer(5)    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数    demo()  # 15    demo2 = outer(7)    demo2()  def outer(a):    # a和b都是外函数的临时变量    b = 10    def inner():        print(a + b)  # 在内函数中 用到了外函数的临时变量    return inner  # 外函数的返回值是内函数的引用和环境变量if __name__ == '__main__':    \"\"\"        调用外函数传入参数5        此时外函数两个临时变量 a是5 b是10 ，        并创建了内函数，然后把内函数的引用返回存给了demo        外函数结束的时候发现内部函数将会用到自己的临时变量，        这两个临时变量就不会释放，会绑定给这个内部函数    \"\"\"    demo = outer(5)    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数    demo()  # 15    demo2 = outer(7)    demo2()  # 17\n两次调用外部函数outer，分别传入的值是5和7。内部函数只定义了一次，我们发现调用的时候，内部函数是能识别外函数的临时变量是不一样的。\n123456789101112131415161718192021from functools import wraps def cache(func):  # 定义装饰器，cache是外层函数    store = {} # 外部变量        @wraps(func)    def _(n):     # 闭包函数        if n in store:            return store[n]        else:            res = func(n)            store[n] = res            return res    return _ # 用装饰器的方式记录前面的结果    @cache def fib(n):       # 斐波那契数列    if n &lt;= 1:        return 1    return fib(n - 1) + fib(n - from functools import wraps def cache(func):  # 定义装饰器，cache是外层函数    store = {} # 外部变量        @wraps(func)    def _(n):     # 闭包函数        if n in store:            return store[n]        else:            res = func(n)            store[n] = res            return res    return _ # 用装饰器的方式记录前面的结果    @cache def fib(n):       # 斐波那契数列    if n &lt;= 1:        return 1    return fib(n - 1) + fib(n - 2)\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["python"]},{"title":"面向对象编程OOP","url":"https://bubbleboy11.github.io/2020/08/21/mian-xiang-dui-xiang-bian-cheng-oop/","content":"面向对象编程 Object Oriented Programming（OOP）面向对象的设计思想是 描述现实世界把对象作为基本单元，把对象抽象成类(Class)，包含成员(属性)和方法(用来操作成员)。根据Class创建Instance。\n面向对象三大特点：\n\n封装：对外部隐藏有关对象工作原理的细节，提供一些可以被外界访问的属性的方法\n继承：使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展\n多态：子类重写父类方法\n\nPython 中使用类来实现。过程式编程(函数)，OOP(类)(object)，表示该类是从哪个类继承下来的，默认继承object类，可不写创建类\n1234567class Person(object):     def __init__(self, name, age):  # 构造方法用来初始化成员(属性)        self.name = name        self.age = age             def print_name(self)：          # 操作成员(属性)的类的方法         print('my name is {}'.format(class Person(object):     def __init__(self, name, age):  # 构造方法用来初始化成员(属性)        self.name = name        self.age = age             def print_name(self)：          # 操作成员(属性)的类的方法         print('my name is {}'.format(self.name))\n变量名前加单下划线表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，如：self._sex = 0  。\n\n变量名前加双下划线表示的是 私有类型(private)的变量, 只能是允许这个类本身进行访问了。如：self.__foo = 0。\n\nPython在名称前后加双下划线表示的是特殊方法（魔术方法），一般是系统定义名字，如：def __len__(self): .....。\n\n2.classmethod / staticmethod区别  (它们两个经常被用作类方法的装饰器)\n\n都可以通过 Class.method() 的方式调用\n\n类方法：定义加@classmethod，类方法关联的是类，通常用来操作类变量，第一个形参是 cls，cls代表的是调用的类，类方法不会被自动调用，（也可以是别的，建议cls）类方法可以通过类名.方法名()和实例名.方法名()两种方法进行调用在类方法中访问类变量，用cls.变量名访问；可以用类也可以用对象调用类方法（但是不建议用对象调用类方法，毕竟逻辑不符），在类方法中不可以访问实例变量。\n\nstaticmethod 静态方法，使用起来和普通函数一样，只不过放在类里去组织类的静态方法可以通过类名.方法名()调用类的静态方法可以通过实例名.方法名()调用staticmethod是代码组织的需要，完全可以放到类之外并没有引用当前类的任何东西，可以把staticmethod理解为本来该放到外面的函数只是给塞到类里。其实跟类并没有什么关系，相当于给了它一个作用范围，让它可以在类里面去使用\n12345678910111213class Persion:    Country = 'China'   # class var        def __init__(self, name):        self.name = name        @classmethod            def print_country(cls):           print(cls.Country)        @staticmethod    def join_name(first_name, last_name):        return last_name + first_name    class Persion:    Country = 'China'   # class var        def __init__(self, name):        self.name = name        @classmethod            def print_country(cls):           print(cls.Country)        @staticmethod    def join_name(first_name, last_name):        return last_name + first_name    # last_name 姓\n\n\n\n123456789101112class Point(object):    def __init__(self, x, y):        self.x = x        self.y = y    def __str__(self):        return '点的位置:({0}, {1})'.format(self.x, self.y)if __name__ == '__main__':    p = Point(1, 2)    print(p)  class Point(object):    def __init__(self, x, y):        self.x = x        self.y = y    def __str__(self):        return '点的位置:({0}, {1})'.format(self.x, self.y)if __name__ == '__main__':    p = Point(1, 2)    print(p)  # 点的位置:(1, 2)\n\n123456789101112131415161718192021222324252627282930313233343536373839class MyDate(object):    \"\"\"自己实现的日期类\"\"\"    source = 'ioomc'    def __init__(self, month, day):        \"\"\"构造方法\"\"\"        self.month = month        self.day = day    def show_info(self):        \"\"\"展示日期详情\"\"\"        print('月份: {0}; 日期: {1}'.format(self.month, self.day))        print('实例方法访问类的属性: {0}'.format(self.source))    @staticmethod    def validate_month(month):        \"\"\"静态方法，验证我们的月份是否合法\"\"\"        month = int(month)        print('类的属性: {}'.format(MyDate.source))        # return month &gt;= 1 and month &lt;= 12        return 1 &lt;= month &lt;= 12if __name__ == '__main__':    my_date = MyDate(5, 20)        # 实例方法的调用    my_date.show_info()    # 月份: 5; 日期: 20    # 实例方法访问类的属性: ioomc    # 静态方法的调用    print(MyDate.validate_month('15'))    # 类的属性: ioomc    # False    print(my_date.validate_month('11'))    # 类的属性: ioomc    class MyDate(object):    \"\"\"自己实现的日期类\"\"\"    source = 'ioomc'    def __init__(self, month, day):        \"\"\"构造方法\"\"\"        self.month = month        self.day = day    def show_info(self):        \"\"\"展示日期详情\"\"\"        print('月份: {0}; 日期: {1}'.format(self.month, self.day))        print('实例方法访问类的属性: {0}'.format(self.source))    @staticmethod    def validate_month(month):        \"\"\"静态方法，验证我们的月份是否合法\"\"\"        month = int(month)        print('类的属性: {}'.format(MyDate.source))        # return month &gt;= 1 and month &lt;= 12        return 1 &lt;= month &lt;= 12if __name__ == '__main__':    my_date = MyDate(5, 20)        # 实例方法的调用    my_date.show_info()    # 月份: 5; 日期: 20    # 实例方法访问类的属性: ioomc    # 静态方法的调用    print(MyDate.validate_month('15'))    # 类的属性: ioomc    # False    print(my_date.validate_month('11'))    # 类的属性: ioomc    # True\n\n12345678910111213class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score    def print_score(self):        print('%s: %s' % (self.name, self.score))bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()  # Bart Simpson: 59lisa.print_score()  class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score    def print_score(self):        print('%s: %s' % (self.name, self.score))bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()  # Bart Simpson: 59lisa.print_score()  # Lisa Simpson: 87\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"Python3和python2差异","url":"https://bubbleboy11.github.io/2020/08/21/python3-he-python2-chai-yi/","content":"Python关键字\n12345import keywordprint(keyword.kwlist)# ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',# 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',import keywordprint(keyword.kwlist)# ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',# 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',# 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\nprintpython2中是关键字。\n12345# python2的打印 print&gt;&gt;&gt; print 'b'b&gt;&gt;&gt; print('a', 'b') # 打印的是a和b合并成tuple对象('a', # python2的打印 print&gt;&gt;&gt; print 'b'b&gt;&gt;&gt; print('a', 'b') # 打印的是a和b合并成tuple对象('a', 'b')\n\npython3成为函数就支持传入不同参数，比如不同换行符end或者分隔符sep\n1234567# python3的打印 print()&gt;&gt;&gt; print('b')b&gt;&gt;&gt; print('a', 'b',sep='|' ) # sep:分隔符，end:换行符a|b&gt;&gt;&gt; print('a', # python3的打印 print()&gt;&gt;&gt; print('b')b&gt;&gt;&gt; print('a', 'b',sep='|' ) # sep:分隔符，end:换行符a|b&gt;&gt;&gt; print('a', 'b')a b\n\n计算机是 以字节为单位 来 存储和传输数据的，\n\n一个字节 由 8位二进制数字表示，最多可以表示从0到255，一共256个字符。\n\nPython中字符串的类型只有两种（str，bytes）文本字符串和字节字符串。其中文本字符串类型被命名为str，内部采用Unicode字符集（兼容ASCII码），而字节字符串则直接用来表示原始的字节序列（用print函数来打印字节字符串时，若字节在ascii码范围内，则显示为ascii码对应的字符，其余的则直接显示为16进制数），该类型被命名为bytes。\n有三种前缀\n\n无前缀一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。\n\n前缀u/U:一个具体的unicode字符表示法\\uxxxx，\\u会自动去寻找后面4位16进制数，然后去Unicode字符集寻找对应的字符来显式输出。不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。\n\n\n123//定义变量存放unicode编码表示的字符char c = '\\u005d';System.out.println(\"c=\" + c);  //定义变量存放unicode编码表示的字符char c = '\\u005d';System.out.println(\"c=\" + c);  // c=]\n\n\n前缀b: bytes 文件操作模式会用到 可存储到文件或者传输到网络中\n\nPython3字符串str==unicode，是和人交互的，用来操作的，前缀带不带u，其实都一样。每个字符用字符本身或者\\u1234，来表示都可以，后者则是直接是Unicode编码。但打印时都是打印字符本身。\n想在py3里看字符，必须得是unicode编码，其它编码一律按bytes格式展示。unicode是某种特定编码的字节流，是bytes的子集。这就意味着：所有的unicode都能放进bytes，但某些bytes无法放进unicode。不是utf-8，utf-8编码的是bytes\n字节串bytes!=str：计算机自己能理解的“语言”是二进制数，最小的信息标识是二进制位，给计算机传输或者保存的 字节是将unicode编码后的utf或gbk字节串，bytes是(py2.x)的str不能print，直接print你decode出来的那个str就行了，不需要再encode\npython2字符串有两种字符串类型unicode，str和是python3中的byte，bytes==strunicode!=str\npython里写入文件出现乱码通常都是因为编码导致的。很多人说我已经encode设置为utf-8了呀，怎么还会出现乱码呢？其实这里涉及到2个编码的问题1、字符串的编码，比如我们爬虫返回的text的编码2、文件的编码要想不出现编码，必须保证文字的编码和文件的编码一致。\n编码和解码就是Python中str和bytes这两种字符串类型之间的互相转换。\nstr.encode(encoding='UTF-8', errors='strict')以指定的编码格式编码，把str类型的字符串转换为bytes字符串，字符对应的若干十六进制数，\n如```\\xc9```，代表两位16进制，一个字节123456789101112- encoding -- 要使用的编码   - ```utf-8``` ```UTF8``` 用三个十六进制 3个字节 来表示一个中文字符，   - ```gbk```编码中文用 二个十六进制 2个字节Bytes 来表示一个中文字符，每个bytes，即8位bit的第一个位作为标志位，标志位为1则表示是中文字符，如果标志位为0则表示为英文字符```pyimport sysprint(sys.platform)  # win32print(sys.getdefaultencoding())  # utf-8# 平台默认选择的就是utf-8编码方式。\n\n\nerrors – 设置不同错误的处理方案。默认为 ‘strict’，意为编码错误引起一个UnicodeError。 其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。该方法返回编码后的字符串，它是一个 bytes 对象。\n\nbytes.decode(encoding=\"utf-8\", errors=\"strict\")以指定的编码格式解码 bytes 对象。\n\nencoding – 要使用的编码，默认编码为 ‘utf-8’。\nerrors – 设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeError。其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。\n\n从文件中读入文字信息， 从网络上接收 文字信息，获取的数据通常是使用某种字符编码后的 字节串\n当python解释器执行到产生字符串的代码时（例如x=’上’），会申请新的内存地址，然后将’上’编码成文件开头指定的编码格式\n想看x在内存中的真实格式，可以将其放入列表中再打印，而不要直接打印，因为直接print()会自动转换编码，\n字符串编码转换\n12345678910111213# python2 编码# coding:gbkx='上'y='下'print([x,y]) # ['\\xc9\\xcf', '\\xcf\\xc2']print(type(x),type(y)) # (&lt;type 'str'&gt;, &lt;type 'str'&gt;)# c9cf总共4位16进制数，# 一个16进制 4个比特位# 4个16进制数则是16个比特位，即2个Bytesx='上'.decode('gbk')y='下'.decode('gbk')print([x,y]) # python2 编码# coding:gbkx='上'y='下'print([x,y]) # ['\\xc9\\xcf', '\\xcf\\xc2']print(type(x),type(y)) # (&lt;type 'str'&gt;, &lt;type 'str'&gt;)# c9cf总共4位16进制数，# 一个16进制 4个比特位# 4个16进制数则是16个比特位，即2个Bytesx='上'.decode('gbk')y='下'.decode('gbk')print([x,y]) #[u'\\u4e0a', u'\\u4e0b']\n123&gt;&gt;&gt; s = u'中文' # python2中定义包含中文字符串必须加U前缀&gt;&gt;&gt; type(s)&lt;type &gt;&gt;&gt; s = u'中文' # python2中定义包含中文字符串必须加U前缀&gt;&gt;&gt; type(s)&lt;type 'unicode'>\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344# python3 编码string = u'中文'  # 加u，'中文'也会被以unicode形式保存新的内存空间中print(string, type(string), len(string))  # 中文 &lt;class 'str'&gt; 2s = '中文'  # 无需加u，'中文'也会被以unicode形式保存新的内存空间中print(s, type(s), type(s), len(s))  # 中文 &lt;class 'str'&gt; 2print(string == s)  # Trueprint(string is s)  # True# 将 Unicode 编码格式字符串转换成 UTF-8print(s.encode(), type(s.encode()), len(s.encode()))  # 默认UTF-8# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt; 6# utf-8是多字节编码，你的\\xe4\\xb8\\xad合起来是一个字符，# 而unicode里面，\\xe4, \\xb8, \\xad各自是一个字符，# 相当于\\u00e4, \\u00b8, \\u00ad，所以当然是乱码了print(s.encode(encoding=\"UTF8\", type(s.encode()), len(s.encode())),      type(s.encode(encoding=\"UTF-8\")))# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt;print(s.encode(encoding=\"UTF-8\", type(s.encode()), len(s.encode())),      type(s.encode(encoding=\"UTF-8\")))# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt;print(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\"),\\    type(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\")),len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\")))# 中文 &lt;class 'str'&gt;# 将 Unicode 编码格式字符串 转换成 GBK 编码print(s.encode(\"GBK\"), type(s.encode(\"GBK\")), len(s.encode(\"GBK\")))# b'\\xd6\\xd0\\xce\\xc4' &lt;class 'bytes'&gt;# 将 GBK 编码格式字符串 转化成 Unicodeprint(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK'),\\    type(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK', 'strict')),len(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK', 'strict')))# 中文 &lt;class 'str'&gt;# 只有ascii字符集中的字符，三种编码方式得到的结果才完全一致。print('abc'.encode())  # b'abc'print('abc'.encode('GBK'))  # b'abc'print('abc'.encode('latin-1'))  # python3 编码string = u'中文'  # 加u，'中文'也会被以unicode形式保存新的内存空间中print(string, type(string), len(string))  # 中文 &lt;class 'str'&gt; 2s = '中文'  # 无需加u，'中文'也会被以unicode形式保存新的内存空间中print(s, type(s), type(s), len(s))  # 中文 &lt;class 'str'&gt; 2print(string == s)  # Trueprint(string is s)  # True# 将 Unicode 编码格式字符串转换成 UTF-8print(s.encode(), type(s.encode()), len(s.encode()))  # 默认UTF-8# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt; 6# utf-8是多字节编码，你的\\xe4\\xb8\\xad合起来是一个字符，# 而unicode里面，\\xe4, \\xb8, \\xad各自是一个字符，# 相当于\\u00e4, \\u00b8, \\u00ad，所以当然是乱码了print(s.encode(encoding=\"UTF8\", type(s.encode()), len(s.encode())),      type(s.encode(encoding=\"UTF-8\")))# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt;print(s.encode(encoding=\"UTF-8\", type(s.encode()), len(s.encode())),      type(s.encode(encoding=\"UTF-8\")))# b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' &lt;class 'bytes'&gt;print(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\"),\\    type(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\")),len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode(\"UTF-8\")))# 中文 &lt;class 'str'&gt;# 将 Unicode 编码格式字符串 转换成 GBK 编码print(s.encode(\"GBK\"), type(s.encode(\"GBK\")), len(s.encode(\"GBK\")))# b'\\xd6\\xd0\\xce\\xc4' &lt;class 'bytes'&gt;# 将 GBK 编码格式字符串 转化成 Unicodeprint(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK'),\\    type(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK', 'strict')),len(b'\\xd6\\xd0\\xce\\xc4'.decode('GBK', 'strict')))# 中文 &lt;class 'str'&gt;# 只有ascii字符集中的字符，三种编码方式得到的结果才完全一致。print('abc'.encode())  # b'abc'print('abc'.encode('GBK'))  # b'abc'print('abc'.encode('latin-1'))  # b'abc'\n\n12345def 大写(s):    return s.upper()print(大写('abc'))  def 大写(s):    return s.upper()print(大写('abc'))  # 'ABC'\n\n如果**type(text) is str**，那么text.encode(‘latin1’).decode(‘unicode_escape’)\n如果**type(text) is bytes**，那么text.decode('unicode_escape')\nunicode_escape unicode-escape 的解码与编码规则，编码用unicode数字字符串表示字符\n解码碰到\\会去掉一个\\，编码的时候会添上一个,所以就解释了b’\\uxxxx’就是b’\\uxxxx’ ，因为\\u的情况下面，根本不可能出现一个\\的情况。所以总的思路是出现’\\uxxxx’的字符串，首先通过一种常规的字符编码方式utf8 gbc随便你，转换成b’\\uxxxx’的形式，然后再通过’unicode_escape’的编码解码，变成’\\uxxxx’的形式，\n12345678910111213141516171819202122232425print('中文'.encode('unicode_escape'))# b'\\\\u4e2d\\\\u6587'print('中文'.encode('unicode-escape'))# b'\\\\u4e2d\\\\u6587'print(type('中文'.encode('unicode_escape')), len('中文'.encode('unicode_escape')))# &lt;class 'bytes'&gt; 12# 一个反斜杠 unicode转义数字 写字符串print('\\u4e2d\\u6587', type('\\u4e2d\\u6587'), len('\\u4e2d\\u6587'))# 中文 &lt;class 'str'&gt; 2# Python的字符串中应该不会出现'\\uxxxx'的字符。# 如果出现了，那应该是'\\\\uxxxx'注意前面应该是两个反斜杠，直接把\\u的反斜杠转义了print(r'\\u5bb6')  # \\u5bb6 print(b'\\u5bb6')  # b'\\\\u5bb6'print(b'\\u5bb6'.decode('unicode_escape'))  # 家print('\\u5bb6')  # 家print('\\\\u5bb6')  # \\u5bb6print('\\\\u5bb6'.encode())  # b'\\\\u5bb6'print('\\\\u5bb6'.encode().decode())  # \\u5bb6print('\\\\u5bb6'.encode().decode('unicode_escape'))  # 家print('\\\\u5bb6'.encode('unicode_escape'))  # b'\\\\\\\\u5bb6'print('\\\\u5bb6'.encode('unicode_escape').decode('unicode_escape'))  print('中文'.encode('unicode_escape'))# b'\\\\u4e2d\\\\u6587'print('中文'.encode('unicode-escape'))# b'\\\\u4e2d\\\\u6587'print(type('中文'.encode('unicode_escape')), len('中文'.encode('unicode_escape')))# &lt;class 'bytes'&gt; 12# 一个反斜杠 unicode转义数字 写字符串print('\\u4e2d\\u6587', type('\\u4e2d\\u6587'), len('\\u4e2d\\u6587'))# 中文 &lt;class 'str'&gt; 2# Python的字符串中应该不会出现'\\uxxxx'的字符。# 如果出现了，那应该是'\\\\uxxxx'注意前面应该是两个反斜杠，直接把\\u的反斜杠转义了print(r'\\u5bb6')  # \\u5bb6 print(b'\\u5bb6')  # b'\\\\u5bb6'print(b'\\u5bb6'.decode('unicode_escape'))  # 家print('\\u5bb6')  # 家print('\\\\u5bb6')  # \\u5bb6print('\\\\u5bb6'.encode())  # b'\\\\u5bb6'print('\\\\u5bb6'.encode().decode())  # \\u5bb6print('\\\\u5bb6'.encode().decode('unicode_escape'))  # 家print('\\\\u5bb6'.encode('unicode_escape'))  # b'\\\\\\\\u5bb6'print('\\\\u5bb6'.encode('unicode_escape').decode('unicode_escape'))  # \\u5bb6\n\n12345678910b = b'apple'print(b, type(b))# b'apple' &lt;class 'bytes'&gt;print(b[0])  # 97print(b[1:])  # b'pple'print(list(b))  # [97, 112, 112, 108, 101]userInputTag = [\"\\xe5\\x8f\\xa4\\xe8\\xbf\\xb9\", \"\\xe5\\xbb\\xba\\xe7\\xad\\x91\"]print(userInputTag[0].encode('latin-1').decode('utf-8'), type(userInputTag[0]))b = b'apple'print(b, type(b))# b'apple' &lt;class 'bytes'&gt;print(b[0])  # 97print(b[1:])  # b'pple'print(list(b))  # [97, 112, 112, 108, 101]userInputTag = [\"\\xe5\\x8f\\xa4\\xe8\\xbf\\xb9\", \"\\xe5\\xbb\\xba\\xe7\\xad\\x91\"]print(userInputTag[0].encode('latin-1').decode('utf-8'), type(userInputTag[0]))# 古迹 \n\n\n除法变化Python3除号返回浮点数，Python2中直接截断并且返回整数，像是C语言的除法\n123# python2中除法&gt;&gt;&gt; 5/22  # python2中除法&gt;&gt;&gt; 5/22  # 会做整数截断，只保留整数值 \n\n1234# python3中除法print(5/2)  # 2.5  float的值print(5//2)  # 2 实现python2一样除法print(-5//2)  # python3中除法print(5/2)  # 2.5  float的值print(5//2)  # 2 实现python2一样除法print(-5//2)  # -3 实现python2一样除法\n\n类型注解(type hint)。给变量添加类型提示IDE可以根据它检查类型是否一致。解释器运行时，并不会做检查\nOnce compiled, a function’s annotations are available via the function’s annotations attribute.This attribute is a mutable dictionary,sThere is a special key in the annotations mapping, “return”.This key is present only if an annotation was supplied for the function’s return value.如果该函数上没有注释，或者该函数是从lambda表达式创建的，则__annotations__是一个空的可变字典。第一行输出中的__annotations__是函数的保留属性，保存的是函数声明中的注释内容，\n使用dir(fucntionName)的时候，多了一个__annotations__的属性annotations：注解; 评注; 注文; 释文\nPython 3 extends the feature by allowing you to attach metadatato functions describing their parameters and return values为了标注 输入参数参数和返回值的类型。“-&gt;” 函数返回值的类型建议符，类型建议符并非强制规定和检查，也就是说即使传入的实际参数与建议参数不符，也不会报错。-&gt; str 意思即是提醒函数使用者返回值会是一个str型。:后面是建议传入的参数类型，\n使用第三方工具mypy实现类型检查，消除一些代码错误\n1234567# name:str 表示输入的name的值是str类型, -&gt; st 表示返回值是str类型def hello(name: str) -&gt; str:  # 起到提示作用，并没有实现真正类型检查    return 'hello ' + nameprint(hello('Ashe'))# name:str 表示输入的name的值是str类型, -&gt; st 表示返回值是str类型def hello(name: str) -&gt; str:  # 起到提示作用，并没有实现真正类型检查    return 'hello ' + nameprint(hello('Ashe'))# hello Ashe\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596def greeting(name: str) -&gt; str:    return 'Hello ' + nameprint(greeting.__annotations__)def foo(a: 'x', b: 5 + 6, c: list) -&gt; max(2, 9):    passprint(foo.__annotations__)# {'a': 'x', 'b': 11, 'c': &lt;class 'list'&gt;, 'return': 9}def twoSum(num1: int, num2: int = 100) -&gt; int:    sum = num1 + num2    return sumprint('-----')print(dir(twoSum))# output: ['__annotations__', '__call__', '__class__', '__closure__', ... ]print(twoSum.__annotations__)# {'num1': &lt;class 'int'&gt;, 'num2': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;}print(twoSum(1, 2))  # 3print(twoSum(1))  # 101print(twoSum('I love ', 'python'))  # I love python# print(twoSum('python'))  # TypeError: can only concatenate str (not \"int\") to str\"\"\"第二行输出是正常用法。第三行输出验证了：注释内容后可以跟等号\"=\",意思为未传入实参时，该参数获得的默认值第四行输出则验证了该解释说明符并非强制检查，我们传入了两个str实参，并不会报错，而是继续进行函数中的加法运算。如果传入的两个实参无法进行函数中规定的运算，则会正常报错。\"\"\"def kinetic_energy(m: 'in KG', v: 'in M/S') -&gt; 'Joules':    return 1 / 2 * m * v ** 2print(kinetic_energy.__annotations__)# {'m': 'in KG', 'v': 'in M/S', 'return': 'Joules'}print('{:,} {}'.format(kinetic_energy(20, 3000),                       kinetic_energy.__annotations__['return']))# 90,000,000.0 Joules# Annotations are dictionaries# There is a special key in the __annotations__ mapping, \"return\".# This key is present only if an annotation was supplied for the function's return value.rd = {'type': float, 'units': 'Joules', 'docstring': 'Given mass and velocity returns kinetic energy in Joules'}def f() -&gt; rd:    passprint(f.__annotations__['return']['type'])# &lt;class 'float'&gt;print(f.__annotations__['return']['units'])# 'Joules'print(f.__annotations__['return']['docstring'])# 'Given mass and velocity returns kinetic energy in Joules'# you can use function attributes to validate called values:def validate(func, locals):    for var, test in func.__annotations__.items():        value = locals[var]        try:            pr = test.__name__ + ': ' + test.__docstring__        except AttributeError:            pr = test.__name__        msg = '{}=={}; Test: {}'.format(var, value, pr)        assert test(value), msgdef between(lo, hi):    def _between(x):        return lo &lt;= x &lt;= hi    _between.__docstring__ = 'must be between {} and {}'.format(lo, hi)    return _betweendef f(x: between(3, 10), y: lambda _y: isinstance(_y, int)):    validate(f, locals())    print(x, y)f(2, 2)# AssertionError: x==2; Test: _between: must be between 3 and 10f(3, 2.1)def greeting(name: str) -&gt; str:    return 'Hello ' + nameprint(greeting.__annotations__)def foo(a: 'x', b: 5 + 6, c: list) -&gt; max(2, 9):    passprint(foo.__annotations__)# {'a': 'x', 'b': 11, 'c': &lt;class 'list'&gt;, 'return': 9}def twoSum(num1: int, num2: int = 100) -&gt; int:    sum = num1 + num2    return sumprint('-----')print(dir(twoSum))# output: ['__annotations__', '__call__', '__class__', '__closure__', ... ]print(twoSum.__annotations__)# {'num1': &lt;class 'int'&gt;, 'num2': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;}print(twoSum(1, 2))  # 3print(twoSum(1))  # 101print(twoSum('I love ', 'python'))  # I love python# print(twoSum('python'))  # TypeError: can only concatenate str (not \"int\") to str\"\"\"第二行输出是正常用法。第三行输出验证了：注释内容后可以跟等号\"=\",意思为未传入实参时，该参数获得的默认值第四行输出则验证了该解释说明符并非强制检查，我们传入了两个str实参，并不会报错，而是继续进行函数中的加法运算。如果传入的两个实参无法进行函数中规定的运算，则会正常报错。\"\"\"def kinetic_energy(m: 'in KG', v: 'in M/S') -&gt; 'Joules':    return 1 / 2 * m * v ** 2print(kinetic_energy.__annotations__)# {'m': 'in KG', 'v': 'in M/S', 'return': 'Joules'}print('{:,} {}'.format(kinetic_energy(20, 3000),                       kinetic_energy.__annotations__['return']))# 90,000,000.0 Joules# Annotations are dictionaries# There is a special key in the __annotations__ mapping, \"return\".# This key is present only if an annotation was supplied for the function's return value.rd = {'type': float, 'units': 'Joules', 'docstring': 'Given mass and velocity returns kinetic energy in Joules'}def f() -&gt; rd:    passprint(f.__annotations__['return']['type'])# &lt;class 'float'&gt;print(f.__annotations__['return']['units'])# 'Joules'print(f.__annotations__['return']['docstring'])# 'Given mass and velocity returns kinetic energy in Joules'# you can use function attributes to validate called values:def validate(func, locals):    for var, test in func.__annotations__.items():        value = locals[var]        try:            pr = test.__name__ + ': ' + test.__docstring__        except AttributeError:            pr = test.__name__        msg = '{}=={}; Test: {}'.format(var, value, pr)        assert test(value), msgdef between(lo, hi):    def _between(x):        return lo &lt;= x &lt;= hi    _between.__docstring__ = 'must be between {} and {}'.format(lo, hi)    return _betweendef f(x: between(3, 10), y: lambda _y: isinstance(_y, int)):    validate(f, locals())    print(x, y)f(2, 2)# AssertionError: x==2; Test: _between: must be between 3 and 10f(3, 2.1)# AssertionError: y==2.1; Test: \n\n优化的 super() 方便直接调用父类函数  super().eat()  # 直接就可以调用父类，像什么 self 都不必传递\n\n12345678910111213141516171819class Base(object):    def hello(self):        print('hello')        class C(Base):    def hello(self):        # py2，显示调用父类方法        return super(C, self).hello() c = C()c.hello()   # hello class C2(Base):    def hello(self):        # py3，显示调用父类方法        return super().hello() c2 = C2()c2.hello()  class Base(object):    def hello(self):        print('hello')        class C(Base):    def hello(self):        # py2，显示调用父类方法        return super(C, self).hello() c = C()c.hello()   # hello class C2(Base):    def hello(self):        # py3，显示调用父类方法        return super().hello() c2 = C2()c2.hello()  # hello\n\n高级解包操作123456789# python2中无解包操作&gt;&gt;&gt; a, b, c = [1, 2, 3]&gt;&gt;&gt; a,b,c(1, 2, 3)&gt;&gt;&gt; a, b, *c = range(10)    File \"&lt;stdin&gt;\", line 1    a, b, *c = range(# python2中无解包操作&gt;&gt;&gt; a, b, c = [1, 2, 3]&gt;&gt;&gt; a,b,c(1, 2, 3)&gt;&gt;&gt; a, b, *c = range(10)    File \"&lt;stdin&gt;\", line 1    a, b, *c = range(10)          ^SyntaxError: invalid syntax\n12345678910111213# python3中解包操作&gt;&gt;&gt; a, b, *c = range(10)  &gt;&gt;&gt; a0&gt;&gt;&gt; b1&gt;&gt;&gt; c[2, 3, 4, 5, 6, 7, 8, 9]  # 剩下的元素全部赋值给c&gt;&gt;&gt; a, b, *_ = range(5)  # 丢弃2,3,4元素&gt;&gt;&gt; a0&gt;&gt;&gt; b# python3中解包操作&gt;&gt;&gt; a, b, *c = range(10)  &gt;&gt;&gt; a0&gt;&gt;&gt; b1&gt;&gt;&gt; c[2, 3, 4, 5, 6, 7, 8, 9]  # 剩下的元素全部赋值给c&gt;&gt;&gt; a, b, *_ = range(5)  # 丢弃2,3,4元素&gt;&gt;&gt; a0&gt;&gt;&gt; b1\n\n限定关键字参数当参数特别多的时候，想把后面参数指定名字进行传入，限定关键字参数需要指定参数名传参，关键字参数实际就是传入值得时候指定值的参数名字，\nKeyword only arguments 关键字参数根据参数名来传入参数值，则无须遵守定义形参的顺序，以param = value的方式传递数据\n使用关键字参数好处 :①关键字参数顺序也可以不按函数声明参数的顺序。可以防止参数的位置顺序搞混②清晰地指出了参数值，有助于提高程序的可读性\n1234567def add(a, b, *, c):    # python3中支持语法，要显示转入c的值，前面加一个参数*号就行。    return a + b + c# c = 3 就是限定关键字参数方式print(add(1, 2, c=def add(a, b, *, c):    # python3中支持语法，要显示转入c的值，前面加一个参数*号就行。    return a + b + c# c = 3 就是限定关键字参数方式print(add(1, 2, c=3))\n\n\nChained exception(连接异常)。Python3重新抛出异常不会丢失栈信息，有 raise from 保留异常栈信息python2重新抛出异常会丢失栈信息、原来的 traceback 信息\n12345678910111213141516171819202122232425```pythonimport shutil  def mycopy(source, dest):    # Python3中支持 raise from保留异常栈信息    try:        shutil.copy2(source, dest)    except OSError: # python2中raise会丢失原来的 traceback信息        raise NotImplementedError(\"automatic sudo injection\") from OSError        # 这样会把所有栈信息抛出，有利于去排错  mycopy('old', 'new')输出结果：# OSError # The above exception was the direct cause of the following exception: # Traceback (most recent call last):#   File \"chain_exception.py\", line 12, in #     mycopy('old', 'new')#   File \"chain_exception.py\", line 9, in mycopy#     raise NotImplementedError(\"automatic sudo injection\") from OSError# NotImplementedError: automatic sudo injection\n\n\n一切都是返回迭代对象 range, zip, map, dict.values, etc, are.all iterators。python2中range和map返回的都是列表，当这个列表非常大时候会非常消耗内存，python3中很多内置函数之前返回列表的现在返回是迭代器，迭代器是”惰性加载”的，这样会省很多内存如果我们需要显示得到一个列表时候，我么就需要list进行强转一下)，返回列表会消耗大的内存\n1234567891011121314151617181920212223# python2中&gt;&gt;&gt; range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # 返回列表&gt;&gt;&gt; print(type(range(10)))&lt;type 'list'&gt;&gt;&gt;&gt; print(xrange(10))xrange(10) &gt;&gt;&gt; for i in xrange(100):print(i) # python2中xrange返回可迭代对象，python3中没有xrange函数 ---------------------------------------------------------------# python3中&gt;&gt;&gt; range(10)range(0, 10)  # 返回软加载可迭代对象&gt;&gt;&gt; print(type(range(10)))&lt;class 'range'&gt;&gt;&gt;&gt; print(list(range(10)))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]   &gt;&gt;&gt; for i in range(10):print(i， end=' ')   # end默认值是'\\n'换行，置空表示水平输出...0 1 2 3 4 5 6 7 8 # python2中&gt;&gt;&gt; range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  # 返回列表&gt;&gt;&gt; print(type(range(10)))&lt;type 'list'&gt;&gt;&gt;&gt; print(xrange(10))xrange(10) &gt;&gt;&gt; for i in xrange(100):print(i) # python2中xrange返回可迭代对象，python3中没有xrange函数 ---------------------------------------------------------------# python3中&gt;&gt;&gt; range(10)range(0, 10)  # 返回软加载可迭代对象&gt;&gt;&gt; print(type(range(10)))&lt;class 'range'&gt;&gt;&gt;&gt; print(list(range(10)))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]   &gt;&gt;&gt; for i in range(10):print(i， end=' ')   # end默认值是'\\n'换行，置空表示水平输出...0 1 2 3 4 5 6 7 8 9\npython3中不再使用dict.iteritems() ，直接使用dict.items()方法就可以返回可迭代对象。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":["剑指offer","Leetcode"]},{"title":"Python常用内置算法和数据结构","url":"https://bubbleboy11.github.io/2020/08/21/python-chang-yong-nei-zhi-suan-fa-he-shu-ju-jie-gou/","content":"Python常用内置算法和数据结构\n\n\n数据结构/算法\n语言内置\n内置库\n\n\n\n线性结构\nlist(列表)/tuple(元祖)\narray(数组，不常用)/collections.namedtuple\n\n\n链式结构\n\ncollections.deque(双端队列)\n\n\n字典结构\ndict(字典)\ncollections.Counter(计数器)/OrderedDict(有序字典)/defaultdict\n\n\n集合结构\nset(集合)/frozenset(不可变集合)\n\n\n\n排序算法\nsorted\n\n\n\n二分算法\n\nbisect模块\n\n\n堆算法\n\nheapq模块\n\n\n缓存算法\n\nfunctools.lru_cache(Least Recent Used, python3)\n\n\nfrozenset固定集合是不可变、无序的，含有唯一元素的不可迭代的集合，作用：固定集合可以作为字典的键，还可以作为字典的值\nfrozenset([iterable])``` 固定集合的构造函数123456789101112131415iterable -- 可迭代的对象，比如列表、字典、元组等等。用可迭代对象创建一个固定的、不能再添加或删除任何元素的集合，返回新的 frozenset 对象，如果不提供任何参数，默认会生成空的固定集合为什么需要冻结的集合（即不可变的集合）呢？因为在集合的关系中，有集合的中的元素是另一个集合的情况，但是普通集合（set）本身是可变的，那么它的实例就不能放在另一个集合中（set中的元素必须是不可变类型）。所以，frozenset提供了不可变的集合的功能，当集合不可变时，它就满足了作为集合中的元素的要求，就可以放在另一个集合中了。```python>>>a = frozenset(range(10))     # 生成一个新的不可变集合>>> afrozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])>>> b = frozenset('runoob') >>> bfrozenset(['b', 'r', 'u', 'o', 'n'])   # 创建不可变集合\n\ncollections是Python内建的一个集合模块，提供的一些内置数据结构拓展，力扣提交时环境中已经有import collections\nnamedtuple()factory function for creating tuple subclasses with named fields创建命名元组子类的工厂函数  具名元组接受类型的名称和属性列表创建一个自定义的 tuple 对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。作用场景：通过下标不太可读通过属性名称变得比较可读。它具备tuple的不变性\ntuple可以表示一个元组，是不可变的集合,例如一个点的二维坐标就可以这样表示成p=(1,2)但是，(1,2)很难看出这个tuple是用来表示一个坐标的\n12345678import collectionsPoint = collections.namedtuple('Point', 'x,y')  # 定义一个tuple对象p = Point(1, 2)  # 给x赋值1，y赋值2print(p.x)  # 1print(p.y)  # 2print(p[0])  # 1print(p[1])  # 2print(p.x == p[0])  import collectionsPoint = collections.namedtuple('Point', 'x,y')  # 定义一个tuple对象p = Point(1, 2)  # 给x赋值1，y赋值2print(p.x)  # 1print(p.y)  # 2print(p[0])  # 1print(p[1])  # 2print(p.x == p[0])  # True\n\n\ndeque /dek/list-like container with fast appends and pops on either end类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)是为了高效实现插入和删除操作的双向列表，deque可以方便实现 queue (队列 ) / stack (栈)。\n123456789import collectionsde = collections.deque()  # 定义deque对象print(de)  # deque([])de.append(1)  # 右边添加1元素de.appendleft(0)  # 左边添加0元素print(de)  # deque([0, 1])de.pop()  # 1 输出右边元素de.popleft()  # 0 输出左边元素print(de)  import collectionsde = collections.deque()  # 定义deque对象print(de)  # deque([])de.append(1)  # 右边添加1元素de.appendleft(0)  # 左边添加0元素print(de)  # deque([0, 1])de.pop()  # 1 输出右边元素de.popleft()  # 0 输出左边元素print(de)  # deque([])\n\nCounterdict subclass for counting hashable objects字典的子类，提供了可哈希对象的计数功能，值是一个字典\n\n\n12345678910111213141516&gt;&gt;&gt; import collections&gt;&gt;&gt; c = collections.Counter()   # 定义Counter对象&gt;&gt;&gt; c = collections.Counter('abcab') # 统计字符数目&gt;&gt;&gt; cCounter({'a': 2, 'b': 2, 'c': 1})   # 值是一个字典，a是有2个，b是有2个，c是有1个&gt;&gt;&gt; c['a']  # 统计字符串每个字符个数2&gt;&gt;&gt; c.most_common() # 获取从大到小每个字符数量[('a', 2), ('b', 2), ('c', 1)]&gt;&gt;&gt;&gt;&gt;&gt; for ch in 'programming':      c[ch]=c[ch]+1...&gt;&gt;&gt; cCounter({'g':2,'m'2,'r':2,'a':1,'i':1,'o':1,'n':1,'p':&gt;&gt;&gt; import collections&gt;&gt;&gt; c = collections.Counter()   # 定义Counter对象&gt;&gt;&gt; c = collections.Counter('abcab') # 统计字符数目&gt;&gt;&gt; cCounter({'a': 2, 'b': 2, 'c': 1})   # 值是一个字典，a是有2个，b是有2个，c是有1个&gt;&gt;&gt; c['a']  # 统计字符串每个字符个数2&gt;&gt;&gt; c.most_common() # 获取从大到小每个字符数量[('a', 2), ('b', 2), ('c', 1)]&gt;&gt;&gt;&gt;&gt;&gt; for ch in 'programming':      c[ch]=c[ch]+1...&gt;&gt;&gt; cCounter({'g':2,'m'2,'r':2,'a':1,'i':1,'o':1,'n':1,'p':1})\n\n\nOrderedDictdict subclass that remembers the order entries were added字典的子类，保存了他们被添加的顺序，key 顺序是第一次插入的顺序。\n1234567&gt;&gt;&gt; import collections&gt;&gt;&gt; od = collections.OrderedDict()&gt;&gt;&gt; od['c'] = 'c'&gt;&gt;&gt; od['a'] = 'a'&gt;&gt;&gt; od['b'] = 'b'&gt;&gt;&gt; list(od.keys())['c', 'a', 'b']   &gt;&gt;&gt; import collections&gt;&gt;&gt; od = collections.OrderedDict()&gt;&gt;&gt; od['c'] = 'c'&gt;&gt;&gt; od['a'] = 'a'&gt;&gt;&gt; od['b'] = 'b'&gt;&gt;&gt; list(od.keys())['c', 'a', 'b']   # key的顺序是第一次插入的顺序。\n\ndefaultdictdict subclass that calls a factory function to supply missing valuesdefaultdict字典的子类，提供了一个工厂函数，为字典查询提供一个默认值\n\n\n1234567&gt;&gt;&gt; import collections&gt;&gt;&gt; dd = collections.defaultdict(int) # 第一个参数必须是可调用的，否则为None&gt;&gt;&gt; dd['a']  # 不存在的key默认为00&gt;&gt;&gt; dd['b'] += 1&gt;&gt;&gt; import collections&gt;&gt;&gt; dd = collections.defaultdict(int) # 第一个参数必须是可调用的，否则为None&gt;&gt;&gt; dd['a']  # 不存在的key默认为00&gt;&gt;&gt; dd['b'] += 1>>> dddefaultdict(, {'a': 0, 'b': 1})\n\nPython dict/set 底层都是哈希表\n哈希表的实现原理, 底层其实就是一个数组, 通过哈希函数把相应的元素映射到一个数组槽里面。\n根据哈希函数快速定位一个元素，平均查找时间复杂度O(1)，查找和插入的速度极快，不会随着key的增加而变慢；二分查找\n不断加入元素会引起哈希表重新开辟空间，拷贝之前元素到新数组，需要占用大量的内存，内存浪费多。\ndict是用来存储键值对（key-value）结构的数据的，\nset没有存储对应的value，其实也是存储的键值对，只是默认键和值是相同的,\n\ndict是python中的一个可变的数据类型，用{}表示，dict curly bracket 花括号dict的key必须是不可变的数据类型对象，同一个字典中的键必须唯一，如果出现多个相同的键，则最新的键会被记住而value的数据类型可以任意\n新版哈希表结构：\n123456789101112131415Indices----------------------------------------------------None | index | None | None | index | None | index ...----------------------------------------------------Entries--------------------hash0   key0  value0---------------------hash1   key1  value1---------------------hash2   key2  value2---------------------Indices----------------------------------------------------None | index | None | None | index | None | index ...----------------------------------------------------Entries--------------------hash0   key0  value0---------------------hash1   key1  value1---------------------hash2   key2  value2---------------------        ...---------------------\n\n集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。\ndict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）\n{0, 1, 2} set 无序，不能通过索引访问，不重复，用来去重set() 创建一个空集合，{}新建一个空字典{} - {}求两个集合的差集，去掉相同的元素，以前面集合为标准，从一个集合里面去掉后面集合特有的元素{} &amp; {}求两个集合的交集，找两个集合的公有元素{} | {}求两个集合的并集，把两个集合合并在一起，按照从前往后的顺序，去掉相同的元素\n\nCPython解释器使用二次探查解决哈希冲突问题\n\n哈希冲突当插入一个Entry&lt;k,v&gt;时，将key经过hash计算出的下标中已经存在另一个Entry&lt;k,v&gt;，这时就会产生哈希冲突。哈希冲突主要是是由于哈希函数产生的哈希值是有限的\n解决哈希冲突的常用方法有\n\n链接法：元素key冲突之后使用一个链表填充相同key 的元素\n开放寻址法(探查法) 又分为线性探查和二次探查等，冲突之后根据一种方式(二次探查)寻找下一个可用的槽。( 探查是一次还是二次看使用函数是一次还是二次的)，\n\n哈希扩容：HashMap的初始值是16（1,&lt;&lt;4）,负载因子0.75（听说这个值是经过大量实践算出来的，这个值设定最合理），初始值16指的是数组的长度（1&lt;&lt;4是2的4次方，这样写计算机执行更快），当数组的容量达到12（16*0.75）时，这时开始扩容，扩容为32（1&lt;&lt;5即2的5次方），每次扩容按照2的倍数递增，扩容是为了减少hash碰撞，让链表的数据更少（最好链表上就一个数据，即为数组的下标数据）\n当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突，满足这两个条件就会哈希扩容。\ndict则为了快速查找使用了一种特别的方法，哈希表，采用哈希函数从key计算得到一个数字（哈希函数有个特点：对于不同的key，有很大的概率得到的哈希值也不同），然后直接把value存储到这个数字所对应的地址上，比如key=’ABC’，value=10，经过哈希函数得到key对应的哈希值为123，那么就申请一个有1000个地址（从0到999）的内存，然后把10存放在地址为123的地方。对于key=’BCD’，value=20，得到key的哈希值为234，那么就把20存放在地址为234的地方。对于这样的表查找起来是非常方便的。只要给出key，计算得到哈希值，然后直接到对应的地址去找value就可以了。无论有几个元素，都可以直接找到value，无需遍历整个表。不过虽然dict查找速度快，但内存浪费严重，你看我们只存储了两个元素，都要申请一个长度为1000的内存。3.现在你知道为啥key要用不可变对象了吧？因为不可变对象是常量，每次的哈希值算出来都是固定的，这样就不会出错。比如key=’ABC’，value=10，存储地址为123，假设我突发奇想，把key改成’BCD’，那么当查找’BCD’的value的时候就会去234的地址找，但那里啥也没有，这就乱套了。\n\nDictionary key 必须是不可变的\n\nPython中list/tuple区别\n都是线性结构、支持下标访问\n\nlist是可变对象，查找和删除的时间复杂度是O(n)，添加的时间复杂度是O(1)没有办法作为字典的key，因为list有可能因为添加新的元素而导致内存地址的更换list既可以当栈、也可以当队列，通过数组实现，而不是链表；因此，每当执行 insert(0, val) 操作时，需要将元素都向后移动一位才可插入，复杂度 O(N) ；这和insert方法不同，是根据索引值来判断插入到链表的哪个位置。\n\ntuple是保存的引用不可变，你没法替换这个对象，但是如果它本身就是一个可变对象，是可以修改这个引用指向的可变对象，比如tuple中包容可变对象，如果tuple里面保存一个list，list本身还是可变的。 parenthese 圆括号，有序的 不变的顺序表可以作为字典的key，可以用在字符串格式化中。\n123456print((), type(()))# () &lt;class 'tuple'&gt; 空元组print((3), type((3)))# 3 &lt;class 'int'&gt;print((3, ), type((3,)))print((), type(()))# () &lt;class 'tuple'&gt; 空元组print((3), type((3)))# 3 &lt;class 'int'&gt;print((3, ), type((3,)))# (3,)  只有一个元组元素后面要加逗号\n\n\n\n1.list和tuple其实是用链表顺序存储的，也就是前一个元素中存储了下一个元素的位置，这样只要找到第一个元素的位置就可以顺藤摸瓜找到所有元素的位置，所以list的名字其实就是个指针，指向list的第一个元素的位置。list的插入和删除等可以直接用链表的方式进行，比如我要在第1个元素和第2个元素中间插入一个元素，那么直接在链表的最后面（我们假设这个list只有两个元素，那么也就是在第3个元素的位置上）插入这个元素，然后把第一个元素指针指向这个元素（第3个位置），然后再把新插入的元素的指针指向原来的第2个元素，这样插入操作就完成了。读取这个list的时候，先用list的名字（就是个指针，指向第1个元素的位置）找到第一个元素，然后用第1一个元素的指针找到第2个元素（位置3），然后用第2个元素的指针找到第3个元素（位置2），以此类推。所以list的顺序和内存中的实际顺序其实不一定完全对应。这种存储方式占用空间小，浪费内存很少。因为要按照链表一个一个找下去，查找和插入的时间随着元素的增加而增加；\n12345678910111213141516s = set([1, 2, 3])print(s)  # {1, 2, 3}   s.add(4)print(s)  # {1, 2, 3, 4}s.remove(4)print(s)  # {1, 2, 3}   t = ([1], 2, 3)print(t[0])  # [1]t[0].append(1)print(t)# ([1, 1], 2, 3)  # 第一个列表对象元素虽然改变，但它依然是这个列表对象print(t[2])  # 3，不可变对象t[2] = 3  s = set([1, 2, 3])print(s)  # {1, 2, 3}   s.add(4)print(s)  # {1, 2, 3, 4}s.remove(4)print(s)  # {1, 2, 3}   t = ([1], 2, 3)print(t[0])  # [1]t[0].append(1)print(t)# ([1, 1], 2, 3)  # 第一个列表对象元素虽然改变，但它依然是这个列表对象print(t[2])  # 3，不可变对象t[2] = 3  # TypeError: 'tuple' object does not support item assignment\n12345678t = (1, '23', [123, 'abc'], ('python', 'learn'))tls = list(t)  #tuple--&gt;listprint(tls)# [1, '23', [123, 'abc'], ('python', 'learn')]t_tuple = tuple(tls)  #list--&gt;tupleprint(t_tuple)t = (1, '23', [123, 'abc'], ('python', 'learn'))tls = list(t)  #tuple--&gt;listprint(tls)# [1, '23', [123, 'abc'], ('python', 'learn')]t_tuple = tuple(tls)  #list--&gt;tupleprint(t_tuple)# (1, '23', [123, 'abc'], ('python', 'learn'))\n\n常用函数listmin(list_name) max(list_name) sum(list_name)len(list_name)\nlist.index(x[, start[, end]])从列表中找出某个值第一个匹配项的索引位置。x– 查找的对象。start– 可选，查找的起始位置。end– 可选，查找的结束位置。返回：查找对象的索引位置，如果没有找到对象则抛出异常。\nstart, end)```返回开始的索引值，没找到则抛出异常。1234567891011121314151617181920212223242526272829303132333435363738```pylist1 = ['Google', 'Runoob', 'Taobao']print('Google 索引值为', list1.index('Google'))# Google 索引值为 0print('Runoob 索引值为', list1.index('Runoob'))# Runoob 索引值为 1print('Taobao 索引值为', list1.index('Taobao'))# Taobao 索引值为 2# 从指定位置开始搜索print('Runoob 索引值为', list1.index('Runoob', 1))# Runoob 索引值为 1# print('Runoob 索引值为', list1.index('Runoob', 2))# ValueError: 'Runoob' is not in listlist1 = ['Google', 'Runoob', 'Taobao']list2 = ['Runoob', 'Taobao', 'Google']dic = {}for i in range(len(list2)):    dic[list2[i]] = i    print(dic)# {'Runoob': 0}# {'Runoob': 0, 'Taobao': 1}# {'Runoob': 0, 'Taobao': 1, 'Google': 2}# {'Runoob': 0, 'Taobao': 1, 'Google': 2}print(list1[0])  # Googlei = dic[list1[0]]print(i)  # 2x = dict()print(x)  # {}dict2 = {val: idx for idx, val in enumerate(list2)}print(dict2)# {'Runoob': 0, 'Taobao': 1, 'Google': 2}\n\n根据值移除元素1234567891011121314```del a[索引号]``````list.pop([index=-1])```移除列表中指定索引号一个元素（默认最后一个元素），并且返回该元素的值。```pythonlist1 = ['Google', 'Runoob', 'Taobao', \"Yahoo\"]list1.pop()  # 括号里没有参数，表示删除list数组中最后一个元素print(\"列表现在为 : \", list1)# 列表现在为 :  ['Google', 'Runoob', 'Taobao']list_pop = list1.pop(1)print(\"删除的项为 :\", list_pop)# 删除的项为 : Runoobprint(\"列表现在为 : \", list1)# 列表现在为 :  ['Google', 'Taobao']print(\"删除的项为 :\", list1.pop(0), \"，列表现在为 : \", list1)# 删除的项为 : Google ，列表现在为 :  ['Taobao']\n\n .sort(key=lambda x: x[0], reverse=True) .sort(key=lambda x:(-x[1],x[0],x[2])) .sort(key=lambda x:(-x[1],x[0],x[2]))默认是升序，加个符号变降序，可做多级排序。\n不在本地做排序123456789101112131415161718192021222324```.reverse()```函数用于反向列表中元素。不能将字符串反转。```.reversed()```函数是返回序列seq的反向访问的迭代子。参数可以是列表，元组，字符串```py# 组织列表 sort() 永久性排序 abcde正向或逆向顺序排序che = [\"motuo\", \"qiche\", \"zixingche\", 'huoche']# 倒着打印列表  永久性的修改顺序 也可以随时改回来che = [\"motuo\", \"qiche\", \"zixingche\", 'huoche']# 倒着打印che.reverse()print(che)# ['huoche', 'zixingche', 'qiche', 'motuo']# 再次倒着改回che.reverse()print(che)# ['motuo', 'qiche', 'zixingche', 'huoche']# \"iloveChina\".reverse()  # 直接将字符串用reverse异常，reverse适用于list(列表)a= \"ilovechina\"[::-1] print(a)b = ''.join(reversed('ilovechina'))print(b)\n\n元素 in list_name.append.insert(序号，内容)函数参数是可以是任意一个元素，作用是在列表的最后添加上这个新元素。\n变量float(‘inf’)\n字典\n查询字典的键12345678910111213141516171819202122232425262728293031323334```.values()``` 查询字典的值```.items()``` 返回的是元组```dict.get(key, default=None)``` 查询某个键是否存在，key -- 字典中要查找的键。default -- 如果指定键的值不存在时，返回该默认值。返回指定键的值，如果值不在字典中或不存在此键，返回默认值None。可以在get()方法中添加信息避免出现None```py# 字典的查询dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}print(dict1.keys())  # dict_keys(['name', 'age', 'male'])print(dict1.values())  # dict_values(['Ashe', 18, '男'])print(dict1.items())  # dict_items([('name', 'Ashe'), ('age', 18), ('male', '男')])# 判断key是否在字典里print('name' in dict1)  # True，效率高print('name' in dict1.keys())  # True 效率低，要先生成遍历字典的所有内容一个列表，这样字典的优势就没有了# 打印dict1的键for i in dict1.keys():    print(i)    # name    # age    # male# 打印dict的值for v in dict1.values():    print(v)  #Ashe 18 男    # Ashe    # 18    # 男\n\n打印字典的键值：\n12345678910111213dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}for i in dict1.items():    print(i)    # ('name', 'Ashe')    # ('age', 18)    # 'male', '男')for k, v in dict1.items():    print(k, v)    # name Ashe    # age 18    dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}for i in dict1.items():    print(i)    # ('name', 'Ashe')    # ('age', 18)    # 'male', '男')for k, v in dict1.items():    print(k, v)    # name Ashe    # age 18    # male 男\n\n123456dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}print(dict1.get('name'))  # Asheprint(dict1.get('address'))  # Noneprint(dict1.get('address', '没有此键'))  # 没有此键print(dict1.get('name', 'age'))  # Asheprint(dict1.get('age', 'name'))  dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}print(dict1.get('name'))  # Asheprint(dict1.get('address'))  # Noneprint(dict1.get('address', '没有此键'))  # 没有此键print(dict1.get('name', 'age'))  # Asheprint(dict1.get('age', 'name'))  # 18\n\n123456789101112131415161718192021a = {'x': 1}print(a['x'])  # 1# print(a[1]) # KeyError:1b = {(1, 2, 3): 'test'}print(b[(1, 2, 3)])  # test# c = {[1, 2, 3]: 'test'}# print(c[[1, 2, 3]])  # TypeError: unhashable type: 'list'print(a.keys())  # dict_keys(['x'])print(a.values())  # dict_values([1])print(b.keys())  # dict_keys([(1, 2, 3)])print(b.values())  # dict_values(['test'])print(a.get('x'))  # 1print(a.get('x', 4))  # 1 指定的键的值不存在，返回默认值print(a.get(4))  # None 指定的键的值不存在，返回默认值Noneprint(b.get((1, 2, 3)))  # testprint(b.get('y'))  # None，指定键的值不存在时，返回该默认值None。print(b.get('y', 2))  a = {'x': 1}print(a['x'])  # 1# print(a[1]) # KeyError:1b = {(1, 2, 3): 'test'}print(b[(1, 2, 3)])  # test# c = {[1, 2, 3]: 'test'}# print(c[[1, 2, 3]])  # TypeError: unhashable type: 'list'print(a.keys())  # dict_keys(['x'])print(a.values())  # dict_values([1])print(b.keys())  # dict_keys([(1, 2, 3)])print(b.values())  # dict_values(['test'])print(a.get('x'))  # 1print(a.get('x', 4))  # 1 指定的键的值不存在，返回默认值print(a.get(4))  # None 指定的键的值不存在，返回默认值Noneprint(b.get((1, 2, 3)))  # testprint(b.get('y'))  # None，指定键的值不存在时，返回该默认值None。print(b.get('y', 2))  # 2，如果指定键的值不存在时，返回该默认值2。\n\ndict有两种增加的方法如果没有的键值对，则进行添加，如果有，则将值进行覆盖\n123456dict1={'name':'Ashe','age':18,'male':'男'}print(dict1)dict1['high']=185print(dict1)  # {'name': 'Ashe', 'age': 18, 'male': '男', 'high': 185}dict1['age']=16print(dict1) dict1={'name':'Ashe','age':18,'male':'男'}print(dict1)dict1['high']=185print(dict1)  # {'name': 'Ashe', 'age': 18, 'male': '男', 'high': 185}dict1['age']=16print(dict1) #  {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185}\n\n如果有键值对，不做任何改变，没有键值对，才进行添加\n12345678910111213dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}dict1.setdefault(\"weight\")print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None}dict1.setdefault('weight', '65kg')print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None}dict1.setdefault('address', '北京')print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}dict1.setdefault('address', '桂林')print(dict1)dict1 = {'name': 'Ashe', 'age': 18, 'male': '男'}dict1.setdefault(\"weight\")print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None}dict1.setdefault('weight', '65kg')print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None}dict1.setdefault('address', '北京')print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}dict1.setdefault('address', '桂林')print(dict1)# {'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}\n\n12345678```pydelDict={'name': 'Ashe', 'age': 16, 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}print(delDict.pop('age'))  # 16print(delDict)  #{'name': 'Ashe', 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}print(delDict.pop('职业','没有此键'))  #没有此键del a['x']  # 删除keyprint(a['y'])  # 2\n\npop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key: 要删除的键值default: 如果没有 key，返回 default 值\n12345678910111213site = {'name': '菜鸟教程', 'alexa': 10000, 'url': 'www.runoob.com'}pop_obj = site.pop('name')print(pop_obj)  # 菜鸟教程dict1 = {1: \"a\", 2: [1, 2]}print(dict1.pop(1), dict1)# a {2: [1, 2]}print(dict1.pop(3, \"nokey\"), dict1)  # 设置默认值，必须添加，否则报错# nokey {2: [1, 2]}print(dict1.pop(3), dict1)  # 没用设置默认值，报错# Traceback (most recent call last):#   print(dict1.pop(3), dict1)site = {'name': '菜鸟教程', 'alexa': 10000, 'url': 'www.runoob.com'}pop_obj = site.pop('name')print(pop_obj)  # 菜鸟教程dict1 = {1: \"a\", 2: [1, 2]}print(dict1.pop(1), dict1)# a {2: [1, 2]}print(dict1.pop(3, \"nokey\"), dict1)  # 设置默认值，必须添加，否则报错# nokey {2: [1, 2]}print(dict1.pop(3), dict1)  # 没用设置默认值，报错# Traceback (most recent call last):#   print(dict1.pop(3), dict1)# KeyError: 3\n\n123456789101112131415161718```pydelDict = {    'name': 'Ashe',    'age': 16,    'male': '男',    'high': 185,    'weight': None,    'address': '北京'}print(delDict.pop('age'))  # 16print(delDict)# {'name': 'Ashe', 'male': '男', 'high': 185, 'weight': None, 'address': '北京'}print(delDict.pop('职业', '没有此键'))  # 没有此键print(delDict.popitem())  # ('address', '北京') 随机删除，返回值是删除的键值对print(delDict)  # {'name': 'Ashe', 'male': '男', 'high': 185, 'weight': None}\n\n12345678```pydelDict = {'name': 'Ashe', 'male': '男', 'high': 185, 'weight': None}del delDict['name']print(delDict)  # {'male': '男', 'high': 185, 'weight': None}# 使用del清空列表del delDictprint(delDict)  # NameError: name 'delDict' is not defined\n\n1234```pydelDict = {'name': 'Ashe', 'male': '男', 'high': 185, 'weight': None}print(delDict.clear())  # Noneprint(delDict)  # {}\n\n12345678910111213141516171819202122232425262728293031323334353637# 修改字典x = {'a': 1, 'b': 2}y = {'c': 3, 'd': 4}x.update(y)  # 这里注意我是直接改变的x变量，具体根据程序逻辑来定，可以用其它变量接受。print(x)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}x = {'a': 1, 'b': 2}y = {'a': 3, 'd': 4}x.update(y)  # 这里注意我是直接改变的x变量，具体根据程序逻辑来定，可以用其它变量接受。print(x)  # {'a': 3, 'b': 2, 'd': 4}# 字典合并的方法print('====')x = {'a': 1, 'b': 2}y = {'c': 3, 'd': 4}# 法一z = {}for k, v in x.items():    z[k] = vfor k, v in y.items():    z[k] = vprint(z)# {'a': 1, 'b': 2, 'c': 3, 'd': 4}# 法二q = {**x, **y}print(q)print('^^^^^^^')a = {\"A\": 1, \"B\": 2}b = {\"A\": 3, \"D\": 4}print({**a, **b})# {'A': 3, 'B': 2, 'D': 4}  # 这里取的是b中的A，即b覆盖了aprint('-----')print(dict(a, **b))# 修改字典x = {'a': 1, 'b': 2}y = {'c': 3, 'd': 4}x.update(y)  # 这里注意我是直接改变的x变量，具体根据程序逻辑来定，可以用其它变量接受。print(x)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}x = {'a': 1, 'b': 2}y = {'a': 3, 'd': 4}x.update(y)  # 这里注意我是直接改变的x变量，具体根据程序逻辑来定，可以用其它变量接受。print(x)  # {'a': 3, 'b': 2, 'd': 4}# 字典合并的方法print('====')x = {'a': 1, 'b': 2}y = {'c': 3, 'd': 4}# 法一z = {}for k, v in x.items():    z[k] = vfor k, v in y.items():    z[k] = vprint(z)# {'a': 1, 'b': 2, 'c': 3, 'd': 4}# 法二q = {**x, **y}print(q)print('^^^^^^^')a = {\"A\": 1, \"B\": 2}b = {\"A\": 3, \"D\": 4}print({**a, **b})# {'A': 3, 'B': 2, 'D': 4}  # 这里取的是b中的A，即b覆盖了aprint('-----')print(dict(a, **b))# {'A': 3, 'B': 2, 'D': 4}\n\n\n字符串\nbeg12345678```pystr = \"this is string example....wow!!!\"print(str.startswith('this'))  # True 字符串是否以 this 开头print(str.startswith('string', 8))  # True 从第九个字符开始的字符串是否以 string 开头print(str.startswith('this', 2, 4))  # False 从第2个字符开始到第四个字符结束的字符串是否以 this 开头\n\nbeg12345678910111213beg -- 开始索引，默认为0。```pyinfo = 'abca'print(info.find('a'))  # 0 从下标0开始，查找在字符串里第一个出现的子串print(info.find('a', 1))  # 3 从下标1开始，查找在字符串里第一个出现的子串print(info.find('3'))  # -1 查找不到str1 = \"Runoob example....wow!!!\"str2 = \"exam\"print(str1.find(str2))  # 7print(str1.find(str2, 5))  # 7  第2个参数5，表示从素引5的位置开始往后查找print(str1.find(str2, 10))  # -1\n\n方法用于截掉字符串左边的空格或指定字符。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354```str.rstrip([chars])``` 方法用于截掉字符串右边的空格或指定字符。从左到右移除字符串的指定字符，```.strip()```无字符集参数或为 None 时 去除首位空格匹配时不是按照整个字符串匹配的，而是一个个匹配的。移除所有属于字符集子串的字符一旦不属于则停止移除并返回字符串副本。chars --指定截取的字符。返回截掉字符串左边的空格或指定字符后生成的新字符串。```.strip().strip(‘-a’)```去除首位空格和字符```pystr = \"     this is string example....wow!!!     \"print(str.lstrip())# this is string example....wow!!!str = \"88888888this is string example....wow!!!8888888\"print(str.lstrip('8'))# this is string example....wow!!!8888888print('www.example.com'.lstrip('we.'))# xample.comprint('www.example.com'.lstrip('we'))# '.example.com'print('www.example.com'.lstrip('e'))# 'www.example.com'print('www.example.com'.lstrip('cmowz.'))# 'example.com'print('www.example.com'.lstrip('cmoz.'))# 'www.example.com'message = \"\\tpython xue xi\\t\"# 每个单词的首字母大写的写法print(message.title())# 单词全部大写的写法print(message.upper())  # 单词全部小写的写法print(message.lower())  # 去除字符串前面的空白print(message.lstrip())# 去除字符串后面的空白print(message.rstrip())# 去除字符串两边的空白print(message.strip())#         Python Xue Xi#         PYTHON XUE XI#         python xue xi# python xue xi        #         python xue xi# python xue xi    \n\nS[:3]+S[5:] 拼接字符串，去除某个字符\n替换字符123456789101112131415161718192021222324```re.sub(‘a’,’b’,s)``` 替换字符```ord(a)```它以一个字符（长度为1）作为参数，返回对应的 ASCII 数值(返回值是对应的十进制整数)，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。因为python里不像C++那样两个字符相减可以求出ASCII数值差```chr(a)``` 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数 是ord的逆过程，将ASCII值转化成该编码对应的字符```pyprint(ord(' '), type(ord(' ')))  # 32  空格的ascii码print(ord('0'))  # 48print(ord('1'))  # 49print(ord('2'))  # 50print(ord('2'), type(ord('2')))  # 50  print(ord('3'))  # 51# print(ord('10')) TypeError: ord() expected a character, but string of length 2 foundprint(ord('A'))  # 65print(ord('B'))  # 66print(ord('C'))  # 67print(ord('a'))  # 97print(ord('b'))  # 98print(ord('c'))  # 99\n\n1234print(chr(32))  # 空格print(chr(50), type(chr(50)))  # 2  &lt;class 'str'&gt;print(chr(65))  # Aprint(chr(97))  print(chr(32))  # 空格print(chr(50), type(chr(50)))  # 2  &lt;class 'str'&gt;print(chr(65))  # Aprint(chr(97))  # a\n\n方法返回\"标题化\"的字符串，就是说所有单词的首个字母转化为大写，其余字母均为小写123456返回\"标题化\"的字符串,就是说所有单词的首字母都转化为大写。```pystr = \"this is string example from runoob....wow!!!\"print(str.title())# This Is String Example From Runoob....Wow!!! \n\n非字母后的第一个字母将转换为大写字母：\n12txt = \"hello b2b2b2 and 3g3g3g\"print(txt.title())  txt = \"hello b2b2b2 and 3g3g3g\"print(txt.title())  # Hello B2B2B2 And 3G3G3G\n\nstr.split(str=\"\", num=string.count(str))通过指定分隔符对字符串进行切片，不是对列表对象切片返回分割后的字符串列表。如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。str – 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。num – 分割次数。默认为 -1, 即分隔所有。\n123456789101112131415161718192021222324252627url = \"http://www.baidu.com/python/image/123456.jpg\"print(url.split())  # 以空格为分隔符# ['http://www.baidu.com/python/image/123456.jpg']print(url.split(\"/\"))  # 以“/” 进行分隔# ['http:', '', 'www.baidu.com', 'python', 'image', '123456.jpg']print(url.split('/', 1))  # 以 / 为分隔符，分割为2个字符串列表# ['http:', '/www.baidu.com/python/image/123456.jpg']print(url.split(\"/\")[-1])  # 分隔符分割后列表最后一个元素(字符串类型），图片名称的获取# 123456.jpgprint(url.split(\"/\")[0])  # 分隔符分割后列表第一个元素(字符串类型）# http:print(url[1:-1], type(url[1:-1]))  # 切片，去除第一个和最后一个元素# ttp://www.baidu.com/python/image/123456.jp &lt;class 'str'&gt;print(url[1:-1].split(\"/\")[0])  # 列表第一个元素(字符串类型）# ttp:url = \"[http://www.baidu.com/python/image/123456.jpg]\"print(url[:], type(url[:]))# [http://www.baidu.com/python/image/123456.jpg] &lt;class 'str'&gt;print(url[:].split(\"/\")[0])  # 列表第一个元素(字符串类型）# [http:data = '[1, 2, 3, null, 4, 5, null]'print(data[1:-1], type(data[1:-1]))# 1, 2, 3, null, 4, 5, null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))url = \"http://www.baidu.com/python/image/123456.jpg\"print(url.split())  # 以空格为分隔符# ['http://www.baidu.com/python/image/123456.jpg']print(url.split(\"/\"))  # 以“/” 进行分隔# ['http:', '', 'www.baidu.com', 'python', 'image', '123456.jpg']print(url.split('/', 1))  # 以 / 为分隔符，分割为2个字符串列表# ['http:', '/www.baidu.com/python/image/123456.jpg']print(url.split(\"/\")[-1])  # 分隔符分割后列表最后一个元素(字符串类型），图片名称的获取# 123456.jpgprint(url.split(\"/\")[0])  # 分隔符分割后列表第一个元素(字符串类型）# http:print(url[1:-1], type(url[1:-1]))  # 切片，去除第一个和最后一个元素# ttp://www.baidu.com/python/image/123456.jp &lt;class 'str'&gt;print(url[1:-1].split(\"/\")[0])  # 列表第一个元素(字符串类型）# ttp:url = \"[http://www.baidu.com/python/image/123456.jpg]\"print(url[:], type(url[:]))# [http://www.baidu.com/python/image/123456.jpg] &lt;class 'str'&gt;print(url[:].split(\"/\")[0])  # 列表第一个元素(字符串类型）# [http:data = '[1, 2, 3, null, 4, 5, null]'print(data[1:-1], type(data[1:-1]))# 1, 2, 3, null, 4, 5, null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))# ['1', ' 2', ' 3', ' null', ' 4', ' 5', ' null'] \n\nstr.splitlines([keepends])按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，keepends – 在输出结果里是否去掉换行符(‘\\r’, ‘\\r\\n’, \\n’)，默认为 False，不包含换行符，如果为 True，则保留换行符。\n1234print('ab c\\n\\nde fg\\rkl\\r\\n'.splitlines())# ['ab c', '', 'de fg', 'kl']print('ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(True))print('ab c\\n\\nde fg\\rkl\\r\\n'.splitlines())# ['ab c', '', 'de fg', 'kl']print('ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(True))# ['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\n\n'sep'.join(seq)以sep作为分隔符，将seq所有的元素合并成一个新的字符串将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串\n参数说明sep：分隔符。string（字符串），可以为空seq：要连接的元素列表、字符串、元组、字典返回值：返回一个以分隔符sep连接各个元素后生成的字符串\n1234567891011121314151617181920212223# 对字符串进行操作print(':'.join(\"hello good boy \"))# h:e:l:l:o: :g:o:o:d: :b:o:y:# 用字符串把字符串列表里的字符串连接起来# 用空字符串''隔开print(''.join([\"hello\", \"world\", \"!\"]))  # helloworld!# 用' '隔开，用空格print(' '.join([\"hello\", \"world\", \"!\"]))  # hello world !# 用'-'隔开print('-'.join([\"hello\", \"world\", \"!\"]))  # hello-world-!# 对元组进行操作seq3 = ('hello', 'good', 'boy')print(':'.join(seq3))# hello:good:boy# 对字典进行操作seq4 = {'hello': 1, 'good': 2, 'boy': 3}print(':'.join(seq4))# 对字符串进行操作print(':'.join(\"hello good boy \"))# h:e:l:l:o: :g:o:o:d: :b:o:y:# 用字符串把字符串列表里的字符串连接起来# 用空字符串''隔开print(''.join([\"hello\", \"world\", \"!\"]))  # helloworld!# 用' '隔开，用空格print(' '.join([\"hello\", \"world\", \"!\"]))  # hello world !# 用'-'隔开print('-'.join([\"hello\", \"world\", \"!\"]))  # hello-world-!# 对元组进行操作seq3 = ('hello', 'good', 'boy')print(':'.join(seq3))# hello:good:boy# 对字典进行操作seq4 = {'hello': 1, 'good': 2, 'boy': 3}print(':'.join(seq4))# hello:good:boy\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","数据结构和算法"]},{"title":"Vue实战项目搭建","url":"https://bubbleboy11.github.io/2020/08/21/vue-shi-zhan-xiang-mu-da-jian/","content":"项目的搭建\n项目公共的配置（ajax配置、项目结构、目录等）\n前后端通信方式（接口规范、错误码等）\n\n开发的流程\n【前端】实现页面（组件）\n【前端】使用假数据，或者是mock数据\n【后端】模型分析，建模\n【后端】实现接口\n【前/后端】接口文档编写\n【前/后端】接口联调(对接)\n\n实战项目搭建操作步骤\n\n第一步，使用Vue CLI 搭建项目\n第二步，准备好静态资源（图片资源）\n第三步，调整生产项目结构\n\n项目结构\n\n公共的样式src/assets/common.less\n公共js（工具函数、接口地址、配置文件）123456// 接口地址配置src/utils/apis.js// 常量配置src/utils/constants.js// 工具函数src/utils/filters// 接口地址配置src/utils/apis.js// 常量配置src/utils/constants.js// 工具函数src/utils/filters.js\n\n\n\n首页拆解操作步骤\n\n第一步，分析首页的结构\n第二步，新建页面\n第三步，新建对应组件\n\n首页组件拆分\n\n标题\n轮播图（Banner图）\n本周推荐\n精选景点\n底部导航如果组件很多地方都用到过，应该放在/src/component/common如果只有某一个页面用到，应该放在/src/component/home\n\n为何不能在Vue.js中使用AJAX\nAjax是通过浏览器后台与服务器通信的技术\njQuery 中的AJAX只是基于jQuery的实现\n在Vue.js中使用jQuery不能充分利用Vue.js的特性\n\naxios异步请求库\n基于Promise的HTTP库\n支持Node.js和浏览器\n浏览器：XMLHttpRequest\nNode.js：http\n\n对axios进行全局配置可提升代码的可维护性\nPromise\n一种异步编程解决方案\nPromise其实一直都在，只是在ES6时，才被并入标准库\n\n处理回调\nthen函数的使用12345678new Promise((resolve, reject) =&gt; {// 业务逻辑resolve(1);}).then(res =&gt; {// 你的代码1}) .then(res =&gt; {new Promise((resolve, reject) =&gt; {// 业务逻辑resolve(1);}).then(res =&gt; {// 你的代码1}) .then(res =&gt; {// 你的代码2})\n\n\n\n处理异常123456789```jsnew Promise((resolve, reject) => {    // 业务逻辑    reject(throw new Error('It is my fault'))    }) .then(res => {        // 正常的逻辑代码    }).catch(err => {        // 产生异常后执行的代码    })\n\n如何安装\n\n方式一：引用JS&lt;script src=\"./axios.min.js\"&gt;&lt;/script&gt;\n方式二：使用npm/cnpm/yarn安装npm install axios -S\n\n使用npm/cnpm安装\n安装到dependencies（生产环境依赖）npm install axios --save或者npm install axios -S\n\n安装到devDependencies（开发环境依赖）npm install axios --save-dev或者npm install axios -D\n\n\n如何使用axios1234567axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])\n\n\nGET请求\n1234567891011axios.get('/user', {    params: {        ID: 12345    }}).then(function (response) {    console.log(response);}).catch(function (error) {    axios.get('/user', {    params: {        ID: 12345    }}).then(function (response) {    console.log(response);}).catch(function (error) {    console.log(error);});\n\nPOST请求\n12345678910axios.post('/user', {    firstName: 'Fred',    lastName: 'Flintstone'}).then(function (response) {    console.log(response);}).catch(function (error) {    axios.post('/user', {    firstName: 'Fred',    lastName: 'Flintstone'}).then(function (response) {    console.log(response);}).catch(function (error) {    console.log(error);});\n\n\n\n请求响应拦截使用场景\n设置自定义请求头\n默认携带上次的cookie\n添加loading动画（请求发起前显示、完成后隐藏）\n统一的错误处理\n\n实现方法\n创建axios的实例const ajax = axios.create(options)\n常用参数\nheaders: 设置请求头\ntimeout: 超时的毫秒数\ndata: POST/PUT/PATCH请求的数据\nparams: URL中的参数\nresponseType: 默认为json\n\n\n\n设置自定义请求头123456const ajax = axios.create({headers: {source: 'h5','Content-Type': const ajax = axios.create({headers: {source: 'h5','Content-Type': 'application/x-www-form-urlencoded'}})\n\n默认携带上次的cookie123const ajax = axios.create({    withCredentials: const ajax = axios.create({    withCredentials: true})\n\n添加loading动画\n 请求拦截\n1234567axios.interceptors.request.use(function (config) {// 在发送请求之前做些什么return config}, function (error) {// 对请求错误做些什么return axios.interceptors.request.use(function (config) {// 在发送请求之前做些什么return config}, function (error) {// 对请求错误做些什么return Promise.reject(error)});\n\n 响应拦截\n1234567axios.interceptors.response.use(function (response) {// 对响应数据做点什么return response}, function (error) {// 对响应错误做点什么return axios.interceptors.response.use(function (response) {// 对响应数据做点什么return response}, function (error) {// 对响应错误做点什么return Promise.reject(error)});\n\n\n\n统一的错误处理\n400参数错误提示\n401未登录，跳转到登录页面\n500/504服务器正忙，网络异常/请求超时\n\n跨域出于安全考虑，浏览器要求你的网站不能执行/访问其它网站的资源\n\n如何认定为“其它的网站”：同源策略http://www.imooc.com:80协议 域名/主机 端口\n\n跨域的影响\n\n浏览器本地存储无法使用（Cookie、LocalStorage 和 IndexDB）\nDOM对象 、JS 对象无法获取\nAJAX无法使用\n\n\n跨域问题解决\n\n利用HTML标签的特性script、a、iframe、img、link等\n在前端使用代理解决\n在服务器端解决CORS(Cross-Origin Resource Sharing)——跨域资源共享，通过添加响应头信息来解决\n\n\n\n在Vue.js中解决跨域问题\n添加配置文件vue.config.js添加配置项参数解释\n target目标地址\n changeOrigin变更请求头中设置的host\n pathRewriteURL重写规则12345678910111213141516171819// vue.config.js// Node.js里面的模块module.exports = {  // http://localhost:8080/api/test  // =&gt;  // http://localhost:8000/test  // 在Vue.js中解决跨域问题  devServer: {    proxy: {      '/api': {        target: 'http://django.t.mukewang.com',    // 这个地址的服务器要启动才能访问         changeOrigin: true,        pathRewrite: {          '^/api': ''   // vue.config.js// Node.js里面的模块module.exports = {  // http://localhost:8080/api/test  // =&gt;  // http://localhost:8000/test  // 在Vue.js中解决跨域问题  devServer: {    proxy: {      '/api': {        target: 'http://django.t.mukewang.com',    // 这个地址的服务器要启动才能访问         changeOrigin: true,        pathRewrite: {          '^/api': ''   // 重写的URL，空字符表示把/api字符串去掉        }      }    }  }}\n\n\n\n使用axios获取数据\n123456789101112131415161718// Home.vueexport default {  name: 'Home',  components: {  },  created () {    // ajax.get('http://django.t.mukewang.com/api/system/slider/list/?types=11').then(resp =&gt; {    // 未登录访问用户信息    // ajax.get('http://django.t.mukewang.com/api/accounts/user/detail/').then(resp =&gt; {    // ajax.get('http://localhost:8080/api/system/slider/list/?types=11').then(resp =&gt; {    // ajax.get('http://localhost:9527/hello/world/').then(resp =&gt; {    ajax.get('http://localhost:8080/test/hello/world/').then(resp =&gt; {      console.log('返回的结果：', resp)    }).catch(err =&gt; {      console.log(// Home.vueexport default {  name: 'Home',  components: {  },  created () {    // ajax.get('http://django.t.mukewang.com/api/system/slider/list/?types=11').then(resp =&gt; {    // 未登录访问用户信息    // ajax.get('http://django.t.mukewang.com/api/accounts/user/detail/').then(resp =&gt; {    // ajax.get('http://localhost:8080/api/system/slider/list/?types=11').then(resp =&gt; {    // ajax.get('http://localhost:9527/hello/world/').then(resp =&gt; {    ajax.get('http://localhost:8080/test/hello/world/').then(resp =&gt; {      console.log('返回的结果：', resp)    }).catch(err =&gt; {      console.log('请求出错：', err)    })  }}\n\n在Django中解决跨域问题\n 第一步：安装第三方扩展\n1>> pip install django-cors-headers\n 第二步：配置django的setting.py\n1INSTALLED_APPS = [INSTALLED_APPS = ['corsheaders',]\n\n 第三步：配置中间件\n1234567# setting.pyMIDDLEWARE_CLASSES = ['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','corsheaders.middleware.CorsMiddleware',# setting.pyMIDDLEWARE_CLASSES = ['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','corsheaders.middleware.CorsMiddleware','django.middleware.common.CommonMiddleware',]\n\n第四步：添加白名单\n12345# setting.pyCORS_ORIGIN_WHITELIST = ('http://127.0.0.1:8080',# setting.pyCORS_ORIGIN_WHITELIST = ('http://127.0.0.1:8080','http://localhost:8080',)\n\n\n\n第五步：可选配置\n12345# setting.py# 允许哪些请求头CORS_ALLOW_HEADERS = ('source', 'icode')# 允许携带cookieCORS_ALLOW_CREDENTIALS = # setting.py# 允许哪些请求头CORS_ALLOW_HEADERS = ('source', 'icode')# 允许携带cookieCORS_ALLOW_CREDENTIALS = True\n\nVantUI\n开源免费\n轻量、可靠的移动端 Vue 组件库\n\nVant组件库\n基础组件按钮、图标、布局、提示信息等\n表单组件日历、复选框、时间选择、输入框、评分等\n反馈组件弹出框、加载、下拉菜单、消息提示、下拉刷新、滚动加载等\n展示组件进度条、倒计时、分割线、懒加载、列表等\n导航组件宫格、索引、导航栏、分页、多标签页等\n业务组件地址编辑、联系人、优惠券、提交订单、SKU选择框等\n\n开始使用\n第一步：安装&gt;&gt; cnpm install vant -S\n\n第二步：手动按需导入组件\n12import Button from 'vant/lib/button';import import Button from 'vant/lib/button';import 'vant/lib/button/style';\n1234567export default {  name: 'Home',  components: {    'v-button': Button    export default {  name: 'Home',  components: {    'v-button': Button    // Button: Button  }}  \n\n第二步：导入全部组件，全局引用main.js\n12345import Vue from 'vue';import Vant from 'vant';  // VantUI组件库import 'vant/lib/index.css';Vue.use(Vant);  import Vue from 'vue';import Vant from 'vant';  // VantUI组件库import 'vant/lib/index.css';Vue.use(Vant);  // 把VantUI当做一个插件，在Vue中使用\n\n\n\n轮播图组件开发开发步骤\n第一步，查找Vant中可以使用的组件\n第二步，实现组件模板部分\\src\\components\\common\\Banner.vue1234567891011            <van-swipe-item v-for=\"item in bannerList\"        :key=\"item.id\">                    \nHome.vue12345678910111213141516171819            // 引入组件import Banner from '@/components/home/Banner'export default {  name: 'Home',  components: {    // banner图    Banner,  }}\n第三步，模型层准备数据，通过接口的方式从django服务器获取\\src\\components\\common\\Banner.vue1234567891011121314151617181920212223242526import { ajax } from '@/utils/ajax'import { SystemApis } from '@/utils/apis'export default {  data () {    return {      bannerList: []    }  },  methods: {    /**     * 获取轮播图的数据     */    getDataList () {      ajax.get(SystemApis.sliderListUrl).then(res => {        console.log('res:', res)        this.bannerList = res.data.objects      })    }  },  created () {    // 从接口获取数据    this.getDataList()  }}\n第四步，模拟数据，实现轮播效果\n\n热门推荐组件开发开发步骤\n第一步，查找Vant中可以使用的组件\n\n第二步，完成布局，实现组件模板部分\\src\\components\\common\\Hot.vue\n123456789101112131415161718192021222324252627282930            <van-cell      title=\"热门推荐\"      icon=\"/static/home/hot/fire.png\"      is-link      title-style=\"text-align:left\"      value=\"全部榜单\" />                  <a href=\"#\" class=\"hot-item\"        v-for=\"item in dataList\"        :key=\"item.id\">                                                    {{ item.name }}                  ￥{{ item.min_price }}起                        \nHome.vue\n123456789101112131415161718            // 引入组件import Hot from '@/components/home/Hot'export default {  name: 'Home',  components: {    // 热门推荐景点    Hot,  }}\n\n第三步，模型层准备数据\\src\\components\\common\\Hot.vue\n123456789101112131415161718192021222324252627282930313233import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'export default {  data () {    return {      dataList: []    }  },  methods: {    /**     * 查热门景点     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          is_hot: 1        }      }).then(({ data }) => {        this.dataList = data.objects      })    }  },  created () {    // 查询获取接口数据    this.getDataList()    // this.dataList = [    //   {id: 1, img: '/static/home/hot/h1.jpg', name: '景点名称', price: 65},    //   {id: 2, img: '/static/home/hot/h2.jpg', name: '景点名称景点名称', price: 65},    //   {id: 3, img: '/static/home/hot/h3.jpg', name: '景点名称', price: 65},  }}\n\n第四步，添加假数据，实现效果\n\n\n景点列表组件开发开发步骤\n第一步，分析组件的复用情况\n第二步，新建组件文件，实现组件内容\\src\\components\\common\\ListSight.vue123456789101112131415161718192021            <van-cell      title=\"精选景点\"      icon=\"location-o\"      is-link      title-style=\"text-align:left\"      value=\"更多\" />                        <sight-item v-for=\"item in dataList\"        :key=\"item.id\"        :item=\"item\"/>>          \n第三步，设置props,从父组件传递数据\\src\\components\\common\\ListSight.vue12345export default {  props: ['item']}\n\n\n\n精选景点组件开发开发步骤\n第一步，查找Vant中可以使用的组件\n第二步，完成布局，实现组件模板部分\n\n\\src\\components\\common\\Fine.vue\n123456789101112131415161718192021            <van-cell      title=\"精选景点\"      icon=\"location-o\"      is-link      title-style=\"text-align:left\"      value=\"更多\" />                        <sight-item v-for=\"item in dataList\"        :key=\"item.id\"        :item=\"item\"/>>          \nHome.vue\n123456789101112131415161718            // 引入组件import Fine from '@/components/home/Fine'export default {  name: 'Home',  components: {    // 精选景点    Fine,  }}\n\n第三步，模型层准备数据,从父组件传递数据\\src\\components\\common\\Fine.vue\n12345678910111213141516171819202122232425262728293031323334353637import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'import SightItem from '@/components/common/ListSight'export default {  components: {    SightItem  },  data () {    return {      dataList: []    }  },  methods: {    /**     * 查精选景点     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          is_top: 1        }      }).then(({ data }) => {        this.dataList = data.objects      })    }  },  created () {    this.getDataList()    // this.dataList = [    //   {id: 1, name: '景点名称', score: 5, price: 98},    //   {id: 2, name: '景点名称', score: 4.5, price: 98},    //   {id: 3, name: '景点名称', score: 4, price: 98},    // ]  }}\n\n第四步，添加假数据，实现效果\n\n\n页面底部组件开发开发步骤\n第一步，查找Vant中可以使用的组件\n第二步，完成布局，实现组件模板部分\\src\\components\\common\\Footer.vue12345678910              首页      搜索      我的      \nHome.vue123456789101112131415161718            // 引入组件import TripFooter from '@/components/common/Footer'export default {  name: 'Home',  components: {    // 底部导航    TripFooter  }}\n第三步，模型层准备数据\\src\\components\\common\\Footer.vue123456789export default {  data () {    return {      active: 'home'    }  }}\n第四步，模拟从不同的菜单进入效果\n\n模型设计\n系统模块（公共的、可服用）：轮播图、用户反馈\n景点模块：景点、景点详情、景点评论\n用户模块：用户、用户详细信息、登录历史\n订单模块：订单、订单明细、支付相关\n\n设计轮播图ORM模型开发步骤\n第一步，分析并设计数据库模型创建app\n1python manage.py startapp system\n\n第二步，完成ORM模型编码system/model.py\n12345678910111213141516171819from django.db import modelsclass Slider(models.Model):    name = models.CharField('名称', max_length=32)    desc = models.CharField('描述', max_length=32, null=True, blank=True)    types = models.SmallIntegerField('展现的位置', default=10)    img = models.ImageField('图片地址', max_length=255, upload_to='%Y%m/slider')    reorder = models.SmallIntegerField('排序字段', default=0, help_text='数字越大越靠前')    start_time = models.DateTimeField('生效开始时间', null=True, blank=True)    end_time = models.CharField('生效结束时间', null=True, blank=True)    target_url = models.CharField('跳转的地址', max_length=255, null=True, blank=True)    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table = 'system_slider'        ordering = [from django.db import modelsclass Slider(models.Model):    name = models.CharField('名称', max_length=32)    desc = models.CharField('描述', max_length=32, null=True, blank=True)    types = models.SmallIntegerField('展现的位置', default=10)    img = models.ImageField('图片地址', max_length=255, upload_to='%Y%m/slider')    reorder = models.SmallIntegerField('排序字段', default=0, help_text='数字越大越靠前')    start_time = models.DateTimeField('生效开始时间', null=True, blank=True)    end_time = models.CharField('生效结束时间', null=True, blank=True)    target_url = models.CharField('跳转的地址', max_length=255, null=True, blank=True)    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table = 'system_slider'        ordering = ['-reorder']\nsystem/setting.py\n1INSTALLED_APPS = [INSTALLED_APPS = ['system.apps.SystemConfig',]\n第三步，检测ORM模型\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546python manage.py check``` - 第四步，模型同步```bashpython manage.py makemigrationspython manage.py migrate```  ### 设计轮播图查询接口#### 开发步骤- 第一步，设计接口返回标准   - 定义接口的返回结构   - 接口的错误信息约定- 第二步，编写接口代码```system/views.py``````pythonfrom django import httpfrom django.http import HttpResponsefrom django.shortcuts import renderfrom system.models import Sliderdef slider_list(request):    \"\"\" 轮播图接口    {        \"meta\": {},        \"objects\": []    }    \"\"\"    data = {        'meta': {        },        'objects': []    }    queryset = Slider.objects.filter(is_valid=True)    for item in queryset:        data['objects'].append({            'id': item.id,            'img_url': item.img.url,            'target_url': item.target_url,            'name': item.name        })    # return HttpResponse(data)    python manage.py check``` - 第四步，模型同步```bashpython manage.py makemigrationspython manage.py migrate```  ### 设计轮播图查询接口#### 开发步骤- 第一步，设计接口返回标准   - 定义接口的返回结构   - 接口的错误信息约定- 第二步，编写接口代码```system/views.py``````pythonfrom django import httpfrom django.http import HttpResponsefrom django.shortcuts import renderfrom system.models import Sliderdef slider_list(request):    \"\"\" 轮播图接口    {        \"meta\": {},        \"objects\": []    }    \"\"\"    data = {        'meta': {        },        'objects': []    }    queryset = Slider.objects.filter(is_valid=True)    for item in queryset:        data['objects'].append({            'id': item.id,            'img_url': item.img.url,            'target_url': item.target_url,            'name': item.name        })    # return HttpResponse(data)    return http.JsonResponse(data)\n\n\n\nsystem/url.py\n1234567891011121314151617181920212223242526from django.urls import pathfrom system import viewsurlpatterns = [    path('slider/list/', views.slider_list, name=\"slider_list\"),]```  ```trip/url.py``````pythonfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    # 系统模块    path('system/', include('system.urls')),]``` - 第三步，模拟HTTP请求，测试验证接口### 设计景点ORM模型from django.urls import pathfrom system import viewsurlpatterns = [    path('slider/list/', views.slider_list, name=\"slider_list\"),]```  ```trip/url.py``````pythonfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    # 系统模块    path('system/', include('system.urls')),]``` - 第三步，模拟HTTP请求，测试验证接口### 设计景点ORM模型#### 开发步骤- 第一步，分析并设计模型景点简单信息、景点详细信息```pypython manage.py startapp sight\n\n第二步，完成ORM模型编码sight/model.py\n12345678910111213141516171819202122232425262728from django.db import modelsclass Sight(models.Model):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table ='sight'        ordering = [from django.db import modelsclass Sight(models.Model):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table ='sight'        ordering = ['-updated_at']\nsight/setting.py\n1INSTALLED_APPS = [INSTALLED_APPS = ['sight.apps.SightConfig',]\n\n第三步，检测ORM模型\n123456python manage.py check```  - 第四步，模型同步```bashpython manage.py makemigrationspython manage.py migrate\n\n\n\n设计景点列表API接口开发步骤\n第一步，设计接口返回内容及字段\n第二步，编写接口代码（查数据、分页）sight/views.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from django import httpfrom django.db.models import Qfrom django.shortcuts import renderfrom django.views.generic import ListViewfrom sight.models import Sightclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 1. 热门景点        is_hot = self.request.GET.get('is_hot', None)        if is_hot:            query = query &amp; Q(is_hot=True)        # 2. 精选景点        is_top = self.request.GET.get('is_top', None)        if is_top:            query = query &amp; Q(is_top=True)        # TODO 3. 景点名称搜索        queryset = Sight.objects.filter(query)        return queryset    def render_to_response(self, context, **response_kwargs):        page_obj = context['page_obj']        data = {            'meta': {                'total_count': page_obj.paginator.count,                'page_count': page_obj.paginator.num_pages,                'current_page': page_obj.number,            },            'objects': []        }        for item in page_obj.object_list:            data['objects'].append({                'id': item.id,                'name': item.name,                'main_img': item.main_img.url,                'score': item.score,                'province': item.province,                'min_price': item.min_price,                'city': item.city,                # TODO 评论数量暂时无法获取                'comment_count': 0            })        from django import httpfrom django.db.models import Qfrom django.shortcuts import renderfrom django.views.generic import ListViewfrom sight.models import Sightclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 1. 热门景点        is_hot = self.request.GET.get('is_hot', None)        if is_hot:            query = query &amp; Q(is_hot=True)        # 2. 精选景点        is_top = self.request.GET.get('is_top', None)        if is_top:            query = query &amp; Q(is_top=True)        # TODO 3. 景点名称搜索        queryset = Sight.objects.filter(query)        return queryset    def render_to_response(self, context, **response_kwargs):        page_obj = context['page_obj']        data = {            'meta': {                'total_count': page_obj.paginator.count,                'page_count': page_obj.paginator.num_pages,                'current_page': page_obj.number,            },            'objects': []        }        for item in page_obj.object_list:            data['objects'].append({                'id': item.id,                'name': item.name,                'main_img': item.main_img.url,                'score': item.score,                'province': item.province,                'min_price': item.min_price,                'city': item.city,                # TODO 评论数量暂时无法获取                'comment_count': 0            })        return http.JsonResponse(data)\n\n\n\nsight/url.py\n12345678910111213141516171819202122from django.urls import pathfrom system import viewsurlpatterns = [    # 景点列表接口    path('sight/list/', views.SightListView.as_view(), name=\"sight_list\"),]```  ```trip/url.py``````pythonfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    # 景点相关的URL    path('sight/', include(from django.urls import pathfrom system import viewsurlpatterns = [    # 景点列表接口    path('sight/list/', views.SightListView.as_view(), name=\"sight_list\"),]```  ```trip/url.py``````pythonfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    # 景点相关的URL    path('sight/', include('sight.urls'))]``` - 第三步，模拟HTTP请求，测试验证接口```bashpython manage.py runserver\n\n接口文档编写\n第一步，学习Markdown语法，可以生成html结构的文档\n第二步，编写文档公共部分\n第三步，编写接口文档\n\n轮播图接口数据获取(接口联调)实现步骤\n第一步，阅读接口文档\n\n第二步，配置接口地址src\\utils\\apis.js\n1234567891011121314151617181920212223242526/** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  loginUrl: '/',  logoutUrl: ''}/** * 系统模块的接口 */const SystemApis = {  // 轮播图列表  sliderListUrl: apiHost + '/system/slider/list/'}/** * 存放项目中所有的接口地址 */const apiHost = 'http://localhost:8080/api'/** * 用户账户相关的接口 */const AccountsApis = {  loginUrl: '/',  logoutUrl: ''}/** * 系统模块的接口 */const SystemApis = {  // 轮播图列表  sliderListUrl: apiHost + '/system/slider/list/'}export {  AccountsApis,  SystemApis}\nvue.config.js\n123456789101112131415161718// Node.js里面的模块module.exports = {  // http://localhost:8080/api/system/slider/list/  // =&gt;  // http://127.0.0.1:8080/system/slider/list/  // 在Vue.js中解决跨域问题  devServer: {    proxy: {      '/api': {  // 从/api开头 代理到目标地址        target: 'http://127.0.0.1:8000/',  // 这个地址的服务器要启动才能访问         changeOrigin: true,        pathRewrite: {          '^/api': ''   // Node.js里面的模块module.exports = {  // http://localhost:8080/api/system/slider/list/  // =&gt;  // http://127.0.0.1:8080/system/slider/list/  // 在Vue.js中解决跨域问题  devServer: {    proxy: {      '/api': {  // 从/api开头 代理到目标地址        target: 'http://127.0.0.1:8000/',  // 这个地址的服务器要启动才能访问         changeOrigin: true,        pathRewrite: {          '^/api': ''   //  重写URL，空字符表示把/api字符串去掉        }      }    }  }}\n\n第三步，在组件中使用axios获取数据src/components/home/Bannaer\n123456789101112131415161718192021222324import { ajax } from '@/utils/ajax'import { SystemApis } from '@/utils/apis'export default {  data () {    return {      bannerList: []    }  },  methods: {    /**     * 获取轮播图的数据     */    getDataList () {      ajax.get(SystemApis.sliderListUrl).then(res =&gt; {        console.log('res:', res)        this.bannerList = res.data.objects      })    }  },  created () {    // 从接口获取数据    import { ajax } from '@/utils/ajax'import { SystemApis } from '@/utils/apis'export default {  data () {    return {      bannerList: []    }  },  methods: {    /**     * 获取轮播图的数据     */    getDataList () {      ajax.get(SystemApis.sliderListUrl).then(res =&gt; {        console.log('res:', res)        this.bannerList = res.data.objects      })    }  },  created () {    // 从接口获取数据    this.getDataList()  }}\n\n\n\ndjango项目的trip/setting.py的STATIC_URL = '/static/'下一行加上\n1MEDIA_URL = MEDIA_URL = 'http://localhost:8080/'\n\n\n第四步，将数据设置到模型层Vue组件Banner.vue的模板里的数据img_id和img_url是调用django的视图system/view.py里面的1234567891011            <van-swipe-item v-for=\"item in bannerList\"        :key=\"item.id\">                    \n\n\n\n景点列表接口数据获取实现步骤\n第一步，阅读接口文档\n第二步，配置接口地址src\\utils\\apis.js123456789101112/** * 景点模块 */const SightApis = {  // 景点列表  sightListUrl: apiHost + '/sight/sight/list/'}/** * 景点模块 */const SightApis = {  // 景点列表  sightListUrl: apiHost + '/sight/sight/list/'}export {  SightApis}\nvue.config.js1234567891011121314151617```- 第三步，使用axios获取数据```jsmethods: {    /**     * 查热门景点     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          is_hot: 1        }      }).then(({ data }) =&gt; {        ```- 第三步，使用axios获取数据```jsmethods: {    /**     * 查热门景点     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          is_hot: 1        }      }).then(({ data }) =&gt; {        this.dataList = data.objects      })    }  }\n第四步，将数据设置到模型层，Vue组件Hot.vue的模板里的数据main_img和name和min_price是调用django的视图sight/view.py里面的123456789101112131415161718192021222324252627282930            <van-cell      title=\"热门推荐\"      icon=\"/static/home/hot/fire.png\"      is-link      title-style=\"text-align:left\"      value=\"全部榜单\" />                  <a href=\"#\" class=\"hot-item\"        v-for=\"item in dataList\"        :key=\"item.id\">                                                    {{ item.name }}                  ￥{{ item.min_price }}起                        \n\n\n\nVue组件Fine.vue的模板里的数据is_top和name和min_price是调用django的视图sight/view.py里面的\n1234567891011121314151617181920212223242526272829303132333435import SightItem from '@/components/common/ListSight'export default {  components: {    SightItem  },  data () {    return {      dataList: []    }  },  methods: {    /**     * 查精选景点     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          is_top: 1        }      }).then(({ data }) => {        this.dataList = data.objects      })    }  },  created () {    this.getDataList()    // this.dataList = [    //   {id: 1, name: '景点名称', score: 5, price: 98},    //   {id: 2, name: '景点名称', score: 4.5, price: 98},    //   {id: 3, name: '景点名称', score: 4, price: 98},    // ]  }}\n\nsrc\\components\\common\\ListSight.vue的name和score是调用sight/view.py\n123456789101112                {{ item.name }}            {{ item.comment_count }}人点评 | 100%满意      {{ item.province }} - {{ item.city }}      ￥ {{ item.min_price }} 起      \n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["Vue"]},{"title":"java数据类型","url":"https://bubbleboy11.github.io/2020/08/21/java-shu-ju-lei-xing/","content":"内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nbyte 字节型，在内存中占1个字节 8位、有符号的，以二进制补码表示的整数；最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；例子：byte a = 100，byte b = -50。\nshort 短整型，2个字节 16个二进制位、有符号的以二进制补码表示的整数7483647，默认值0最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；默认值是 0；Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；例子：short s = 1000，short r = -20000。\nint：整型，4个字节 32个二进制位、有符号的以二进制补码表示的整数；整型变量默认为 int 类型；整型字面值默认情况下是int类型最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；默认值是 0 ；例子：int a = 100000定义变量的同时对变量进行初始化变量a和它的值在内存当中如何存储的？在内存的栈中开辟int类型大小的空间，把100这个整型字面值存储到开辟的空间中，变量名a看作是100所在的内存空间的别名，a就代表100\nlong：长整型，在内存中占8个字节，64个二进制位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；默认值是 0L；这种类型主要使用在需要比较大整数的系统上；\n例子： long a = 100000L，Long b = -200000L，Long c = 0x1abcL。长整型则在末尾加l或L，”L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。\n数据表示范围依次增大。选择数据类型的时候可以参考表示范围来选取，但实际应用中，int和long是常用的数据类型，而byte和short使用较少，即使数值比较小一般也会使用int类型。byte类型主要对二进制数据进行存储，在文件输入输出流部分将会使用，用于二进制数据的传输。short类型在有的需求中会用到，比如：对于登录账号的状态表示，一般用0表示正常，1表示冻结，2表示已删除。这里的数值比较固定，值也比较小，可以使用short类型表示。\n浮点数就是小数点在逻辑上是不固定的\nfloat：数据类型是单精度浮点型，在内存中占4个字节，32位，精度是 78 位，符合IEEE 754标准的浮点数；用于存储带小数点的数字（与double的区别在于float类型有效小数点只有67位而且在内存中的占的位数也不同），则需要在字面值后加f或F默认值是 0.0f；在储存大型浮点数组的时候可节省内存空间；浮点数不能用来表示精确的值，如货币；例子：\n1234float f1 = 234.5ffloat f1 = 234.5F// 后面不加d或者f表示double，double比float数据表示范围大float f1 = 234.5 float f1 = 234.5ffloat f1 = 234.5F// 后面不加d或者f表示double，double比float数据表示范围大float f1 = 234.5 // java: 不兼容的类型: 从double转换到float可能会有损失\n\ndouble 双精度浮点型，在内存中占8个字节 64 位，精度是 16~17 位，符合IEEE 754标准的浮点数；用于存储带有小数点的数字，浮点数（浮点型字面值）的默认类型为double类型；后面不加d或者f表示double，也可以在值后加d或Ddouble类型同样不能表示精确的值，如货币；默认值是 0.0d；例子：\n123double d1 = 123.4double d2 = 123.4ddouble d3 = double d1 = 123.4double d2 = 123.4ddouble d3 = 123.4D\n\n科学计数法表示浮点数123456double x = 1.23E5;System.out.println(\"x=\" + x);  // x=123000.0float y = 1.23e5f;System.out.println(\"y=\" + y);  // y=123000.0double z = .2;System.out.println(\"z=\" + z);  double x = 1.23E5;System.out.println(\"x=\" + x);  // x=123000.0float y = 1.23e5f;System.out.println(\"y=\" + y);  // y=123000.0double z = .2;System.out.println(\"z=\" + z);  // z=0.2\n\nboolean数据类型表示1个字节8位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；例子：boolean one = true。\n二、浮点型的应用场景浮点类型表示小数，包括float和double两种类型，具体使用哪种数据类型，也是可以按照表示范围进行选择。但double类型使用相对较多。应用场景主要是要求数据精度高、并且数据量大的情况，如：医学、化学、军事、天文等领域。这里需要注意，浮点型因为其表示方式的原因，会产生精度丢失的问题，\n精确计算通过 BigDecimal 类，先将浮点型数据转换为 String 类型的数据，然后再进行相应的计算。以下为利用 BigDecimal 类进行加法和减法运算的测试代码\n12345678910111213141516171819202122232425262728293031323334package com.imooc;public class Test {    public static void main(String[] args) {        double a = 1.9;        double b = 1.7;        System.out.println(\"直接进行减法运算，运算结果:\\n\" + (a - b));        System.out.println(\"利用 BigDecimal类的进行减法运算结果:\\n\" + sub(a, b));        System.out.println();        System.out.println(\"直接进行加法运算，运算结果:\\n\" + (a + b));        System.out.println(\"利用 BigDecimal类的进行加法运算结果:\\n\" + add(a, b));    }    //利用 BigDecimal类的进行减法运算    public static double sub(double v1, double v2) {        //将浮点数转为 String类型        BigDecimal b1 = new BigDecimal(Double.toString(v1));        BigDecimal b2 = new BigDecimal(Double.toString(v2));        //通过 BigDecimal类中 subtract方法完成减法运算,        // 其中b1是被减数,b2是减数        double b = b1.subtract(b2).doubleValue();        return b;    }    //利用 BigDecimal类的进行加法运算    public static double add(double v1, double v2) {        BigDecimal b1 = new BigDecimal(Double.toString(v1));        BigDecimal b2 = new BigDecimal(Double.toString(v2));        package com.imooc;public class Test {    public static void main(String[] args) {        double a = 1.9;        double b = 1.7;        System.out.println(\"直接进行减法运算，运算结果:\\n\" + (a - b));        System.out.println(\"利用 BigDecimal类的进行减法运算结果:\\n\" + sub(a, b));        System.out.println();        System.out.println(\"直接进行加法运算，运算结果:\\n\" + (a + b));        System.out.println(\"利用 BigDecimal类的进行加法运算结果:\\n\" + add(a, b));    }    //利用 BigDecimal类的进行减法运算    public static double sub(double v1, double v2) {        //将浮点数转为 String类型        BigDecimal b1 = new BigDecimal(Double.toString(v1));        BigDecimal b2 = new BigDecimal(Double.toString(v2));        //通过 BigDecimal类中 subtract方法完成减法运算,        // 其中b1是被减数,b2是减数        double b = b1.subtract(b2).doubleValue();        return b;    }    //利用 BigDecimal类的进行加法运算    public static double add(double v1, double v2) {        BigDecimal b1 = new BigDecimal(Double.toString(v1));        BigDecimal b2 = new BigDecimal(Double.toString(v2));        return b1.add(b2).doubleValue();    }}\n\nchar类型是一个单一的占2个字节，16个二进制位 无符号Unicode 字符；最小值是 \\u0000（即为 0）；最大值是 \\uffff（即为65,535）；char 数据类型可以储存任何字符；字符就是整数类型例子：char letter = 'A';。\nabstract 修饰抽象类。\nbreak 一般用于循环里面作用是结束当前循环。 \ncase 用于swith里面。 continue 结束当天循环进入下次循环。 default 用于 swith case与接口里。 do 用于循环，一般用于 do{循环内容}(判断条件)；else 用于判断 if(条件){ } else if(条件){} else{}. extends 子类继承父类。false 可以用于判断条件 也可以给boolean赋值。final 修饰的类不可被继承方法不能被重新 变量不可变。 finally 用于try catch 的结尾 表示最终一定会执行 也会不会的执行的情况例如在try catch 里面有return语句，死循环等 System.exit() 中止 守护线程等。\nfor 循环。if 判断。 \nimplements 实现接口，一个类型可以实现多个接口。 import 导入。 native 修饰方法为本地方法。 \ninterface 定义接口。instan\n常见的常量类型有整型常量（int），浮点数常量（float）,布尔型常量（boolean），字符常量（char），字符串常量（string），引用类型常量。String&nbsp;是一种常见的引用数据类型，用来表示字符串，即多个字符。例如系统中的用户名、密码、电子邮箱等。\n格式化字符串字面值&nbsp;\n12345a='python'b=len(a)print('hah'+str(b))#hah6print(f'hah{b}')print(a='python'b=len(a)print('hah'+str(b))#hah6print(f'hah{b}')print('hah{}'.format(b))\n{&nbsp;&nbsp;}&nbsp;来标记变量将被替换的位置\n变量声明格式：数据类型 变量名；\nn;``` 声明整型变量n123456789101112131415161718192021```long count;``` 声明长整型变量count- 相同类型的数据变量可以一次定义多个，变量名之间用逗号隔开```float a,b1=1.23f;```a是float类型，但是没初始化，bfloat类型且初始化- 同方法内不可以重复定义相同的变量名### 使用“＝”运算符进行赋值“＝”叫作赋值运算符，将运算符右边的值赋给左边的变量。例：```int n;``` 定义int型变量n  ```n=3;``` 将3赋值给n- 可以在定义变量的同时给变量赋值，即变量的初始化。例：```int n=3;```- 数据类型 变量名＝变量值变量定义```javaint octal=037; //定义int类型变量存放八进制数据long longNumber=0xa2cdf3ffL; //定义变量存放十六进制长整型数据short shortNumber=123;  //定义变量存放短整型数据byte b=10; //定义变量存放byte类型数据\n\n语句\n以分号结束\n不能换到一行写\n单行注释，注释一行\n\n数据类型分类\n基本数据类型 \n\n引用数据类型存的是保存数据的空间地址，这个抽屉的钥匙，钥匙和抽屉一一对应\n\n类 class\n接口 interface\n数组\n\n\n\n类定义的变量又叫对象\n按照作用范围分为:\n类级\n对象实例级\n方法级（局部变量，定义在主方法中）\n块级\n\n字面值是常量和变量实际表示的数值，都是有数据类型的字面值是常量的一种\n字符型字面值用单引号内的只有一个单个字符表示，不能双引号字符：单个字母，键盘上的，空格也是字符，算长度空格也算如：char ‘a’，char ‘b’，char ‘$’，不能写char \"a\"\n\n如何定义字符型变量？类型转换分为\n\n\n自动类型转换（隐式）数据所表示的数据范围小的转换位所表示的数据范围大的\n1234567       // 定义一个变量存放字符'a'，字符a的值赋值字符变量a       char a = 'a';       System.out.println(\"a=\" + a);       // 整型赋值给char类型，如果字面值没有超出char类型所表示的数据范围，转换成它的ASCII值所对应的字符数据char ascii_97 = 97;  // a=aSystem.out.println(\"ascii_97=\" + ascii_97);         // 定义一个变量存放字符'a'，字符a的值赋值字符变量a       char a = 'a';       System.out.println(\"a=\" + a);       // 整型赋值给char类型，如果字面值没有超出char类型所表示的数据范围，转换成它的ASCII值所对应的字符数据char ascii_97 = 97;  // a=aSystem.out.println(\"ascii_97=\" + ascii_97);  // ascii_97=a\n\n强制类型转换如果A类型的数据表示范围比B类型大，则将A类型的值赋值给B类型，需要强制类型转换格式（数据类型） 数值double d＝123.4;float f=(float)d;\n\n\n如果字面值超出char类型所表示的数据范围，需要进行强制类型转换。\n123456789101112131415161718192021222324252627282930313233long var = (long) 1.9e8;System.out.println(\"var=\" + var);  // var=190000000double z = var;System.out.println(\"z=\" + z);  // z=1.9E8char ch = 65535;char ch1 = (char) 65536;System.out.println(\"ch=\" + ch);  // ch=￿System.out.println(\"ch1=\" + ch1);  // ch1=//char类型和int类型之间的转换char c = (char) 65536;System.out.println(\"c=\" + c);  // c=int n;n = c;//隐式类型转换System.out.println(\"n=\" + n);  // n=0c = (char) n;System.out.println(\"c=\" + c);  // c=//整型和整型的类型转换问题long l = 987654321;int i = (int) l;System.out.println(\"i=\" + i);//整型和浮点型的类型转换问题int x = 100;long y = x;x = (int) y;float f = 100000000000000L;System.out.println(\"f=\" + f);  // f=1.0E14float f1 = 103948583923948L;System.out.println(\"f1=\" + f1);  long var = (long) 1.9e8;System.out.println(\"var=\" + var);  // var=190000000double z = var;System.out.println(\"z=\" + z);  // z=1.9E8char ch = 65535;char ch1 = (char) 65536;System.out.println(\"ch=\" + ch);  // ch=￿System.out.println(\"ch1=\" + ch1);  // ch1=//char类型和int类型之间的转换char c = (char) 65536;System.out.println(\"c=\" + c);  // c=int n;n = c;//隐式类型转换System.out.println(\"n=\" + n);  // n=0c = (char) n;System.out.println(\"c=\" + c);  // c=//整型和整型的类型转换问题long l = 987654321;int i = (int) l;System.out.println(\"i=\" + i);//整型和浮点型的类型转换问题int x = 100;long y = x;x = (int) y;float f = 100000000000000L;System.out.println(\"f=\" + f);  // f=1.0E14float f1 = 103948583923948L;System.out.println(\"f1=\" + f1);  // f1=1.03948585E14 数据丢失\n\n字符串字面值\n双引号引起来的0个或多个字符字符串不属于基本数据类型，它是类，双引号的1234567891011121314151617// 定义一个空字符串String s1 = \"\";System.out.println(\"s1=\" + s1);  // s1=//定义一个包含空格的字符串String s5 = \"Hello   imooc!\";System.out.println(\"s5=\" + s5);  // s4=Hello   imooc!//定义一个字符串，内容是HelloString s2 = \"Hello\";System.out.println(\"s2=\" + s2);  // s2=Hello//定义一个unicode字符的字符串String s3 = \"\\u005d\\u005f\";System.out.println(\"s3=\" + s3);  // s3=]_//定义一个包含unicode字符和其他字符写在一起的字符串String s4 = \"A\\u005d\\u005fB\";System.out.println(\"s4=\" + s4);  // 定义一个空字符串String s1 = \"\";System.out.println(\"s1=\" + s1);  // s1=//定义一个包含空格的字符串String s5 = \"Hello   imooc!\";System.out.println(\"s5=\" + s5);  // s4=Hello   imooc!//定义一个字符串，内容是HelloString s2 = \"Hello\";System.out.println(\"s2=\" + s2);  // s2=Hello//定义一个unicode字符的字符串String s3 = \"\\u005d\\u005f\";System.out.println(\"s3=\" + s3);  // s3=]_//定义一个包含unicode字符和其他字符写在一起的字符串String s4 = \"A\\u005d\\u005fB\";System.out.println(\"s4=\" + s4);  // s4=A]_B\n\n\n\n\n12345678910111213141516System.out.println(3 + \"\\t\" + 5);// 3    5 双引号只有一个字符的字符串System.out.println(3 + '\\t' + 5);// 17 双引号只有一个字符的字符串System.out.println(3 + \"\\t\" + 5 + '\\n');// 3    5 双引号只有一个字符的字符串，字符串连接//System.out.println(3 + '\\t' + 5 + '\\n');  // 27 字符就是整型，把字符都转换成整数，进行加法运算System.out.println(\"\" + 3 + '\\t' + 5 + '\\n');  // 3    5 最前面加一个空串，一开始就是做字符串连接System.out.println('\\n' + 3 + \"\\t\" + 5);  // 13System.out.println(\"\\n\" + 3 + \"\\t\" + 5);//System.out.println(3 + \"\\t\" + 5);// 3    5 双引号只有一个字符的字符串System.out.println(3 + '\\t' + 5);// 17 双引号只有一个字符的字符串System.out.println(3 + \"\\t\" + 5 + '\\n');// 3    5 双引号只有一个字符的字符串，字符串连接//System.out.println(3 + '\\t' + 5 + '\\n');  // 27 字符就是整型，把字符都转换成整数，进行加法运算System.out.println(\"\" + 3 + '\\t' + 5 + '\\n');  // 3    5 最前面加一个空串，一开始就是做字符串连接System.out.println('\\n' + 3 + \"\\t\" + 5);  // 13System.out.println(\"\\n\" + 3 + \"\\t\" + 5);//// 3    5\n\n布尔类型字面值布尔值只能定义为true和false例：boolean b=true;\n1234567891011121314151617181920212223242526272829303132// FloatDemo.javapackage com.imooc;public class FloatDemo {    public static void main(String[] args) {        //定义一个单精度浮点型变量，存放1234.328        float f = 1234.328f;        System.out.println(\"f=\" + f);        //f=1234.328        //定义一个双精度浮点型变量，存放5623.465        double d = 5623.464;        System.out.println(\"d=\" + d);        //d=5623.464        //将整型赋值给浮点型        double d1 = 123;        System.out.println(\"d1=\" + d1);        //d1=123.0        //变量间的赋值        double d2 = d;        System.out.println(\"d2=\" + d2);        //d2=5623.464        //将单精度浮点型赋值给双精度        double d3 = 1.23f;        System.out.println(\"d3=\" + d3);        // FloatDemo.javapackage com.imooc;public class FloatDemo {    public static void main(String[] args) {        //定义一个单精度浮点型变量，存放1234.328        float f = 1234.328f;        System.out.println(\"f=\" + f);        //f=1234.328        //定义一个双精度浮点型变量，存放5623.465        double d = 5623.464;        System.out.println(\"d=\" + d);        //d=5623.464        //将整型赋值给浮点型        double d1 = 123;        System.out.println(\"d1=\" + d1);        //d1=123.0        //变量间的赋值        double d2 = d;        System.out.println(\"d2=\" + d2);        //d2=5623.464        //将单精度浮点型赋值给双精度        double d3 = 1.23f;        System.out.println(\"d3=\" + d3);        //d3=1.2300000190734863    }}\n\n整数型的阈值 \n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimitiveTypeTest {    public static void main(String[] args) {        // byte        System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE);        System.out.println(\"包装类：java.lang.Byte\");        System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE);        System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE);        System.out.println();        // short        System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE);        System.out.println(\"包装类：java.lang.Short\");        System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE);        System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE);        System.out.println();        // int        System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE);        System.out.println(\"包装类：java.lang.Integer\");        System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE);        System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE);        System.out.println();        // long        System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);        System.out.println(\"包装类：java.lang.Long\");        System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);        System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);        System.out.println();        // float        System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);        System.out.println(\"包装类：java.lang.Float\");        System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);        System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);        System.out.println();        // double        System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);        System.out.println(\"包装类：java.lang.Double\");        System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);        System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);        System.out.println();        // char        System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);        System.out.println(\"包装类：java.lang.Character\");        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台        System.out.println(\"最小值：Character.MIN_VALUE=\"                + (int) Character.MIN_VALUE);        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台        System.out.println(\"最大值：Character.MAX_VALUE=\"                + (public class PrimitiveTypeTest {    public static void main(String[] args) {        // byte        System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE);        System.out.println(\"包装类：java.lang.Byte\");        System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE);        System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE);        System.out.println();        // short        System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE);        System.out.println(\"包装类：java.lang.Short\");        System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE);        System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE);        System.out.println();        // int        System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE);        System.out.println(\"包装类：java.lang.Integer\");        System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE);        System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE);        System.out.println();        // long        System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);        System.out.println(\"包装类：java.lang.Long\");        System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);        System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);        System.out.println();        // float        System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);        System.out.println(\"包装类：java.lang.Float\");        System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);        System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);        System.out.println();        // double        System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);        System.out.println(\"包装类：java.lang.Double\");        System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);        System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);        System.out.println();        // char        System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);        System.out.println(\"包装类：java.lang.Character\");        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台        System.out.println(\"最小值：Character.MIN_VALUE=\"                + (int) Character.MIN_VALUE);        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台        System.out.println(\"最大值：Character.MAX_VALUE=\"                + (int) Character.MAX_VALUE);    }}\n12345678910111213141516171819202122232425262728293031323334基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.MAX_VALUE=65535\n\n基本类型的创建：先去常量池中找是否存在该值，如果存在直接调取引用，如果不存在则先在常量池中创建该值，在调引用\n所以，不可以创建一个空值给基本数据类型。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["java"],"tags":["剑指offer","Leetcode"]},{"title":"linux","url":"https://bubbleboy11.github.io/2020/08/21/linux/","content":"操作系统是你的电脑和应用程序之间的连接工具\n操作系统的核心称为“内核″，但内核并不就等于操作系统内核提供系统服务，比如文件管理、虚拟內存、设备I/O等它管理着整台计算机的硬件，负责应用程序和硬件之间的交互工作。除内核以外，在应用软件与内核之间通常还有些作为中间件的API还包含一些基本的程序，例如文本编辑器，编译器，外壳程序 Shell单独的 Linux内核没办法工作,须要有GNU项目的众多应用程序Linux的官方称谓应该是“GNU/ Linux”,一般简称 Linux\n自由的软件意味着源代码必须公开自由的软件大部分时候是免费的,但也可以复制,修改和出售自由运动的口号是:“团结就是力量”\nCentos是 Community Enterprise Operating System “社区企业操作系统”Centos兼具 Community(社区)和 Enterprise(企业)的特性\nmacoS和 Windows的源代码是闭源的(看不到), Linux则开源有很多不同的 Linux变体,术语称为“ Linux发行版”\n主板 Motherboard 或 Mainboard◆ 构成复杂电子系统例如电子计算机的中心或者主电路板\n电脑启动时,按先后顺序发生的\n启动界面（主板）\nbootloader\n操作系统（例如Windows）的启动\n其他程序\n\nWindows启动的必要性\n\nWindows启动后,才可以使用各种应用程序\n你的电脑需要一个类似“大管家”的软件\n“大管家”软件起到连接电脑硬件和软件的“桥梁”的作用\n\nbootloaderboot(“启动”的意思) loader(“加载器”的意思)通过这段小程序，初始化硬件设备、建立內存空间的映射图为最终调用操作系统内核准备好正确的环境\n一台电脑可以拥有两个(甚至更多)的操作系统当启动界面结束后，会有一个被称为bootloader的程序显示出来bootloader让你做出选择，到底选择哪个操作系统来启动然后是操作系统的内核运行\n通常, bootloader严重依赖于硬件而实现的,特别是在嵌入式领域一般在 Linux和 Windows之间做出选择的 bootloader叫GRUB如果没有做岀选择，GRUB在几秒之后就会启动默认的操作系统\n图形化界面(Graphical User Interface GUI)这种方式简单直观,使用者易于接受,容易上手操作。\n命令行界面(Command Line Interface CLI)需要有个控制台,是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行完成些操作。Command Line CMD\nShell「壳」，即人与电脑的接口，实际上是个命令解释程序，从标准输入读取你的命令，把命令结果输出到标准输出和标准错误等设备。Shell 通常指的是命令行界面的解析器，一个为操作系统提供访问内核的程序Windows 下的 cmd、PowerShell，这些都是 shell，这个应该很容易理解。win终端 虚拟终端cmd是DOS窗口，而powershell才是真正的Windows Terminal窗口\nLinux 下的 Bash、Zsh，bash，全名叫做 Bourne-Again SHell，绝大多数 Linux 发行版的默认 shell。zsh，全名叫做 Z shell，新版 MacOS 的默认 shell。对 Bourne shell 做出了大量改进，同时加入了 Bash、ksh 及 tcsh 的某些功能Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，然后把执行结果返回给终端。终端干的活儿是从用户（通过键盘和鼠标）这里接收输入，然后扔给 Shell，然后把 Shell 返回的结果展示给用户（通过显示器）。\nConsole(控制台)真正的终端没有图形界面,只有黑底白字的全屏幕的终端即在 Linux 下按 Ctrl-Alt-F? 看到的那个命令界面。事实上，在远古的 Unix 大型机时代，console 应该是指物理连接在主机上的输入输出设备，而 terminal 是指与 console 进行远程通信的串行设备。而如今的 Linux 控制台实际上是内核模拟的 /dev/ttyn 终端，/dev/console 一般就是 /dev/tty0，只有 root 用户才能写入。\nTTY是 TeleTYpe 或者 teletypewriters,原来指的是电传打字机远程连接到控制台的串行设备，现在来说通常也就是 /dev/ttyn 这些设备啦\n进入登录tty1~tty5这五个真正的全屏幕的tty终端的快捷键\nterminal 1(:0大致等于tty1)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485```Ctrl +Alt +F3```: terminal 2(tty2)```Ctrl+ Alt+ F4```: terminal 3(tty3)```Ctrl+ Alt+F5```: terminal 4(tty4)```Ctrl + Alt + F6```: terminal5(tty5)退出tty终端```ctrl+Alt+F1```:回到图形界面(感谢上帝图形模式的终端:一般在 Centos等 Linux发行版下日常使用可以配置终端的外观,用鼠标操作,可以同时运行其他应用程序打开图形模式终端的方式- 调出系统搜索框，在搜索框中输入\"terminal\"- 用快捷键来调出终端，比如可以自己设置快捷键:Ctr|+At+T### Linux 的目录组织普通的文件文本类型的文件（.txt，.doc，.odt，等等声音文件（.wav，.mp3，.ogg），还有程序，等这样的文件在 Windows 中也有特殊的文件你的光盘驱动器就是这类特殊的文件Linux 中一切都是文件### 根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。点开手机内部储存看到的就是手机的根目录Linux 根目录```/```是Linux 最顶层的目录，没有比根目录再高一阶的目录了，没有目录包含根目录用斜杠 ```/``` 来标明目录的层级与包含关系目录形式是这样的 /usr/binbin 是 usr 目录的子目录，usr 是 / 这个根目录的子目录Linux 的文件和目录都是由根目录 / 开始自顶向下呈乔木状分散的Windows 中用反斜杠 \\ 来标明目录的层级与包含关系C 盘（C:\\）是硬盘的根目录（假如没有把 C 盘磁盘分区的话）可以有好几个根目录，双击C盘就进入C盘的根目录，双击D盘就进入D盘的根目录，H 盘可能是光盘驱动器的根目录点开游戏文件夹看到的就是游戏的根目录。一个目录的形式是这样的 C:\\Program Files\\BaiduBaidu 这个目录是 Program Files 这个目录的一个子目录Program Files 这个目录是 C 盘这个根目录的一个子目录目录名称可以包含空格等符号在 Linux 下命名目录时尽量不使用空格或者其他特殊的符号尽量用小写英文字母### Linux 的根目录的直属子目录目录的列表形式，在类 Unix 的操作系统里是类似的苹果的桌面操作系统 macOS 的目录结构也是从根目录 / 开始的- bin：是 binary “二进制文件” ，可执行文件是二进制的bin 目录包含了会被所有用户使用的可执行程序- boot 目录包含与 Linux 启动密切相关的文件- dev： device “设备”包含外设。它里面的子目录，每一个对应一个外设比如光盘驱动器的文件就会出现在这个目录下- etc：是法语 et cetera ，包含系统的配置文件- home： home 表示“家”。用户的私人目录，我们放置私人的文件类似 Windows 中的 Documents 文件夹，也叫“我的文档除了root外每个用户都在 home 目录下有一个私人目录存放自己私人文件假如我的用户名是 oscar，那么我的私人目录就是 /home/oscar- lib：library“库”，目录包含被程序所调用的库文件，例如 .so 结尾的文件，Windows 下这样的库文件则是以 .dll 结尾- media 可移动的外设（USB 盘，SD卡，DVD，光盘，等等）插入电脑时，访问这些外设中的内容- mnt： mount “挂载”，mnt： mount “挂载”- opt： optional application software package ，“可选的应用软件包”， 安装多数第三方软件和插件- root 超级用户 root 的家目录一般的用户的家目录位于 /home 下，root 用户是个例外- sbin： system binary “系统二进制文件“，比 bin 目录多了一个前缀 system（“系统”），包含系统级的重要可执行程序- srv： service “服务”，包含一些网络服务启动之后所需要取用的数据- tmp： temporary “临时的”，普通用户和程序存放临时文件的地方，- usr：是 Unix Software Resource “Unix操作系统软件资源”，类似 Windows 中的 C:\\Windows，和 C:\\Program Files 这两个文件夹的集合，usr 目录里安装了大部分用户要调用的程序- var：variable “动态的，可变的”，包含程序的数据，比如 log（日志）文件， log 文件记录电脑中发生了什么事```pwd```  print working directory打印当前工作目录的路径\nadduser test 创建用户```passwd test输入密码 \n1234567891011121314151617181920212223242526```code &lt;文件路径/文件名&gt;```vscode中打开项目终端在每一行的开头处会有一个被称为“命令行提示符”的字符串，提示在其后面输入命令，这个提示符的格式可以自行设置，我们在命令提示符后面输入命令，告诉电脑我们想要它完成的任务```[]```：提示符的分隔符号，没有特殊含义。```root```：当前的登录用户。Linux 是多用户的操作系统```@```：分隔符号，没有特殊含义。前面是用户名，后面是所在的域```localhost```：当前系统的简写电脑/主机的名字（hostname127.0.0.```code &lt;文件路径/文件名&gt;```vscode中打开项目终端在每一行的开头处会有一个被称为“命令行提示符”的字符串，提示在其后面输入命令，这个提示符的格式可以自行设置，我们在命令提示符后面输入命令，告诉电脑我们想要它完成的任务```[]```：提示符的分隔符号，没有特殊含义。```root```：当前的登录用户。Linux 是多用户的操作系统```@```：分隔符号，没有特殊含义。前面是用户名，后面是所在的域```localhost```：当前系统的简写电脑/主机的名字（hostname127.0.0.1（完整主机名是localhost.localdomain）。```~```：代表用户当前所在的目录名字，刚打开一个终端（Terminal），当前所在的目录是你的用户家目录（home directory。会随着用户进入不同目录而改变```#```：root超级用户的提示符，Linux用这个符号标识登录的用户权限等级。```$``` 普通用户的权限的提示符reboot、shutdown -h now、init、halt、user管理，在普通用户身份上都是操作不了，但是有些特殊的情况下又需要有执行权限。又不可能让root用户把自己的密码告诉普通用户，这个问题该怎么解决？该问题是可以被解决的，可以使用sudo（switch user do）命令来进行权限设置。Sudo可以让管理员（root）事先定义某些特殊命令谁可以执行。 默认sudo中是没有除root之外用户的规则，要想使用则先配置sudo。 Sudo配置文件：/etc/sudoers配置sudo文件请使用“#visudo”，打开之后其使用方法和vim一致 配置普通用户的权限\nallow root to run any commands anywhereroot   ALL=(ALL)   ALL\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546Root表示用户名，如果是用户组，则可以写成“%组名”ALL：表示允许登录的主机（地址白名单）(ALL)：表示以谁的身份执行，ALL表示root身份ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割 案例：本身test用户不能添加用户，要求使用sudo配置，将其设置为可以添加用户，并且可以修改密码（但是不能修改root用户密码）。注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。路径可以使用which命令来查看语法：#which 指令名称在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码。 此处按照案例要求，不能让test用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：禁止修改root密码的配置（先允许全部，再拒绝root密码设置）： /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd rootsudo  -l 在普通用户下查看自己具有哪些特殊权限sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。```sudo su```用户切换为root退出 root 身份，可以用 ```Ctrl + D``` 的组合键，或者用 ```exit``` 命令```whoami``` 我是谁，显示当前登录的用户名```adduser test 创建用户```passwd test输入密码```shell[root@VM-0-9-centos ~]# dateMon Mar  1 16:46:16 CST 2021# CST  Central Standard Time “中央标准时间”[root@VM-0-9-centos ~]# date +%F2021-03-01[root@VM-0-9-centos ~]# date \"+%Y-%m-%d\"2021-03-01[root@VM-0-9-centos ~]# date \"+%Y %T\"2021 16:51:47[root@VM-0-9-centos ~]# date \"+%Y-%m-%d %H:%M:%S\"2021-03-01 16:54:21[root@VM-0-9-centos ~]# cal     March 2021     Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 Root表示用户名，如果是用户组，则可以写成“%组名”ALL：表示允许登录的主机（地址白名单）(ALL)：表示以谁的身份执行，ALL表示root身份ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割 案例：本身test用户不能添加用户，要求使用sudo配置，将其设置为可以添加用户，并且可以修改密码（但是不能修改root用户密码）。注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。路径可以使用which命令来查看语法：#which 指令名称在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码。 此处按照案例要求，不能让test用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：禁止修改root密码的配置（先允许全部，再拒绝root密码设置）： /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd rootsudo  -l 在普通用户下查看自己具有哪些特殊权限sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。```sudo su```用户切换为root退出 root 身份，可以用 ```Ctrl + D``` 的组合键，或者用 ```exit``` 命令```whoami``` 我是谁，显示当前登录的用户名```adduser test 创建用户```passwd test输入密码```shell[root@VM-0-9-centos ~]# dateMon Mar  1 16:46:16 CST 2021# CST  Central Standard Time “中央标准时间”[root@VM-0-9-centos ~]# date +%F2021-03-01[root@VM-0-9-centos ~]# date \"+%Y-%m-%d\"2021-03-01[root@VM-0-9-centos ~]# date \"+%Y %T\"2021 16:51:47[root@VM-0-9-centos ~]# date \"+%Y-%m-%d %H:%M:%S\"2021-03-01 16:54:21[root@VM-0-9-centos ~]# cal     March 2021     Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31\n引号表示让“年月日与时分秒”成为一个不可分割的整体\nWindows 可执行程序以 .exe 结尾Linux 每一条命令其实对应了一个可执行程序，一般是没有后缀名的\n\n在终端中输入命令，按回车的时候，就是执行了对应的那个程序，\n一个命令，其实只不过是一个我们随时可以调用的程序罢了\n\nwhich 命令：显示一个命令的对应的可执行文件程序的位置which命令接受一个参数，是你想知道其可执行程序位于哪里的那个命令\n\npwd 命令对应的 pwd 这个可执行程序位于 Linux 中的 /usr/bin 目录中12[root@VM-0-9-centos ~]# which pwd# /usr/bin/[root@VM-0-9-centos ~]# which pwd# /usr/bin/pwd\n\n\n\nselinux 安全模块\nbin binary 二进制，可执行文件dev device 硬件etc 系统配置文件，root才能登home 家目录  类似window userprov 进程\nusr 对应 win program files\n命令``` manual 命令使用手册1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768```q``` 退出 quit```help``` 命令查看保留关键字folder 文件夹file 文件```command parameters```命令和参数之间有空格隔开参数好比选项，改变命令的行为，同一个命令不同功能 区分大小写### 短参数（一个横杠、一个字母 缩写名称）最常用的参数形式就是一个短横线后接一个字母 command -p一次加好几个短参数，可以用空格隔开：command -p -a -T -多个短参数也可以合并在一起，效果是叠加：command -paT### 长参数（两个横杠、多个字母 全称）长参数没有短参数那么常用，但也是很有用的短参数是以一个短横线开始，而长参数是以两个短横线开始的格式：```command --parameter```多个长参数，是不能像多个短参数那样合并写的而是只能以空格隔开：```command --parameter1 --parameter2```可以组合使用短参数和长参数例如 ```command -paTc --parameter1 --parameter2```有时候，同一个意义的参数有短参数和长参数两种形式效果是一样的：例如 ```ls -a``` 和 ```ls --all```### 参数的值有一些参数需要赋值。短参数和长参数的赋值方式不一样短参数赋值，通常是这样的：command -p 长参数赋值，通常是这样的：command --parameter=10```tab``` 在输入了一个命令的首字母或前几个字母后，自动补全命令或文件名、路径名，按两下有提示 可以增加效率，防止手动输入路径时将名字写错，同时想不起来一个命令到底是如何拼写 ```#```开头 注释向上键：按时间顺序向前查找用过的命令，每按一次就前进一个命令向下键：按时间顺序向后查找用过的命令，每按一次就前进一个命令```Ctrl + R``` 用于查找使用过的命令```history``` 列出之前使用过的所有命令```!编号```这样的格式来重新运行 history输出中对应编号的命令空格下一页回车：运行，下一行### CentOS 的终端默认是有颜色标注的。- 蓝色 --> 目录- 绿色 --> 可执行文件- 红色 --> 压缩文件- 浅蓝色 --> 链接文件- 灰色 --> 其他文件```ls```列出文件和目录```ls -l 路径``` ：缩写```ll```，以详细信息列表的形式列出当前目录下的文件和目录，查看权限 每一个文件或目录都有对应的一行信息，列出的文件详细信息中，文件大小是以字节为单位的```ls -a``` ：显示所有文件和目录，包括隐藏的（以.开头）不包括开头的两个 . 和 .. ```.``` （一个点）表示当前目录； ```..``` （两个点）表示上一级目录```ls -A``` ：作用和小写的 -a 几乎一样，唯一不同就是 -A 不列出 . 和 .. 这两个文件```ls -la 路径``` ：所以文件（夹） ，并显示隐藏文件，以.开头，```ls --color=auto``` 来开启颜色标注```ls --color=none```关闭颜色标注```bash[root@VM-0-9-centos ~]# ls -l /roottotal 4-rw-r--r-- 1 root root    0 Feb 28 23:13 authorized_keysdrwxr-xr-x 2 root root 4096 Mar  1 00:37 dev\n上述列表中的第一列字符表示文档的类型,其中“-”表示改行对应的文档类型为文件,“d”表示文档类型为文件夹。|a. 其是文件夹类型b. 文件的所有者：拥有全部权限（读写执行）c. 文件所在的群组同组用户：可读、可执行d. 其他用户：可读、可执行e.文件链接数量3个文件大小：单位是 octet， byte“字节”最近一次修改的时间最后一列 文件或目录的名\n-h```human readable，“适合人类阅读的” 以 Ko，Mo，Go 的形式显示文件大小12345678910111213141516171819202122232425262728293031323334353637383940```ls -lh 路径``` 列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的 时候以可读性较高的形式显示```ls -t```按照文件或目录最近一次修改时间的降序排列```ls -l |grep jpg | wc -l```一个目录里,有各种文件类型:文本文件,图片,音频,视频。如果你想知道这里面有多少个JPEG类型的图片。```ls -l |grep jpg | wc -l &gt; jpeg_num.txt```把统计的数目存储到一个文本文件(jpeg_nb.txt)里```ls -l |grep jpg | wc -l &gt; jpeg_num.txt | mail -s \"jpeg number\" ashe@gmail.com```先统计这个数目,保存到 jpeg nb. txt文件里,再把这个文件用emai传给一个朋友```ctrl+L```用于清理终端的内容,清屏。同 ```clear```命令,  并不是真的清除了之前的信息,而是把之前的信息的隐藏到了最上面,通过滚动条继续查看以前的信息。  ```Ctrl+D```给终端传递EOF( End of file,文件结束符)  ```Shift+PgUp```用于向上滚屏,与鼠标的滚轮向上滚屏是一个效果  ```Shift + PgDn``` 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果  ```ctrl+a``` 光标移动到行首 Home 键有相同的效果  ```ctrl+e``` 光标移动到行末 End 键有相同的效果  ```ctrl+u``` 剪切/删除 光标到行首、除所有在光标左侧的命令字符  ```crtl+k```剪切/删除光标后的内容 光标右侧的命令字符  ```ctrl+w``` 剪切/删除光标左侧的一个“单词”word,用空格隔开的一个字符串。例如 -a 就是一个“单词  ```ctrl+y``` 粘贴用 Ctrl + U， Ctrl + K 或 Ctrl + W“删除”的字符串，有点像“剪切-粘贴”  ```cd```等同于```cd ~``` 等同于```cd /home/username``` change directory 直接切换到家目录  ```cd 路径```要去的那个目录的路径  ```cd ..``` 要回到上一级目录（父目录）  ```cd ../..``` 要回到上一级目录的上一级目录（爷目录）```du``` disk usage “磁盘使用/占用”，文件和目录所占的空间大小，深入遍历每个目录的子目录，统计所有文件的大 默认情况下只显示目录的大小```du -h``` 目录路径  以较高可读性的形式显示 以 Ko，Mo，Go 的形式显示文件大小```du -a``` 目录路径  显示文件和目录的大小 汇总```du -s``` 目录路径 summary 只显示汇总大小，当前目录的总大小```du -sh``` 目录路径 查看目录的真实大小```ls -lh 路径``` 列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的 时候以可读性较高的形式显示```ls -t```按照文件或目录最近一次修改时间的降序排列```ls -l |grep jpg | wc -l```一个目录里,有各种文件类型:文本文件,图片,音频,视频。如果你想知道这里面有多少个JPEG类型的图片。```ls -l |grep jpg | wc -l &gt; jpeg_num.txt```把统计的数目存储到一个文本文件(jpeg_nb.txt)里```ls -l |grep jpg | wc -l &gt; jpeg_num.txt | mail -s \"jpeg number\" ashe@gmail.com```先统计这个数目,保存到 jpeg nb. txt文件里,再把这个文件用emai传给一个朋友```ctrl+L```用于清理终端的内容,清屏。同 ```clear```命令,  并不是真的清除了之前的信息,而是把之前的信息的隐藏到了最上面,通过滚动条继续查看以前的信息。  ```Ctrl+D```给终端传递EOF( End of file,文件结束符)  ```Shift+PgUp```用于向上滚屏,与鼠标的滚轮向上滚屏是一个效果  ```Shift + PgDn``` 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果  ```ctrl+a``` 光标移动到行首 Home 键有相同的效果  ```ctrl+e``` 光标移动到行末 End 键有相同的效果  ```ctrl+u``` 剪切/删除 光标到行首、除所有在光标左侧的命令字符  ```crtl+k```剪切/删除光标后的内容 光标右侧的命令字符  ```ctrl+w``` 剪切/删除光标左侧的一个“单词”word,用空格隔开的一个字符串。例如 -a 就是一个“单词  ```ctrl+y``` 粘贴用 Ctrl + U， Ctrl + K 或 Ctrl + W“删除”的字符串，有点像“剪切-粘贴”  ```cd```等同于```cd ~``` 等同于```cd /home/username``` change directory 直接切换到家目录  ```cd 路径```要去的那个目录的路径  ```cd ..``` 要回到上一级目录（父目录）  ```cd ../..``` 要回到上一级目录的上一级目录（爷目录）```du``` disk usage “磁盘使用/占用”，文件和目录所占的空间大小，深入遍历每个目录的子目录，统计所有文件的大 默认情况下只显示目录的大小```du -h``` 目录路径  以较高可读性的形式显示 以 Ko，Mo，Go 的形式显示文件大小```du -a``` 目录路径  显示文件和目录的大小 汇总```du -s``` 目录路径 summary 只显示汇总大小，当前目录的总大小```du -sh``` 目录路径 查看目录的真实大小### xargs（eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：\nfind /sbin -perm +700 |ls -l       #这个命令是错误的find /sbin -perm +700 |xargs ls -l   #这样才是正确的\n12345678xargs 一般是和管道一起使用。命令格式：```somecommand |xargs -item  command```交互式 Bash Shell 只输出进程pid的ID号，进程名字为adb。```bash[root@localhost ~]# ps -ef|grep mysqlmysql     3361     1  1 21:06 ?        00:00:01 /usr/sbin/mysqldroot      3460  3435  0 21:08 pts/0    00:00:00 grep --color=xargs 一般是和管道一起使用。命令格式：```somecommand |xargs -item  command```交互式 Bash Shell 只输出进程pid的ID号，进程名字为adb。```bash[root@localhost ~]# ps -ef|grep mysqlmysql     3361     1  1 21:06 ?        00:00:01 /usr/sbin/mysqldroot      3460  3435  0 21:08 pts/0    00:00:00 grep --color=auto mysql\n方法一12[root@localhost ~][root@localhost ~]# pgrep -f mysql    # 仅输出进程ID号3361\n方法二123[root@localhost ~][root@localhost ~]# ps -ef|grep mysql|awk '{print $2}'33613486\n获取到pid后，可以进行后续处理。比如执行删除等操作。\n1ps -ef | awk '{print $2}' | xargs ps -ef | awk '{print $2}' | xargs kill -9\n如果需要查找到 pid 之后 kill 掉该进程，还可以使用 pkill：\n1pkill -f name\n\n找出占用端口的进程\n12# netstat -anp|grep \":80 \" |grep LISTENtcp     0      0 0.0.0.0:80        0.0.0.0:*      LISTEN      17785/nginx: worker\n\n替换指定的目录及其子目录下所有文件中的adc为bcd。sed [-hnV][-e][-f][文本文件]（ stream editor 简写sed ）\nsed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！-i 选项可以直接修改文件内容，举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！s ：取代，可以直接进行取代的工作，通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！如果是要改变两行以上，每一行之间都必须要以反斜杠『 \\ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \\ 存在。\n方法一\n1234567[root@localhost test]# find -type f | xargs catadcadc[root@localhost test]# find -type f | xargs sed -i &#x27;s/adc/bcd/g&#x27; [root@localhost test][root@localhost test]# find -type f | xargs catadcadc[root@localhost test]# find -type f | xargs sed -i &#x27;s/adc/bcd/g&#x27; [root@localhost test]# find -type f | xargs catbcdbcd\n方法二\n12[root@localhost test]# sed -i &#x27;s/adc/bcd/g&#x27; `grep &quot;adc&quot; -rl ./`[root@localhost test]# sed -i &#x27;s/adc/bcd/g&#x27; `grep &quot;adc&quot; -rl ./`# 注意：grep内容是用的反引号\n\n替换某个文件中的内容adb为bcd（替换指定文件的字符串）。\n12345[root@localhost test]# cat hello.txt i love you[root@localhost test]# sed -i &quot;s/i/I/g&quot; hello.txt [root@localhost test][root@localhost test]# cat hello.txt i love you[root@localhost test]# sed -i &quot;s/i/I/g&quot; hello.txt [root@localhost test]# cat hello.txt I love you\n\n软链接有点类似于Windows中的快捷方式，里面保存的是指向源文件的绝对路径，当访问它的时候就会替换成指向文件的路径。对于操作系统是通过 inode值访问硬盘的区块，对于软链接来说inode值和源文件的inode值是不一样的，但是硬链接是一样的inode值。只要有文件inode值指向这个区块，这个文件就始终不会消失。软链接文件只是维持了从软链接到源文件的指向关系，不是源文件的内容。\n硬链接相当于创建了一个普通文件，但硬链接的inode值和源文件的inode值相同都指向同一个区块。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份源文件。\ninode介绍：文件或目录的inode编号是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象。inode就像人的身份证。\ncrontad:定时任务例如：下单操作，需要在单个小时内付完款，通过定时任务每半个小时进行一下数据释放。\n\n编辑当前用户的计数器设置，与vim操作是一样的12[xiaokang@localhost ~]$ crontab -e      [xiaokang@localhost ~]$ crontab -e      # 编辑crontabcrontab: no changes made to crontab\n列出该用户的计数器设置123[xiaokang@localhost www]$ crontab -l*/1 * * * * php /data/www/cron.php  &gt;&gt; /tmp/cron.log   # */1表示每隔1分钟执行一次[xiaokang@localhost www]$ crontab -l*/1 * * * * php /data/www/cron.php  &gt;&gt; /tmp/cron.log   # */1表示每隔1分钟执行一次# * * * * * 分别代表分 时 日 月 周\n\n\n\n\nnslookup domain[dns-server] 查看域名解析是否正常，在网络故障的时候用来诊断网络问题。可以指定查询的类型，可以查到DNS记录的生存时间还可以指定使用那个DNS服务器进行解释。\n如何用本地计算机查询DNS记录?\n打开命令提示符窗口(开始–运行—输入CMD–回车)\nnslookup –qt=类型 目标域名(注意qt必须小写)\n类型主要有:\nA 地址记录(Ipv4)\nAAAA 地址记录（Ipv6）\nCNAME 别名记录\nHINFO 硬件配置记录，包括CPU、操作系统信息\nISDN 域名对应的ISDN号码\nMB 存放指定邮箱的服务器\nMG 邮件组记录\nMINFO 邮件组和邮箱的信息记录\nMR 改名的邮箱记录\nMX 邮件服务器记录\nNS 名字服务器记录\nPTR 反向记录\nRP 负责人记录\nSRV TCP服务器信息记录\nTXT 域名对应的文本信息\n比如你要查询tool.chinaz.com的A记录,那在命令符提示窗口输入：\nnslookup -qt=a tool.chinaz.com\n\n则可以查到相应的记录\n如何使用指定DNS服务器查询?语法为nslookup -qt=类型 目标域名 指定的DNS服务器IP或域名\n例子：nslookup -qt=A tool.chinaz.com 8.8.8.8\n返回信息说明服务器：本机DNS服务器信息\n非权威应答：Non-authoritative answer，除非实际存储DNS Server中获得域名解析回答的，都称为非权威应答。也就是从缓存中获取域名解析结果。\naddress：目标域名对应物理IP可有多个\naliase：目标域名nslookup google.com 和 nslookup google.com 8.8.8.8\n1 查看内存总数\ncat /proc/meminfo | grep MemTotal\n2.查看当前系统用户数\nwho\n统计显示 7个用户\n3.查看当前系统版本及系统位数\nuname -a\n4.查看当前系统引用的JDK 是否是自己安装的配置的jdk\nwhich java\n5.查看系统端口是否被占用\nnetstat -pan|grep 8017\n使用 netstat + grep 来查看某个端口是否在使用\n6.查看系统进程 （查看项目or应用程序的进程）\nps -ef|grep tomcat-probe\n7.查看防火墙状态及启动防火墙\nservice iptables status\n启动的话： service iptables start\n8.查看文件在哪个目录路径\n命令：locate\n如：locate stats.properties\n9查看系统内存\n命令：free -m\n参数 m 是兆\n10.网络配置（相关命令）\n命令：ifconfig\n11.系统资源查看\n命令： vmstat\n命令 ：top\n命令： uptime\n12:目录命令操作\nmkdir -p a/b/c —- 批量新增目录\nmv 命令可以重命名\ncp 命令 复制文件或者文件夹 （可用于项目包的备份处理）\n如： cp -rf 123.tar …/backup/123.tar.20181122\n13:文件操作\n文件的操作，个人觉得有些命令很常用， cat ,tail (监控查看日志文件)、vi\nvi 命令涉及到很多实用快捷操作 ，\n三中模式：\n（命令模式 、编辑模式 、末行模式）\nN 向上查找\nn 向下查找\n—- 删除命令\nndw或ndW：删除光标处开始及其后的n-1个字\ndo：删至行首\nd$：删至行尾\n—- 搜索及替换命令\n/pattern：从光标开始处向文件尾搜索pattern\n?pattern：从光标开始处向文件首搜索pattern\nn：在同一方向重复上一次搜索命令\nN：在反方向上重复上一次搜索命令\n：1，$ s/p1/p2/g：将当前行中所有p1均用p2替代\n：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代\n13:修改文件或者目录权限\nchmod chown chgrp 命令的使用\n14：查看文件大小\n命令：du\n15：查看环境变量\n命令： env\n还有 set 命令也可以\n补充：\n2.1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】\n用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。\n例如：编辑/etc/profile文件，添加CLASSPATH变量\nvi /etc/profileexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n2.2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】\n用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。\n例如：编辑guok用户目录(/home/guok)下的.bash_profile\n$ vi /home/guok/.bash.profile\n添加如下内容：\nexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效\n16：抓包\n命令 tcpdump\ntcpdump -s 0 -w /tmp/20150203.cap host 211.137.182.167\n17:查找文件并询问是否删除\nfind ./ -name ‘IceGpsAndGprsAnalyze*’ -exec rm -i {} ;\n18：修改系统时间\ndate -s “20120827 15:04:00”\n或者\ndate -s “2012-08-27 15:04:00”\n或者\ndate -s “15:04:00 2012-08-27”\n或者\ndate -s “15:04:00 20120827”\n记得 双引号\n19 通过关键字 来查找包含关键字的文件\n命令 find\nfind ./ -type f|xargs grep “T2001774”\nfind . -name * -type f -print |xargs grep ‘关键字’\n命令： grep\ngrep ‘T2001774’ ./*\n20：文件压缩和解压\n压缩\ntar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\ntar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\ntar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\ntar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\nrar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\nzip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n解压\ntar -xvf file.tar //解压 tar包\ntar -xzvf file.tar.gz //解压tar.gz\ntar -xjvf file.tar.bz2 //解压 tar.bz2\ntar -xZvf file.tar.Z //解压tar.Z\nunrar e file.rar //解压rar\nunzip file.zip //解压zip\n总结\n1、*.tar 用 tar -xvf 解压\n2、*.gz 用 gzip -d或者gunzip 解压\n3、.tar.gz和.tgz 用 tar -xzf 解压\n4、*.bz2 用 bzip2 -d或者用bunzip2 解压\n5、*.tar.bz2用tar -xjf 解压\n6、*.Z 用 uncompress 解压\n7、*.tar.Z 用tar -xZf 解压\n8、*.rar 用 unrar e解压\n9、*.zip 用 unzip 解压\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["linux"],"tags":["剑指offer","linux"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/mock/","content":"mock用来替代你测试应用的某一部分好处1：加快测试速度，如果你的应用是依赖于资源的，mock可以有效减少资源的占用2：避免不必要的副作用\n在单元测试进行的同时，就离不开mock模块的存在，初次接触这个概念的时候会有这样的疑问：把要测的东西都模拟掉了还测试什么呢？　　但在，实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：•接口的依赖•外部接口调用•测试环境非常复杂单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的.使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。在这里插入图片描述因为在为代码进行单元测试的同时，会发现该模块依赖于其他的模块，例如数据库，网络，或者第三方模块的存在，而我们对一个模块进行单元测试的目的，是测试当前模块正常工作，这样就要避开对其他模块的依赖，而mock主要作用便在于，专注于待测试的代码。而在但与测试中，如何灵活的使用mock模块是核心所在。下面便以mock为核心，结合最近所写的代码，阐述mock模块的使用。\n这个例子，本来被调用的sum函数要执行很长时间为了加快测试进度，我们使用patch装饰器来直接mock sum函数\n123456789101112131415161718192021222324import unittestimport timefrom unittest import TestCasefrom unittest.mock import patchdef sum(a, b):    time.sleep(100)  # long running process    return a + bclass TestCalculator(TestCase):    # 用patch装饰器来mock对象    @patch('__main__.sum', return_value=5)    def test_sum(self, sum):        self.assertEqual(sum(2, 3), 5)if __name__ == '__main__':    unittest.main()# ----------------------------------------------------------------------# Ran 1 test in 0.001simport unittestimport timefrom unittest import TestCasefrom unittest.mock import patchdef sum(a, b):    time.sleep(100)  # long running process    return a + bclass TestCalculator(TestCase):    # 用patch装饰器来mock对象    @patch('__main__.sum', return_value=5)    def test_sum(self, sum):        self.assertEqual(sum(2, 3), 5)if __name__ == '__main__':    unittest.main()# ----------------------------------------------------------------------# Ran 1 test in 0.001s# OK\n\n\nmock模块的使用在mock模块中，两个常用的类型为Mock，MagicMock，两个类的关系是MagicMock继承自Mock，最重要的两个属性是return_value, side_effect。12345&gt;&gt;&gt; from mock import Mock&gt;&gt;&gt; fake_obj = Mock()&gt;&gt;&gt;fake_obj.return_value = 'This is a mock object'&gt;&gt;&gt; fake_obj()&gt;&gt;&gt; from mock import Mock&gt;&gt;&gt; fake_obj = Mock()&gt;&gt;&gt;fake_obj.return_value = 'This is a mock object'&gt;&gt;&gt; fake_obj()'This is a mock object'\n\n\n\n我们通过Mock()可以创建一个mock对象，通过renturn_value 指定它的返回值。即当下文出现fake_obj()会返回其return_value所指定的值。也可以通过side_effect指定它的副作用，这个副作用就是当你调用这个mock对象是会调用的函数,也可以选择抛出一个异常，来对程序的错误状态进行测试。\n12345678910&gt;&gt;&gt;def b():...    print 'This is b'...&gt;&gt;&gt;fake_obj.side_effect = b&gt;&gt;&gt;fake_obj()This is b&gt;&gt;&gt;fake_obj.side_effect = KeyError('This is b')&gt;&gt;&gt;fake_obj()...KeyError: &gt;&gt;&gt;def b():...    print 'This is b'...&gt;&gt;&gt;fake_obj.side_effect = b&gt;&gt;&gt;fake_obj()This is b&gt;&gt;&gt;fake_obj.side_effect = KeyError('This is b')&gt;&gt;&gt;fake_obj()...KeyError: 'This is b'\n如果要模拟一个对象而不是函数，你可以直接在mock对象上添加属性和方法，并且每一个添加的属性都是一个mock对象【注意，这种方式很有用】，也就是说可以对这些属性进行配置,并且可以一直递归的定义下去。\n123&gt;&gt;&gt;fake_obj.fake_a.return_value = 'This is fake_obj.fake_a'&gt;&gt;&gt;fake_obj.fake_a()&gt;&gt;&gt;fake_obj.fake_a.return_value = 'This is fake_obj.fake_a'&gt;&gt;&gt;fake_obj.fake_a()'This is fake_obj.fake_a'\n上述代码片段中fake_obj是一个mock对象，而fake_obj.fake_a的这种形式使得fake_a变成了fake_obj的一个属性，作用是在fake_obj.fake_a()调用时会返回其return_value。另外也可以通过为side_effect指定一个列表，这样在每次调用时会依次返回，如下：\n1234567&gt;&gt;&gt; fake_obj = Mock(side_effect = [1, 2, 3])&gt;&gt;&gt;fake_obj()1&gt;&gt;&gt;fake_obj()2&gt;&gt;&gt;fake_obj()&gt;&gt;&gt; fake_obj = Mock(side_effect = [1, 2, 3])&gt;&gt;&gt;fake_obj()1&gt;&gt;&gt;fake_obj()2&gt;&gt;&gt;fake_obj()3\n7.1 函数的如何mock在rbd_api.py文件中如下内容：\n123456789import DAO_PoolMgrdef checkpoolstat(pool_name)  ret， poolstat = DAO_PoolMgr.DAO_query_ispoolok(pool_name)if ret != MGR_COMMON.MONGO_SUCCESS:    return retif poolstat is False:    return MGR_COMMON.POOL_STAT_ERRORimport DAO_PoolMgrdef checkpoolstat(pool_name)  ret， poolstat = DAO_PoolMgr.DAO_query_ispoolok(pool_name)if ret != MGR_COMMON.MONGO_SUCCESS:    return retif poolstat is False:    return MGR_COMMON.POOL_STAT_ERRORreturn MGR_COMMON.SUCCESS\n\n要为这个函数撰写单元测试，因为其有数据库的操作，因而就需要mock 出DAO_query_ispoolok操作。因此，我们在test_rbd_api.py文件中可以这么写：因为DAO_query_ispoolok是类DAO_PoolMgr的操作，因此可以这么写\n123456789101112131415161718192021#!/usr/bin/pythonimport DAO_PoolMgrimport unittestimport rbd_api as rbdAPIclass TestAuxiliaryFunction(unittest.TestCase):    def setUp(self):        self.pool_name = \"aaa\"        def tearDown(self):        self.pool_name = None    @mock.patch.object(DAO_PoolMgr, \"DAO_query_ispoolok\")    def test_checkpoolstat(self, mock_DAO_query_ispoolok):        mock_DAO_query_ispoolok.return_value = (MGR_COMMON.POOL_STAT_ERROR, None)        self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)        mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, False)        self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)                mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, True)        self.#!/usr/bin/pythonimport DAO_PoolMgrimport unittestimport rbd_api as rbdAPIclass TestAuxiliaryFunction(unittest.TestCase):    def setUp(self):        self.pool_name = \"aaa\"        def tearDown(self):        self.pool_name = None    @mock.patch.object(DAO_PoolMgr, \"DAO_query_ispoolok\")    def test_checkpoolstat(self, mock_DAO_query_ispoolok):        mock_DAO_query_ispoolok.return_value = (MGR_COMMON.POOL_STAT_ERROR, None)        self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)        mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, False)        self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.POOL_STAT_ERROR)                mock_DAO_query_ispoolok.return_value = (MGR_COMMON.SUCCESS, True)        self.assert(rbdAPI.checkpoolstat(self.pool_name), MGR_COMMON.SUCCESS)\n测试用例上的装饰器含义如下：@mock.pathc.object(类名，“类中函数名”)，而如果想要忽略某个测试用例，则可以通过装饰器@unittest.skip(“原因”)而对于另外一种情形则是在另外一个函数中调用了checkpoolstat函数。如下rbd_api.py：\n123456789def checkpoolstat():    ……class Disk(Resource):    def  __init__(self):        ……    def delete(def checkpoolstat():    ……class Disk(Resource):    def  __init__(self):        ……    def delete(self, pool, img):        ret = rbd_api.checkpoolstat()        ……\n这样，我们在为delete函数撰写单元测试时，也可以在test_rbd_api.py中使用如下的方式：\n1234567891011import rbd_apiclass TestDisk(unittest.TestCase):    def setup():        …      def teardown():              …      @mock.patch(“rbd_api.checkpoolstat”, Mock(return_value = True))      def test_delete():         import rbd_apiclass TestDisk(unittest.TestCase):    def setup():        …      def teardown():              …      @mock.patch(“rbd_api.checkpoolstat”, Mock(return_value = True))      def test_delete():         # rbd_api.checkpoolstat 已经成为一个mock对象了，调用时返回True            …\n此时的装饰器应该为\n1@mock.patch(“模块名.函数名”)\n\n7.2 链式函数抛出异常在rbd_api.py文件中，有一行代码如下：\n1ret = OpRBD(pool).flatten(img)\n类似这种链式调用的，在前一个函数中抛出异常，要怎么写？如下：\n12rbdServ.OpRBD = MagicMock()rbdServ.OpRBD(pool).side_effect = rados.Error(“Error: error connecting to the cluster: error code rbdServ.OpRBD = MagicMock()rbdServ.OpRBD(pool).side_effect = rados.Error(“Error: error connecting to the cluster: error code 24”)\n7.3 全局函数如何mock例如在文件rbd_api.py中有全局函数checkpoolstat(pool)，它是一个全局函数，这样在进行单元测试的过程中，我们可能需要mock该函数。该函数的具体代码如下：\n因此，我们在test_rbd_api.py文件中为该函数撰写单元测试，可以这么做。在文件开始处导入该rbd_api模块。\n12345import rbd_api as rbdAPIdef test_patchInvalid_Parameter(import rbd_api as rbdAPIdef test_patchInvalid_Parameter(self):    ……    rbdAPI.checkpoolstat.return_value = MGR_COMMON.POOL_STAT_ERROR    即可。\n7.4 链式调用正常在rbd_api文件中有如下代码行：\n1ret = OpRBD(pool).flatten(img)\n在第一个函数未出现异常，在flatten函数中返回值可以在test_rbd_api.py文件中如下写代码：\n1rbdServ.OpRBD(pool).snap_rollback = MagicMock(return_value = RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY)\n7.5 with子句mock\n12345678910111213141516171819#!/usr/bin/pythonimport radosclass OpRBD:    def __init__(self):        ...        def __del__(self):        ...        def resize(self, img, size):        try:            with rbd.Image(self.ioctx, img) as image:                if image.size() &lt; size:                    image.resize(size)                else:                    return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL        except rbd.ImageNotFound as exce1          print(exce1)          #!/usr/bin/pythonimport radosclass OpRBD:    def __init__(self):        ...        def __del__(self):        ...        def resize(self, img, size):        try:            with rbd.Image(self.ioctx, img) as image:                if image.size() &lt; size:                    image.resize(size)                else:                    return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL        except rbd.ImageNotFound as exce1          print(exce1)          return RBD_COMMON.CODE_IMAGE_NOT_FOUND\n由于是在with子句中要进行mock，在此简单的对with的知识点进行说明：要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。下面是一组与上下文管理器和with 语句有关的概念。\n上下文管理协议（Context Management Protocol）：包含方法 enter() 和 exit()，支持该协议的对象要实现这两个方法。上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了 enter() 和 exit() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 enter() 和exit() 方法实现，enter() 方法在语句体执行之前进入运行时上下文，exit() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 enter() 方法，执行完语句体之后会执行 exit() 方法。出现异常时，如果 exit(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理。因此，在对with子句进行mock时，要具有两个函数，exit, enter，并且如果在with语句体重抛出异常并被with之外的代码进行捕获异常，要使得__exit__返回False，因此可以撰写测试代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/pythonimport radosclass OpRBD:    def __init__(self):    ...    def __del__(self):        ...            def resize(self, img, size):            try:                with rbd.Image(self.ioctx, img) as image:                    if image.size() &lt; size:                        image.resize(size)                    else:                        return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL            except rbd.ImageNotFound as exce1                print(exce1)                return RBD_COMMON.CODE_IMAGE_NOT_FOUND    class TestOpRBD(unittest.TestCase):        def setUp(self):            ...        def tearDown(self):            ...        def test_resize(self):            fake_image = Mock()            fake_image.__enter__ = Mock(return_value = fake_image)            fake_image.__exit__ = Mock(return_value = True)            rbd.Image = Mock(return_value = fake_image)            size = 1073741824L / 2            fake_image.size = Mock(return_value = 1073741824L)            fake_image.resize = Mock(return_value = None)            self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL)                        size = 2 * 1073741824L            self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY)            rbd.Image = Mock(side_effect = rbd.ImageNotFound(\"%s image not found!\" %self.img))            self.assertEqual(self.resize(self.img, size), RBD_COMMON.CODE_IMAGE_NOT_FOUND)```    7.6 连续mock在rbd_api文件中有一个OpRados类的内容如下：```py#!/usr/bin/pythonimport radosclass OpRados:     def __init__(self):          self.cluster = rados.Rados(conffile=rconf['conffile'])          self.cluster.connect()          def __del__(self):          self.cluster.shutdown()          def lists(self):          return util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET, \"\", self.cluster.list_pools())为该类写单元测试，具体代码如下：#!/usr/bin/pythonimport radosimport unittestfrom mock import Mockclass TestOpRados(unittest.TestCase):    def setUp(self)：        fake_Rados = Mock()        fake_Rados.connect = Mock(return_value = None)        fake_Rados.shutdown = Mock(return_value = None)        fake_Rados.list_pools = Mock(return_value = [\"sqh\", \"sqh1\"])        # 注意：此处要使得rados.Rados()调用返回fake_Rados.        # 如果写成rados.Rados = fake_Rados,只能使得self.cluster重新生成一个Mock对象        # 无法有效的控制为fake_Rados所添加的属性。        rados.Rados = Mock(return_value = fake_Rados)        self.opRados = OpRados()            def tearDown(self):        fake_Rados = None        self.opRados = None        def test_list(self):        return_list = [\"sqh\", \"sqh1\"]        self.assertEqual(self.opRados.lists(), util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET,  #!/usr/bin/pythonimport radosclass OpRBD:    def __init__(self):    ...    def __del__(self):        ...            def resize(self, img, size):            try:                with rbd.Image(self.ioctx, img) as image:                    if image.size() &lt; size:                        image.resize(size)                    else:                        return RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL            except rbd.ImageNotFound as exce1                print(exce1)                return RBD_COMMON.CODE_IMAGE_NOT_FOUND    class TestOpRBD(unittest.TestCase):        def setUp(self):            ...        def tearDown(self):            ...        def test_resize(self):            fake_image = Mock()            fake_image.__enter__ = Mock(return_value = fake_image)            fake_image.__exit__ = Mock(return_value = True)            rbd.Image = Mock(return_value = fake_image)            size = 1073741824L / 2            fake_image.size = Mock(return_value = 1073741824L)            fake_image.resize = Mock(return_value = None)            self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_ARGUMENT_LESS_THAN_ORIGINAL)                        size = 2 * 1073741824L            self.assertEqual(self.opRBD.resize(self.img, size), RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY)            rbd.Image = Mock(side_effect = rbd.ImageNotFound(\"%s image not found!\" %self.img))            self.assertEqual(self.resize(self.img, size), RBD_COMMON.CODE_IMAGE_NOT_FOUND)```    7.6 连续mock在rbd_api文件中有一个OpRados类的内容如下：```py#!/usr/bin/pythonimport radosclass OpRados:     def __init__(self):          self.cluster = rados.Rados(conffile=rconf['conffile'])          self.cluster.connect()          def __del__(self):          self.cluster.shutdown()          def lists(self):          return util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET, \"\", self.cluster.list_pools())为该类写单元测试，具体代码如下：#!/usr/bin/pythonimport radosimport unittestfrom mock import Mockclass TestOpRados(unittest.TestCase):    def setUp(self)：        fake_Rados = Mock()        fake_Rados.connect = Mock(return_value = None)        fake_Rados.shutdown = Mock(return_value = None)        fake_Rados.list_pools = Mock(return_value = [\"sqh\", \"sqh1\"])        # 注意：此处要使得rados.Rados()调用返回fake_Rados.        # 如果写成rados.Rados = fake_Rados,只能使得self.cluster重新生成一个Mock对象        # 无法有效的控制为fake_Rados所添加的属性。        rados.Rados = Mock(return_value = fake_Rados)        self.opRados = OpRados()            def tearDown(self):        fake_Rados = None        self.opRados = None        def test_list(self):        return_list = [\"sqh\", \"sqh1\"]        self.assertEqual(self.opRados.lists(), util.return_format(RBD_COMMON.CODE_EXEC_SUCCESS_GET,  \"\", return_list))\n7.7 Flask API 接口的模拟调用有三个文件：rbd_app.py文件内容如下：\n1234567891011121314151617181920#!/usr/bin/pythonfrom flask imort Flaskfrom flask.ext import restfulapp = Flask(__name__)api = restful.Api(app)api_version = \"/v1.0\"#### Actually setup the Api resource ruting here##...api.add_resource(rbd_api.Disk, api_version+\"pools/&lt;pool&gt;/disks/&lt;img&gt;\")...if __name__ == __main__:    from gevent.wsgi import WSGIServer    http_server = WSGIServer(('0.0.0.0', #!/usr/bin/pythonfrom flask imort Flaskfrom flask.ext import restfulapp = Flask(__name__)api = restful.Api(app)api_version = \"/v1.0\"#### Actually setup the Api resource ruting here##...api.add_resource(rbd_api.Disk, api_version+\"pools/&lt;pool&gt;/disks/&lt;img&gt;\")...if __name__ == __main__:    from gevent.wsgi import WSGIServer    http_server = WSGIServer(('0.0.0.0', 4806), app)    http_server.serve_forever()\n\nrbd_api.py文件中Disk类内容如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/pythonimport requestsfrom flask import requestfrom flask_restful import reqparse, Resourceclass Disk(Resource):    def get(self, pool, img):        ret, rbd_info = DAO_query_rbd_info(pool, img)        ...        def post(self, pool, img):        parser = reqparser.RequestParser()        # action: create\\copy\\clone        parser.add_argument('action', type=str)        parser.add_argument('src_pool', type=str)        parser.add_argument('src_rbd', type=str)        parser.add_argument('src_snap', type=str)        parser.add_argument('size', type=str)        parser.add_argument('unit', type=str)                action = args.get('action')        if action == \"create\":            size = args.get('size')            unit = args.get('unit')            ...        elif action == 'copy':            src_pool = args.get('src_pool')            src_rbd = args.get('src_rbd')            ...        else            return ...        def delete(self, pool, img):        ...        def put(self, pool, img):        parser = reqparser.RequestParser()        parser.add_argument('rb_snap', type=str)        parser.add_argument('action', type=str)        args = parser.parse_args()                if action == \"flatten\":            ...        elif action == \"rollback\":            snap = args.get(\"rb_snap\")            ...        else:            return ...        def patch(self, pool, img):        parser = reqparse.RequestParser()        parser.add_argument(\"action\", type=srt)        parser.add_argument(\"name\", type=str)        parser.add_argument(\"size\", type=float)        parser.add_argument(\"unit\", type=str)        args = parser.parse_args()        action = args.get('action')        if action == \"resize\":            size = args.get('size')            unit = args.get('unit')            ....        else:            #!/usr/bin/pythonimport requestsfrom flask import requestfrom flask_restful import reqparse, Resourceclass Disk(Resource):    def get(self, pool, img):        ret, rbd_info = DAO_query_rbd_info(pool, img)        ...        def post(self, pool, img):        parser = reqparser.RequestParser()        # action: create\\copy\\clone        parser.add_argument('action', type=str)        parser.add_argument('src_pool', type=str)        parser.add_argument('src_rbd', type=str)        parser.add_argument('src_snap', type=str)        parser.add_argument('size', type=str)        parser.add_argument('unit', type=str)                action = args.get('action')        if action == \"create\":            size = args.get('size')            unit = args.get('unit')            ...        elif action == 'copy':            src_pool = args.get('src_pool')            src_rbd = args.get('src_rbd')            ...        else            return ...        def delete(self, pool, img):        ...        def put(self, pool, img):        parser = reqparser.RequestParser()        parser.add_argument('rb_snap', type=str)        parser.add_argument('action', type=str)        args = parser.parse_args()                if action == \"flatten\":            ...        elif action == \"rollback\":            snap = args.get(\"rb_snap\")            ...        else:            return ...        def patch(self, pool, img):        parser = reqparse.RequestParser()        parser.add_argument(\"action\", type=srt)        parser.add_argument(\"name\", type=str)        parser.add_argument(\"size\", type=float)        parser.add_argument(\"unit\", type=str)        args = parser.parse_args()        action = args.get('action')        if action == \"resize\":            size = args.get('size')            unit = args.get('unit')            ....        else:            return ...\n在test_rbd_api.py中卫Disk类撰写单元测试\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from rbd_app import app        class TestDisk(uniitest.TestCase):    def setUp(self):        self.disk = Disk()        self.content_type = \"application/json\"        ...        def tearDown(self):        self.disk = None        self.content_type = None        ...        @mock.path.object(DAO_RBDMgr, \"DAO_query_rbd_info\")    def test_get(self, mock_DAO_query_rbd_info):        rbd_info = {\"pool_name\":\"sqh\", \"parent\":{}, \"image_size\":1073741824L,...}        mock_DAO_query_rbd_info.return_value = (RBD_COMMON.MONGO_SUCCESS, rbd_info)                with app.test_request_context(\"/?pool_name=sqh&amp;image_name=sqh001\"):            pool = request.args.get('pool_name')            img=request.args.get('image_name')            self.assertEqual(selff.disk.get(pool, img), RBD_COMMON.http_return(RBD_COMMON.MONGO_SUCCESS))            def test_post(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"create\", \"size\":2, \"unit\":\"GB\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.post(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_GET))        def test_delete(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        with app.test_request_context(path_url):            self.assertEqual(self.disk.delete(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_DELETE))                def test_put(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"rollback\", \"rb_snap\":\"sqh_snap\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.put(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_FLATTENING))        def test_patch(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = 'v1.0/pools/%s/disks/%s' %　(pool, img)        size = 1073741824L        data = {\"action\":\"resize\", \"size\":size, \"unit\":\"GB\"}        # the action resize        from rbd_app import app        class TestDisk(uniitest.TestCase):    def setUp(self):        self.disk = Disk()        self.content_type = \"application/json\"        ...        def tearDown(self):        self.disk = None        self.content_type = None        ...        @mock.path.object(DAO_RBDMgr, \"DAO_query_rbd_info\")    def test_get(self, mock_DAO_query_rbd_info):        rbd_info = {\"pool_name\":\"sqh\", \"parent\":{}, \"image_size\":1073741824L,...}        mock_DAO_query_rbd_info.return_value = (RBD_COMMON.MONGO_SUCCESS, rbd_info)                with app.test_request_context(\"/?pool_name=sqh&amp;image_name=sqh001\"):            pool = request.args.get('pool_name')            img=request.args.get('image_name')            self.assertEqual(selff.disk.get(pool, img), RBD_COMMON.http_return(RBD_COMMON.MONGO_SUCCESS))            def test_post(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"create\", \"size\":2, \"unit\":\"GB\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.post(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_GET))        def test_delete(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        with app.test_request_context(path_url):            self.assertEqual(self.disk.delete(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_DELETE))                def test_put(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"rollback\", \"rb_snap\":\"sqh_snap\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.put(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_FLATTENING))        def test_patch(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = 'v1.0/pools/%s/disks/%s' %　(pool, img)        size = 1073741824L        data = {\"action\":\"resize\", \"size\":size, \"unit\":\"GB\"}        # the action resize        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.patch(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_MODIFY))\n7.7.1 Get请求\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@mock.path.object(DAO_RBDMgr, \"DAO_query_rbd_info\")    def test_get(self, mock_DAO_query_rbd_info):        rbd_info = {\"pool_name\":\"sqh\", \"parent\":{}, \"image_size\":1073741824L,...}        mock_DAO_query_rbd_info.return_value = (RBD_COMMON.MONGO_SUCCESS, rbd_info)                with app.test_request_context(\"/?pool_name=sqh&amp;image_name=sqh001\"):            pool = request.args.get('pool_name')            img=request.args.get('image_name')            self.assertEqual(selff.disk.get(pool, img), RBD_COMMON.http_return(RBD_COMMON.MONGO_SUCCESS))``在为flask接口撰写单元测试时，最关键的是如何传递数据，我们在setUp函数中初始化Disk类的实例,即self.disk。在传递参数的时候通过调用app.test_request_context(“url”)。因为是restful的get请求，因而我们可以使用？param1=val1&amp;param2=val2的形式。7.7.2 Post请求在Post请求，我们需要传递动作的类型，即其他参数，在app.test_request_context函数中，传递了字符串url， data字典，HTTP请求头信息。def test_post(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"create\", \"size\":2, \"unit\":\"GB\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.post(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_GET))7.7.3 Delete请求如post7.7.4 Put请求如post7.7.5 Patch请求如post8. Python 单元测试环境安装因为在python2.*中，mock是单独的模块，因而我们需要单独安装mock模块才能够正常的使用。因此，我们首先要在rpm find 网站下载好pip，然后通过pip安装mock。http://rpmfind.net/linux/RPM/epel/7/x86_64/Packages/p/python2-pip-8.1.2-5.el7.noarch.html依赖于python-setuptoolshttp://rpmfind.net/linux/RPM/centos/7.4.1708/x86_64/Packages/python-setuptools-0.9.8-7.el7.noarch.htmlmock的下载网址：https://pypi.python.org/pypi/mock/2.0.0下一章节要用的coverage，测试代码覆盖率，网址在：https://pypi.python.org/pypi/coverage/4.5.19. 使用coverage测试覆盖率在单元测试的过程中，应尽量使得单元都被覆盖过，因而需要使用专门的工具来进行测试代码覆盖率。以test_rbd_api.py为准测试的步骤如下：```py@mock.path.object(DAO_RBDMgr, \"DAO_query_rbd_info\")    def test_get(self, mock_DAO_query_rbd_info):        rbd_info = {\"pool_name\":\"sqh\", \"parent\":{}, \"image_size\":1073741824L,...}        mock_DAO_query_rbd_info.return_value = (RBD_COMMON.MONGO_SUCCESS, rbd_info)                with app.test_request_context(\"/?pool_name=sqh&amp;image_name=sqh001\"):            pool = request.args.get('pool_name')            img=request.args.get('image_name')            self.assertEqual(selff.disk.get(pool, img), RBD_COMMON.http_return(RBD_COMMON.MONGO_SUCCESS))``在为flask接口撰写单元测试时，最关键的是如何传递数据，我们在setUp函数中初始化Disk类的实例,即self.disk。在传递参数的时候通过调用app.test_request_context(“url”)。因为是restful的get请求，因而我们可以使用？param1=val1&amp;param2=val2的形式。7.7.2 Post请求在Post请求，我们需要传递动作的类型，即其他参数，在app.test_request_context函数中，传递了字符串url， data字典，HTTP请求头信息。def test_post(self):        pool = \"sqh\"        img = \"sqh001\"        path_url = \"v1.0/pools/%s/disks%s\" % (pool, img)        data = {\"action\":\"create\", \"size\":2, \"unit\":\"GB\"}        with app.test_request_context(path_url, data=json.dumps(data), content_type=self.content_type):            self.assertEqual(self.disk.post(pool, img), RBD_COMMON.http_return(RBD_COMMON.CODE_EXEC_SUCCESS_GET))7.7.3 Delete请求如post7.7.4 Put请求如post7.7.5 Patch请求如post8. Python 单元测试环境安装因为在python2.*中，mock是单独的模块，因而我们需要单独安装mock模块才能够正常的使用。因此，我们首先要在rpm find 网站下载好pip，然后通过pip安装mock。http://rpmfind.net/linux/RPM/epel/7/x86_64/Packages/p/python2-pip-8.1.2-5.el7.noarch.html依赖于python-setuptoolshttp://rpmfind.net/linux/RPM/centos/7.4.1708/x86_64/Packages/python-setuptools-0.9.8-7.el7.noarch.htmlmock的下载网址：https://pypi.python.org/pypi/mock/2.0.0下一章节要用的coverage，测试代码覆盖率，网址在：https://pypi.python.org/pypi/coverage/4.5.19. 使用coverage测试覆盖率在单元测试的过程中，应尽量使得单元都被覆盖过，因而需要使用专门的工具来进行测试代码覆盖率。以test_rbd_api.py为准测试的步骤如下：```py>>> coverage run test_rbd_api.py>>>coverage report -m path/to/rbd_api.py\n即可查看代码覆盖程度。\n很多时候开发人员和其他系统联调时，如果关联系统还没有开发完成，这时只能使用mock来模拟关联系统的返回自动化测试也常常遇到同样的问题，为了验证关联系统不同的返回对被测对象的影响，需要mock关联系统的返回一个例子\n\n被测对象从关联接口获得用户信息\n在关联接口开发完成之前，只能使用mock来模拟关联接口的返回，完成对被测对象的测试\n\n1234567891011121314151617181920212223242526272829303132import unittestimport requestsfrom unittest import TestCasefrom unittest.mock import patchclass User(object):    def get_user_info(uid):        resp = requests.get(\"http://api.server.com/user/{0}\".format(uid))        return resp.json()class TestUserInfo(TestCase):    @patch('__main__.User')    def test_user_name(self, MockUser):        user = MockUser()        user.get_user_info.return_value = {            \"user_id\": 1,            \"name\": \"python\",            \"age\": 20        }        resp = user.get_user_info(1)        self.assertEqual(resp.get(\"name\"), \"python\")        self.assertEqual(resp.get(\"age\"), 20)if __name__ == '__main__':    unittest.main()# ----------------------------------------------------------------------# Ran 1 test in 0.001simport unittestimport requestsfrom unittest import TestCasefrom unittest.mock import patchclass User(object):    def get_user_info(uid):        resp = requests.get(\"http://api.server.com/user/{0}\".format(uid))        return resp.json()class TestUserInfo(TestCase):    @patch('__main__.User')    def test_user_name(self, MockUser):        user = MockUser()        user.get_user_info.return_value = {            \"user_id\": 1,            \"name\": \"python\",            \"age\": 20        }        resp = user.get_user_info(1)        self.assertEqual(resp.get(\"name\"), \"python\")        self.assertEqual(resp.get(\"age\"), 20)if __name__ == '__main__':    unittest.main()# ----------------------------------------------------------------------# Ran 1 test in 0.001s# OK\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import unittestfrom unittest.mock import MagicMock# 将要测试的排序函数def sort(arr):    l = len(arr)    for i in range(0, l):        for j in range(i + 1, l):            if arr[i] &gt;= arr[j]:                tmp = arr[i]                arr[i] = arr[j]                arr[j] = tmp# 单元测试class TestSort(unittest.TestCase):    # 以test开头的函数会被测试    def test_sort(self):        arr = [3, 4, 1, 5, 6]        sort(arr)        self.assertEqual(arr, [1, 3, 4, 5, 6])# mockclass A(unittest.TestCase):    def m1(self):        val = self.m2()        self.m3(val)    def m2(self):        pass    def m3(self, val):        pass    def test_m1(self):        a = A()        a.m2 = MagicMock(return_value=\"custom_val\")        a.m3 = MagicMock()        a.m1()        self.assertTrue(a.m2.called)        a.m3.assert_called_with(\"custom_val\")def side_effect(arg):    if arg &lt; 0:        return 1    else:        return 2if __name__ == \"__main__\":    unittest.main()    mock = MagicMock()    mock.side_effect = side_effect    print(mock(1))    print(mock(import unittestfrom unittest.mock import MagicMock# 将要测试的排序函数def sort(arr):    l = len(arr)    for i in range(0, l):        for j in range(i + 1, l):            if arr[i] &gt;= arr[j]:                tmp = arr[i]                arr[i] = arr[j]                arr[j] = tmp# 单元测试class TestSort(unittest.TestCase):    # 以test开头的函数会被测试    def test_sort(self):        arr = [3, 4, 1, 5, 6]        sort(arr)        self.assertEqual(arr, [1, 3, 4, 5, 6])# mockclass A(unittest.TestCase):    def m1(self):        val = self.m2()        self.m3(val)    def m2(self):        pass    def m3(self, val):        pass    def test_m1(self):        a = A()        a.m2 = MagicMock(return_value=\"custom_val\")        a.m3 = MagicMock()        a.m1()        self.assertTrue(a.m2.called)        a.m3.assert_called_with(\"custom_val\")def side_effect(arg):    if arg &lt; 0:        return 1    else:        return 2if __name__ == \"__main__\":    unittest.main()    mock = MagicMock()    mock.side_effect = side_effect    print(mock(1))    print(mock(-2))\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/sql/","content":"mysql命令行中执行多行命令时，如果前边输入的命令发生错误，通过\\c来取消当前的命令，重新进入“mysql-&gt;”提示符\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215```\\q```退出mysql```\\h```帮助信息```\\d```改变执行符号```\\s```显示服务器状态### 整数类型范围1，tinyint类型占用的字节最小，表示1字节整数。取值范围也是最小的。2，smalllint类，表示2个字节整数。3，mediumint类型占用的字节最大，表示3字节整数。4，int类型，表示4字节整数，和integer类型的字节数和取值范围是一样的，5，bigint类型占用的字节最大，表示8字节整数。气质范围是最大的。属性 字段约束任何整数类型后面都可以加一个```unsigned```属性，表示数据是无符号的，即非负整数。用此类型可以增加数据长度。例如如果tinyint最大是127，那tinyint unsigned最大就可以到127 * 2。例如：int类型的整数，有符号值：-128到127，无符号值：0到255。不同类型的整数类型的字节数不同，根据类型所占的字节数可以算出该类型的取值范围。比如intyint的空间是一个字节，一个字节是8位。那么tinyint无符号数的最大值就是2的8次-1，也就是255。tinyint有符号数的最大值就是2的7次-1，也就是127。defaultzerofill。该属性参数表示数字不足的显示空间由0来填补。使用zerofill参数时，MySQL会自动加上unsinged属性。那么该整数类型只能表示无符号数，其显示宽度比默认宽度小1。默认没有零填充整数类型还有一个auto_increment属性，该属性可是使字段成为自增字段，具有该属性的字段，在插入新的记录时，该字段的值都会在前一条记录的基础上1。所以这个时候就不用人为的设值了呢，一般用来主键的设置上该属性。主键约束PRIMARY KEY(字段名)，自带索引，不能为null，不能重复为表加上一个列用来存储唯一标志即主键列建议用数字类型，检索速度快，加上auoto_increment自增长非空约束 not null唯一约束 unique 可以为NULL，如果不为NULL，必须唯一外键约束 foreign key （子表字段名）reference 父表名(字段名) 保持关联数据的逻辑性MySQL中显示的字段名是：外键属性名_id。数据类型参数是整数数据类型的名称定义后面Length字段，并不是指的数值范围，而是指数据库里面可见的最大数据的长度。int(5)就是指定int类型的显示字符的长度是5，始终是4个字节，可以存1234INT(11)表示长度为11的INT类型，对大多数应用是没有意义的,它不会限制值的合法范围,只会影响显示字符的个数，只是当定义了UNSIGNED ZEROFILL属性配合使用才有意义。```int(3) zerofill```自动填充0，可以存1234，012```int(5) zerofill```自动填充0，可以存01234，00012假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。### 实数类型DECIMAL可存储比 BIGINT还大的整数，存储精确的小数FLOAT和 DOUBLE 是有取值范围的，支持使用标准的浮点进行近似计算FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。### 字符串类型VARCHAR、CHAR、TEXT、BLOBVARCHAR类型用于存储可变长字符串,它比定长类型更节省空间VARCHAR使用1或2个额外字节记录字符串的长度,列长度小于255字节,使用1个字节表示,否则用2个内部存储varchar是存入的实际字符数+1个字节（n255)，VARCHAR长度，如果存储内容超出指定长度，会被截断VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留CHAR是定长的，根据定义的字符串长度分配足够的空间CHAR会根据需要采用空格进行填充以方便比较CHAR适合存储很短的字符串,或者所有值都接近同一个长度CHAR存储的内容超出设置的长度时，内容同样会被截断。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，对于经常变更的数据,CHAR比 VARCHAR更好,CHAR不容易产生碎片对于非常短的列,CHAR比 VARCHAR在存储空间上更有效率只分配真正需要的空间,更长的列会消耗更多的内存定义一个CHAR[10]和VARCHAR[10],如果存进去的是‘ABCD’, char(10)不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充，除了字符‘ABCD’外，后面跟六个空格，而varchar(50)中50的含义是最多存放50个字符，VARCHAR的长度变为4了，取数据的时候，CHAR类型的要用trim()去掉多余的空格，而VARCHAR类型是不需要的。char(16)表示固定长度字符串，长度为16、varchar(16)表示可变长度字符串，长度为16、text表示字符串类型，内部存储text是实际字符数+2个字节。能存储大字符串，最多存储65535字节数据尽量避免使用BLOB/TEXT类型，查询会使用临时表,导致严重的性能开销。请说明varchar和text的区别varchar可指定字符数，text不能指定，text类型不能有默认值。varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text，在都创建索引的情况下，text的索引几乎不起作用。### 枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数枚举表会使表大小大大减小### 日期和时间类型尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。```SELECT CURRENT_DATE();```获取当前日期InnoDB表引擎，默认事务型引擎数据存储在共享表空间,可以通过配置分开，也就是多个表和索引都存储在一个表空间中，可以通过配置文件改变此配置。对主键查询的性能高于其他类型的存储引擎内部做了很多优化,从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区通过一些机制和工具支持真正的热备份支持崩溃后的安全恢复支持事务 提供了对数据库ACID事务的支持；支持行级锁和表锁支持外键不支持全文索引插入缓冲（insert buffer)二次写(double write)自适应哈希索引(ahi)预读(read ahead)没有保存表的行数MyISAM表引擎表存储在两个文件,MYD和MYI拥有全文索引、压缩、空间函数不支持事务和行级锁和外键,不支持崩溃后的安全恢复存储了表的行数只支持表锁设计简单,某些场景下性能很好，例如获取整个表有多少条数据，性能很高。全文索引不是很常用，不如使用外部的ElasticSearch或Lucene。其他表引擎Archive、 Blackhole、CSV、Memory### 锁机制表锁是日常开发当中常见的问题,因此也是面试当中最常见的考察点,当多个查询同一时刻进行数据修改时,就会产生并发控制的问题#### 共享锁和排他锁,其实就是读锁和写锁读锁：共享的，不堵塞，多个用户可以同时读一个资源，互不干扰。写锁：排他的，一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。#### 锁粒度行锁，最大程度的支持并发处理，但是也带来了最大的锁开销表锁，系统性能开销最小，会锁定整张表，MyIsam使用表锁。### 存储过程为以后的使用而保存的一条或多条 MySQL语句的集合存储过程就是有业务逻辑和流程的集合可以在存储过程中创建表，更新数据，删除等等使用场景：通过把处理封装在容易使用的单元中，简化复杂的操作保证数据的一致性简化对变动的管理### 触发器是指一段代码，当触发某个事件时，自动执行这些代码。提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程使用场景可通过数据库中的相关表实现级联更改实时监控某张表中的某个字段的更改而需要做出相应的处理某些业务编号的生成等滥用会造成数据库及应用程序的维护困难在MySQL数据库中有如下六种1、Before Insert2、After Insert3、Before Update4、After Update5、Before Delete6、After Delete十进制的浮点数转换从二进制的浮点数会丢失数据IP 该如何保存?最简单的办法是使用字符串（varchar）来保存，如果从效率考虑的话，可以将ip 保存为整型（unsigned int），使用 mysql 提供的函数将 ip 转换为整型，然后存储即可。MySQL 函数：inet_aton()和 inet_ntoa解题方法对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。请简述项目中优化SQL语句执行效率的方法，从哪些方面，SQL语句性能如何分析？考点分析：SQL语句查询速度慢的方法延伸考点：优化查询过程中的数据访问优化长难的查询语句优化特定类型的查询语句排查查询速度慢的原因1. 开启并且查询慢查询日志，慢查询通常是缺少索引，索引不合理或者业务代码实现导致开启慢查询功能slow_query_log_file 慢查询日志文件路径slow_query_log 用于指定是否打开慢查询日志long_query_time 超过多少秒的查询就写入日志2. 调整数据修改索引；业务代码层限制不合理访问，如：因为数据类型不匹配导致全表扫描；一次获取太多数据等查找分析查询速度慢的原因1. 记录慢查询日志。分析查询日志，不要直接打开慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析如何排查慢查询？ 2. 使用show profile，通过临时表的主键ID去查一条sql语句是在什么地方发生慢的操作。```sqlset profiling=1; # 开启，服务器上所有执行语句会记录执行时间，存到临时表中mysql> show profiles; # 查看临时表+----------+------------+-------------------+| Query_ID | Duration   | Query             |+----------+------------+-------------------+|        1 | 0.00315025 | SELECT DATABASE() ||        2 | 0.04271325 | select * from a   |+----------+------------+-------------------+2 rows in set, 1 warning (0.00 sec)\n\nshow profile for query 临时表ID，通过临时表的主键ID去查一条sql语句是在什么地方发生慢的操作。\n123456789101112131415161718192021mysql&gt; show profile for query 2;+----------------------+----------+| Status               | Duration |+----------------------+----------+| starting             | 0.001101 || checking permissions | 0.000016 || Opening tables       | 0.037732 || init                 | 0.000040 || System lock          | 0.000021 || optimizing           | 0.000006 || statistics           | 0.002043 || preparing            | 0.000025 || executing            | 0.000003 || Sending data         | 0.001608 || end                  | 0.000006 || query end            | 0.000007 || closing tables       | 0.000013 || freeing items        | 0.000071 || cleaning up          | 0.000022 |+----------------------+----------+15 rows in set, 1 warning (mysql&gt; show profile for query 2;+----------------------+----------+| Status               | Duration |+----------------------+----------+| starting             | 0.001101 || checking permissions | 0.000016 || Opening tables       | 0.037732 || init                 | 0.000040 || System lock          | 0.000021 || optimizing           | 0.000006 || statistics           | 0.002043 || preparing            | 0.000025 || executing            | 0.000003 || Sending data         | 0.001608 || end                  | 0.000006 || query end            | 0.000007 || closing tables       | 0.000013 || freeing items        | 0.000071 || cleaning up          | 0.000022 |+----------------------+----------+15 rows in set, 1 warning (0.00 sec)\n\n\n使用show statusshow status会返回一些计数器，show global status会查看所有服务器级别的所有计数有时根据这些计数，可以推测出哪些操作代价较高或者消耗时间多\n\nshow processlist\n1234567mysql&gt; show processlist;+----+------+-----------------+------+---------+------+----------+------------------+| Id | User | Host            | db   | Command | Time | State    | Info             |+----+------+-----------------+------+---------+------+----------+------------------+|  3 | root | localhost:14778 | test | Query   |    0 | starting | show processlist |+----+------+-----------------+------+---------+------+----------+------------------+1 row in set (mysql&gt; show processlist;+----+------+-----------------+------+---------+------+----------+------------------+| Id | User | Host            | db   | Command | Time | State    | Info             |+----+------+-----------------+------+---------+------+----------+------------------+|  3 | root | localhost:14778 | test | Query   |    0 | starting | show processlist |+----+------+-----------------+------+---------+------+----------+------------------+1 row in set (0.01 sec)\n观察是否有大量线程处于不正常的状态或特征\n\n使用explain 分析单条SQL语句、排查索引问题，注意格式化 \\G 输出后不需要加分号。\n1234567mysql&gt; explain select * from a;+----+-------------+-------+------------+------+---------------+------+---------+| id | select_type | table | partitions | type | possible_keys | key  | key_len |+----+-------------+-------+------------+------+---------------+------+---------+|  1 | SIMPLE      | a     | NULL       | ALL  | NULL          | NULL | NULL    |+----+-------------+-------+------------+------+---------------+------+---------+1 row in set, 1 warning (mysql&gt; explain select * from a;+----+-------------+-------+------------+------+---------------+------+---------+| id | select_type | table | partitions | type | possible_keys | key  | key_len |+----+-------------+-------+------------+------+---------------+------+---------+|  1 | SIMPLE      | a     | NULL       | ALL  | NULL          | NULL | NULL    |+----+-------------+-------+------------+------+---------------+------+---------+1 row in set, 1 warning (0.00 sec)\n\n\n\n123456789101112131415mysql&gt; explain select * from a\\G  -- 注意:格式化输出内容，\\G相当于;*************************** 1. row **********           id: 1  select_type: SIMPLE        table: a   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 2     filtered: 100.00        Extra: NULL1 row in set, 1 warning (mysql&gt; explain select * from a\\G  -- 注意:格式化输出内容，\\G相当于;*************************** 1. row **********           id: 1  select_type: SIMPLE        table: a   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 2     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)\n\n\n优化查询过程中的数据访问访问数据太多导致查询性能下降确定应用程序是否在检索大量超过需要的数据，可能是太多行或列确认MySQL服务器是否在分析大量不必要的数据行避免犯如下SQL语句错误查询不需要的数据。解决办法：使用limit解决多表关联返回全部列。解决办法：指定列名总是返回全部列。解决办法：避免使用 SELECT *重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存是否在扫描额外的记录。解决办法：使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。改变数据库和表的结构，修改数据表范式重写SQL语句，让优化器可以以更优的方式执行查询。\n优化长难的查询语句一个复杂查询还是多个简单查询MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。切分查询将一个大的查询分为多个小的相同的查询一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。\n分解关联查询，将一条关联语句分解成多条SQL来执行让缓存的效率更高。执行单个查询可以减少锁的竞争。在应用层做关联更容易对数据库进行拆分。查询效率会有大幅提升。较少冗余记录的查询。\n优化特定类型的查询语句count(列名) 返回指定列的值的数目，包含非空值的记录数会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，&nbsp;即某个字段值为NULL时，不统计。count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即&nbsp;不统计字段为null 的记录。&nbsp;&nbsp;count(*)会忽略所有的列，直接统计所有列数，相当于行数，不会忽略列值为NULL&nbsp;&nbsp;比count(列名)效率高\n返回表中包含空值的记录数count(1) 会统计表中的所有的记录数，包含字段为null 的记录包括了忽略所有列，用1代表代码行，COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目、不重复的记录条数\nGROUP BY product_typeHAVING count(*) &gt; 1 #分组内的化为一行的数量\nMyISAM中，没有任何where条件的count()非常快。当有where条件时，MyISAM的count统计不一定比其它引擎快。可以使用explain查询近似值，用近似值替代count()增加汇总表使用缓存\n优化GROUP BY和DISTINCT这两种查询据可以使用索引来优化，是最有效的优化方法关联查询中，使用标识列分组的效率更高如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。WITH ROLLUP超级聚合，可以挪到应用程序处理\n优化LIMIT分页LIMIT偏移量大的时候，查询效率较低可以记录上次查询的最大ID，下次查询时直接根据该ID来查询\n常规sql优化思路（众多解决方案之一）1、查看slow-log，分析slow-log，分析出查询慢的语句。2、按照一定优先级，进行一个一个的排查所有慢语句。3、分析top sql，进行explain调试，查看语句执行时间。4、调整索引或语句本身。\nSQL语句优化的一些方法？1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n1select id from t where num is select id from t where num is null\n可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\n1select id from t where select id from t where num=\n3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\n1select id from t where num=10 or num=select id from t where num=10 or num=20\n可以这样查询：\n1234select id from t where num=10 union all select id from t where num=select id from t where num=10 union all select id from t where num=20\n\n5.in 和 not in 也要慎用，否则会导致全表扫描，如：\n1select id from t where num in(1,2,select id from t where num in(1,2,3) \n对于连续的数值，能用 between 就不要用 in 了：\n1select id from t where num between 1 and select id from t where num between 1 and 3\n\n6.下面的查询也将导致全表扫描：\n1select id from t where name like select id from t where name like '%李%'\n若要提高效率，可以考虑全文检索。\n\n如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：1select id from t where num=@select id from t where num=@num\n可以改为强制查询使用索引：1select id from t with(index(索引名)) where num=@select id from t with(index(索引名)) where num=@num\n\n\n\n8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n1select id from t where num/2=select id from t where num/2=100\n应改为:\n1select id from t where num=100*select id from t where num=100*2\n\n9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n1select id from t where substring(name,1,3)=select id from t where substring(name,1,3)='abc'\nname以abc开头的id应改为:\n1select id from t where name like select id from t where name like 'abc%'\n\n10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n分区表的工作原理对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。\n如图所示：MySQL将表分成多个物理字表，但PHP客户端并无感知，仍然认为操作的是一个表。\n创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有需要的数据的分区，这样只需要查询数据所在分区即可。\n这样子表相对于未分区的表来说占用空间小，数据量更小，因此操作速度更快。\n分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性的删除整个分区的数据也和方便。\n适用场景1、表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据。2、分区表的数据更易维护，可以对独立的分区进行独立的操作。3、分区表的数据可以分布在不同的机器上，从而高效适用资源。4、可以使用分区表来避免某些特殊的瓶颈5、可以备份和恢复独立的分区限制1、一个表最多只能有1024个分区2、5.1版本中，分区表表达式必须是整数，5.5可以使用列分区3、分区表字段如果有主键和唯一索引列，那么主键列和唯一索引列都必须包含进来4、分区表中无法使用外键约束5、需要对现有表的结构进行修改6、所有分区都必须使用相同的存储引擎7、分区函数中可以使用的函数和表达式会有一些限制8、某些存储引擎不支持分区9、对于MyISAM的分区表，不能使用load index into cache10、对于MyISAM表，使用分区表时需要打开更多的文件描述符\n分库分表的工作原理通过一些HASH算法或者工具实现将一张数据表垂直或者水平进行物理切分适用场景1、单表记录条数达到百万或千万级别时2、解决表锁的问题分表方式水平分割：表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数\n适用场景1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。2、需要把数据存放在多个介质上。\n水平切分的缺点1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数\n垂直分表把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中适用场景1、如果一个表中某些列常用，另外一些列不常用2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数垂直分表缺点管理冗余列，查询所有数据需要join操作\n分表缺点有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差对于应用层来说，逻辑算法增加开发成本\nMySQL的复制原理及负载均衡MySQL主从复制工作原理在主库上把数据更高记录到二进制日志从库将主库的日志复制到自己的中继日志从库读取中继日志的事件，将其重放到从库数据中\nMySQL主从复制解决的问题数据分布：随意开始或停止复制，并在不同地理位置分布数据备份负载均衡：降低单个服务器的压力高可用和故障切换：帮助应用程序避免单点失败升级测试：可以用更高版本的MySQL作为从库\n解题方法充分掌握分区分表的工作原理和适用场景，在面试中，此类题通常比较灵活，会给一些现有公司遇到问题的场景，大家可以根据分区分表，MySQL复制、负载均衡的适用场景来根据情况进行回答\n问:28：设定网站用户数量在千万级，但是活跃用户数量只有1%，如何通过优化数据库提高活跃用户访问速度？可以使用MySQL的分区，把活跃用户分在一个区，不活跃用户分在另外一个区，本身活跃用户区数据量比较少，因此可以提高活跃用户访问速度。还可以水平分表，把活跃用户分在一张表，不活跃用户分在另一张表，可以提高活跃用户访问速度。\n常见的web安全问题,原理和防范措施。安全意识◆SQL注入◆XSS(跨站脚本攻击, Cross-Site Scripting)◆CSRF(跨站请求伪造, Cross- site request forgery)\nweb 安全一大原则：永远不要相信用户的任何输入对输入参数做好检查(类型和范围)；过滤和转义特殊字符不要直接拼接sql，使用ORM 有安全性考虑，通过传参的形式不会有 sql 注入问题，查询错误信息不要返回给用户，将错误记录到日志，不要明文存储敏感信息。1、定期做数据备份2、不给查询用户root权限，合理分配权限3、关闭远程访问数据库权限4、修改root口令，不用默认口令，使用较复杂的口令5、删除多余的用户6、改变root用户的名称7、限制一般用户浏览其它库8、限制用户对数据文件的访问权限\n问题29：SQL语句应该考虑哪些安全性？SQL查询的安全方案、MySQL的其它安全设置解题方法SQL安全的优先考虑SQL注入的防护手段。\nsql语句是解释性语言，SQL注入的关键是单引号的闭合，\n\n通过构造特殊的输入参数传入Web应用，\n通常由于程序员未对输入过滤，直接动态拼接 SQL 产生\n可以使用开源工具 sqlmap，SQLninja 检测\n\nSQL注入（SQLi）是一种注入攻击，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。\n1、使用预处理语句防止SQL注入，\n12345678910111213141516171819delete from user where id = ?```  SQL注入代码演示示例    1）创建users表和插入相应信息```sql --  创建users数据表CREATE TABLE `users`(    `id` INT NOT NULL AUTO_INCREMENT,    `name` VARCHAR(45) NULL,    `email` VARCHAR(45) NULL,    `password` VARCHAR(45) NULL,    PRIMARY KEY (`id`));  -- 插入users表三条数据insert into users (name,email,password) values ('zhangsan','zhangsan@qq.com',md5('zhangsan123'));insert into users (name,email,password) values ('lisi','lisi@qq.com',md5('lisi123'));insert into users (name,email,password) values ('wangwu','wangwu@qq.com',md5(delete from user where id = ?```  SQL注入代码演示示例    1）创建users表和插入相应信息```sql --  创建users数据表CREATE TABLE `users`(    `id` INT NOT NULL AUTO_INCREMENT,    `name` VARCHAR(45) NULL,    `email` VARCHAR(45) NULL,    `password` VARCHAR(45) NULL,    PRIMARY KEY (`id`));  -- 插入users表三条数据insert into users (name,email,password) values ('zhangsan','zhangsan@qq.com',md5('zhangsan123'));insert into users (name,email,password) values ('lisi','lisi@qq.com',md5('lisi123'));insert into users (name,email,password) values ('wangwu','wangwu@qq.com',md5('wangwu123'));\n\n 2） 存在SQL漏洞代码示例：在终端下输入名称和密码然后查询用户信息\n1234567891011121314151617181920212223242526# sql 注入演示代码 sql_inject_demo.pyimport osimport MySQLdb   # pip install mysqlclient # 新建数据库链接db = MySQLdb.connect(    host='localhost',    user='root',    passwd='123456',    db='test')cur = db.cursor() name = input('Enter name: ')print('您输入的用户name是: {}'.format(name))password = input('Enter password：')print('您输入的密码是: {}'.format(password))# 直接拼接 sql 参数,使用md5的 passwordsql = \"SELECT * FROM users WHERE name='\" + name + \"'\"+\"AND password=md5('\" + password + \"')\"print(sql)cur.execute(sql)for row in cur.fetchall():    print('查询结果：', row)# sql 注入演示代码 sql_inject_demo.pyimport osimport MySQLdb   # pip install mysqlclient # 新建数据库链接db = MySQLdb.connect(    host='localhost',    user='root',    passwd='123456',    db='test')cur = db.cursor() name = input('Enter name: ')print('您输入的用户name是: {}'.format(name))password = input('Enter password：')print('您输入的密码是: {}'.format(password))# 直接拼接 sql 参数,使用md5的 passwordsql = \"SELECT * FROM users WHERE name='\" + name + \"'\"+\"AND password=md5('\" + password + \"')\"print(sql)cur.execute(sql)for row in cur.fetchall():    print('查询结果：', row)# 关闭连接db.close()\n\n 3）SQL注入演示结果运行后再终端输入\n1234567## 输入正确的用户名和密码Enter name: lisi您输入的用户name是: lisiEnter password：lisi123您输入的密码是: lisi123SELECT * FROM users WHERE name='lisi'AND password=md5('lisi123')查询结果：(2, 'lisi', 'lisi@qq.com', 'c3cb6d12c40908943b64bc0681af47db')\n\n12345678910111213141516171819# 输出错误密码Enter name: lisi您输入的用户name是: lisiEnter password：1234您输入的密码是: 1234SELECT * FROM users WHERE name='lisi'AND password=md5('1234')# 没有返回查询结果用户信息的一行，说明密码不正确```~```~shell# 因为代码有sql注入漏洞，在用户名后面加入中线，这里还输错误密码，Enter name: lisi' -- '   # -- 中线前后都有空格，中线在sql语句中表示注释意思您输入的用户name是: lisi' -- 'Enter password：123456 您输入的密码是: 123456SELECT * FROM users WHERE name='lisi' -- ''AND password=md5('123456')查询结果：(2, 'lisi', 'lisi@qq.com', 'c3cb6d12c40908943b64bc0681af47db')# 还是返回查询结果，这里就是通过SQL注入方式绕过网站的安全验证## 输出错误密码Enter name: lisi您输入的用户name是: lisiEnter password：1234您输入的密码是: 1234SELECT * FROM users WHERE name='lisi'AND password=md5('1234')# 没有返回查询结果用户信息的一行，说明密码不正确```~```~shell# 因为代码有sql注入漏洞，在用户名后面加入中线，这里还输错误密码，Enter name: lisi' -- '   # -- 中线前后都有空格，中线在sql语句中表示注释意思您输入的用户name是: lisi' -- 'Enter password：123456 您输入的密码是: 123456SELECT * FROM users WHERE name='lisi' -- ''AND password=md5('123456')查询结果：(2, 'lisi', 'lisi@qq.com', 'c3cb6d12c40908943b64bc0681af47db')# 还是返回查询结果，这里就是通过SQL注入方式绕过网站的安全验证# --后面的部分当作注释，不起作用\n\n4）怎么修复sql注入问题，其实只要把使用拼接的地方直接换成占位符就可以\n1234# 只需要修改成以下方式sql = \"SELECT * from users WHERE name=%s and password=md5(%s)\"print(sql)cur.execute(sql, (name, password)) # 只需要修改成以下方式sql = \"SELECT * from users WHERE name=%s and password=md5(%s)\"print(sql)cur.execute(sql, (name, password)) # execute它会自动执行转义操作\n\n123456Enter name: lisi' -- '您输入的用户name是: lisi' -- 'Enter password：123456您输入的密码是: 123456SELECT * from users WHERE name=%s and password=md5(%s)#Enter name: lisi' -- '您输入的用户name是: lisi' -- 'Enter password：123456您输入的密码是: 123456SELECT * from users WHERE name=%s and password=md5(%s)# 没有返回查询结果用户信息的一行，说明密码不正确，并没有像上面的一样绕过安全验证\n\n数据库的三大范式：第一范式:  每一列都不可以再拆分；第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不是主键的一部分。第三范式：在第二范式的基础上，非主键完全依赖于主键，而不是其他的非主键。关联性，每列都与主键有直接关系,不存在传递依赖\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["剑指offer","Leetcode"]},{"title":"实现同步登录及退出实现步骤","url":"https://bubbleboy11.github.io/2020/08/21/shi-xian-tong-bu-deng-lu-ji-tui-chu-shi-xian-bu-zou/","content":"实现同步登录及退出实现步骤\n第一步，准备登录的Django模板、表单新建accounts\\templates12345678910111213141516```html    用户的基本信息      当前登录的用户是：{{ user.username }}-{{ user.email }}    {% if user.is_authenticated %}  退出登录  {% endif %}\n\n\n\n123456789101112131415161718192021222324252627282930313233343536```html    用户登录      .errorlist {      color: #f00;    }    用户登录      {% csrf_token %}{#    {{ form.as_p }}#}                {{ form.username.label }}      {{ form.username }}      {{ form.username.errors.as_text }}                    {{ form.password.label }}      {{ form.password }}      {{ form.password.errors.as_text }}              {{ form.non_field_errors.as_text }}          \n\naccounts\\forms.py\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import refrom django import formsfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码', max_length=200, min_length=6,                               widget=forms.PasswordInput)    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username, ))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data['username']        password = data['password']        # username = data.get('username', None)        # password = data.get('password', None)        if username and password:            # 查询用户名和密码匹配的用户            user_list = User.objects.filter(username=username)            err_list = []            if user_list.count() == 0:                err_list.append(forms.ValidationError('用户名不存在'))                # raise forms.ValidationError('用户名不存在')            # 验证密码是否正确            # TODO 使用加密算法进行验证            if not user_list.filter(password=password).exists():                # raise forms.ValidationError('密码不正确')                err_list.append(forms.ValidationError('密码不正确'))            if err_list:                raise forms.ValidationError(err_list)        import refrom django import formsfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码', max_length=200, min_length=6,                               widget=forms.PasswordInput)    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username, ))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data['username']        password = data['password']        # username = data.get('username', None)        # password = data.get('password', None)        if username and password:            # 查询用户名和密码匹配的用户            user_list = User.objects.filter(username=username)            err_list = []            if user_list.count() == 0:                err_list.append(forms.ValidationError('用户名不存在'))                # raise forms.ValidationError('用户名不存在')            # 验证密码是否正确            # TODO 使用加密算法进行验证            if not user_list.filter(password=password).exists():                # raise forms.ValidationError('密码不正确')                err_list.append(forms.ValidationError('密码不正确'))            if err_list:                raise forms.ValidationError(err_list)        return data\n\naccounts\\views.py\n123456789101112131415161718192021222324252627282930from django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom accounts.forms import LoginFormdef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# @login_required(login_url='/accounts/user/login/')@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, from django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom accounts.forms import LoginFormdef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# @login_required(login_url='/accounts/user/login/')@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, 'user_info.html')\n\naccounts\\urls.py\n123456789from django.urls import pathfrom accounts import viewsurlpatterns = [    # 用户登录表单    path('user/login/', views.user_login, name='user_login'),    path('user/info/', views.user_info, name=from django.urls import pathfrom accounts import viewsurlpatterns = [    # 用户登录表单    path('user/login/', views.user_login, name='user_login'),    path('user/info/', views.user_info, name='user_info'),]\n\ntrip\\urls.py\n12345urlpatterns = [    path('admin/', admin.site.urls),    # 用户账户模块    path('accounts/', include(urlpatterns = [    path('admin/', admin.site.urls),    # 用户账户模块    path('accounts/', include('accounts.urls')),]\n\n\n第二步，设计用户模型accounts\\models.py\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Profile(models.Model):    \"\"\" 用户详细信息 \"\"\"    # 性别    # 手机号码    # 年龄    # 生日    # 真实姓名    SEX_CHOICES = (        (1, '男'),        (0, '女'),    )    username = models.CharField('用户名', max_length=64, unique=True, editable=False)    user = models.OneToOneField(User, related_name='profile', on_delete=models.CASCADE)    real_name = models.CharField('真实姓名', max_length=32)    email = models.CharField('电子邮箱', max_length=128, null=True, blank=True)    is_email_valid = models.BooleanField('邮箱是否已经验证', default=False)    phone_no = models.CharField('手机号码', max_length=20, null=True, blank=True)    is_phone_valid = models.BooleanField('是否已经验证', default=False)    sex = models.SmallIntegerField('性别', default=1, choices=SEX_CHOICES)    age = models.SmallIntegerField('年龄', default=0)    source = models.CharField('登录的来源', max_length=16, null=True)    version = models.CharField('登录的版本', max_length=16, null=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table = 'accounts_user_profile'class LoginRecord(models.Model):    \"\"\" 用户登录日志 \"\"\"    # 关联用户    # 登录账号    # 登录的时间    # ip    # 登录的来源    # 登录的客户端版本号    user = models.ForeignKey(User, related_name='login_records', on_delete=models.CASCADE)    username = models.CharField('登录的账号', max_length=64)    ip = models.CharField('IP', max_length=32)    address = models.CharField('地址', max_length=32, null=True, blank=True)    source = models.CharField('登录的来源', max_length=16, null=True)    version = models.CharField('登录的版本', max_length=16, null=True)    created_at = models.DateTimeField('登录时间', auto_now_add=True)    class Meta:        db_table = class Profile(models.Model):    \"\"\" 用户详细信息 \"\"\"    # 性别    # 手机号码    # 年龄    # 生日    # 真实姓名    SEX_CHOICES = (        (1, '男'),        (0, '女'),    )    username = models.CharField('用户名', max_length=64, unique=True, editable=False)    user = models.OneToOneField(User, related_name='profile', on_delete=models.CASCADE)    real_name = models.CharField('真实姓名', max_length=32)    email = models.CharField('电子邮箱', max_length=128, null=True, blank=True)    is_email_valid = models.BooleanField('邮箱是否已经验证', default=False)    phone_no = models.CharField('手机号码', max_length=20, null=True, blank=True)    is_phone_valid = models.BooleanField('是否已经验证', default=False)    sex = models.SmallIntegerField('性别', default=1, choices=SEX_CHOICES)    age = models.SmallIntegerField('年龄', default=0)    source = models.CharField('登录的来源', max_length=16, null=True)    version = models.CharField('登录的版本', max_length=16, null=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        db_table = 'accounts_user_profile'class LoginRecord(models.Model):    \"\"\" 用户登录日志 \"\"\"    # 关联用户    # 登录账号    # 登录的时间    # ip    # 登录的来源    # 登录的客户端版本号    user = models.ForeignKey(User, related_name='login_records', on_delete=models.CASCADE)    username = models.CharField('登录的账号', max_length=64)    ip = models.CharField('IP', max_length=32)    address = models.CharField('地址', max_length=32, null=True, blank=True)    source = models.CharField('登录的来源', max_length=16, null=True)    version = models.CharField('登录的版本', max_length=16, null=True)    created_at = models.DateTimeField('登录时间', auto_now_add=True)    class Meta:        db_table = 'accounts_login_record'\n123>python manage.py check>python manage.py makemigrations>python manage.py migrate  \n\n第三步，实现用户的同步登录\n\n第四步，添加登录拦截，用户登录了可以看用户信息，没登陆看用户信息先登录\n\n第五步，实现退出登录的功能用户登录\n\n步骤一：认证用户user = authenticate(username='john', password='secret')accounts\\forms.py\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.utils.timezone import nowfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码',                               max_length=200,                               min_length=6,                               widget=forms.PasswordInput)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data.get('username', None)        password = data.get('password', None)        user = authenticate(username=username, password=password)        if not user:            raise forms.ValidationError('用户名或者是密码不正确')        else:            if not user.is_active:                raise forms.ValidationError('该用户已经被禁用')        self.user = user        import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.utils.timezone import nowfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码',                               max_length=200,                               min_length=6,                               widget=forms.PasswordInput)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data.get('username', None)        password = data.get('password', None)        user = authenticate(username=username, password=password)        if not user:            raise forms.ValidationError('用户名或者是密码不正确')        else:            if not user.is_active:                raise forms.ValidationError('该用户已经被禁用')        self.user = user        return data\n\n步骤二：判断认证后的用户是否为None用户不为None则表示用户认证通过\n\n步骤三：调用login(request, user, backend=None)函数登录用户accounts\\forms.py\n1234567891011121314151617181920212223242526272829import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.utils.timezone import nowfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名')    password = forms.CharField(label='密码')    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def do_login(self, request):        \"\"\" 执行用户登录 \"\"\"        user = self.user        # 调用登录        login(request, user)        # 修改最后登录的时间        user.last_login = now()        user.save()        # TODO 保存登录历史        import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.utils.timezone import nowfrom accounts.models import Userclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名')    password = forms.CharField(label='密码')    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def do_login(self, request):        \"\"\" 执行用户登录 \"\"\"        user = self.user        # 调用登录        login(request, user)        # 修改最后登录的时间        user.last_login = now()        user.save()        # TODO 保存登录历史        return user\n\n\n\naccounts/views.py\n12345678910111213141516171819202122232425262728293031323334from django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom accounts.forms import LoginFormdef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# 需要登录以后才能访问user_info，# 否则跳转到登录地址http://127.0.0.1:8000/accounts/user/login/?next=/accounts/user/info/# 方式一# @login_required(login_url='/accounts/user/login/')# 方式二  trip/settings.py加上LOGIN_URL = '/accounts/user/login/'@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, from django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom accounts.forms import LoginFormdef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# 需要登录以后才能访问user_info，# 否则跳转到登录地址http://127.0.0.1:8000/accounts/user/login/?next=/accounts/user/info/# 方式一# @login_required(login_url='/accounts/user/login/')# 方式二  trip/settings.py加上LOGIN_URL = '/accounts/user/login/'@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, 'user_info.html')\n\ntrip/settings.py\n1LOGIN_URL = LOGIN_URL = '/accounts/user/login/'\n\naccounts/urls.py\n12345urlpatterns = [    # 用户登录表单    path('user/login/', views.user_login, name='user_login'),    path('user/info/', views.user_info, name=urlpatterns = [    # 用户登录表单    path('user/login/', views.user_login, name='user_login'),    path('user/info/', views.user_info, name='user_info'),]\n\n用户退出\n使用logout函数退出当前登录的用户accounts/views.py123456from django.contrib.auth import logoutdef user_logout(request):    \"\"\" 用户退出登录 \"\"\"    logout(request)    return redirect(from django.contrib.auth import logoutdef user_logout(request):    \"\"\" 用户退出登录 \"\"\"    logout(request)    return redirect('/accounts/user/info/')\n\n\n\naccounts/urls.py\n1234urlpatterns = [    # 用户退出登录    path('user/logout/', views.user_logout, name=urlpatterns = [    # 用户退出登录    path('user/logout/', views.user_logout, name='user_logout'),]\n\n用户登录、退出接口开发开发步骤\n第一步，设计接口返回内容及字段\n第二步，编写接口代码\n第三步，模拟HTTP请求，测试验证接口\n\naccounts/urls.py\n12345urlpatterns = [    # 登录和退出的接口    path('user/api/login/', views.user_api_login, name='user_api_login'),    path('user/api/logout/', views.user_api_logout, name=urlpatterns = [    # 登录和退出的接口    path('user/api/login/', views.user_api_login, name='user_api_login'),    path('user/api/logout/', views.user_api_logout, name='user_api_logout'),]\n\nutils/response.py\n1234567891011121314151617181920212223242526from django.http import JsonResponseclass BadRequestJsonResponse(JsonResponse):    \"\"\" 表单请求验证没有通过，错误显示 \"\"\"    status_code = 400    def __init__(self, err_list=[], *args, **kwargs):        data = {            \"error_code\": \"400000\",            \"error_msg\": \"参数格式不正确\",            \"error_list\": err_list        }        super().__init__(data, *args, **kwargs)class MethodNotAllowedJsonResponse(JsonResponse):    \"\"\" 请求方式不被允许 \"\"\"    status_code = 405    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"405000\",            \"error_msg\": from django.http import JsonResponseclass BadRequestJsonResponse(JsonResponse):    \"\"\" 表单请求验证没有通过，错误显示 \"\"\"    status_code = 400    def __init__(self, err_list=[], *args, **kwargs):        data = {            \"error_code\": \"400000\",            \"error_msg\": \"参数格式不正确\",            \"error_list\": err_list        }        super().__init__(data, *args, **kwargs)class MethodNotAllowedJsonResponse(JsonResponse):    \"\"\" 请求方式不被允许 \"\"\"    status_code = 405    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"405000\",            \"error_msg\": \"请求方式不被允许\",        }        super().__init__(data, *args, **kwargs)\n\naccounts/serializers.py\n1234567891011121314151617181920212223from utils.serializers import BaseSerializerclass UserSerializer(BaseSerializer):    \"\"\" 用户的基础信息 \"\"\"    def to_dict(self):        user = self.obj        return {            'username': user.username,            'nickname': user.nickname,            'avatar': user.avatar.url        }class UserProfileSerializer(BaseSerializer):    \"\"\" 用户的详细信息 \"\"\"    def to_dict(self):        profile = self.obj        return {            'real_name': profile.real_name,            'sex': profile.sex,            from utils.serializers import BaseSerializerclass UserSerializer(BaseSerializer):    \"\"\" 用户的基础信息 \"\"\"    def to_dict(self):        user = self.obj        return {            'username': user.username,            'nickname': user.nickname,            'avatar': user.avatar.url        }class UserProfileSerializer(BaseSerializer):    \"\"\" 用户的详细信息 \"\"\"    def to_dict(self):        profile = self.obj        return {            'real_name': profile.real_name,            'sex': profile.sex,            'sex_display': profile.get_sex_display(),        }\n\naccounts/views.py\n1234567891011121314151617181920212223242526272829303132333435363738import jsonfrom django import httpfrom django.contrib.auth import logoutfrom accounts import serializersfrom accounts.forms import LoginFormfrom utils.response import UnauthorizedJsonResponsedef user_api_login(request):    \"\"\" 用户登录接口-POST \"\"\"    # 获取输入的内容    if request.method == 'POST':        # 表单验证        form = LoginForm(request.POST)        # 如果通过了验证，执行登录        if form.is_valid():            user = form.do_login(request)            # 返回内容：用户的信息（用户的基本信息、详细详细）            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)        else:            # 如果没有通过表单验证，返回表单的错误信息            err = json.loads(form.errors.as_json())            return BadRequestJsonResponse(err)    else:        # GET请求不被允许        return MethodNotAllowedJsonResponse()def user_api_logout(request):    \"\"\" 用户退出接口 \"\"\"    logout(request)    return http.HttpResponse(status=import jsonfrom django import httpfrom django.contrib.auth import logoutfrom accounts import serializersfrom accounts.forms import LoginFormfrom utils.response import UnauthorizedJsonResponsedef user_api_login(request):    \"\"\" 用户登录接口-POST \"\"\"    # 获取输入的内容    if request.method == 'POST':        # 表单验证        form = LoginForm(request.POST)        # 如果通过了验证，执行登录        if form.is_valid():            user = form.do_login(request)            # 返回内容：用户的信息（用户的基本信息、详细详细）            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)        else:            # 如果没有通过表单验证，返回表单的错误信息            err = json.loads(form.errors.as_json())            return BadRequestJsonResponse(err)    else:        # GET请求不被允许        return MethodNotAllowedJsonResponse()def user_api_logout(request):    \"\"\" 用户退出接口 \"\"\"    logout(request)    return http.HttpResponse(status=201)\n\n用户详情接口开发开发步骤\n第一步，设计接口返回内容及字段\n第二步，编写接口代码\n第三步，模拟HTTP请求，测试验证接口accounts/urls.py1234urlpatterns = [    # 用户详细信息接口    path('user/api/info/', views.UserDetailView.as_view(), name=urlpatterns = [    # 用户详细信息接口    path('user/api/info/', views.UserDetailView.as_view(), name='user_api_info'),]\n\n\n\nutils/response.py\n123456789101112from django.http import JsonResponseclass UnauthorizedJsonResponse(JsonResponse):    status_code = 401    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"401000\",            \"error_msg\": from django.http import JsonResponseclass UnauthorizedJsonResponse(JsonResponse):    status_code = 401    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"401000\",            \"error_msg\": \"请登录\",        }        super().__init__(data, *args, **kwargs)\n\naccounts/views.py\n123456789101112131415161718192021222324252627import jsonfrom django import httpfrom django.views import Viewfrom accounts import serializersfrom utils.response import BadRequestJsonResponse, MethodNotAllowedJsonResponse, UnauthorizedJsonResponseclass UserDetailView(View):    \"\"\" 用户详细接口 \"\"\"    def get(self, request):        # 获取用户信息        user = request.user        # 用户：是游客吗？数据库中是否存在        if not user.is_authenticated:            # 返回401状态码            return UnauthorizedJsonResponse()        else:            # 返回详细信息            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            import jsonfrom django import httpfrom django.views import Viewfrom accounts import serializersfrom utils.response import BadRequestJsonResponse, MethodNotAllowedJsonResponse, UnauthorizedJsonResponseclass UserDetailView(View):    \"\"\" 用户详细接口 \"\"\"    def get(self, request):        # 获取用户信息        user = request.user        # 用户：是游客吗？数据库中是否存在        if not user.is_authenticated:            # 返回401状态码            return UnauthorizedJsonResponse()        else:            # 返回详细信息            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)\n\n\n\n\n\nParser功能是配置文件进行预处理，因此，每一次更新都会执行一次Parser，因此自定义规则会永远存在，只要你不删除Parser。修改parsers\nparsers:\n  - url: https://example.com/profile.yaml\n    yaml:\n      prepend-rules:\n        - DOMAIN,test.com,DIRECT # rules最前面增加一个规则\n      append-proxies:\n        - name: test # proxies最后面增加一个服务\n          type: http\n          server: 123.123.123.123\n          port: 456\n\nurl：改成本人的订阅地址，如果不知道，可以直接在Profiles下点击当前订阅的Change imformation，复制其中的URL即可。prepen-rules 数组合并至原配置rules数组前 此处添加你的自定义规则，每一条占一行，按照规则类型，值，代理策略排列，使用逗号分隔。注意的是，每一行都需要以一个短横线 - 加一个空格 开头，同时注意对齐。具体的自定义规则如何书写在本文的后半部分有说明。点击右下角保存，在Profiles里更新订阅，这样就可以将新的规则添加上了。可以点击Edit rules查看规则进行验证。之后打开相应网页看是否生效。\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["django"]},{"title":"文件操作","url":"https://bubbleboy11.github.io/2020/08/21/wen-jian-cao-zuo/","content":"文件读写模式open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)打开一个文件，生成并且返回文件对象，在对文件进行处理过程（创建、读写操作）都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。默认的创建的目录在当前程序所在的目录，文件不存在，则在当前目录创建该文件file：一个包含了你要访问的文件路径的字符串值。\nbuffering: 设置缓冲buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。\nencoding: Windows系统在写入中文时需要设置编码格式，一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。\nmode 模式是一个可选非强制字符串，指定打开文件的模式。\n123456789101112131415161718192021222324252627282930313233```'w'```写入模式，打开一个文件只用于写入。打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被覆盖删除。如果该文件不存在，创建新文件。指针在开始```'a'```追加(Attach)模式，如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。```'b'```二进制模式（与其他模式结合使用）binary mode doesn't take an encoding argument，b模式不能再加上encoding```'ab'``` 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。```'rb'```    以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。```+```读写模式（与其他模式结合使用），打开一个文件进行更新(可读可写)。```'r+```打开一个文件用于读写。文件指针将会放在文件的开头。```'W+'```以读写的方式打开文件。打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被覆盖删除。如果该文件不存在，创建新文件。```'a+'```如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是读写追加模式。如果该文件不存在，创建新文件用于读写```'ab+```以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于写入。```'rb+'```    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。```'wb'```以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，以二进制格式创建新文件。一般用于非文本文件如图片等。比特类型bytes，字符前缀```b``````'wb+'```    以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。不使用with语句写法```pyfile=open('文件路径'，访问模式) data = file.read()\n\n使用with语法，到达该语句未尾时，将自动close()关闭文件释放资源，即便出现异常亦如此中文字体写入默认是GB2312编码。\n\n不指定编码格式\n12with open（\"file_path\") with open（\"file_path\") as file：    do_something(file)\n\n指定编码格式：指定编码写入，需要打开文件的时候按指定的编码写入，open写encoding编码方式。\n123456# 1. 打开file = open(\"readme.txt\", \"a\", encoding='utf-8')  # a 以追加的方式打开# 2. 写入文件file.write(\"123 hello\")# 1. 打开file = open(\"readme.txt\", \"a\", encoding='utf-8')  # a 以追加的方式打开# 2. 写入文件file.write(\"123 hello\")# 3. 关闭file.close()\n\n\n\n12345678910111213141516当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用来关闭文件并立即释放它使用的所有系统资源。如果你没有显式地关闭文件，Python的垃圾回收器最终将销毁该对象并为你关闭打开的文件，但这个文件可能会保持打开状态一段时间。一是可能忘记关闭文件句柄；二是文件读取数据发生异常，没有做异常处理一个文件被打开后，你有一个file对象，你可以得到有关该文件对象相关的所有属性的属性    描述```file.closed```    返回true如果文件已被关闭，否则返回false。```file.mode```    返回被打开文件的访问模式。```file.name```    返回文件的路径。```pyfo = open(\"代码\\pi_digits.txt\", \"w\")print(\"文件路径: \", fo.name)  # 文件路径:  代码\\pi_digits.txtprint(\"是否已关闭 : \", fo.closed)  # 是否已关闭 :  Falseprint(\"访问模式 : \", fo.mode)  # 访问模式 :  w\n\n12345678910111213141516171819202122232425262728293031323334353637383940如果使用read读了多次，那么后面继续使用read读取的数据是从上次读完后的位置开始的```readline([count])```：对文件的数据按行读取，（行的划分是\\n）.每次只读取一行。如果有多次读取的话，下面一次读取的偏移量是上面读取后的偏移量。```readlines()```：按照行的方式把整个文件中的内容进行一次性读取，读取所有行(直到结束符 EOF)并返回一个列表，其中每一行（按着换行符进行判断一行）的数据为一个元素。```write(“string”)```函数向打开的文件对象写入指定字符串，如果文件不存在那么创建，如果存在那么就先清空文件(覆盖)，然后写入数据到文件里。Python字符串可以是二进制数据，而不是仅仅是文字。不会在字符串的结尾添加换行符('\\n')```writelines(string_list)```函数向打开的文件对象写入多行内容以往后遇加的模式与入文件在默认模式下读取文本文件时（二进制文件不可以），文件中的换行符会转换为'\\n'形式。在默认模式下写入文件时，文本中的'\\n'会转换为换行符。```tell()```方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。```seek(offset [,from])```方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。```seek(3)```从文件起始位置偏移3个字符从第4个字符位置开始读取```seek(0，0)```重新从文件启始位置读取```pyimport oscurrent_path = os.getcwd()with open(current_path + '/' + 'test1.txt', 'w+',          encoding='utf-8') as file_object:    file_object.write('Ashe正在学习Python')    content = file_object.read()    print(content, type(content))    #   注意前面有一个空格表示content是空字符串    # 因为此时读取的是最后一个字符，写完内容之后就是空字符串    file_object.seek(0)    content = file_object.read()    print(content, type(content))    # Ashe正在学习Python \n\n1234567891011121314import oscurrent_path = os.getcwd()with open(current_path + '/' + 'test1.txt', 'ab+') as file_object:    string = b'Ashe Python'    file_object.write(string)    content = file_object.read()    print(content, type(content))    # b'' &lt;class 'bytes'&gt; 注意前面有一个空格表示content是空字符串    # 因为此时读取的是最后一个字符，写完内容之后就是空字符串    file_object.seek(0)    content = file_object.read()    print(content, type(content))    import oscurrent_path = os.getcwd()with open(current_path + '/' + 'test1.txt', 'ab+') as file_object:    string = b'Ashe Python'    file_object.write(string)    content = file_object.read()    print(content, type(content))    # b'' &lt;class 'bytes'&gt; 注意前面有一个空格表示content是空字符串    # 因为此时读取的是最后一个字符，写完内容之后就是空字符串    file_object.seek(0)    content = file_object.read()    print(content, type(content))    # b'Ashe Python' \n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566filename = '代码\\generate_text.txt'# 使用‘w’来提醒python用写入的方式打开 指定编码为with open(filename, 'w', encoding='utf-8') as fileobject:    fileobject.write('I love your name!'                     '\\nI love your cloth!'                     '\\nI love your shoes!'                     '\\nI love your hair!')# 使用‘a’来提醒python用附加模式的方式打开指定编码为'utf-8'with open(filename, 'a', encoding='utf-8') as fileobject:    fileobject.write('\\nI an superman.我是超人')# 使用‘a’来提醒python用附加模式的方式打开不指定编码为'utf-8'with open(filename, 'a') as fileobject:    fileobject.write('\\nI an superman.我是超人')with open('代码\\generate_text.txt', 'r') as f:    content = f.readline()    print(\"第一次读取:%s\" % content)    # 第一次读取:I love your name!    print(\"第一次读取:\", content)    # 第一次读取:I love your name!    content = f.readline()    print(\"第二次读取:%s\" % content)    # 第二次读取:I love your cloth!    content = f.read(6)    print(\"第三次读取:%s\" % content)    # 第三次读取:I love    position = f.tell()    print(\"当前文件位置 : \", position)    # 当前文件位置 :  45    # 把指针再次重新定位到文件开头    position = f.seek(0, 0)    str = f.read(16)    print(\"读取的字符串是 : \", str)    # 读取的字符串是 :  I love your name    position = f.tell()    print(\"当前文件位置 : \", position)    # 当前文件位置 :  16with open('代码\\generate_text.txt', 'r') as f:    content = f.read()    print(\"读取:%s\" % content)    # 读取:I love your name!    # I love your cloth!    # I love your shoes!    # I love your hair!    # I an superman.鎴戞槸瓒呬汉    # I an superman.我是超人    # 注意如果用read（），读取全部，后面再加read(num),就没有内容可读了。返回空字符串    content = f.read(6)    print(\":%s\" % content)    # :with open('代码\\generate_text.txt', 'r') as f:    content = f.readlines()    print(\"读取:%s\" % content)#     读取:['I love your name!\\n', 'I love your cloth!\\n', 'I love your # shoes!\\n', 'I love your hair!\\n', 'I an superman.鎴戞槸瓒呬汉\\n', filename = '代码\\generate_text.txt'# 使用‘w’来提醒python用写入的方式打开 指定编码为with open(filename, 'w', encoding='utf-8') as fileobject:    fileobject.write('I love your name!'                     '\\nI love your cloth!'                     '\\nI love your shoes!'                     '\\nI love your hair!')# 使用‘a’来提醒python用附加模式的方式打开指定编码为'utf-8'with open(filename, 'a', encoding='utf-8') as fileobject:    fileobject.write('\\nI an superman.我是超人')# 使用‘a’来提醒python用附加模式的方式打开不指定编码为'utf-8'with open(filename, 'a') as fileobject:    fileobject.write('\\nI an superman.我是超人')with open('代码\\generate_text.txt', 'r') as f:    content = f.readline()    print(\"第一次读取:%s\" % content)    # 第一次读取:I love your name!    print(\"第一次读取:\", content)    # 第一次读取:I love your name!    content = f.readline()    print(\"第二次读取:%s\" % content)    # 第二次读取:I love your cloth!    content = f.read(6)    print(\"第三次读取:%s\" % content)    # 第三次读取:I love    position = f.tell()    print(\"当前文件位置 : \", position)    # 当前文件位置 :  45    # 把指针再次重新定位到文件开头    position = f.seek(0, 0)    str = f.read(16)    print(\"读取的字符串是 : \", str)    # 读取的字符串是 :  I love your name    position = f.tell()    print(\"当前文件位置 : \", position)    # 当前文件位置 :  16with open('代码\\generate_text.txt', 'r') as f:    content = f.read()    print(\"读取:%s\" % content)    # 读取:I love your name!    # I love your cloth!    # I love your shoes!    # I love your hair!    # I an superman.鎴戞槸瓒呬汉    # I an superman.我是超人    # 注意如果用read（），读取全部，后面再加read(num),就没有内容可读了。返回空字符串    content = f.read(6)    print(\":%s\" % content)    # :with open('代码\\generate_text.txt', 'r') as f:    content = f.readlines()    print(\"读取:%s\" % content)#     读取:['I love your name!\\n', 'I love your cloth!\\n', 'I love your # shoes!\\n', 'I love your hair!\\n', 'I an superman.鎴戞槸瓒呬汉\\n', # 'I an superman.我是超人']\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 相对文件路径 （优先使用）with open('牛客网剑指offer66题思路分析\\代码\\pi_digits.txt') as file_object:    contents = file_object.read()    # 多出一个空行的情况下可以使用 rstrip() 来去除字符串后面的空白    print(contents.rstrip())    # 3.1415926535      #   8979323846      #   2643383279      # 'abc  '         # '  abc'         # abc    #   abc      print('******')    print(contents.lstrip())    # 3.1415926535      #   8979323846      #   2643383279      # 'abc  '         # '  abc'         # abc    #   abc # 绝对文件路径file_path = 'C:\\python代码\\牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('----')    print(file_object.read())# 逐行 读取文件的信息file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('======')    for line in file_object:        # 多出一个空行的情况下可以使用 rstrip() 来去除字符串后面的空白        print(line.rstrip())  # 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('^^^^^^^')    lines = file_object.readlines()    print(lines)    # ['3.1415926535\\n', '  8979323846\\n', '  2643383279\\n', \"'abc  '\\n\", \"'  abc'\\n\", 'abc\\n', '  abc']    # 遍历列表，将读取的内容显示出来，按照原来文件的行划分。    for line in lines:        # 相对文件路径 （优先使用）with open('牛客网剑指offer66题思路分析\\代码\\pi_digits.txt') as file_object:    contents = file_object.read()    # 多出一个空行的情况下可以使用 rstrip() 来去除字符串后面的空白    print(contents.rstrip())    # 3.1415926535      #   8979323846      #   2643383279      # 'abc  '         # '  abc'         # abc    #   abc      print('******')    print(contents.lstrip())    # 3.1415926535      #   8979323846      #   2643383279      # 'abc  '         # '  abc'         # abc    #   abc # 绝对文件路径file_path = 'C:\\python代码\\牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('----')    print(file_object.read())# 逐行 读取文件的信息file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('======')    for line in file_object:        # 多出一个空行的情况下可以使用 rstrip() 来去除字符串后面的空白        print(line.rstrip())  # 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    print('^^^^^^^')    lines = file_object.readlines()    print(lines)    # ['3.1415926535\\n', '  8979323846\\n', '  2643383279\\n', \"'abc  '\\n\", \"'  abc'\\n\", 'abc\\n', '  abc']    # 遍历列表，将读取的内容显示出来，按照原来文件的行划分。    for line in lines:        # 多出一个空行的情况下可以使用 rstrip() 来去除字符串后面的空白        print(line.rstrip())串后面的空白\n\n12345678910# 使用文件的内容 读取/拼接# 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    lines = file_object.readlines()  # 读取文件中每行的信息pi_string = ''  # 创建一个字符串for line in lines:  # 遍历读取到的文件的每行信息 存储到line中    pi_string += line.strip()  # 读取到的每行信息+创建的字符串  并用strip()去除两端的空格print(pi_string)  # 输出拼接之后的信息# 使用文件的内容 读取/拼接# 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    lines = file_object.readlines()  # 读取文件中每行的信息pi_string = ''  # 创建一个字符串for line in lines:  # 遍历读取到的文件的每行信息 存储到line中    pi_string += line.strip()  # 读取到的每行信息+创建的字符串  并用strip()去除两端的空格print(pi_string)  # 输出拼接之后的信息# 3.141592653589793238462643383279'abc  ''  abc'abcabc\n\n123456789101112131415# 读取一个百万位的大型文件# 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    lines = file_object.readlines()  # 读取文件中每行的信息pi_string = ''  # 创建一个字符串for line in lines:  # 遍历读取到的文件的每行信息 存储到line中    # 读取到的每行信息+创建的字符串  并用strip()去除两端的空格    pi_string += line.strip()# 输出拼接之后的信息 只输出列表中的前9位 如果输出百万位 把9改为1000000print(pi_string[:9] + '...')# 输出拼接之后的信息的字符串长度print(len(pi_string))# 3.1415926...# 读取一个百万位的大型文件# 逐行 读取文件的信息 使用readlines()file_path = '牛客网剑指offer66题思路分析\\代码\\pi_digits.txt'with open(file_path) as file_object:    lines = file_object.readlines()  # 读取文件中每行的信息pi_string = ''  # 创建一个字符串for line in lines:  # 遍历读取到的文件的每行信息 存储到line中    # 读取到的每行信息+创建的字符串  并用strip()去除两端的空格    pi_string += line.strip()# 输出拼接之后的信息 只输出列表中的前9位 如果输出百万位 把9改为1000000print(pi_string[:9] + '...')# 输出拼接之后的信息的字符串长度print(len(pi_string))# 3.1415926...# 52\n\n1234567891011121314151617181920# 写入文件 执行完之后 文件目录中 会生成一个generate_text.txt的文件 # 内容就是‘正在学习Python’ 在读取写入的文件内容和文件长度file_path = '牛客网剑指offer66题思路分析\\代码\\generate_doc.txt'with open(file_path, 'w') as file_object:    file_object.write('Ashe正在学习Python' + '\\n')    file_object.write('Ashe正在学习Python1' + '\\n')with open(file_path, 'a') as file_object:    file_object.write('Ashe正在学习Python' + '\\n')with open(file_path, 'r') as file_object:    lines = file_object.readlines()    for line in lines:        print(line.strip())        print(len(line))        # Ashe正在学习Python        # 15        # Ashe正在学习Python1        # 16        # Ashe正在学习Python        # 写入文件 执行完之后 文件目录中 会生成一个generate_text.txt的文件 # 内容就是‘正在学习Python’ 在读取写入的文件内容和文件长度file_path = '牛客网剑指offer66题思路分析\\代码\\generate_doc.txt'with open(file_path, 'w') as file_object:    file_object.write('Ashe正在学习Python' + '\\n')    file_object.write('Ashe正在学习Python1' + '\\n')with open(file_path, 'a') as file_object:    file_object.write('Ashe正在学习Python' + '\\n')with open(file_path, 'r') as file_object:    lines = file_object.readlines()    for line in lines:        print(line.strip())        print(len(line))        # Ashe正在学习Python        # 15        # Ashe正在学习Python1        # 16        # Ashe正在学习Python        # 15\n\n1234567# 提示用户输入自己的姓名 再将用户输入的姓名写入到文件中输出file_path = '牛客网剑指offer66题思路分析\\代码\\generate_input.txt'with open(file_path, 'w') as file_object:  # w:表示写入(Write)到这个文件中    message = input('input your name：')    file_object.write(message)    # 提示用户输入自己的姓名 再将用户输入的姓名写入到文件中输出file_path = '牛客网剑指offer66题思路分析\\代码\\generate_input.txt'with open(file_path, 'w') as file_object:  # w:表示写入(Write)到这个文件中    message = input('input your name：')    file_object.write(message)    # input: Ashe\n\n1234567891011121314151617181920212223242526272829import json# 将列表数据number存储在number.json 文件中number = [2, 3, 4, 5, 7, 11, 13]filename = 'number.json'with open(filename, 'w') as f_obj:    # f_obj:存入到的文件的位置    # json.dump用来存储。    json.dump(number, f_obj)    print('数据存储到' + filename + '完成！')    # 数据存储到number.json完成！# 读取前面写入到number.json文件的数据内容with open(filename, 'r') as f_obj:    # json.load用来读取。    # f_obj:读取的数据源的位置    numbers = json.load(f_obj)    print(numbers)    # [2, 3, 4, 5, 7, 11, 13]# for循环遍历输出读取到的文件中的每条列表中的数据 并 打印输出for number in numbers:    print(number)    # 2    # 3    # 4    # 5    # 7    # 11    import json# 将列表数据number存储在number.json 文件中number = [2, 3, 4, 5, 7, 11, 13]filename = 'number.json'with open(filename, 'w') as f_obj:    # f_obj:存入到的文件的位置    # json.dump用来存储。    json.dump(number, f_obj)    print('数据存储到' + filename + '完成！')    # 数据存储到number.json完成！# 读取前面写入到number.json文件的数据内容with open(filename, 'r') as f_obj:    # json.load用来读取。    # f_obj:读取的数据源的位置    numbers = json.load(f_obj)    print(numbers)    # [2, 3, 4, 5, 7, 11, 13]# for循环遍历输出读取到的文件中的每条列表中的数据 并 打印输出for number in numbers:    print(number)    # 2    # 3    # 4    # 5    # 7    # 11    # 13\n\n1234567891011121314151617181920212223import jsondata_list = [{    'href': 'https://bubbleboy11.github.io/',    'text': ' 首页'}, {    'href': 'https://bubbleboy11.github.io/',    'text': ' python'}]# python按行写入文件for item in data_list:    with open('代码\\generate_data.json', 'a+', encoding='utf-8') as f:        line = json.dumps(item, ensure_ascii=False)        f.write(line + '\\n')# 按行读取文件的操作方法with open('代码\\generate_data.json', 'r', encoding=\"utf-8\") as f:    # 读取所有行 每行会是一个字符串    for jsonstr in f.readlines():        # 将josn字符串转化为dict字典        jsonstr = json.loads(jsonstr)        print(jsonstr)        # {\"href\": \"https://bubbleboy11.github.io/\", \"text\": \" 首页\"}        import jsondata_list = [{    'href': 'https://bubbleboy11.github.io/',    'text': ' 首页'}, {    'href': 'https://bubbleboy11.github.io/',    'text': ' python'}]# python按行写入文件for item in data_list:    with open('代码\\generate_data.json', 'a+', encoding='utf-8') as f:        line = json.dumps(item, ensure_ascii=False)        f.write(line + '\\n')# 按行读取文件的操作方法with open('代码\\generate_data.json', 'r', encoding=\"utf-8\") as f:    # 读取所有行 每行会是一个字符串    for jsonstr in f.readlines():        # 将josn字符串转化为dict字典        jsonstr = json.loads(jsonstr)        print(jsonstr)        # {\"href\": \"https://bubbleboy11.github.io/\", \"text\": \" 首页\"}        # {\"href\": \"https://bubbleboy11.github.io/\", \"text\": \" python\"}\n\n1234567891011121314151617181920212223import timeimport shutilimport osseconds = time.time()print(seconds)localtime = time.localtime(seconds)print(localtime)print(localtime.tm_year)print(localtime.tm_mon)print(localtime.tm_mday)asctime = time.asctime(localtime)print(asctime)strtime = time.strftime('%Y-%m-%d %H:%M:%S', localtime)print(strtime)mydate = time.strptime('2018-1-1', '%Y-%m-%d')print(mydate)shutil.copy('/Users/Hao/hello.py', '/Users/Hao/Desktop/first.py')os.system('ls -l')os.chdir('/Users/Hao')os.system('ls -l')os.mkdir(import timeimport shutilimport osseconds = time.time()print(seconds)localtime = time.localtime(seconds)print(localtime)print(localtime.tm_year)print(localtime.tm_mon)print(localtime.tm_mday)asctime = time.asctime(localtime)print(asctime)strtime = time.strftime('%Y-%m-%d %H:%M:%S', localtime)print(strtime)mydate = time.strptime('2018-1-1', '%Y-%m-%d')print(mydate)shutil.copy('/Users/Hao/hello.py', '/Users/Hao/Desktop/first.py')os.system('ls -l')os.chdir('/Users/Hao')os.system('ls -l')os.mkdir('test')\n\n在项目中需要进行很多重复的操作，如要给代码的源文件添加相同的代码，这个时候一个文件一个文件的操作就很浪费时间了，通过python批处理一秒不到全部添加完成，本代码只是一个抛砖引玉的效果，只要是有特征的文本修改均可由代码完成，解放双手！\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osimport shutildef text_edit_vhd(filepath):    with open(filepath, 'r+') as file_head:        content = file_head.read()        file_head.seek(0, 0)        file_head.write(\"`protect begin \\n\" + content)        file_head.seek(0, 2)        file_head.write(\"\\n`protect end \")def text_edit_v(filepath):    with open(filepath, 'r+') as file_head:        content = file_head.read()        file_head.seek(0, 0)        file_head.write(\"`protect \\n\" + content)        file_head.seek(0, 2)        file_head.write(\" \\n`endprotect \")def add_text(srcpath):  # 寻找本文件夹及子文件夹下所以符合要求的文本进行处理    srcdirs = os.listdir(srcpath)    for dir in srcdirs:        if not os.path.isfile(os.path.join(srcpath, dir)):  # 判断dir属性，为文件或者文件夹            add_text(os.path.join(srcpath, dir))        else:            if '.vhd' == dir[-4:]:                print(\"正在处理文件中，文件路径为：\" + os.path.join(srcpath, dir))                text_edit_vhd(os.path.join(srcpath, dir))                print(\"文件处理完成！\")            elif '.v' == dir[-2:]:                print(\"正在处理文件中，文件路径为：\" + os.path.join(srcpath, dir))                text_edit_v(os.path.join(srcpath, dir))                print(\"文件处理完成！\")current_path = os.getcwd()print('当前文件路径为：' + current_path)os.chdir('..')root_path = os.getcwd()handle_path = root_path + '\\handle'print('当前文件路径为：' + handle_path)shutil.copytree(path, handle_path)  # 备份后进行数据处理add_text(handle_path)print(import osimport shutildef text_edit_vhd(filepath):    with open(filepath, 'r+') as file_head:        content = file_head.read()        file_head.seek(0, 0)        file_head.write(\"`protect begin \\n\" + content)        file_head.seek(0, 2)        file_head.write(\"\\n`protect end \")def text_edit_v(filepath):    with open(filepath, 'r+') as file_head:        content = file_head.read()        file_head.seek(0, 0)        file_head.write(\"`protect \\n\" + content)        file_head.seek(0, 2)        file_head.write(\" \\n`endprotect \")def add_text(srcpath):  # 寻找本文件夹及子文件夹下所以符合要求的文本进行处理    srcdirs = os.listdir(srcpath)    for dir in srcdirs:        if not os.path.isfile(os.path.join(srcpath, dir)):  # 判断dir属性，为文件或者文件夹            add_text(os.path.join(srcpath, dir))        else:            if '.vhd' == dir[-4:]:                print(\"正在处理文件中，文件路径为：\" + os.path.join(srcpath, dir))                text_edit_vhd(os.path.join(srcpath, dir))                print(\"文件处理完成！\")            elif '.v' == dir[-2:]:                print(\"正在处理文件中，文件路径为：\" + os.path.join(srcpath, dir))                text_edit_v(os.path.join(srcpath, dir))                print(\"文件处理完成！\")current_path = os.getcwd()print('当前文件路径为：' + current_path)os.chdir('..')root_path = os.getcwd()handle_path = root_path + '\\handle'print('当前文件路径为：' + handle_path)shutil.copytree(path, handle_path)  # 备份后进行数据处理add_text(handle_path)print(\"run done\\n\")\n\n1234567891011121314151617181920# Description   : Checks to see if a directory exists in the users home directory, if not then create it# 检查主目录中是否存在某文件夹，若不存在则创建import os  # Import the OS moduleMESSAGE = 'The directory already exists.'TESTDIR = 'testdir'try:    # Set the variable home by expanding the user's set home directory    home = os.path.expanduser(\"~\")    print(home)  # Print the location    # os.path.join() for making a full path safely    if not os.path.exists(os.path.join(home, TESTDIR)):        # If not create the directory, inside their home directory        os.makedirs(os.path.join(home, TESTDIR))    else:        print(MESSAGE)except Exception # Description   : Checks to see if a directory exists in the users home directory, if not then create it# 检查主目录中是否存在某文件夹，若不存在则创建import os  # Import the OS moduleMESSAGE = 'The directory already exists.'TESTDIR = 'testdir'try:    # Set the variable home by expanding the user's set home directory    home = os.path.expanduser(\"~\")    print(home)  # Print the location    # os.path.join() for making a full path safely    if not os.path.exists(os.path.join(home, TESTDIR)):        # If not create the directory, inside their home directory        os.makedirs(os.path.join(home, TESTDIR))    else:        print(MESSAGE)except Exception as e:    print(e)\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding:utf-8import osdef create_package(path):    if os.path.exists(path):        raise Exception('%s 已经存在不可创建' % path)    os.makedirs(path)    init_path = os.path.join(path, '__init__.py')    f = open(init_path, 'w')    f.write('# coding:utf-8\\n')    f.close()class Open(object):    def __init__(self, path, mode='w', is_return=True):        self.path = path        self.mode = mode        self.is_return = is_return    def write(self, message):        f = open(self.path, mode=self.mode)        if self.is_return:            message = '%s\\n' % message        f.write(message)        f.close()    def read(self, is_strip=True):        result = []        with open(self.path, mode=self.mode) as f:            data = f.readlines()        for line in data:            if is_strip == True:                temp = line.strip()                if temp != \"\":                    result.append(temp)            else:                if line != '':                    result.append(line)        return resultif __name__ == '__main__':    current_path = os.getcwd()    # path = os.path.join(current_path, 'test1')    # create_package(path)    # open_path = os.path.join(current_path, 'b.txt')    o = Open('package_datetime.py', mode='r')    # o.write('你好 小慕')    data = o.read(is_strip=# coding:utf-8import osdef create_package(path):    if os.path.exists(path):        raise Exception('%s 已经存在不可创建' % path)    os.makedirs(path)    init_path = os.path.join(path, '__init__.py')    f = open(init_path, 'w')    f.write('# coding:utf-8\\n')    f.close()class Open(object):    def __init__(self, path, mode='w', is_return=True):        self.path = path        self.mode = mode        self.is_return = is_return    def write(self, message):        f = open(self.path, mode=self.mode)        if self.is_return:            message = '%s\\n' % message        f.write(message)        f.close()    def read(self, is_strip=True):        result = []        with open(self.path, mode=self.mode) as f:            data = f.readlines()        for line in data:            if is_strip == True:                temp = line.strip()                if temp != \"\":                    result.append(temp)            else:                if line != '':                    result.append(line)        return resultif __name__ == '__main__':    current_path = os.getcwd()    # path = os.path.join(current_path, 'test1')    # create_package(path)    # open_path = os.path.join(current_path, 'b.txt')    o = Open('package_datetime.py', mode='r')    # o.write('你好 小慕')    data = o.read(is_strip=False)    print(data)\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["python"],"tags":[]},{"title":"验证码获取接口联调","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-yan-zheng-ma-huo-qu-jie-kou-lian-diao/","content":"短信验证码接口开发开发步骤\n第一步，设计接口返回内容及字段\n第二步，编写接口代码\n\nutils/response.py\n1234567891011from django.http import JsonResponseclass ServerErrorJsonResponse(JsonResponse):    status_code = 500    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"500000\",            \"error_msg\": from django.http import JsonResponseclass ServerErrorJsonResponse(JsonResponse):    status_code = 500    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"500000\",            \"error_msg\": \"服务器正忙，请稍后重试\",        }        super().__init__(data, *args, **kwargs)\n\n\n验证码只存取5分钟，之后自动删除，用redis实现验证码存储system/forms.py\n123456789101112131415161718192021222324252627282930313233343536373839404142import randomimport refrom django import formsfrom django.core.cache import cacheclass SendSmsCodeForm(forms.Form):    \"\"\" 发送验证码的表单 \"\"\"    phone_num = forms.CharField(label='手机号码', required=True, error_messages={        'required': '请输入手机号码'    })    def clean_phone_num(self):        \"\"\" 验证是否为手机号 \"\"\"        phone_num = self.cleaned_data['phone_num']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, phone_num):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(phone_num,))        return phone_num    def send_sms_code(self):        \"\"\" 生成验证码并发送短信 \"\"\"        sms_code = random.randint(100000, 999999)        phone_num = self.cleaned_data.get('phone_num', None)        try:            # TODO 调用发送验证码的短信接口            # redis中的key            key = 'sms_code_{}'.format(phone_num)            # 将验证码存入redis            timeout = 5 * 60            cache.set(key, sms_code, timeout=timeout)            return {                'phone_num': phone_num,                'sms_code': sms_code,                'timeout': timeout            }        except Exception as e:            print(e)            return import randomimport refrom django import formsfrom django.core.cache import cacheclass SendSmsCodeForm(forms.Form):    \"\"\" 发送验证码的表单 \"\"\"    phone_num = forms.CharField(label='手机号码', required=True, error_messages={        'required': '请输入手机号码'    })    def clean_phone_num(self):        \"\"\" 验证是否为手机号 \"\"\"        phone_num = self.cleaned_data['phone_num']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, phone_num):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(phone_num,))        return phone_num    def send_sms_code(self):        \"\"\" 生成验证码并发送短信 \"\"\"        sms_code = random.randint(100000, 999999)        phone_num = self.cleaned_data.get('phone_num', None)        try:            # TODO 调用发送验证码的短信接口            # redis中的key            key = 'sms_code_{}'.format(phone_num)            # 将验证码存入redis            timeout = 5 * 60            cache.set(key, sms_code, timeout=timeout)            return {                'phone_num': phone_num,                'sms_code': sms_code,                'timeout': timeout            }        except Exception as e:            print(e)            return None\n\nsystem/views.py\n123456789101112131415161718192021222324252627import jsonfrom django.views.generic import FormViewfrom system.forms import SendSmsCodeFormfrom utils.response import BadRequestJsonResponse, ServerErrorJsonResponsedef send_sms(request):    pass    # 1. 拿到手机号，判断是否为真实的手机号码    # 2. 生成验证码，并存储    # TODO 3. 调用短信的发送接口    # 4. 告诉用户验证码发送是否成功（会把验证码直接告诉用户）class SmsCodeView(FormView):    form_class = SendSmsCodeForm    def form_valid(self, form):        \"\"\" 表单已经通过验证 \"\"\"        data = form.send_sms_code()        if data:            return http.JsonResponse(data, status=201)        return ServerErrorJsonResponse()    def form_invalid(self, form):        \"\"\" 表单没有通过验证 \"\"\"        err_list = json.loads(form.errors.as_json())        import jsonfrom django.views.generic import FormViewfrom system.forms import SendSmsCodeFormfrom utils.response import BadRequestJsonResponse, ServerErrorJsonResponsedef send_sms(request):    pass    # 1. 拿到手机号，判断是否为真实的手机号码    # 2. 生成验证码，并存储    # TODO 3. 调用短信的发送接口    # 4. 告诉用户验证码发送是否成功（会把验证码直接告诉用户）class SmsCodeView(FormView):    form_class = SendSmsCodeForm    def form_valid(self, form):        \"\"\" 表单已经通过验证 \"\"\"        data = form.send_sms_code()        if data:            return http.JsonResponse(data, status=201)        return ServerErrorJsonResponse()    def form_invalid(self, form):        \"\"\" 表单没有通过验证 \"\"\"        err_list = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err_list)\n\nsystem/urls.py\n1234urlpatterns = [    # 发送验证码    path('send/sms/', views.SmsCodeView.as_view(), name=urlpatterns = [    # 发送验证码    path('send/sms/', views.SmsCodeView.as_view(), name=\"send_sms\"),]\n\n\n第三步，模拟HTTP请求，测试验证接口\n\n用户注册接口开发开发步骤\n第一步，设计接口返回内容及字段\n第二步，编写接口代码\n\nutils/constants.py\n12# 用户注册时，发送验证码的redis keyREGISTER_MSM_CODE_KEY = # 用户注册时，发送验证码的redis keyREGISTER_MSM_CODE_KEY = 'reg_sms_'\n\nsystem/forms.py\n1234567891011121314151617181920212223242526272829303132333435363738394041424344import randomimport refrom django import formsfrom django.core.cache import cachefrom utils import constantsclass SendSmsCodeForm(forms.Form):    \"\"\" 发送验证码的表单 \"\"\"    phone_num = forms.CharField(label='手机号码', required=True, error_messages={        'required': '请输入手机号码'    })    def clean_phone_num(self):        \"\"\" 验证是否为手机号 \"\"\"        phone_num = self.cleaned_data['phone_num']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, phone_num):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(phone_num,))        return phone_num    def send_sms_code(self):        \"\"\" 生成验证码并发送短信 \"\"\"        sms_code = random.randint(100000, 999999)        phone_num = self.cleaned_data.get('phone_num', None)        try:            # TODO 调用发送验证码的短信接口            # redis中的key            key = '{}{}'.format(constants.REGISTER_MSM_CODE_KEY, phone_num)            # 将验证码存入redis            timeout = 5 * 60            cache.set(key, sms_code, timeout=timeout)            return {                'phone_num': phone_num,                'sms_code': sms_code,                'timeout': timeout            }        except Exception as e:            print(e)            return import randomimport refrom django import formsfrom django.core.cache import cachefrom utils import constantsclass SendSmsCodeForm(forms.Form):    \"\"\" 发送验证码的表单 \"\"\"    phone_num = forms.CharField(label='手机号码', required=True, error_messages={        'required': '请输入手机号码'    })    def clean_phone_num(self):        \"\"\" 验证是否为手机号 \"\"\"        phone_num = self.cleaned_data['phone_num']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, phone_num):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(phone_num,))        return phone_num    def send_sms_code(self):        \"\"\" 生成验证码并发送短信 \"\"\"        sms_code = random.randint(100000, 999999)        phone_num = self.cleaned_data.get('phone_num', None)        try:            # TODO 调用发送验证码的短信接口            # redis中的key            key = '{}{}'.format(constants.REGISTER_MSM_CODE_KEY, phone_num)            # 将验证码存入redis            timeout = 5 * 60            cache.set(key, sms_code, timeout=timeout)            return {                'phone_num': phone_num,                'sms_code': sms_code,                'timeout': timeout            }        except Exception as e:            print(e)            return None\n\naccounts/forms.py\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.core.cache import cachefrom django.db import transactionfrom django.utils.timezone import nowfrom accounts.models import User, Profilefrom utils import constantsclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码',                               max_length=200,                               min_length=6,                               widget=forms.PasswordInput)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data.get('username', None)        password = data.get('password', None)        user = authenticate(username=username, password=password)        if user is None:            raise forms.ValidationError('用户名或者是密码不正确')        else:            if not user.is_active:                raise forms.ValidationError('该用户已经被禁用')        self.user = user        return data    def do_login(self, request):        \"\"\" 执行用户登录 \"\"\"        user = self.user        # 调用登录        login(request, user)        # 修改最后登录的时间        user.last_login = now()        user.save()        # TODO 保存登录历史        return userclass RegisterForm(forms.Form):    \"\"\" 用户注册 \"\"\"    username = forms.CharField(label='手机号码', max_length=16, required=True, error_messages={        'required': '请输入手机号码'    })    password = forms.CharField(label='密码', max_length=128, required=True, error_messages={        'required': '请输入密码'    })    nickname = forms.CharField(label='昵称', max_length=16, required=True, error_messages={        'required': '请输入昵称'    })    sms_code = forms.CharField(label='验证码', max_length=6, required=True, error_messages={        'required': '请输入验证码'    })    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        if User.objects.filter(username=username).exists():            raise forms.ValidationError('手机号已经被使用')        return username    def clean_nickname(self):        \"\"\" 昵称验证 \"\"\"        nickname = self.cleaned_data['nickname']        if User.objects.filter(nickname=nickname).exists():            raise forms.ValidationError('昵称已经被使用')        return nickname    def clean(self):        data = super().clean()        if self.errors:            return        phone_num = self.cleaned_data.get('username', None)        sms_code = self.cleaned_data.get('sms_code', None)        # redis 中的验证码key        key = '{}{}'.format(constants.REGISTER_MSM_CODE_KEY, phone_num)        code = cache.get(key)        # code 已失效        if not code:            raise forms.ValidationError('验证码已经失效')        if str(code) != sms_code:            raise forms.ValidationError('验证码输入不正确')        return data    @transaction.atomic    def do_register(self, request):        \"\"\" 执行注册 \"\"\"        data = self.cleaned_data        version = request.headers.get('version', '')        source = request.headers.get('source', '')        try:            # 1. 创建基础信息表            user = User.objects.create_user(                username=data.get('username', None),                password=data.get('password', None),                nickname=data.get('nickname', None)            )            # 2. 创建详细表            profile = Profile.objects.create(                user=user,                username=user.username,                version=version,                source=source            )            # 3. 执行登录            login(request, user)            # 4. 记录登录日志            user.last_login = now()            user.save()            ip = request.META.get('REMOTE_ADDR', '')            user.add_login_record(username=user.username, ip=ip, source=source, version=version)            return user, profile        except Exception as e:            print(e)            return import refrom django import formsfrom django.contrib.auth import authenticate, loginfrom django.core.cache import cachefrom django.db import transactionfrom django.utils.timezone import nowfrom accounts.models import User, Profilefrom utils import constantsclass LoginForm(forms.Form):    \"\"\" 登录表单 \"\"\"    username = forms.CharField(label='用户名',                               max_length=100,                               required=False,                               help_text='使用帮助',                               initial='admin')    password = forms.CharField(label='密码',                               max_length=200,                               min_length=6,                               widget=forms.PasswordInput)    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        # 当前登录的用户        self.user = None    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        return username    def clean(self):        data = super().clean()        print(data)        # 如果单个字段有错误，直接返回，不执行后面的验证        if self.errors:            return        username = data.get('username', None)        password = data.get('password', None)        user = authenticate(username=username, password=password)        if user is None:            raise forms.ValidationError('用户名或者是密码不正确')        else:            if not user.is_active:                raise forms.ValidationError('该用户已经被禁用')        self.user = user        return data    def do_login(self, request):        \"\"\" 执行用户登录 \"\"\"        user = self.user        # 调用登录        login(request, user)        # 修改最后登录的时间        user.last_login = now()        user.save()        # TODO 保存登录历史        return userclass RegisterForm(forms.Form):    \"\"\" 用户注册 \"\"\"    username = forms.CharField(label='手机号码', max_length=16, required=True, error_messages={        'required': '请输入手机号码'    })    password = forms.CharField(label='密码', max_length=128, required=True, error_messages={        'required': '请输入密码'    })    nickname = forms.CharField(label='昵称', max_length=16, required=True, error_messages={        'required': '请输入昵称'    })    sms_code = forms.CharField(label='验证码', max_length=6, required=True, error_messages={        'required': '请输入验证码'    })    def clean_username(self):        \"\"\" 验证用户名 hook 钩子函数 \"\"\"        username = self.cleaned_data['username']        pattern = r'^1[0-9]{10}$'        if not re.search(pattern, username):            raise forms.ValidationError('手机号%s输入不正确',                                        code='invalid_phone',                                        params=(username,))        if User.objects.filter(username=username).exists():            raise forms.ValidationError('手机号已经被使用')        return username    def clean_nickname(self):        \"\"\" 昵称验证 \"\"\"        nickname = self.cleaned_data['nickname']        if User.objects.filter(nickname=nickname).exists():            raise forms.ValidationError('昵称已经被使用')        return nickname    def clean(self):        data = super().clean()        if self.errors:            return        phone_num = self.cleaned_data.get('username', None)        sms_code = self.cleaned_data.get('sms_code', None)        # redis 中的验证码key        key = '{}{}'.format(constants.REGISTER_MSM_CODE_KEY, phone_num)        code = cache.get(key)        # code 已失效        if not code:            raise forms.ValidationError('验证码已经失效')        if str(code) != sms_code:            raise forms.ValidationError('验证码输入不正确')        return data    @transaction.atomic    def do_register(self, request):        \"\"\" 执行注册 \"\"\"        data = self.cleaned_data        version = request.headers.get('version', '')        source = request.headers.get('source', '')        try:            # 1. 创建基础信息表            user = User.objects.create_user(                username=data.get('username', None),                password=data.get('password', None),                nickname=data.get('nickname', None)            )            # 2. 创建详细表            profile = Profile.objects.create(                user=user,                username=user.username,                version=version,                source=source            )            # 3. 执行登录            login(request, user)            # 4. 记录登录日志            user.last_login = now()            user.save()            ip = request.META.get('REMOTE_ADDR', '')            user.add_login_record(username=user.username, ip=ip, source=source, version=version)            return user, profile        except Exception as e:            print(e)            return None\n\naccounts/views.py\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import jsonfrom django import httpfrom django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom django.views import Viewfrom django.views.generic import FormViewfrom accounts import serializersfrom accounts.forms import LoginForm, RegisterFormfrom utils.response import BadRequestJsonResponse, MethodNotAllowedJsonResponse, UnauthorizedJsonResponse, \\    ServerErrorJsonResponsedef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# 需要登录以后才能访问user_info，# 否则跳转到登录地址http://127.0.0.1:8000/accounts/user/login/?next=/accounts/user/info/# 方式一# @login_required(login_url='/accounts/user/login/')# 方式二@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, 'user_info.html')def user_logout(request):    \"\"\" 用户退出登录 \"\"\"    logout(request)    return redirect('/accounts/user/info/')def user_api_login(request):    \"\"\" 用户登录接口-POST \"\"\"    # 获取输入的内容    if request.method == 'POST':        # 表单验证        form = LoginForm(request.POST)        # 如果通过了验证，执行登录        if form.is_valid():            user = form.do_login(request)            # 返回内容：用户的信息（用户的基本信息、详细详细）            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)        else:            # 如果没有通过表单验证，返回表单的错误信息            err = json.loads(form.errors.as_json())            return BadRequestJsonResponse(err)    else:        # GET请求不被允许        return MethodNotAllowedJsonResponse()def user_api_logout(request):    \"\"\" 用户退出接口 \"\"\"    logout(request)    return http.HttpResponse(status=201)class UserDetailView(View):    \"\"\" 用户详细接口 \"\"\"    def get(self, request):        # 获取用户信息        user = request.user        # 用户：是游客吗？数据库中是否存在        if not user.is_authenticated:            # 返回401状态码            return UnauthorizedJsonResponse()        else:            # 返回详细信息            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)def user_api_register(request):    \"\"\" 用户注册 \"\"\"    # 1. 表单，验证用户输入的信息（用户名、昵称、验证码）    # 2. 创建用户基础信息表、用户详细信息表    # 3. 执行登录    # 4. 保存登录日志    passclass UserRegisterView(FormView):    \"\"\" 用户注册接口 \"\"\"    form_class = RegisterForm    http_method_names = ['post']    def form_valid(self, form):        \"\"\" 表单已经通过验证 \"\"\"        result = form.do_register(request=self.request)        if result:            user, profile = result            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data, status=201)        return ServerErrorJsonResponse()    def form_invalid(self, form):        \"\"\" 表单没有通过验证 \"\"\"        err_list = json.loads(form.errors.as_json())        import jsonfrom django import httpfrom django.contrib.auth import logoutfrom django.contrib.auth.decorators import login_requiredfrom django.shortcuts import render, redirectfrom django.views import Viewfrom django.views.generic import FormViewfrom accounts import serializersfrom accounts.forms import LoginForm, RegisterFormfrom utils.response import BadRequestJsonResponse, MethodNotAllowedJsonResponse, UnauthorizedJsonResponse, \\    ServerErrorJsonResponsedef user_login(request):    \"\"\" 用户登录 \"\"\"    if request.method == 'POST':        form = LoginForm(data=request.POST)        if form.is_valid():            form.do_login(request)            print('表单验证通过')            return redirect('/accounts/user/info/')        else:            print(form.errors)    else:        form = LoginForm()    return render(request, 'user_login.html', {        'form': form    })# 需要登录以后才能访问user_info，# 否则跳转到登录地址http://127.0.0.1:8000/accounts/user/login/?next=/accounts/user/info/# 方式一# @login_required(login_url='/accounts/user/login/')# 方式二@login_requireddef user_info(request):    \"\"\" 用户信息 \"\"\"    print(request.user)    return render(request, 'user_info.html')def user_logout(request):    \"\"\" 用户退出登录 \"\"\"    logout(request)    return redirect('/accounts/user/info/')def user_api_login(request):    \"\"\" 用户登录接口-POST \"\"\"    # 获取输入的内容    if request.method == 'POST':        # 表单验证        form = LoginForm(request.POST)        # 如果通过了验证，执行登录        if form.is_valid():            user = form.do_login(request)            # 返回内容：用户的信息（用户的基本信息、详细详细）            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)        else:            # 如果没有通过表单验证，返回表单的错误信息            err = json.loads(form.errors.as_json())            return BadRequestJsonResponse(err)    else:        # GET请求不被允许        return MethodNotAllowedJsonResponse()def user_api_logout(request):    \"\"\" 用户退出接口 \"\"\"    logout(request)    return http.HttpResponse(status=201)class UserDetailView(View):    \"\"\" 用户详细接口 \"\"\"    def get(self, request):        # 获取用户信息        user = request.user        # 用户：是游客吗？数据库中是否存在        if not user.is_authenticated:            # 返回401状态码            return UnauthorizedJsonResponse()        else:            # 返回详细信息            profile = user.profile            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data)def user_api_register(request):    \"\"\" 用户注册 \"\"\"    # 1. 表单，验证用户输入的信息（用户名、昵称、验证码）    # 2. 创建用户基础信息表、用户详细信息表    # 3. 执行登录    # 4. 保存登录日志    passclass UserRegisterView(FormView):    \"\"\" 用户注册接口 \"\"\"    form_class = RegisterForm    http_method_names = ['post']    def form_valid(self, form):        \"\"\" 表单已经通过验证 \"\"\"        result = form.do_register(request=self.request)        if result:            user, profile = result            data = {                'user': serializers.UserSerializer(user).to_dict(),                'profile': serializers.UserProfileSerializer(profile).to_dict()            }            return http.JsonResponse(data, status=201)        return ServerErrorJsonResponse()    def form_invalid(self, form):        \"\"\" 表单没有通过验证 \"\"\"        err_list = json.loads(form.errors.as_json())        return BadRequestJsonResponse(err_list)\n\naccounts/urls.py\n1234urlpatterns = [   # 用户注册    path('user/api/register/', views.UserRegisterView.as_view(), name=urlpatterns = [   # 用户注册    path('user/api/register/', views.UserRegisterView.as_view(), name='user_api_register'),]\n\n第三步，模拟HTTP请求，测试验证接口\n\n验证码获取接口联调实现步骤\n第一步，阅读接口文档\n第二步，配置接口地址src\\utils\\apis.js1234567/** * 系统模块的接口 */const SystemApis = {  // 发送短信验证码  sendSmsCodeUrl: apiHost + /** * 系统模块的接口 */const SystemApis = {  // 发送短信验证码  sendSmsCodeUrl: apiHost + '/system/send/sms/'}\n\n\n\nsrc\\components\\common\\SendSmsCode.vue\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677    <van-button    size=\"small\"    type=\"primary\"    @click.prevent=\"sendSmsCode()\"    :disabled=\"isSmsSend\"    >{{ sendBtnText }}import { ajax } from '@/utils/ajax'import { SystemApis } from '@/utils/apis'export default {  props: ['phoneNum'],  data () {    return {      // 是否已经发送了验证码，不能再点击发送验证码      isSmsSend: false,      sendBtnText: '点击发送验证码',      timer: null,      counter: 60    }  },  methods: {    reset () {      this.isSmsSend = false      this.sendBtnText = '点击发送验证码'      if (this.timer) {        clearInterval(this.timer)        this.counter = 60        this.timer = null      }    },    /**     * 倒计时     */    countDown () {      this.timer = setInterval(() => {        this.sendBtnText = `(${this.counter}秒)后重新发送`        this.counter--        if (this.counter < 0) {          this.reset()        }      }, 1000)    },    /**     * 发送验证码     */    sendSmsCode () {      // 判断手机号是否已经输入      if (!this.phoneNum) {        this.$notify('请输入手机号')        return false // 不在执行后面的逻辑      }      // TODO 调用接口，发送短信验证码      ajax.post(SystemApis.sendSmsCodeUrl, {        phone_num: this.phoneNum      }).then(({ data }) => {        // 提示用户验证码已经发送        this.$notify({          message: `验证码为：${data.sms_code}，${data.timeout / 60}分钟内有效`,          duration: 1000 * 10, // 提示持续时间           type: 'success'        })        this.isSmsSend = true        // 开启倒计时, 60s之后才能再次点击        this.countDown()      }).catch(err => {        // 如果产生了异常，提示用户重新操作        this.isSmsSend = false        this.sendBtnText = '点击发送验证码'        console.log(err)      })    }  }}\n\n第三步，使用axios获取数据\n第四步，将数据设置到模型层\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":[]},{"title":"链表","url":"https://bubbleboy11.github.io/2020/08/21/lian-biao/","content":"python用类来实现链表的数据结构\n数组 就是连续的 同一个类型的 元素，而且必须是固定的长度。把数组看做一个内存空间，数组下标就是这个空间的地址，支持根据下标快速访问。但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 O(n)。增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。\n线性表的实际存储方式，分为两种实现模型：1顺序表的构建需要预先知道数据大小来申请连续的存储空间，将元素顺序地存放在一块连续的存储区里而在进行扩充时又需要进行数据的搬迁，元素间的顺序关系由它们的存储顺序自然表示。访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。\n2.链表Linked list：知道了它的头就知道了它的全部，所以最后直接返回头节算法题的自变量head都是链表头节点，不是链表将元素存放在通过链接构造起来的一系列存储块中。如果我们想要非固定的长度来存储数据。这个时候就出现了表链。链表是一种物理存储单元上非连续、非顺序的存储结构，链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。充分利用计算机内存空间，实现灵活的内存动态管理。数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n单向链表链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。\n顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。\n相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点，不能像数组一样随机根据下标访问，你想查找一个元素只能老老实实从头遍历，则需要O(n)的时间，\n无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。\nTips：双指针并不是固定的公式，而是一种思维方式\n链表中的基本要素：1.节点类（Node）或元素)，单链表每个结点有两个域，左边部份叫值域（数据域），value 属性保存值 存储数据元素的域)。头结点的内存地址没有存储在其他结点的指针域右边叫指针域(next)，有一个指针保存指向下一个节点地址位置信，next存储直接后继存储位置的域称为。用 node.next 访问下一个节点。最后一个结点的next指向为None(空值)\n对于单链表结构可以使用 calss 的两个属性表示 val , next。\n实现一个Node类：\n12345class Node:    def __init__(self, x):        self.val = x  # val: 节点保存的数据元素        self.next = None  class Node:    def __init__(self, x):        self.val = x  # val: 节点保存的数据元素        self.next = None  # next: 保存下一个节点对象的地址\n此节点类只有一个构建函数，接收一个数据参数，其中next表示指针域的指针，\n实例化后得到一个节点对象\n1node = Node(node = Node(4)\n此节点对象数据为4，指针指向None。[]C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\节点.jpg\n2.head结点，head结点永远指向第一个结点3.tail结点，tail结点永远指向最后一个节点4.None，链表中最后一个结点tail指针域的指针next指向None值，\n  \n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Node:    def __init__(self, x):  # 传入一个参数        self.val = x        self.next = Nonea = Node(1)b = Node(2)c = Node(3)a.next = bb.next = chead = aprint(a.next.val)  # 2print(a.next.next.val)  # 3print(a.next.next.next.val)# AttributeError: 'NoneType' object has no attribute 'val'# 链表的创建def create_linklist_head(li):    # 头插    head = Node(li[0])    for item in li[1:]:        node = Node(item)  # 生成节点        node.next = head  # next指向原来的头部        head = node  # head 指向在头部插入的节点    return head  # 返回头部def create_linklist_tail(li):    # 尾插    head = Node(li[0])    tail = head    for item in li[1:]:        node = Node(item)  # Node类实例化得到一个node对象。        tail.next = node  # 把原来尾巴的下一个指针指向当前node        tail = node  # 尾巴 指向新部插入的节点    return head  # 返回头部def print_linklist(linklist):    while linklist:        print(linklist.val, end=', ')        linklist = linklist.nextlk = create_linklist_head([1, 2, 3])print_linklist(lk)  # 3, 2, 1,print('---')lk_tail = create_linklist_tail([1, 2, 3])print_linklist(lk_tail)  class Node:    def __init__(self, x):  # 传入一个参数        self.val = x        self.next = Nonea = Node(1)b = Node(2)c = Node(3)a.next = bb.next = chead = aprint(a.next.val)  # 2print(a.next.next.val)  # 3print(a.next.next.next.val)# AttributeError: 'NoneType' object has no attribute 'val'# 链表的创建def create_linklist_head(li):    # 头插    head = Node(li[0])    for item in li[1:]:        node = Node(item)  # 生成节点        node.next = head  # next指向原来的头部        head = node  # head 指向在头部插入的节点    return head  # 返回头部def create_linklist_tail(li):    # 尾插    head = Node(li[0])    tail = head    for item in li[1:]:        node = Node(item)  # Node类实例化得到一个node对象。        tail.next = node  # 把原来尾巴的下一个指针指向当前node        tail = node  # 尾巴 指向新部插入的节点    return head  # 返回头部def print_linklist(linklist):    while linklist:        print(linklist.val, end=', ')        linklist = linklist.nextlk = create_linklist_head([1, 2, 3])print_linklist(lk)  # 3, 2, 1,print('---')lk_tail = create_linklist_tail([1, 2, 3])print_linklist(lk_tail)  # 1, 2, 3,\n\n1234567891011121314151617181920212223class LinkedListNode():    def __init__(self, next=None, value=None):        self.next = next        self.value = value# 创建一个链表lk_head = LinkedListNode()myList = [1, 2, 3, 4, 5]for i in range(len(myList)):    lk_head = LinkedListNode(lk_head, myList[i])print(lk_head)  # &lt;__main__.LinkedListNode object at 0x00000271CCFBFDF0&gt;def print_linklist(lk):  # lk任意命名    while lk:        print(lk.value, end=', ')        lk = lk.next# 头插：链表新插入的节点在表头，# 因此，实际上链表中的顺序，与插入列表的顺序是反过来 逆序print_linklist(lk_head)  class LinkedListNode():    def __init__(self, next=None, value=None):        self.next = next        self.value = value# 创建一个链表lk_head = LinkedListNode()myList = [1, 2, 3, 4, 5]for i in range(len(myList)):    lk_head = LinkedListNode(lk_head, myList[i])print(lk_head)  # &lt;__main__.LinkedListNode object at 0x00000271CCFBFDF0&gt;def print_linklist(lk):  # lk任意命名    while lk:        print(lk.value, end=', ')        lk = lk.next# 头插：链表新插入的节点在表头，# 因此，实际上链表中的顺序，与插入列表的顺序是反过来 逆序print_linklist(lk_head)  # 5, 4, 3, 2, 1, None,\n\n链表的常用方法：LinkedList() 创建空链表，不需要参数，返回值是空链表\nis_empty() 测试链表是否为空，不需要参数，只需要检查head节点是否指向None\n12def is_empty(self):    return self.head is def is_empty(self):    return self.head is None\n返回值是布尔值，如果是空列表返回True，否则返回False\nappend(data) 尾插：在尾部增加一个元素作为链表最后一个参数是要追加的元素，无返回值\n12345678def append(self, data):        node = Node(data)        if self.head is None:  # head指向None，链表是一个空链表            self.head = node  # 把链表的head和tail都指向了node，            self.tail = node        else:  # 当链表不是空链表时            self.tail.next = node  # 将尾节点的next指向新节点            self.tail = node  def append(self, data):        node = Node(data)        if self.head is None:  # head指向None，链表是一个空链表            self.head = node  # 把链表的head和tail都指向了node，            self.tail = node        else:  # 当链表不是空链表时            self.tail.next = node  # 将尾节点的next指向新节点            self.tail = node  # 将尾节点指向新节点\n\n1link_list(append(link_list(append(4))\n增加第二个节点的操作需要分两步完成，第一步：self.tail.next = node，即把上一个节点的next指针指向当前node；第二步：self.tail = node，把tail移动到node，\n当if self.head is None:为False时,说明链表已经增加了一个节点了，再增加一个节点时head已经指向了第一个节点，所以不为None，比如增加的第二个节点为：\nC:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\append1.jpgC:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\append2.jpg当增加第三个、第四个等节点时，按照上边的操作依次类推。\niter() 遍历链表，无参数，无返回值，此方法一般是一个生成器在遍历链表时也要首先考虑空链表的情况。遍历链表时从head开始，直到一个节点的next指向None结束\n12345678def iter(self):        if not self.head:            return        cur = self.head        yield cur.data        while cur.next:            cur = cur.next            def iter(self):        if not self.head:            return        cur = self.head        yield cur.data        while cur.next:            cur = cur.next            yield cur.data\n当是遍历一个空链表时，if not self.head:为True，直接返回None；如果不是空链表就让一个局部变量cur指向head,并把head的data属性yield出来，再对cur的next指针指向的对象做while循环，直到next指向None，这样就遍历了链表。\ninsert(idx,value) 插入一个元素，参数为插入元素的索引和值假如采取append方法又增加了两个节点，增加完成后如下图：C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\append3.jpg\n如果想在数据域为6的那节点处插入一个节点，需要做的操作有两步：1.把新节点的next指针指向数据域为6的这个节点，即为数据域为5节点的next指向指向的对象2.把数据域为5节点的next指针指向新加的节点注： 这两个步骤不能颠倒，如果颠倒，数据域为6的节点会被丢失，数据域为7的节点不再是链表的节点。C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\insert.jpg\n还要额外考虑两种情况：1.空链表时2.插入位置超出链表节点的长度时3.插入位置是链表的最后一个节点时，需要移动tail当是在链表最后一个节点插入时，示意图如下：[]C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\insert2.jpg要在指定的索引位置插入一个节点，前提是需要找到这个位置，在链表中只有采用遍历的方式，具有O(n)的速度，最糟糕时会遍历链表的所有节点，而当找到插入点时，我们并不需要当前节点的信息，而是需要前一个节点的信息，所以代码中巧妙的使用了while cur_idx &lt; idx-1:的方式，这样能使用cur这个变量能指向插入点上一个节点对象。实现insert方法的代码如下：\n12345678910111213141516def insert(self, idx, value):        cur = self.head        cur_idx = 0        if cur is None:            raise Exception('The list is an empty list')        # 在某元素后插入        while cur_idx &lt; idx-1:            cur = cur.next            if cur is None:                raise Exception('list length less than index')            cur_idx += 1        node = Node(value)        node.next = cur.next  # 新插入的节点指向第一个的原来next的指向        cur.next = node        if node.next is def insert(self, idx, value):        cur = self.head        cur_idx = 0        if cur is None:            raise Exception('The list is an empty list')        # 在某元素后插入        while cur_idx &lt; idx-1:            cur = cur.next            if cur is None:                raise Exception('list length less than index')            cur_idx += 1        node = Node(value)        node.next = cur.next  # 新插入的节点指向第一个的原来next的指向        cur.next = node        if node.next is None:            self.tail = node\n\nremove(idx)移除1个元素，参数为要移除的元素或索引，并修改链表接收一个idx参数，表示要删除节点的索引，此方法要考虑以下几种情况：1.空链表，直接抛出异常2.删除第一个节点时，移动head到删除节点的next指针指向的对象3.链表只有一个节点时，把head与tail都指向None即可4.删除最后一个节点时，需要移动tail到上一个节点5.遍历链表时要判断给定的索引是否大于链表的长度，如果大于则抛出异常信息O(n)\n请看下边图例：C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\remove1.jpgC:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\remove2.jpg以下为remove函数的代码：\n12345678910111213141516171819202122232425def remove(self, idx):       cur = self.head       cur_idx = 0       if self.head is None:  # 空链表时           raise Exception('The list is an empty list')       while cur_idx &lt; idx-1:           cur = cur.next           if cur is None:               raise Exception('list length less than index')           cur_idx += 1       if idx == 0:   # 当删除第一个节点时           self.head = cur.next           cur = cur.next           return       if self.head is self.tail:   # 当只有一个节点的链表时           self.head = None           self.tail = None           return       cur.next = cur.next.next       if cur.next is None:  # 当删除的节点是链表最后一个节点时           self.tail = cur       # 在某元素后删除节点node = cur.next        def remove(self, idx):       cur = self.head       cur_idx = 0       if self.head is None:  # 空链表时           raise Exception('The list is an empty list')       while cur_idx &lt; idx-1:           cur = cur.next           if cur is None:               raise Exception('list length less than index')           cur_idx += 1       if idx == 0:   # 当删除第一个节点时           self.head = cur.next           cur = cur.next           return       if self.head is self.tail:   # 当只有一个节点的链表时           self.head = None           self.tail = None           return       cur.next = cur.next.next       if cur.next is None:  # 当删除的节点是链表最后一个节点时           self.tail = cur       # 在某元素后删除节点node = cur.next        # cur.next = cur.next.next  # 被删的节点指向第一个的原来next的指向\n\nsize() 返回链表的元素数，不接收参数，返回值是链表中节点的个数，要获得链表的节点个数，必定会遍历链表，直到最后一个节点的next指针指向None时链表遍历完成，遍历时可以用一个累加器来计算节点的个数，如下代码：\n123456789def size(self):        current = self.head        count = 0        if current is None:            return 'The list is an empty list'        while current is not None:            count += 1            current = current.next        def size(self):        current = self.head        count = 0        if current is None:            return 'The list is an empty list'        while current is not None:            count += 1            current = current.next        return count\n\nsearch(item) 查找链表某元素，search函数接收一个item参数，表示查找节点中数据域的值,要查找的元素或索引。search函数遍历链表，每到一个节点把当前节点的data值与item作比较，最糟糕的情况下会全遍历链表。O(n)如果查找到有些数据则返回True，否则返回False，代码如下：\n123456789def search(self, item):        current = self.head        found = False        while current is not None and not found:            if current.data == item:                found = True            else:                current = current.next        def search(self, item):        current = self.head        found = False        while current is not None and not found:            if current.data == item:                found = True            else:                current = current.next        return found\n\nNode类与LinkedList类完整代码整理如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Node:    def __init__(self, data):        self.data = data        self.next = Noneclass LinkedList:    def __init__(self):        self.head = None        self.tail = None    def is_empty(self):        return self.head is None    def append(self, data):        node = Node(data)  # 实列化节点        if self.head is None:            self.head = node            self.tail = node        else:            self.tail.next = node            self.tail = node    def iter(self):        if not self.head:            return        cur = self.head        yield cur.data        while cur.next:            cur = cur.next            yield cur.data    def insert(self, idx, value):        cur = self.head        cur_idx = 0        if cur is None:  # 判断是否是空链表            raise Exception('The list is an empty list')        while cur_idx &lt; idx - 1:  # 遍历链表            cur = cur.next            if cur is None:  # 判断是不是最后一个元素                raise Exception('list length less than index')            cur_idx += 1        node = Node(value)        node.next = cur.next        cur.next = node        if node.next is None:            self.tail = node    def remove(self, idx):        cur = self.head        cur_idx = 0        if self.head is None:  # 空链表时            raise Exception('The list is an empty list')        while cur_idx &lt; idx - 1:            cur = cur.next            if cur is None:                raise Exception('list length less than index')            cur_idx += 1        if idx == 0:  # 当删除第一个节点时            self.head = cur.next            cur = cur.next            return        if self.head is self.tail:  # 当只有一个节点的链表时            self.head = None            self.tail = None            return        cur.next = cur.next.next        if cur.next is None:  # 当删除的节点是链表最后一个节点时            self.tail = cur    def size(self):        current = self.head        count = 0        if current is None:            return 'The list is an empty list'        while current is not None:            count += 1            current = current.next        return count    def search(self, item):        current = self.head        found = False        while current is not None and not found:            if current.data == item:                found = True            else:                current = current.next        return foundif __name__ == '__main__':    link_list = LinkedList()  # 实列化链表    for i in range(5):        link_list.append(i)    print(link_list)    #    print(link_list.is_empty())    #    link_list.insert(10, 30)    #    link_list.remove(0)    for node in link_list.iter():        print('node is {0}'.format(node))    print(link_list.size())class Node:    def __init__(self, data):        self.data = data        self.next = Noneclass LinkedList:    def __init__(self):        self.head = None        self.tail = None    def is_empty(self):        return self.head is None    def append(self, data):        node = Node(data)  # 实列化节点        if self.head is None:            self.head = node            self.tail = node        else:            self.tail.next = node            self.tail = node    def iter(self):        if not self.head:            return        cur = self.head        yield cur.data        while cur.next:            cur = cur.next            yield cur.data    def insert(self, idx, value):        cur = self.head        cur_idx = 0        if cur is None:  # 判断是否是空链表            raise Exception('The list is an empty list')        while cur_idx &lt; idx - 1:  # 遍历链表            cur = cur.next            if cur is None:  # 判断是不是最后一个元素                raise Exception('list length less than index')            cur_idx += 1        node = Node(value)        node.next = cur.next        cur.next = node        if node.next is None:            self.tail = node    def remove(self, idx):        cur = self.head        cur_idx = 0        if self.head is None:  # 空链表时            raise Exception('The list is an empty list')        while cur_idx &lt; idx - 1:            cur = cur.next            if cur is None:                raise Exception('list length less than index')            cur_idx += 1        if idx == 0:  # 当删除第一个节点时            self.head = cur.next            cur = cur.next            return        if self.head is self.tail:  # 当只有一个节点的链表时            self.head = None            self.tail = None            return        cur.next = cur.next.next        if cur.next is None:  # 当删除的节点是链表最后一个节点时            self.tail = cur    def size(self):        current = self.head        count = 0        if current is None:            return 'The list is an empty list'        while current is not None:            count += 1            current = current.next        return count    def search(self, item):        current = self.head        found = False        while current is not None and not found:            if current.data == item:                found = True            else:                current = current.next        return foundif __name__ == '__main__':    link_list = LinkedList()  # 实列化链表    for i in range(5):        link_list.append(i)    print(link_list)    #    print(link_list.is_empty())    #    link_list.insert(10, 30)    #    link_list.remove(0)    for node in link_list.iter():        print('node is {0}'.format(node))    print(link_list.size())#    print(link_list.search(20))\n\n单向循环链表单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155class Node(object):    \"\"\"节点\"\"\"    def __init__(self, item):        self.item = item        self.next = Noneclass SinCycLinkedlist(object):    \"\"\"单向循环链表\"\"\"    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"判断链表是否为空\"\"\"        return self._head == None    def length(self):        \"\"\"返回链表的长度\"\"\"        # 如果链表为空，返回长度0        if self.is_empty():            return 0        count = 1        cur = self._head        while cur.next != self._head:            count += 1            cur = cur.next        return count    def travel(self):        \"\"\"遍历链表\"\"\"        if self.is_empty():            return        cur = self._head        print(cur.item)        while cur.next != self._head:            cur = cur.next            print(cur.item)    def add(self, item):        \"\"\"头部添加节点\"\"\"        node = Node(item)        if self.is_empty():            self._head = node            node.next = self._head        else:            #添加的节点指向_head            node.next = self._head            # 移到链表尾部，将尾部节点的next指向node            cur = self._head            while cur.next != self._head:                cur = cur.next            cur.next = node            #_head指向添加node的            self._head = node    def append(self, item):        \"\"\"尾部添加节点\"\"\"        node = Node(item)        if self.is_empty():            self._head = node            node.next = self._head        else:            # 移到链表尾部            cur = self._head            while cur.next != self._head:                cur = cur.next            # 将尾节点指向node            cur.next = node            # 将node指向头节点_head            node.next = self._head    def insert(self, pos, item):        \"\"\"在指定位置添加节点\"\"\"        if pos &lt;= 0:            self.add(item)        elif pos &gt; (self.length()-1):            self.append(item)        else:            node = Node(item)            cur = self._head            count = 0            # 移动到指定位置的前一个位置            while count &lt; (pos-1):                count += 1                cur = cur.next            node.next = cur.next            cur.next = node    def remove(self, item):        \"\"\"删除一个节点\"\"\"        # 若链表为空，则直接返回        if self.is_empty():            return        # 将cur指向头节点        cur = self._head        pre = None        # 若头节点的元素就是要查找的元素item        if cur.item == item:            # 如果链表不止一个节点            if cur.next != self._head:                # 先找到尾节点，将尾节点的next指向第二个节点                while cur.next != self._head:                    cur = cur.next                # cur指向了尾节点                cur.next = self._head.next                self._head = self._head.next            else:                # 链表只有一个节点                self._head = None        else:            pre = self._head            # 第一个节点不是要删除的            while cur.next != self._head:                # 找到了要删除的元素                if cur.item == item:                    # 删除                    pre.next = cur.next                    return                else:                    pre = cur                    cur = cur.next            # cur 指向尾节点            if cur.item == item:                # 尾部删除                pre.next = cur.next    def search(self, item):        \"\"\"查找节点是否存在\"\"\"        if self.is_empty():            return False        cur = self._head        if cur.item == item:            return True        while cur.next != self._head:            cur = cur.next            if cur.item == item:                return True        return Falseif __name__ == \"__main__\":    ll = SinCycLinkedlist()    ll.add(1)    ll.add(2)    ll.append(3)    ll.insert(2, 4)    ll.insert(4, 5)    ll.insert(0, 6)    print(\"length:\",ll.length())    ll.travel()    print(ll.search(3))    print(ll.search(7))    ll.remove(1)    print(class Node(object):    \"\"\"节点\"\"\"    def __init__(self, item):        self.item = item        self.next = Noneclass SinCycLinkedlist(object):    \"\"\"单向循环链表\"\"\"    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"判断链表是否为空\"\"\"        return self._head == None    def length(self):        \"\"\"返回链表的长度\"\"\"        # 如果链表为空，返回长度0        if self.is_empty():            return 0        count = 1        cur = self._head        while cur.next != self._head:            count += 1            cur = cur.next        return count    def travel(self):        \"\"\"遍历链表\"\"\"        if self.is_empty():            return        cur = self._head        print(cur.item)        while cur.next != self._head:            cur = cur.next            print(cur.item)    def add(self, item):        \"\"\"头部添加节点\"\"\"        node = Node(item)        if self.is_empty():            self._head = node            node.next = self._head        else:            #添加的节点指向_head            node.next = self._head            # 移到链表尾部，将尾部节点的next指向node            cur = self._head            while cur.next != self._head:                cur = cur.next            cur.next = node            #_head指向添加node的            self._head = node    def append(self, item):        \"\"\"尾部添加节点\"\"\"        node = Node(item)        if self.is_empty():            self._head = node            node.next = self._head        else:            # 移到链表尾部            cur = self._head            while cur.next != self._head:                cur = cur.next            # 将尾节点指向node            cur.next = node            # 将node指向头节点_head            node.next = self._head    def insert(self, pos, item):        \"\"\"在指定位置添加节点\"\"\"        if pos &lt;= 0:            self.add(item)        elif pos &gt; (self.length()-1):            self.append(item)        else:            node = Node(item)            cur = self._head            count = 0            # 移动到指定位置的前一个位置            while count &lt; (pos-1):                count += 1                cur = cur.next            node.next = cur.next            cur.next = node    def remove(self, item):        \"\"\"删除一个节点\"\"\"        # 若链表为空，则直接返回        if self.is_empty():            return        # 将cur指向头节点        cur = self._head        pre = None        # 若头节点的元素就是要查找的元素item        if cur.item == item:            # 如果链表不止一个节点            if cur.next != self._head:                # 先找到尾节点，将尾节点的next指向第二个节点                while cur.next != self._head:                    cur = cur.next                # cur指向了尾节点                cur.next = self._head.next                self._head = self._head.next            else:                # 链表只有一个节点                self._head = None        else:            pre = self._head            # 第一个节点不是要删除的            while cur.next != self._head:                # 找到了要删除的元素                if cur.item == item:                    # 删除                    pre.next = cur.next                    return                else:                    pre = cur                    cur = cur.next            # cur 指向尾节点            if cur.item == item:                # 尾部删除                pre.next = cur.next    def search(self, item):        \"\"\"查找节点是否存在\"\"\"        if self.is_empty():            return False        cur = self._head        if cur.item == item:            return True        while cur.next != self._head:            cur = cur.next            if cur.item == item:                return True        return Falseif __name__ == \"__main__\":    ll = SinCycLinkedlist()    ll.add(1)    ll.add(2)    ll.append(3)    ll.insert(2, 4)    ll.insert(4, 5)    ll.insert(0, 6)    print(\"length:\",ll.length())    ll.travel()    print(ll.search(3))    print(ll.search(7))    ll.remove(1)    print(\"length:\",ll.length())    ll.travel()\n\n双链表相比单链表来说，每个节点既保存了指向下一个节点的指针，最后一个结点next指向为None(空)。同时还保存了上一个节点的指针，双链表第一个结点pre指向为None(空)\n双链表每个结点包括三个域，pre指针指向上一个结点，val存储数据值，next指针指向下一个结点。\n对于双链表可以使用class 的三个属性pre, val, next。\n对， 就多了 prev，有啥优势嘛？\n\n直接删除节点，当然如果给的是一个值，我们还是需要查找这个值在哪个节点？ - 但是如果给了一个节点，我们把它拿掉，直接让它的前后节点互相指过去不就行了？哇欧，删除就是 O(1) 了，两步操作就行啦\n\n看似我们反过来遍历双链表了。反过来从哪里开始呢？我们只要让 root 的 prev 指向 tail 节点，不就串起来了吗？循环双端列表就是在双列表基础上把最后一个结点next指向第一个结点，第一个结点pre指向最后一个结点，这样就形成循环双端链表。\n\n\n最 \n\n\n\n循环双端链表操作 CircularDoubleLinkedList 大写字母缩写 cdll\n平均时间复杂度\n\n\n\ncdll.append(value)\nO(1)\n\n\ncdll.appendleft(value)\nO(1)\n\n\ncdll.remove(node)，注意这里参数是 node\nO(1)\n\n\ncdll.headnode()\nO(1)\n\n\ncdll.tailnode()\nO(1)\n\n\n1234567class Node(object):    # 如果节点很多，我们可以用 __slots__ 来节省内存，把属性保存在一个 tuple 而不是 dict 里    # 感兴趣可以自行搜索  python  __slots__    __slots__ = ('value', 'prev', 'next')    def __init__(class Node(object):    # 如果节点很多，我们可以用 __slots__ 来节省内存，把属性保存在一个 tuple 而不是 dict 里    # 感兴趣可以自行搜索  python  __slots__    __slots__ = ('value', 'prev', 'next')    def __init__(self, value=None, prev=None, next=None):        self.value, self.prev, self.next = value, prev, next\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Node(object):    \"\"\"双向链表节点\"\"\"    def __init__(self, item):        self.item = item        self.next = None        self.prev = Noneclass DLinkList(object):    \"\"\"双向链表\"\"\"    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"判断链表是否为空\"\"\"        return self._head == None    def length(self):        \"\"\"返回链表的长度\"\"\"        cur = self._head        count = 0        while cur != None:            count += 1            cur = cur.next        return count    def travel(self):        \"\"\"遍历链表\"\"\"        cur = self._head        while cur != None:            print(cur.item,            cur = cur.next        print(\"\")    def add(self, item):        \"\"\"头部插入元素\"\"\"        node = Node(item)        if self.is_empty():            # 如果是空链表，将_head指向node            self._head = node        else:            # 将node的next指向_head的头节点            node.next = self._head            # 将_head的头节点的prev指向node            self._head.prev = node            # 将_head 指向node            self._head = node    def append(self, item):        \"\"\"尾部插入元素\"\"\"        node = Node(item)        if self.is_empty():            # 如果是空链表，将_head指向node            self._head = node        else:            # 移动到链表尾部            cur = self._head            while cur.next != None:                cur = cur.next            # 将尾节点cur的next指向node            cur.next = node            # 将node的prev指向cur            node.prev = cur    def search(self, item):        \"\"\"查找元素是否存在\"\"\"        cur = self._head        while cur != None:            if cur.item == item:                return True            cur = cur.next        return class Node(object):    \"\"\"双向链表节点\"\"\"    def __init__(self, item):        self.item = item        self.next = None        self.prev = Noneclass DLinkList(object):    \"\"\"双向链表\"\"\"    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"判断链表是否为空\"\"\"        return self._head == None    def length(self):        \"\"\"返回链表的长度\"\"\"        cur = self._head        count = 0        while cur != None:            count += 1            cur = cur.next        return count    def travel(self):        \"\"\"遍历链表\"\"\"        cur = self._head        while cur != None:            print(cur.item,            cur = cur.next        print(\"\")    def add(self, item):        \"\"\"头部插入元素\"\"\"        node = Node(item)        if self.is_empty():            # 如果是空链表，将_head指向node            self._head = node        else:            # 将node的next指向_head的头节点            node.next = self._head            # 将_head的头节点的prev指向node            self._head.prev = node            # 将_head 指向node            self._head = node    def append(self, item):        \"\"\"尾部插入元素\"\"\"        node = Node(item)        if self.is_empty():            # 如果是空链表，将_head指向node            self._head = node        else:            # 移动到链表尾部            cur = self._head            while cur.next != None:                cur = cur.next            # 将尾节点cur的next指向node            cur.next = node            # 将node的prev指向cur            node.prev = cur    def search(self, item):        \"\"\"查找元素是否存在\"\"\"        cur = self._head        while cur != None:            if cur.item == item:                return True            cur = cur.next        return False\n\n\n双链表节点的插入中间值插入的情况p.next = cur.nextcur.next.prev = pp.prev = curcur.next = p\n指定位置插入节点\n12345678910111213141516171819202122def insert(self, pos, item):        \"\"\"在指定位置添加节点\"\"\"        if pos &lt;= 0:            self.add(item)        elif pos &gt; (self.length()-1):            self.append(item)        else:            node = Node(item)            cur = self._head            count = 0            # 移动到指定位置的前一个位置            while count &lt; (pos-1):                count += 1                cur = cur.next            # 将node的prev指向cur            node.prev = cur            # 将node的next指向cur的下一个节点            node.next = cur.next            # 将cur的下一个节点的prev指向node            cur.next.prev = node            def insert(self, pos, item):        \"\"\"在指定位置添加节点\"\"\"        if pos &lt;= 0:            self.add(item)        elif pos &gt; (self.length()-1):            self.append(item)        else:            node = Node(item)            cur = self._head            count = 0            # 移动到指定位置的前一个位置            while count &lt; (pos-1):                count += 1                cur = cur.next            # 将node的prev指向cur            node.prev = cur            # 将node的next指向cur的下一个节点            node.next = cur.next            # 将cur的下一个节点的prev指向node            cur.next.prev = node            # 将cur的next指向node            cur.next = node\n\n双链表节点的删除，当然如果给的是一个值，我们还是需要查找这个值在哪个节点？ \n\n但是如果给了一个节点，我们把它拿掉，直接让它的前后节点互相指过去不就行了？删除就是 O(1) 了，两步操作就行啦\n\n12345678910111213141516171819202122232425def remove(self, item):        \"\"\"删除元素\"\"\"        if self.is_empty():            return        else:            cur = self._head            if cur.item == item:                # 如果首节点的元素即是要删除的元素                if cur.next == None:                    # 如果链表只有这一个节点                    self._head = None                else:                    # 将第二个节点的prev设置为None                    cur.next.prev = None                    # 将_head指向第二个节点                    self._head = cur.next                return            while cur != None:                if cur.item == item:                    # 将cur的前一个节点的next指向cur的后一个节点                    cur.prev.next = cur.next                    # 将cur的后一个节点的prev指向cur的前一个节点                    cur.next.prev = cur.prev                    def remove(self, item):        \"\"\"删除元素\"\"\"        if self.is_empty():            return        else:            cur = self._head            if cur.item == item:                # 如果首节点的元素即是要删除的元素                if cur.next == None:                    # 如果链表只有这一个节点                    self._head = None                else:                    # 将第二个节点的prev设置为None                    cur.next.prev = None                    # 将_head指向第二个节点                    self._head = cur.next                return            while cur != None:                if cur.item == item:                    # 将cur的前一个节点的next指向cur的后一个节点                    cur.prev.next = cur.next                    # 将cur的后一个节点的prev指向cur的前一个节点                    cur.next.prev = cur.prev                    break                cur = cur.next\n\n测试\n123456789101112131415if __name__ == \"__main__\":    ll = DLinkList()    ll.add(1)    ll.add(2)    ll.append(3)    ll.insert(2, 4)    ll.insert(4, 5)    ll.insert(0, 6)    print(\"length:\",ll.length())    ll.travel()    print(ll.search(3))    print(ll.search(4))    ll.remove(1)    print(if __name__ == \"__main__\":    ll = DLinkList()    ll.add(1)    ll.add(2)    ll.append(3)    ll.insert(2, 4)    ll.insert(4, 5)    ll.insert(0, 6)    print(\"length:\",ll.length())    ll.travel()    print(ll.search(3))    print(ll.search(4))    ll.remove(1)    print(\"length:\",ll.length())    ll.travel()\n\n\n中间值p = cur.next删除的情况cur.next = p.nextp.next.prev = curcur.next = pdel p\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"HTML","url":"https://bubbleboy11.github.io/2020/08/21/vue/","content":"广泛使用的前端开发框架-PC端网页-移动端H5站点-小程序-App(安卓、ios)\n用于开发单页面应用-只有一个HTML页面( Single Page web Application,SPA)-使用 JavaScript动态切换HTML内容\n优点-用户体验更好-减轻服务器的压力-前后端完全分离,通过接口( Restful api)进行通信-接口代码的复用1.体积小压缩后33K2.更高的运行效率基于虚拟dom,一种可以预先通过 JavaScript进行各种计算,把最终的DOM操作计算出来并优化的技术,由于这个DOM操作属于预处理操作,并没有真实的操作DOM,所以叫做虚拟DOM3.双向数据绑定让开发者不用再去操作dom对象,把更多的精力投入到业务逻辑上4生态丰富、学习成本低市场上拥有大量成熟、稳定的基于 vue.S的u框架、常用组件!拿来即用实现快速开发!对初学者友好、入门容易、学习资料多;\nVue生态圈-官方维护开发的框架及扩展-第三方UI框架、组件库如:实战中要使用的 VantUI-基于 Node.js的模块-完整的技术文档和学习资料\nvue项目方式一:引用 vue.Js&lt;script src=\"./vue.Js&gt;&lt;/script&gt;\n-方式二:使用∨ue CLI搭建项目\nvue的实例\n\n示例代码var app= new Vue(options)\n\nel参数挂载到某个HTML标签\n\ndata参数/属性\n\n存放当前组件所需要的数据\n它是响应式的,data某一属性改变当值发生改变的同时，视图也会改变，浏览器dom结构当中会自动跟随改变放在data中的属性。\n\n\ncomputed计算属性\n\n用于复杂的逻辑\n定义的js函数没有形式参数\n必须有返回值，使用插值语法，在界面上显示12345678computed: {    a() {    },    b() {    }}\n\n\n\nmethods参数，不能少复数的s\n\n可以直接通过∨ue实例访问的方法\n定义的js函数有形式参数，可以相互调用\n处理js事件\n\n\ntemplate参数\n\n模板,如果不指定,则使用默认的html模板\n有template参数选项，可以通过 render参数从组建渲染,将其作为模板编译成render函数。\n如果没有template选项，则将外部HTML作为模板编译。\ntemplate中的模板优先级要高于outer HTML的优先级。\n\n\n\nMVVM架构       View ModelView  DOM Listeners =&gt; model(DOM)  Directives       JavaScript Object        DOM操作 \nVue.js中 ViewModel层处理了DOM的操作，使我们的开发更简单\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;h3&gt;表单操作&lt;/h3&gt;        &lt;!-- v-model, @click都是vue.js的属性  --&gt;        &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;        &lt;!-- 点击事件--&gt;        &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;        &lt;p&gt;{{ uname }}&lt;/p&gt;        &lt;h3&gt;动态列表&lt;/h3&gt;        &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;        &lt;ul&gt;            &lt;li v-for=\"item in dataList\"&gt;{{item}}&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: \"#app\",  // Vue实例接管el指定的标签id =\"app\"当中所有的内容            data: { username: 'admin', dataList: [] },            computed: {                uname() {                    // 类方法中的this指向类的实例                    return this.username[0] + \"***\"                }            },            methods: {                submit() {                    console.log(\"获取表单的值：\", this.username)                    this.load()                },                load() {                    this.dataList = ['Beijing', 'Shanghai', 'Guangzhou', 'Shenzhen']                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;h3&gt;表单操作&lt;/h3&gt;        &lt;!-- v-model, @click都是vue.js的属性  --&gt;        &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;        &lt;!-- 点击事件--&gt;        &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;        &lt;p&gt;{{ uname }}&lt;/p&gt;        &lt;h3&gt;动态列表&lt;/h3&gt;        &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;        &lt;ul&gt;            &lt;li v-for=\"item in dataList\"&gt;{{item}}&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: \"#app\",  // Vue实例接管el指定的标签id =\"app\"当中所有的内容            data: { username: 'admin', dataList: [] },            computed: {                uname() {                    // 类方法中的this指向类的实例                    return this.username[0] + \"***\"                }            },            methods: {                submit() {                    console.log(\"获取表单的值：\", this.username)                    this.load()                },                load() {                    this.dataList = ['Beijing', 'Shanghai', 'Guangzhou', 'Shenzhen']                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html>\n在通过live server在浏览器中，F12或右键inspector-console，点击提交按钮，控制台会输出获取表单的值： admin页面会加载’Beijing’, ‘Shanghai’, ‘Guangzhou’, ‘Shenzhen’\n生命周期对于一个程序或Vue.js中的一个实例来说，其生命周期经过一系列的初始化过程开始创建，一个程序本身和程序中的每一个实例和组件都存在生命周期。生命周期：就是从一个组件或实例开始初始化、创建实例到该实例被销毁的过程。\n在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n钩子函数 不能使用箭头函数Vue实例从创建到销毁的过程中 ，这些过程中会伴随着一些函数的自调用，在某一个时间点Vue实例会自动执行的函数称为钩子函数。为什么叫做钩子呢？原因是对于某个实例事件发生后需要响应已经预设好的代码，即某一个钩子钩住了一个实例的状态或者事件。\n\nbeforeCreate在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。此时的 data 和 methods 中的 数据都还没有没初始化。\n\ncreated在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。也就是此时 data 和 methods已经初始化完成了。然而，挂载阶段还没开始，$el 属性目前尚不可用。 页面还没有渲染出来。注意：如果要调用 methods 中的方法，或者操作 data 中的数据，最早只能在 created 中进行操作。\n\nbeforeMount\n\n\n\n如果有el和template，在挂载开始之前被调用。此时页面上还看不到真实的数据，因为模板在内存中编译完成了，但是还没有把模板渲染到页面中。注意：在 beforeMount 执行的时候，页面中的元素还没有被真正替换过来，显示的是之前写的一些模板字符串。\n\n以下代码在浏览器显示是一级标题的test，template: '&lt;h1&gt;test&lt;/h1&gt;'替换了el: '#app'也就是替换了id=\"app\"为&lt;div&gt;的所有内容\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/html>\n123456beforeCreatecreatedundefinedbeforeMountmountedindexVue.html:98 Live reload beforeCreatecreatedundefinedbeforeMountmountedindexVue.html:98 Live reload enabled.\n\n\n如果没有el，浏览器显示id=\"app\"为&lt;div&gt;的所有内容\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/html>\n123beforeCreatecreatedbeforeCreatecreatedundefined\n\n\n如果没有el，在手动$mount('#app')指定挂载到\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    }).$mount('#app')&lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    }).$mount('#app')&lt;/script&gt;&lt;/body&gt;&lt;/html>\n12345indexVue.html:37 beforeCreateindexVue.html:45 createdindexVue.html:46 undefinedindexVue.html:49 beforeMountindexVue.html:52 indexVue.html:37 beforeCreateindexVue.html:45 createdindexVue.html:46 undefinedindexVue.html:49 beforeMountindexVue.html:52 mounted\n\n如果没有template和el属性，浏览器显示id=\"app\"为&lt;div&gt;的所有内容\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        // template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    }).$mount('#app')&lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({  // app是全局变量，在浏览器控制台输入app可以访问到此象        // el: '#app',        // template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate() {  // 没有箭头函数            console.log('beforeCreate')            // console.log(this.load())        },        // beforeCreate: () =&gt; {        //   console.log('beforeCreate')        //   // console.log(this.load())        // },        created() {            console.log('created')            console.log(this.load())        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    }).$mount('#app')&lt;/script&gt;&lt;/body&gt;&lt;/html>\n12345beforeCreatecreatedundefinedbeforeMountbeforeCreatecreatedundefinedbeforeMountmounted\n在浏览器控制台输入app\n12appwn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}$attrs: (...)$children: []$createElement: ƒ (e,n,r,i)$el: div#app$listeners: (...)$options: {components: {…}, directives: {…}, filters: {…}, _base: ƒ, data: ƒ,&nbsp;…}$parent: undefined$refs: {}$root: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}$scopedSlots: {}$slots: {}$vnode: undefineddataList: (...)load: ƒ ()submit: ƒ ()username: (...)_c: ƒ (e,n,r,i)_data: {__ob__: we}_directInactive: false_events: {}_hasHookEvent: false_inactive: null_isBeingDestroyed: false_isDestroyed: false_isMounted: true_isVue: true_renderProxy: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}_self: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}_staticTrees: null_uid: 0_vnode: pe&nbsp;{tag: \"div\", data: {…}, children: Array(11), text: undefined, elm: div#app,&nbsp;…}_watcher: fn&nbsp;{vm: wn, deep: false, user: false, lazy: false, sync: false,&nbsp;…}_watchers: [fn]$data: (...)$isServer: (...)$props: (...)$ssrContext: (...)get $attrs: ƒ ()set $attrs: ƒ (t)get $listeners: ƒ ()set $listeners: ƒ (t)get dataList: ƒ ()set dataList: ƒ (e)get username: ƒ ()set username: ƒ (appwn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}$attrs: (...)$children: []$createElement: ƒ (e,n,r,i)$el: div#app$listeners: (...)$options: {components: {…}, directives: {…}, filters: {…}, _base: ƒ, data: ƒ,&nbsp;…}$parent: undefined$refs: {}$root: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}$scopedSlots: {}$slots: {}$vnode: undefineddataList: (...)load: ƒ ()submit: ƒ ()username: (...)_c: ƒ (e,n,r,i)_data: {__ob__: we}_directInactive: false_events: {}_hasHookEvent: false_inactive: null_isBeingDestroyed: false_isDestroyed: false_isMounted: true_isVue: true_renderProxy: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}_self: wn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}_staticTrees: null_uid: 0_vnode: pe&nbsp;{tag: \"div\", data: {…}, children: Array(11), text: undefined, elm: div#app,&nbsp;…}_watcher: fn&nbsp;{vm: wn, deep: false, user: false, lazy: false, sync: false,&nbsp;…}_watchers: [fn]$data: (...)$isServer: (...)$props: (...)$ssrContext: (...)get $attrs: ƒ ()set $attrs: ƒ (t)get $listeners: ƒ ()set $listeners: ƒ (t)get dataList: ƒ ()set dataList: ƒ (e)get username: ƒ ()set username: ƒ (e)__proto__: Object\n\n\n\n在浏览器控制台输入app.$destroy()\n123app.app.$destroy()beforeDestroydestroyed\n\n\nmounted\n\n\n如果有el，实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。此时数据已经真实渲染到页面上了。mounted 是实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了。\n\n注意：mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：\n\nbeforeUpdate Update当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。\n\nconsole能打印出来并不一定就是有“值”，console当打印出来的是基本数据类型时候当然没问题，否则对于复杂数据类型是会发生改变的，因为只是地址引用而已\n在通过live server在浏览器中，F12或右键inspect-console，点击提交按钮，控制台会输出\n以下代码在浏览器显示是一级标题的test，template: '&lt;h1&gt;test&lt;/h1&gt;'替换了el: '#app'也就是替换了id=\"app\"为&lt;div&gt;的所有内容\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;        &lt;li v-for=\"item in dataList\"&gt;{{ item }}&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({        // el: '#app',        // template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate: () =&gt; {  // 有箭头函数            console.log('beforeCreate')            console.log(this)  // window 指向window            // console.log(this.load())  // 报错，不可以调用vue的实例的方法        },        created() {  // 没有箭头函数            console.log('created')            console.log(this)  // wn  指向vue的实例            console.log(this.load())  // 可以调用vue的实例的方法        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h3&gt;表单操作&lt;/h3&gt;    &lt;input type=\"text\" name=\"username\" v-model=\"username\"&gt;    &lt;input type=\"button\" value=\"提交\" @click=\"submit\"&gt;    &lt;h3&gt;动态列表&lt;/h3&gt;    &lt;input type=\"button\" value=\"加载\" @click=\"load\"&gt;    &lt;ul id=\"list\"&gt;        &lt;li v-for=\"item in dataList\"&gt;{{ item }}&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var app = new Vue({        // el: '#app',        // template: '&lt;h1&gt;test&lt;/h1&gt;',        data: {            username: 'admin',            dataList: []        },        methods: {            submit() {                console.log('获取表单的值：', this.username)            },            load() {                this.dataList = ['北京', '上海', '广州', '深圳']            }        },        beforeCreate: () =&gt; {  // 有箭头函数            console.log('beforeCreate')            console.log(this)  // window 指向window            // console.log(this.load())  // 报错，不可以调用vue的实例的方法        },        created() {  // 没有箭头函数            console.log('created')            console.log(this)  // wn  指向vue的实例            console.log(this.load())  // 可以调用vue的实例的方法        },        beforeMount() {            console.log('beforeMount')        },        mounted() {            console.log('mounted')        },        beforeDestroy() {            console.log('beforeDestroy')        },        destroyed() {            console.log('destroyed')        },        beforeUpdate() {            console.log('beforeUpdate')        },        updated() {            console.log('updated')        }    })&lt;/script&gt;&lt;/body&gt;&lt;/html>\n12345beforeCreateWindow&nbsp;{window: Window, self: Window, document: document, name: \"\", location: Location,&nbsp;…}createdwn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, beforeCreateWindow&nbsp;{window: Window, self: Window, document: document, name: \"\", location: Location,&nbsp;…}createdwn&nbsp;{_uid: 0, _isVue: true, $options: {…}, _renderProxy: wn, _self: wn,&nbsp;…}undefined\n\n\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;p&gt;{{ message }}&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: \"#app\",            data() {                return { message: \"Hello World\" }            },            created: function () {                console.log(\"created\")            },            beforeCreate: function () {                console.log(\"beforeCreate\")            },            beforeMount: function () {                console.log(\"beforeMount\")            },            beforeUpdate: function () {                console.log(\"beforeUpdate\")            },            mounted: function () {                console.log(\"mounted\")            },            beforeDestroy: function () {                console.log(\"beforeDestroy\")            },            updated: function () {                console.log(\"updated\")            },            destroyed: function () {                console.log(\"destroyed\")            }        }        )    &lt;/script&gt;&lt;/body&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue实现&lt;/title&gt;    &lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;p&gt;{{ message }}&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: \"#app\",            data() {                return { message: \"Hello World\" }            },            created: function () {                console.log(\"created\")            },            beforeCreate: function () {                console.log(\"beforeCreate\")            },            beforeMount: function () {                console.log(\"beforeMount\")            },            beforeUpdate: function () {                console.log(\"beforeUpdate\")            },            mounted: function () {                console.log(\"mounted\")            },            beforeDestroy: function () {                console.log(\"beforeDestroy\")            },            updated: function () {                console.log(\"updated\")            },            destroyed: function () {                console.log(\"destroyed\")            }        }        )    &lt;/script&gt;&lt;/body&gt;&lt;/html>\n\n1234beforeCreatecreatedbeforeMountbeforeCreatecreatedbeforeMountmounted\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;  &lt;title&gt;vue生命周期学习&lt;/title&gt;  &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  var vm = new Vue({    el: '#app',    data: {      message: 'Vue的生命周期'    },    beforeCreate: function() {      console.group('------beforeCreate创建前状态------');      console.log(\"%c%s\", \"color:red\" , \"el     : \" + this.$el); //undefined      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //undefined       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message)     },    created: function() {      console.group('------created创建完毕状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el); //undefined      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化    },    beforeMount: function() {      console.group('------beforeMount挂载前状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + (this.$el)); //已被初始化      console.log(this.$el);      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化        console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化      },    mounted: function() {      console.group('------mounted 挂载结束状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el); //已被初始化      console.log(this.$el);          console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化      console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化     },    beforeUpdate: function () {      console.group('beforeUpdate 更新前状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);         console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    updated: function () {      console.group('updated 更新完成状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);       console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    beforeDestroy: function () {      console.group('beforeDestroy 销毁前状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);          console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    destroyed: function () {      console.group('destroyed 销毁完成状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);        console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message)    }  })&lt;/script&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;  &lt;title&gt;vue生命周期学习&lt;/title&gt;  &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  var vm = new Vue({    el: '#app',    data: {      message: 'Vue的生命周期'    },    beforeCreate: function() {      console.group('------beforeCreate创建前状态------');      console.log(\"%c%s\", \"color:red\" , \"el     : \" + this.$el); //undefined      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //undefined       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message)     },    created: function() {      console.group('------created创建完毕状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el); //undefined      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化    },    beforeMount: function() {      console.group('------beforeMount挂载前状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + (this.$el)); //已被初始化      console.log(this.$el);      console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化        console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化      },    mounted: function() {      console.group('------mounted 挂载结束状态------');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el); //已被初始化      console.log(this.$el);          console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data); //已被初始化      console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化     },    beforeUpdate: function () {      console.group('beforeUpdate 更新前状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);         console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    updated: function () {      console.group('updated 更新完成状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);       console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    beforeDestroy: function () {      console.group('beforeDestroy 销毁前状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);          console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message);     },    destroyed: function () {      console.group('destroyed 销毁完成状态===============》');      console.log(\"%c%s\", \"color:red\",\"el     : \" + this.$el);      console.log(this.$el);        console.log(\"%c%s\", \"color:red\",\"data   : \" + this.$data);       console.log(\"%c%s\", \"color:red\",\"message: \" + this.message)    }  })&lt;/script&gt;&lt;/html>\n123456789101112131415161718------beforeCreate创建前状态------el     : undefineddata   : undefinedmessage: undefined------created创建完毕状态------el     : undefineddata   : [object Object]message: Vue的生命周期------beforeMount挂载前状态------el     : [object HTMLDivElement]&lt;div id=​\"app\"&gt;​…​&lt;/div&gt;​data   : [object Object]message: Vue的生命周期------mounted 挂载结束状态------el     : [object HTMLDivElement]&lt;div id=​\"app\"&gt;​…​&lt;/div&gt;​data   : [object Object]------beforeCreate创建前状态------el     : undefineddata   : undefinedmessage: undefined------created创建完毕状态------el     : undefineddata   : [object Object]message: Vue的生命周期------beforeMount挂载前状态------el     : [object HTMLDivElement]&lt;div id=​\"app\"&gt;​…​&lt;/div&gt;​data   : [object Object]message: Vue的生命周期------mounted 挂载结束状态------el     : [object HTMLDivElement]&lt;div id=​\"app\"&gt;​…​&lt;/div&gt;​data   : [object Object]message: Vue的生命周期\n\nVue CLI-快速搭建项目-内置 Babel、 ESlint、 PostCSS等插件-基于 webpack,可灵活配置-图形化的创建和管理工具\nnpm（node package manager）：nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）cnpm:因为npm安装插件是从国外服务器下载，受网络的影响比较大，可能会出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”\nnpm install -g cnpm --registry=https://registry.npm.taobao.orgD:\\Program Files\\nodejs\\node_global\\node_modules\n创建第一个Vue项目\n切换项目路径cd C:\\Vue\\\n命令行创建，vue create project_namevue create hello-world\n图形化界面创建Vue ui\n命令行启动，确定已经切换项目路径npm run serve不是server\n\n项目结构分析理解∨ue的项目结构才能开发单页面应用\n\n文件解释\npackage.json——项目描述文件（包含一些依赖配置）\nvue.config.js——配置文件扩展\nsrc/——源代码\ndist/——构建后的代码（混合、压缩）\npublic/——公共的静态文件\nnode_modules/——项目依赖的安装目录，对应python的site-packages\n\n\n\nvue项目模板\n\nsrc/assets:存放突变\nsrc/components:存放一组件文件\nsrc/App.vue:项目入口文件，我们也可以直接将组建写这里，而不使用Vue根组件，可以通过 render参数从组件渲染\nsrc/mian.js 程序的逻辑入口文件，项目核心文件\n新建目录src/views，存放页面组件123456// vue3 import { createApp } from 'vue'import App from './App.vue'createApp(App).mount('#app')// vue3 import { createApp } from 'vue'import App from './App.vue'createApp(App).mount('#app')// Vue3里面没有全局的Vue，但是有个新的全局API：createApp\n\n\n\n123456789101112// vue2.Ximport Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({    el: '#app',    components: { App },    template: // vue2.Ximport Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({    el: '#app',    components: { App },    template: ''})\npublic/index.html 模板文件\n面向组件编程组件化开发方式把一个页面按照模块拆分成N个小块\n组件带有一个名字：可复用的 Vue 实例，与new vue接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。\n\n按模块划分的前端代码片段\n可复用的前端代码片段，每个组件都会各自独立\n容易维护的前端代码片段一个组件的模板必须有一个根节点为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。\n\n创建局部组件全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。\n创建vue对象，在vue函数的一个参数是一个对象形式，在对象内申明一个compoents属性，在内部进行组件的局部注册对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。\n通过一个普通的 JavaScript 对象来定义组件\n123var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { var ComponentA = { /* ... */ }var ComponentB = { /* ... */ }var ComponentC = { /* ... */ }\n在 components 选项中定义你想要使用的组件\n12345678910new Vue({    el: '#app',    components: {        'component-a': ComponentA,        'component-b': ComponentB,        App: {            template: new Vue({    el: '#app',    components: {        'component-a': ComponentA,        'component-b': ComponentB,        App: {            template: \"\"        }    }})\n\n局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：\n12345678var ComponentA = { /* ... */ }var ComponentB = {  components: {    'component-a': ComponentA  },  var ComponentA = { /* ... */ }var ComponentB = {  components: {    'component-a': ComponentA  },  // ...}\n\n创建全局组件全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。\n\n步骤一:新建组件vue文件，不写.vue后缀12345678910```jsVue.component('my-component-name', {    // … options ...    data: function () {        return {            count: 0        }    },    template: 'You clicked me {{ count }} times.'}\n在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：1new Vue({ el: new Vue({ el: '#components-demo' })\n\n\n\n123456&lt;div id=\"components-demo\"&gt;&lt;!-- 将组件进行任意次数的复用 --&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;&lt;/&lt;div id=\"components-demo\"&gt;&lt;!-- 将组件进行任意次数的复用 --&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;  &lt;my-component-name&gt;&lt;/my-component-name&gt;&lt;/div>\n\n\n步骤二:导入该组件\n步骤三:注册该组件\n步骤四:使用该组件\n\n组件的复用组件中的data属性必须是一个函数一定要在main.js里面。并不是像这样直接提供一个对象：\n123data: {  count: data: {  count: 0}\n取而代之的是，一个组件的 data 选项必须是一个函数，\n\n因此每个实例可以维护一份被返回对象的独立的拷贝：\n\n12345data: function () {  return {    count: data: function () {  return {    count: 0  }}\n\n在模块系统中局部注册使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。然后你需要在局部注册之前导入每个你想使用的组件。使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。\n例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中：\n12345678910import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default {  components: {    ComponentA,    ComponentC  },  import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default {  components: {    ComponentA,    ComponentC  },  // ...}\n现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了\n基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。\n所以会导致很多组件里都会有一个包含基础组件的长列表：\n1234567891011import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default {  components: {    BaseButton,    BaseIcon,    BaseInput  }}\n而只是用于模板中的一小部分：\n1234567&lt;BaseInput  v-model=\"searchText\"  @keydown.enter=\"search\"/&gt;&lt;BaseButton @click=\"search\"&gt;  &lt;BaseIcon name=\"search\"/&gt;&lt;/&lt;BaseInput  v-model=\"searchText\"  @keydown.enter=\"search\"/&gt;&lt;BaseButton @click=\"search\"&gt;  &lt;BaseIcon name=\"search\"/&gt;&lt;/BaseButton>\n\n如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：\n12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context(  // 其组件目录的相对路径  './components',  // 是否查询其子目录  false,  // 匹配基础组件文件名的正则表达式  /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; {  // 获取组件配置  const componentConfig = requireComponent(fileName)  // 获取组件的 PascalCase 命名  const componentName = upperFirst(    camelCase(      // 获取和目录深度无关的文件名      fileName        .split('/')        .pop()        .replace(/\\.\\w+$/, '')    )  )  // 全局注册组件  Vue.component(    componentName,    // 如果这个组件选项是通过 `export default` 导出的，    // 那么就会优先使用 `.default`，    import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context(  // 其组件目录的相对路径  './components',  // 是否查询其子目录  false,  // 匹配基础组件文件名的正则表达式  /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; {  // 获取组件配置  const componentConfig = requireComponent(fileName)  // 获取组件的 PascalCase 命名  const componentName = upperFirst(    camelCase(      // 获取和目录深度无关的文件名      fileName        .split('/')        .pop()        .replace(/\\.\\w+$/, '')    )  )  // 全局注册组件  Vue.component(    componentName,    // 如果这个组件选项是通过 `export default` 导出的，    // 那么就会优先使用 `.default`，    // 否则回退到使用模块的根。    componentConfig.default || componentConfig  )})\n记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。\n模板语法\n显示普通文本&lt;span&gt;消息内容:{{msg}}&lt;/span&gt;\nJavaScript表达式{{ msg.split('').reverse.join('')}}{{ result &gt;0? 'YES':'NO'}}\n\n指令(Directives)是带有v-前缀的特殊属性\n\n富文本(HTML)span V-html=\"rawHtml\"&gt;&lt;/span&gt;\n普通文本(textspan V-text=\"rawHtml\"&gt;&lt;/span&gt;\n\nV-bind\n作用响应式的更新HTML属性\n\n常用的场景设置 class, style、href、src等&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;等同于&lt;a :href=\"url\"&gt;...&lt;/a&gt;\n\n设置class\n\n对象语法v-bind:class=\"{active:isActive, 'text-danger': hasError }\n数组语法bind:class=\"[{ active:isActive }, errorClass]\"加冒号:是v-bind语法\n\n\n设置style\n\n对象语法v-bind:style=\"{ color: activeColor, fontSize:fontSize +'px'}\"\n\n数组语法v-bind:style=\"[baseStyles, overridingStyles]\"\n\n浏览器适配(默认自动适配):style=\"{display:['-Webkit-box', '-ms-flexbox','flex']}\n\n\n\n\nv-if123456不满足条件时，在dom里面找不到元素```html=90\">A=80\">B=60\">CD\n\nv-show通过切换css的 display属性来控制元素的显示与隐藏不满足条件时，在dom里面能找到元素\n1&lt;h1 v-show=\"hasError\"&gt;还有错误哦!&lt;/&lt;h1 v-show=\"hasError\"&gt;还有错误哦!&lt;/h1>\n\nV-tor\n基本语法\n12&lt;li v-for=\"item in items\" :key=\"item id\"&gt;&lt;/li&gt;&lt;div v-for=\"item of items\"&gt;&lt;/&lt;li v-for=\"item in items\" :key=\"item id\"&gt;&lt;/li&gt;&lt;div v-for=\"item of items\"&gt;&lt;/div>\nkey的作用渲染性能优化（修改DOM还是替换DOM）\n\n渲染数组\n123&lt;li v-for=\"(item, index) in items\" :key=\"index\"&gt;{{index}}-{{item.message}}&lt;/&lt;li v-for=\"(item, index) in items\" :key=\"index\"&gt;{{index}}-{{item.message}}&lt;/li>\n\n渲染对象\n123&lt;li v-for=\"(value, key, index) in object\" :key=\"index\"&gt;{{index}}.{{key}}:{{value}}&lt;/&lt;li v-for=\"(value, key, index) in object\" :key=\"index\"&gt;{{index}}.{{key}}:{{value}}&lt;/li>\n\n\n\nv-on 指令监听 DOM 事件v-on指令后面“:”后的参数是要触发的事件类型。v-on的事件类型由参数指定。&lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt;&lt;button @click=\"counter += 1\"&gt;Add 1&lt;/button&gt;\n鼠标事件修饰符\n阻止事件冒泡&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;\n阻止默认行为&lt;a v-on:click.prevent=\"doThis\"&gt;&lt;/a&gt;\n点击事件只触发一次&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;\n\n键盘事件\n监听事件 每次输入键盘抬起的时候&lt;input type=\"text\" v-on:keyup=\"submit\"&gt;&lt;input type=\"text\" @keyup=\"submit\"&gt;\n\n监听回车键&lt;input type=\"text\" v-on:keyup.enter=\"submit\"&gt;&lt;input type=\"text\" @keyup.enter=\"submit\"&gt;\n\n监听删除、退格键&lt;input type=\"text\" v-on:keyup.delete=\"submit\"&gt;```&lt;input type=”text” @keyup=”submit”&gt;``\n\n\n表单输入绑定\n基本语法&lt;input v-model=\"message\"&gt;\n\n单选、多选的绑定\n123456&lt;select v-model=\"hobby\"&gt;  &lt;option :value=\"opion\"   v-for=\"(opion, index) in opitons\"  :key=\"index\"&gt;{{opion.text}}&lt;/option&gt;&lt;/select&gt;&lt;span&gt;您选择了： {{hobby.text}}&lt;/&lt;select v-model=\"hobby\"&gt;  &lt;option :value=\"opion\"   v-for=\"(opion, index) in opitons\"  :key=\"index\"&gt;{{opion.text}}&lt;/option&gt;&lt;/select&gt;&lt;span&gt;您选择了： {{hobby.text}}&lt;/span>\n修饰符：检索代码量\n123456789101112131415161718```number```自动转为数值类型### 过滤器是一个JavaScript函数但是在 vue3.x 中过滤器属性已删除，不再支持#### 过滤器的注册- 在组件内注册,在该组件内使用```js  filters: {    priceFormat: function(price) {      /**       * 过滤器的内容 格式化价格显示       */      if (price === undefined || price === null || isNaN(price)) {        return price       }        return '￥' + (price).toFixed(2)    }  }\n\n过滤器的使用\n方式一:在双大括号中 已经过时？{{ message |priceFormat }}\n方式二:在v-bind中&lt;div v-bind:id=\"rawld | priceFormat\"&gt;&lt;/div&gt;\n\n\n\n\n全局注册,在所有组件内均可使用\n\n\n123Vue.filter('priceFormat', function(value){    Vue.filter('priceFormat', function(value){    //过滤器的内容})\n\n组件中的常见的通信方式\n\n参数传递\n全局共享\n浏览器的存储(storage、 cookie)\nVuex\n\n\n\n父组件到子组件的数据传递\n\n传递方式为子组件定义props属性\n\n传递的数据类型数值、布尔值、数组、对象\n\n添加数据类型验证 \n123456props: {  userName1: {    type:String,    required:props: {  userName1: {    type:String,    required:true  }},\n\n设置默认值 \n123456props: {  userName1: {    type:Number,    default:props: {  userName1: {    type:Number,    default:true  }},\n\n\n\ntype所支持的类型\n\nString:字符串\nObject:对象\nNumber:数字\nDate:日期\nBoolean:布尔值\nFunction:方法/函数\nArray:数组\nSymbol\n\n子组件到父组件的数据传递\n\n在子组件触发自定义事件this.$emit('myEvent')\n在父组件监听事件&lt;my-component v-on:myEvent=\"doSomething\"&gt;&lt;my-component&gt;\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["前端"],"tags":["Vue","前端"]},{"title":"剑指offer40 -50","url":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer40-50/","content":"字符串比较大小就是字典序的大小字符串的比较是通过 内置函数 ord() 获得每个字符的 Unicode 编码进行大小比较\n单个字符常见ASCII码的大小规则：0～9　&lt;　A～Z　&lt;　a～z。1）数字比字母要小。如 “7”&lt;“F”；2）数字0比数字9要小，并按0到9顺序递增。3）字母A比字母Z要小，并按A到Z顺序递增。4）同个字母的大写字母比小写字母要小32。如“A”&lt;“a” 。\n多个字符按位进行字符比对，从字符串的第一个字符开始比较，谁的ASCII码大谁就大。只有首字符相同、再去比较下一个字符，以此类推。如果都相同则相等\n123456789101112print('xnjilhntm'=='xnjilhntm')   # Trueprint('xnjilhntm'&lt;'xnjilhntz')  # Trueprint('abbbbbbb'&gt;'b')  # Falseprint(''&gt;'a')  # Falseprint('A'&gt;'a')  # Falseprint('3' &gt; '20' &gt; '100')  # Trueprint('20' &lt; '200')  # Trueprint(max(['1', '2', '3']))  # 3print(max(['31', '2', '3']))  # 31print(max(['13', '2', '3']))  # 3print(max(['10', '11', '12']))  print('xnjilhntm'=='xnjilhntm')   # Trueprint('xnjilhntm'&lt;'xnjilhntz')  # Trueprint('abbbbbbb'&gt;'b')  # Falseprint(''&gt;'a')  # Falseprint('A'&gt;'a')  # Falseprint('3' &gt; '20' &gt; '100')  # Trueprint('20' &lt; '200')  # Trueprint(max(['1', '2', '3']))  # 3print(max(['31', '2', '3']))  # 31print(max(['13', '2', '3']))  # 3print(max(['10', '11', '12']))  # 12\n\n179. 最大数给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。\n注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n示例 1：\n12输入：nums = [10,2]输出：输入：nums = [10,2]输出：\"210\"\n示例 2：\n12输入：nums = [3,30,34,5,9]输出：输入：nums = [3,30,34,5,9]输出：\"9534330\"\n示例 3：\n12输入：nums = [1]输出：输入：nums = [1]输出：\"1\"\n示例 4：\n12输入：nums = [10]输出：输入：nums = [10]输出：\"10\"\n\n想法为了构建最大数字，希望越高位的数字越大越好。\n设计一个类似从高位开始的基数排序。但在处理不同位长数的排序时，我发现很难给出一个统一的大小判别规律，例如962,96,9的最优排序是996962，而162,16,1的最优排序是162161。因此这个思路就只能毙掉了\n算法首先，将每个整数变成字符串。然后进行排序。如果仅按降序排序，有相同的开头数字的时候会出现问题。比方说，样例 2 按降序排序得到的数字是 95343303 ，然而交换 3 和 30 的位置可以得到正确答案 9534330 。\n例如962,96,9962,96,9的最优排序是996962996962,而162,16,1162,16,1的最优排序是162161162161。\n因此，每一对数在排序的比较过程中，比较两种连接顺序哪一种更好。可以证明这样的做法是正确的：\n假设（不是一般性），某一对整数 a 和 b ，的比较结果是 a 应该在 b 前面，这意味着 a⌢b&gt;b⌢a ，其中 ⌢ 表示连接。如果排序结果是错的，说明存在一个 c ， b 在 c 前面且 c 在 a 的前面。这产生了矛盾，因为 a⌢b&gt;b⌢a 和 b⌢c&gt;c⌢b 意味着 a⌢c&gt;c⌢a 。换言之，我们的自定义比较方法保证了传递性，所以这样子排序是对的。\n一旦数组排好了序，最“重要”的数字会在最前面。有一个需要注意的情况是如果数组只包含 0 ，我们直接返回结果 0 即可。否则，我们用排好序的数组形成一个字符串并返回。\n反证法：假设存在一个最大序列不满足该排序规则，那么至少存在两个数字的顺序不按上述传递性的定义排列，如……s2s1…….，其中s2s1 &lt; s1s2。接下来，其他字符串的位置不变，按照传递性定义，将s2和s1交换位置后，可证明……s1s2…… &gt; ……s2s1……，这与假设不符，即……s2s1…….并不是最大序列，所以最优序列必定满足上述传递性的定义。\n已知：s1应该在s2前边，s2应该在s3前边；求证：s1应该在s3前边。证明：假设“s3在s1前面”成立，则结合已知“s2应该在s3前边”，推出“s2在s1前面”，与已知“s1应该在s2前边”矛盾，故假设不成立，得证。\n\n时间复杂度：O(nlgn)尽管我们在比较函数中做了一些额外的工作，但是这只是一个常数因子。\n\n空间复杂度：O(n)用了 O(n) 的额外空间去保存 nums 的副本。尽管我们就地进行了一些额外的工作，但最后返回的数组需要 O(n) 的空间。因此，需要的额外空间与 nums 大小成线性关系。\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849```key```仅仅支持接受一个参数的函数，该函数用于从从每个被排序元素中提取一个比较键(例如，key=str.lower)。对列表中每个项对应的键计算一次，并返回另一个用以排序的值的可调用对象用于整个排序过程。None的默认值意味着列表项是直接排序的，不需要计算单独的键值。就无法实现两个参数之间的对比这里传入一个类名，生成的实际上是这个类对象。>```sorted()```在对元素进行默认排序是从低到高时会用到小于号<经历如下过程：- 从元素a(用a指代待排序列表中的元素)中提取比较键：LargerNumKey(a)类对象- 比较这些类对象的大小，<调用LargerNumKey类的自定义的富比较函数__lt__进行排序. 这样就实现了按自定义排序规则进行排序。```pyfrom typing import Listclass LargerNumKey(str):    # LargerNumKey类继承了字符串str类，数组中所有元素类型改为字符串    # 所以可以直接使用类名作为函数    def __lt__(x, y):        \"\"\"重写了富比较方法\"\"\"        # x 就是 self, 正常点的写法 就是 __lt__(self, y)        # self 只是惯例，可以叫其他名字        # 本题根据官方题解的字符排列传导性，        # x + y > y + x 等价于 x 必须排在 y 的前面，即compare函数返回 -1        # x + y < y + x 等价于 y 必须排在 x 的前面，即compare函数返回 1        return x + y > y + xclass Solution:    def largestNumber(self, nums: List[int]) -> str:        # key指向一个类，利用了类的实例化生成类对象用作比较键。        # sorted(map(str, nums), key=LargerNumKey) 比较的是字符串大小，我之前想的是根据 __lt__(x, y) 返回的布尔值比较大小。        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))        # If, after being sorted, the largest number is `0`, the entire number is zero.        return '0' if largest_num[0] == '0' else largest_numif __name__ == \"__main__\":    arr = [10, 3, 20]    s = Solution()    print(s.largestNumber(arr))  # 32010    print(s.largestNumber([824, 8247]) == '8248247')    print(s.largestNumber([0, 0]) == '0')    print(s.largestNumber([1, 1, 1]) == '111')    print(s.largestNumber([3, 30, 34, 5, 9]) == \"9534330\")    print(s.largestNumber([10, 2]) == '210')    print(s.largestNumber([0, 2]) == '20')    print(s.largestNumber([1]) == '1')    print(s.largestNumber([0]) == '0')\n\n1234567891011121314151617181920212223242526272829arr = [10, 3, 20]key=LargerNumKey继承 str 的，把int变成strx 就是 self开始执行sort()默认排序是从低到高，两个元素比较用到小于号&lt;，调用__lt__(x, y)__lt__('3', '10')x = '3' y = '10'  '3' + '10' &gt; '10' + '3'  返回True所以 '3' &lt; '10'为 True__lt__('20', '3')x = '20' y = '3'  '20' + '3' &gt; '3' + '20'  返回False所以 '20' &lt; '3'为 False即'3' &lt; '20'为 True__lt__('20', '10')x = '20' y = '10'  '20' + '10' &gt; '10' + '20'  返回True所以 '20' &lt; '10'为 True所以\"10\", \"3\", \"20\"的从小到大的顺序为[\"3\", \"20\", \"10\"]largest_num = ''.join([\"3\", \"20\", \"10\"]) = '32010'largest_num[0] == arr = [10, 3, 20]key=LargerNumKey继承 str 的，把int变成strx 就是 self开始执行sort()默认排序是从低到高，两个元素比较用到小于号&lt;，调用__lt__(x, y)__lt__('3', '10')x = '3' y = '10'  '3' + '10' &gt; '10' + '3'  返回True所以 '3' &lt; '10'为 True__lt__('20', '3')x = '20' y = '3'  '20' + '3' &gt; '3' + '20'  返回False所以 '20' &lt; '3'为 False即'3' &lt; '20'为 True__lt__('20', '10')x = '20' y = '10'  '20' + '10' &gt; '10' + '20'  返回True所以 '20' &lt; '10'为 True所以\"10\", \"3\", \"20\"的从小到大的顺序为[\"3\", \"20\", \"10\"]largest_num = ''.join([\"3\", \"20\", \"10\"]) = '32010'largest_num[0] == '3'\n\n1234567891011class StrLt(str):    def __lt__(self, y):        return self + y &gt; y + selfclass Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        nums.sort(key=StrLt)        res = \"\".join(map(str, nums))        return \"0\" if res[0] == \"0\" class StrLt(str):    def __lt__(self, y):        return self + y &gt; y + selfclass Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        nums.sort(key=StrLt)        res = \"\".join(map(str, nums))        return \"0\" if res[0] == \"0\" else res\n\n把sorted的reverse参数设置为True，排序的顺序是大到小。__lt__方法的返回值和小于的原意一样，可以直接用&lt;、&gt;来比较两个类实例的大小关系，也可以将类传入sorted和sort函数的key参数中，用于类元素组成的序列等的排序。\n12345678910class LargerNumKey(str):    def __lt__(x, y):        return x + y &lt; y + xclass Solution:    def largestNumber(self, nums):        largest_num = ''.join(            sorted(map(str, nums), key=LargerNumKey, reverse=True))        return '0' if largest_num[0] == '0' class LargerNumKey(str):    def __lt__(x, y):        return x + y &lt; y + xclass Solution:    def largestNumber(self, nums):        largest_num = ''.join(            sorted(map(str, nums), key=LargerNumKey, reverse=True))        return '0' if largest_num[0] == '0' else largest_num\n12345678910class LargerNumKey(str):    def __gt__(x, y):        return x + y &gt; y + xclass Solution:    def largestNumber(self, nums):        largest_num = ''.join(            sorted(map(str, nums), key=LargerNumKey, reverse=True))        return '0' if largest_num[0] == '0' class LargerNumKey(str):    def __gt__(x, y):        return x + y &gt; y + xclass Solution:    def largestNumber(self, nums):        largest_num = ''.join(            sorted(map(str, nums), key=LargerNumKey, reverse=True))        return '0' if largest_num[0] == '0' else largest_num\n\n法二不再让LargerNumKey类去继承str类，这个函数的比较实现依赖传入参数value的类型，只要value类型支持‘+’和比较运算符，这个函数就能正常工作。\n123456789101112class LargerNumKey:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value + other.value &gt; other.value + self.valueclass Solution:    def largestNumber(self, nums):        ans = ''.join(sorted(map(str, nums), key=LargerNumKey))        return '0' if ans[0] == '0' class LargerNumKey:    def __init__(self, value):        self.value = value    def __lt__(self, other):        return self.value + other.value &gt; other.value + self.valueclass Solution:    def largestNumber(self, nums):        ans = ''.join(sorted(map(str, nums), key=LargerNumKey))        return '0' if ans[0] == '0' else ans\n\n123456789101112131415161718class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        class cmp_large:            def __init__(self, value):                self.value = str(value)            def __lt__(self, other):                return self.value + other.value &gt; other.value + self.value            def __gt__(self, other):                return self.value + other.value &lt; other.value + self.value            def __eq__(self, other):                return self.value + other.value == other.value + self.value        res = [cmp_large(value) for value in nums]        ans = \"\".join(a.value for a in sorted(res))        return '0' if ans[0] == '0' class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        class cmp_large:            def __init__(self, value):                self.value = str(value)            def __lt__(self, other):                return self.value + other.value &gt; other.value + self.value            def __gt__(self, other):                return self.value + other.value &lt; other.value + self.value            def __eq__(self, other):                return self.value + other.value == other.value + self.value        res = [cmp_large(value) for value in nums]        ans = \"\".join(a.value for a in sorted(res))        return '0' if ans[0] == '0' else ans\n\n12345678class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        class large_num(str):            def __lt__(self, other):                return self + other &gt; other + self        largest_num = \"\".join(sorted(map(str, nums), key=large_num))        return '0' if largest_num[0] == '0' class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        class large_num(str):            def __lt__(self, other):                return self + other &gt; other + self        largest_num = \"\".join(sorted(map(str, nums), key=large_num))        return '0' if largest_num[0] == '0' else largest_num\n\n假设a,b,c分别有m,n,k位数ab &gt; ba =&gt; a * 10^n + b &gt; b * 10^m+ abc &gt; cb =&gt; b * 10^k + c &gt; c * 10^n + b)可以推出: a * 10^k + c &gt; c * 10^m + a =&gt; ac &gt; caa=123 b=34，m=3,n=2ab=12334=123*10^2+34;\n法三：cmp_to_key 函数，接收比较函数cmp(x, y) 接受两个参数用于比较 2 个对象\n\n返回1，是 x &gt; y，\n返回-1，表示 x &lt; y，\n返回0，表示 x == y\n\n1234567891011121314class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        def cmp(x, y):            if x + y &gt; y + x:                return -1            elif x + y &lt; y + x:                return 1            else:                return 0        ans = \"\".join(sorted(map(str, nums), key=cmp_to_key(cmp)))        return '0' if ans[0] == '0' class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        def cmp(x, y):            if x + y &gt; y + x:                return -1            elif x + y &lt; y + x:                return 1            else:                return 0        ans = \"\".join(sorted(map(str, nums), key=cmp_to_key(cmp)))        return '0' if ans[0] == '0' else ans\n\n123456789nums = [3, 20]cmp(x, y)cmp('20', '3')'20' + '3' &lt; '3' + '20''203' &lt; '320'return 1'20' &gt; '3' '3' &lt; nums = [3, 20]cmp(x, y)cmp('20', '3')'20' + '3' &lt; '3' + '20''203' &lt; '320'return 1'20' &gt; '3' '3' &lt; '20'\n\n\n123456789101112131415class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        def cmp(a, b):  # eg.30&lt;3            if a + b &lt; b + a:  # 30+3&lt;3+30-&gt;-1                return -1            elif a + b &gt; b + a:                return 1            else:                return 0        res = ''.join(            sorted(map(str, nums), key=cmp_to_key(cmp), reverse=True))        return '0' if res[0] == '0' class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        def cmp(a, b):  # eg.30&lt;3            if a + b &lt; b + a:  # 30+3&lt;3+30-&gt;-1                return -1            elif a + b &gt; b + a:                return 1            else:                return 0        res = ''.join(            sorted(map(str, nums), key=cmp_to_key(cmp), reverse=True))        return '0' if res[0] == '0' else res\n\n12345678nums = [3, 20]cmp(x, y)cmp('3', '20')'3' + '20' &gt; '20' + '3''320' &gt; '203'return 1'3' &gt; nums = [3, 20]cmp(x, y)cmp('3', '20')'3' + '20' &gt; '20' + '3''320' &gt; '203'return 1'3' &gt; '20' \n\n12345678910111213141516171819nums = [3, 20]cmp(x, y)cmp('3', '20')'3' + '20' &gt; '20' + '3'return 1'3' &gt; '20' cmp('10', '3')'10' + '3' &lt; '3' + '10'return -1'10' &lt; '3' '3' &gt; '10' cmp('10', '20')'10' + '20' &lt; '20' + '10'return -1'10' &lt; '20' '20' &gt; nums = [3, 20]cmp(x, y)cmp('3', '20')'3' + '20' &gt; '20' + '3'return 1'3' &gt; '20' cmp('10', '3')'10' + '3' &lt; '3' + '10'return -1'10' &lt; '3' '3' &gt; '10' cmp('10', '20')'10' + '20' &lt; '20' + '10'return -1'10' &lt; '20' '20' &gt; '10' \n\n如果是int对象比较大小，一般用 x - y来返回，这样就可以很形象的体现两者之间的位置关系了。把数字转换成字符串。然后需要定义一种比较两个数的规则，即把数字m和n拼接为mn，nm，只需要按照字符串大小的比较。\n12345678910class Solution:    def largestNumber(self, nums):        from functools import cmp_to_key        def str_cmp(a, b):            return int(a + b) - int(b + a)        strs = [str(i) for i in nums]        strs.sort(key=cmp_to_key(str_cmp), reverse=True)        return str(int(class Solution:    def largestNumber(self, nums):        from functools import cmp_to_key        def str_cmp(a, b):            return int(a + b) - int(b + a)        strs = [str(i) for i in nums]        strs.sort(key=cmp_to_key(str_cmp), reverse=True)        return str(int(''.join(strs)))\n\n123456789101112131415161718192021strs = ['10', '3', '20']cmp('3', '20')int(a + b) - int(b + a)int('3' + '20') - int('20' + '3')320 - 203 = 117'3' &gt; '20' cmp('10', '3')int('10' + '3') - int('3' + '10')103 - 310 = -207 '10' &lt; '3' '3' &gt; '10' cmp('10', '20')int('10' + '20') - int('20' + '10')1020 - 2010 = -990'10' &lt; '20' '20' &gt; '10' -990 &lt; -207 &lt; 117strs = ['3', '20', strs = ['10', '3', '20']cmp('3', '20')int(a + b) - int(b + a)int('3' + '20') - int('20' + '3')320 - 203 = 117'3' &gt; '20' cmp('10', '3')int('10' + '3') - int('3' + '10')103 - 310 = -207 '10' &lt; '3' '3' &gt; '10' cmp('10', '20')int('10' + '20') - int('20' + '10')1020 - 2010 = -990'10' &lt; '20' '20' &gt; '10' -990 &lt; -207 &lt; 117strs = ['3', '20', '10']\n\n返回大于0的值代表x&gt;y，令x排在y后面\n12345678class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        # 比较两个数xy和yx的大小        key = cmp_to_key(lambda x, y: int(y + x) - int(x + y))        # lstrip() 方法: 截掉字符串左边的空格或指定字符  0012-&gt;12        res = ''.join(sorted(map(str, nums), key=key)).lstrip('0')        return res or class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        from functools import cmp_to_key        # 比较两个数xy和yx的大小        key = cmp_to_key(lambda x, y: int(y + x) - int(x + y))        # lstrip() 方法: 截掉字符串左边的空格或指定字符  0012-&gt;12        res = ''.join(sorted(map(str, nums), key=key)).lstrip('0')        return res or '0'\n\n冒泡把需要判断的两个连续的字符串连起来，直接比较大小，然后根据比较的大小来决定需不需要做交换。\n12345678class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        for i in range(len(nums)):            for j in range(0,len(nums)-i-1):                if str(nums[j]) + str(nums[j+1]) &lt; str(nums[j+1])+ str(nums[j]):                    nums[j] ,nums[j+1] =nums[j+1], nums[j]        res=\"\".join(str(i) for i in nums)        return \"0\" if nums[0]==0 class Solution:    def largestNumber(self, nums: List[int]) -&gt; str:        for i in range(len(nums)):            for j in range(0,len(nums)-i-1):                if str(nums[j]) + str(nums[j+1]) &lt; str(nums[j+1])+ str(nums[j]):                    nums[j] ,nums[j+1] =nums[j+1], nums[j]        res=\"\".join(str(i) for i in nums)        return \"0\" if nums[0]==0 else res\n123456789101112class Solution(object):    def largestNumber(self, nums):        for i in range(len(nums)):            for j in range(len(nums) - i - 1):                if str(nums[j]) + str(nums[j + 1]) &gt; str(nums[j + 1]) + str(nums[j]):                    nums[j], nums[j + 1] = nums[j + 1], nums[j]        s = ''        if nums[-1] == 0:            return('0')        for i in nums:            s = str(i) + s        class Solution(object):    def largestNumber(self, nums):        for i in range(len(nums)):            for j in range(len(nums) - i - 1):                if str(nums[j]) + str(nums[j + 1]) &gt; str(nums[j + 1]) + str(nums[j]):                    nums[j], nums[j + 1] = nums[j + 1], nums[j]        s = ''        if nums[-1] == 0:            return('0')        for i in nums:            s = str(i) + s        return s\n\n本质是排序算法，只是在判断大小的地方，把直接通过数学&lt;、&gt;的地方改成compare函数；快速排序实现\n1234567891011121314151617181920212223242526class Solution(object):    def largestNumber(self, nums):        self.quickSort(nums, 0, len(nums) - 1)        # 边界case        if nums[0] == 0:            return \"0\"        return \"\".join((str(n) for n in nums))    def quickSort(self, nums, L, R):        if L &lt; R:            p = self.partition(nums, L, R)            self.quickSort(nums, L, p - 1)            self.quickSort(nums, p + 1, R)    def partition(self, nums, L, R):        plv = nums[L]        i = L + 1        j = R        while i &lt;= j:            if self.custom_compare(nums[i], plv) == -1:                i += 1                continue            if self.custom_compare(nums[j], plv) == class Solution(object):    def largestNumber(self, nums):        self.quickSort(nums, 0, len(nums) - 1)        # 边界case        if nums[0] == 0:            return \"0\"        return \"\".join((str(n) for n in nums))    def quickSort(self, nums, L, R):        if L &lt; R:            p = self.partition(nums, L, R)            self.quickSort(nums, L, p - 1)            self.quickSort(nums, p + 1, R)    def partition(self, nums, L, R):        plv = nums[L]        i = L + 1        j = R        while i &lt;= j:            if self.custom_compare(nums[i], plv) == -1:                i += 1                continue            if self.custom_compare(nums[j], plv) == 1:\n\n\n剑指 Offer 45. 把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0\n\n示例 1:\n12输入: [10,2]输出: 输入: [10,2]输出: \"102\"\n\n示例 2:\n12输入: [3,30,34,5,9]输出: 输入: [3,30,34,5,9]输出: \"3033459\"\n\n本题的“数字”指的就是每个元素整体\n放数字的顺序肯定是先放第一位(最左边一位)最小的元素，如果第一位相等，比较第二位….，以此类推。排列大小比较和字符串大小有点区别，比如 3 和 30，明显 30 排在前面比较好，\n1print(ord(\"3\" &gt; \"30\"))  print(ord(\"3\" &gt; \"30\"))  # TypeError: ord() expected a character, but string of length 2 found\n1234字典序方法\"330\" &gt; \"303\"\"3\" + \"30\" &gt; \"30\" + \"3\"\"3\" &gt; 字典序方法\"330\" &gt; \"303\"\"3\" + \"30\" &gt; \"30\" + \"3\"\"3\" &gt; \"30\"\n\n解题思路：\n\n此题求拼接起来的 “最小数字” ，本质上是一个排序问题。\n\n排序判断规则： 设 nums 任意两数字的字符串格式 x 和 y ，则\n\n若拼接字符串 x + y &gt; y + x ，则 x &gt; y ；\n反之，若 x + y &lt; y + x ，则 x &lt; y ；不能加等于，要执行严格弱序，编译器发现相等会反序参数调用。也就是说a compare b和b compare a的结果必须是相反的。  \n\n\n根据以上规则，套用任何排序方法对 nums 执行排序即可。\n\n\n算法流程：\n\n初始化： 字符串列表 strs ，保存各数字的字符串格式；\n列表排序： 应用以上 “排序判断规则” ，对 strs 执行排序；\n返回值： 拼接 strs 中的所有字符串，并返回。\n\n复杂度分析：时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度 ≤ N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2) 。空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。\n法一快速排序：\n\n需修改快速排序函数中的排序判断规则。字符串大小（字典序）对比的实现方法：\n\n跟 l 还是 r 比取决于我们把哪个元素看作”哨兵“，跟 l 比也可以，如果要用 l ，哨兵 i, j 的移动先后顺序也要对换因为最后要把 strs[i], strs[l] 交换，因此要保证 ``strs[i] &gt; strs[l]` （和 r 的情况正好相反），这样交换后才符合快排定义。\n123456789101112131415161718192021class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        arr = [str(i) for i in nums]        def quick_sort(left, right):            if left &gt;= right: return             low, high = left, right            target = arr[left]            while left &lt; right:                while left &lt; right and arr[right] + target &gt;= target + arr[right] : right -= 1                arr[left] = arr[right]                while left &lt; right and arr[left] + target &lt;= target + arr[left]: left += 1                arr[right] = arr[left]                        arr[left] = target            quick_sort(low, left-1)            quick_sort(right+1, high)        quick_sort(0, len(arr)-1)        return class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        arr = [str(i) for i in nums]        def quick_sort(left, right):            if left &gt;= right: return             low, high = left, right            target = arr[left]            while left &lt; right:                while left &lt; right and arr[right] + target &gt;= target + arr[right] : right -= 1                arr[left] = arr[right]                while left &lt; right and arr[left] + target &lt;= target + arr[left]: left += 1                arr[right] = arr[left]                        arr[left] = target            quick_sort(low, left-1)            quick_sort(right+1, high)        quick_sort(0, len(arr)-1)        return ''.join(arr)\n\n1234567891011121314151617181920212223242526272829from typing import Listclass Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def fast_sort(l, r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; j:                    j -= 1  # 先移动 j                while strs[i] + strs[l] &lt;= strs[l] + strs[i] and i &lt; j:                    i += 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[l] = strs[l], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)        strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1)        return ''.join(strs)if __name__ == '__main__':    solution = Solution()    nums1 = [10, 2]    nums2 = [3, 30, 34, 5, 9]    print(solution.minNumber(nums1))  # 102    from typing import Listclass Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def fast_sort(l, r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; j:                    j -= 1  # 先移动 j                while strs[i] + strs[l] &lt;= strs[l] + strs[i] and i &lt; j:                    i += 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[l] = strs[l], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)        strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1)        return ''.join(strs)if __name__ == '__main__':    solution = Solution()    nums1 = [10, 2]    nums2 = [3, 30, 34, 5, 9]    print(solution.minNumber(nums1))  # 102    # print(solution.minNumber(nums2))  # 3033459\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576nums = [3, 30, 34, 5, 9]strs = ['3', '30', '34', '5', '9']fast_sort(0, len(strs) - 1)fast_sort(0, 5 - 1)fast_sort(0, 4)i = l = 0, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[0] &gt; strs[0] + strs[4] and 0 &lt; 4'9' + '3' &gt; '3' + '9' and 0 &lt; 4j = j - 1 = 4 - 1 = 0 = 3strs[3] + strs[0] &gt; strs[0] + strs[3] and 0 &lt; 3'5' + '3' &gt; '3' + '5' and 0 &lt; 3j = j - 1 = 3 - 1 = 0 = 2strs[2] + strs[0] &gt; strs[0] + strs[2] and 0 &lt; 2'34' + '3' &gt; '3' + '34' and 0 &lt; 2j = j - 1 = 2 - 1 = 0 = 1strs[1] + strs[0] &lt; strs[0] + strs[1] and 0 &lt; 1'30' + '3' &lt; '3' + '30' and 0 &lt; 1i = i + 1 = 0 + 1 = j strs[i], strs[j] = strs[j], strs[i]strs[1], strs[1] = strs[1], strs[1]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[1], strs[0] = strs[0], strs[1]strs = ['30', '3', '34', '5', '9']fast_sort(l, i - 1)fast_sort(0, 1 - 1)fast_sort(0, 0)i = 0 = jreturnfast_sort(i + 1, r)fast_sort(1 + 1, 4)fast_sort(2, 4)i = l = 2, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[2] &gt; strs[2] + strs[4] and 2 &lt; 4'9' + '34' &gt; '34' + '9' and 2 &lt; 4j = j - 1 = 4 - 1 = 0 = 3strs[3] + strs[2] &gt; strs[2] + strs[3] and 2 &lt; 3'5' + '34' &gt; '34' + '5' and 2 &lt; 3j = j - 1 = 3 - 1 = 0 = 2 = istrs[i], strs[j] = strs[j], strs[i]strs[2], strs[2] = strs[2], strs[2]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[2], strs[2] = strs[2], strs[2]strs = ['30', '3', '34', '5', '9']fast_sort(l, i - 1)fast_sort(2, 2 - 1)fast_sort(2, 1)returnfast_sort(i + 1, r)fast_sort(2 + 1, 4)fast_sort(3, 4)i = l = 3, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[3] &gt; strs[3] + strs[4] and 3 &lt; 4'9' + '5' &gt; '5' + '9' and 3 &lt; 4j = j - 1 = 4 - 1 = 0 = 3 = istrs[i], strs[j] = strs[j], strs[i]strs[3], strs[3] = strs[3], strs[3]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[3], strs[3] = strs[3], strs[3]strs = ['30', '3', '34', '5', '9']fast_sort(i + 1, r)fast_sort(3 + 1, 4)fast_sort(4, 4)reuturnreturn ''.join(strs) = 'nums = [3, 30, 34, 5, 9]strs = ['3', '30', '34', '5', '9']fast_sort(0, len(strs) - 1)fast_sort(0, 5 - 1)fast_sort(0, 4)i = l = 0, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[0] &gt; strs[0] + strs[4] and 0 &lt; 4'9' + '3' &gt; '3' + '9' and 0 &lt; 4j = j - 1 = 4 - 1 = 0 = 3strs[3] + strs[0] &gt; strs[0] + strs[3] and 0 &lt; 3'5' + '3' &gt; '3' + '5' and 0 &lt; 3j = j - 1 = 3 - 1 = 0 = 2strs[2] + strs[0] &gt; strs[0] + strs[2] and 0 &lt; 2'34' + '3' &gt; '3' + '34' and 0 &lt; 2j = j - 1 = 2 - 1 = 0 = 1strs[1] + strs[0] &lt; strs[0] + strs[1] and 0 &lt; 1'30' + '3' &lt; '3' + '30' and 0 &lt; 1i = i + 1 = 0 + 1 = j strs[i], strs[j] = strs[j], strs[i]strs[1], strs[1] = strs[1], strs[1]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[1], strs[0] = strs[0], strs[1]strs = ['30', '3', '34', '5', '9']fast_sort(l, i - 1)fast_sort(0, 1 - 1)fast_sort(0, 0)i = 0 = jreturnfast_sort(i + 1, r)fast_sort(1 + 1, 4)fast_sort(2, 4)i = l = 2, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[2] &gt; strs[2] + strs[4] and 2 &lt; 4'9' + '34' &gt; '34' + '9' and 2 &lt; 4j = j - 1 = 4 - 1 = 0 = 3strs[3] + strs[2] &gt; strs[2] + strs[3] and 2 &lt; 3'5' + '34' &gt; '34' + '5' and 2 &lt; 3j = j - 1 = 3 - 1 = 0 = 2 = istrs[i], strs[j] = strs[j], strs[i]strs[2], strs[2] = strs[2], strs[2]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[2], strs[2] = strs[2], strs[2]strs = ['30', '3', '34', '5', '9']fast_sort(l, i - 1)fast_sort(2, 2 - 1)fast_sort(2, 1)returnfast_sort(i + 1, r)fast_sort(2 + 1, 4)fast_sort(3, 4)i = l = 3, j = r = 4strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[4] + strs[3] &gt; strs[3] + strs[4] and 3 &lt; 4'9' + '5' &gt; '5' + '9' and 3 &lt; 4j = j - 1 = 4 - 1 = 0 = 3 = istrs[i], strs[j] = strs[j], strs[i]strs[3], strs[3] = strs[3], strs[3]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[3], strs[3] = strs[3], strs[3]strs = ['30', '3', '34', '5', '9']fast_sort(i + 1, r)fast_sort(3 + 1, 4)fast_sort(4, 4)reuturnreturn ''.join(strs) = '3303459'\n\n1234567891011121314151617181920212223242526272829303132333435363738nums = [10, 2]strs = ['10', '2']fast_sort(0, len(strs) - 1)fast_sort(0, 2 - 1)fast_sort(0, 1)i = l = 0, j = r = 1strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[1] + strs[0] &gt; strs[0] + strs[1] and 0 &lt; 1'2' + '10' &gt; '10' + '2' and 0 &lt; 1j = j - 1 = 1 - 1 = 0 = istrs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[1] + strs[0] &gt;= strs[0] + strs[1] and 0 &lt; 1j = j - 1 = 1 - 1 = 0 = istrs[i], strs[j] = strs[j], strs[i]strs[0], strs[0] = strs[0], strs[0]j = 0 = istrs[i], strs[j] = strs[j], strs[i]strs[0], strs[0] = strs[0], strs[0]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[0], strs[0] = strs[0], strs[0]strs = ['10', '2']fast_sort(l, i - 1)fast_sort(0, 0 - 1)fast_sort(0, -1)i = l = 0 &gt; j = r = -1returnfast_sort(i + 1, r)fast_sort(0 + 1, 1)fast_sort(1, 1)i = l = 1 = j = r returnreturn ''.join(strs) = 'nums = [10, 2]strs = ['10', '2']fast_sort(0, len(strs) - 1)fast_sort(0, 2 - 1)fast_sort(0, 1)i = l = 0, j = r = 1strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[1] + strs[0] &gt; strs[0] + strs[1] and 0 &lt; 1'2' + '10' &gt; '10' + '2' and 0 &lt; 1j = j - 1 = 1 - 1 = 0 = istrs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; jstrs[1] + strs[0] &gt;= strs[0] + strs[1] and 0 &lt; 1j = j - 1 = 1 - 1 = 0 = istrs[i], strs[j] = strs[j], strs[i]strs[0], strs[0] = strs[0], strs[0]j = 0 = istrs[i], strs[j] = strs[j], strs[i]strs[0], strs[0] = strs[0], strs[0]跳出循环strs[i], strs[l] = strs[l], strs[i]strs[0], strs[0] = strs[0], strs[0]strs = ['10', '2']fast_sort(l, i - 1)fast_sort(0, 0 - 1)fast_sort(0, -1)i = l = 0 &gt; j = r = -1returnfast_sort(i + 1, r)fast_sort(0 + 1, 1)fast_sort(1, 1)i = l = 1 = j = r returnreturn ''.join(strs) = '102'\n\n本文排序规则的传递性证明：\n123456789101112131415161718192021字符串 xy &lt; yx , yz &lt; zy ，需证明 xz &lt; zx 一定成立。设十进制数 x, y, z 分别有 a, b, c 位，则有：（左边是字符串拼接，右边是十进制数计算，两者等价）xy = x * 10^b + y yx = y * 10^a + x则 xy &lt; yx 可转化为：x * 10^b + y &lt; y * 10^a + xx (10^b - 1) &lt; y (10^a - 1)x / (10^a - 1) &lt; y / (10^b - 1)     ①同理， 可将 yz &lt; zy 转化为：y / (10^b - 1) &lt; z / (10^c - 1)     ②将 ① ② 合并，整理得：x / (10^a - 1) &lt; y / (10^b - 1) &lt; z / (10^c - 1)x / (10^a - 1) &lt; z / (10^c - 1)x (10^c - 1) &lt; z (10^a - 1)x * 10^c + z &lt; z * 字符串 xy &lt; yx , yz &lt; zy ，需证明 xz &lt; zx 一定成立。设十进制数 x, y, z 分别有 a, b, c 位，则有：（左边是字符串拼接，右边是十进制数计算，两者等价）xy = x * 10^b + y yx = y * 10^a + x则 xy &lt; yx 可转化为：x * 10^b + y &lt; y * 10^a + xx (10^b - 1) &lt; y (10^a - 1)x / (10^a - 1) &lt; y / (10^b - 1)     ①同理， 可将 yz &lt; zy 转化为：y / (10^b - 1) &lt; z / (10^c - 1)     ②将 ① ② 合并，整理得：x / (10^a - 1) &lt; y / (10^b - 1) &lt; z / (10^c - 1)x / (10^a - 1) &lt; z / (10^c - 1)x (10^c - 1) &lt; z (10^a - 1)x * 10^c + z &lt; z * 10^a + x∴  可推出 xz < zx ，传递性证毕\n\n跟 l 还是 r 比取决于我们把哪个元素看作”哨兵“，跟 r 比也可以，如果要用 r ，哨兵 i, j 的移动先后顺序也要对换因为最后要把 strs[i], strs[r] 交换，因此要保证 ``strs[i] &gt; strs[r]` （和 l 的情况正好相反），这样交换后才符合快排定义。\n123456789101112131415161718class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def fast_sort(l , r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[i] + strs[r] &lt;= strs[r] + strs[i] and i &lt; j:                    i += 1  # 先移动 i                while strs[j] + strs[r] &gt;= strs[r] + strs[j] and i &lt; j:                     j -= 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[r] = strs[r], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)                strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1)        return class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def fast_sort(l , r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[i] + strs[r] &lt;= strs[r] + strs[i] and i &lt; j:                    i += 1  # 先移动 i                while strs[j] + strs[r] &gt;= strs[r] + strs[j] and i &lt; j:                     j -= 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[r] = strs[r], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)                strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1)        return ''.join(strs)\n\n函数 A 内部 定义 函数B ，则 B 的用途就是让 A 去调用的。函数 A 外，是无法访问函数 B 的，可以运行以下代码理解：\n123456789101112131415161718class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1) # 报错 not defined        return ''.join(strs)    def test(self):        def fast_sort(l , r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; j: j -= 1                while strs[i] + strs[l] &lt;= strs[l] + strs[i] and i &lt; j: i += 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[l] = strs[l], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)        return class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        strs = [str(num) for num in nums]        fast_sort(0, len(strs) - 1) # 报错 not defined        return ''.join(strs)    def test(self):        def fast_sort(l , r):            if l &gt;= r: return            i, j = l, r            while i &lt; j:                while strs[j] + strs[l] &gt;= strs[l] + strs[j] and i &lt; j: j -= 1                while strs[i] + strs[l] &lt;= strs[l] + strs[i] and i &lt; j: i += 1                strs[i], strs[j] = strs[j], strs[i]            strs[i], strs[l] = strs[l], strs[i]            fast_sort(l, i - 1)            fast_sort(i + 1, r)        return 0\n\n内置函数：需定义排序规则：Python 定义在函数 sort_rule(x, y) 中；本题可以转化为排序问题，因此我们要定义一个“有效的排序规则”，然后按照这个排序规则、使用任意排序方法，将数组排序~3.8 新版功能.functools.cmp_to_key(func)将(旧式的)比较函数转换为新式的 key function . 在类似于 sorted() ， min() ， max() ， heapq.nlargest() ， heapq.nsmallest() ， itertools.groupby() 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。\n123456789101112131415import functoolsclass Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def sort_rule(x, y):            a, b = x + y, y + x            if a &gt; b: return 1            elif a &lt; b: return -1            else:                return 0        strs = [str(num) for num in nums]        strs.sort(key=functools.cmp_to_key(sort_rule))        return import functoolsclass Solution:    def minNumber(self, nums: List[int]) -&gt; str:        def sort_rule(x, y):            a, b = x + y, y + x            if a &gt; b: return 1            elif a &lt; b: return -1            else:                return 0        strs = [str(num) for num in nums]        strs.sort(key=functools.cmp_to_key(sort_rule))        return ''.join(strs)\n\n\nkey 指向这个cmpSmaller ，然后sorted调用过程中，会强制转换类型 将原先的 str 字符串类型改为 这个 cmpSmaller 类型，然后排序的时候，就会调用这个 重写 的 lt 方法，从而使用了自定义的 排序规则，得到了最终结果。\n12345678910class cmpSmaller(str):    def __lt__(self, y):        return self + y &lt; y + self  # 字符串拼接比较(两两比较)    # 按由小到大来排列class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        res=sorted(map(str, nums),key=cmpSmaller)        smallest = ''.join(res)        class cmpSmaller(str):    def __lt__(self, y):        return self + y &lt; y + self  # 字符串拼接比较(两两比较)    # 按由小到大来排列class Solution:    def minNumber(self, nums: List[int]) -&gt; str:        res=sorted(map(str, nums),key=cmpSmaller)        smallest = ''.join(res)        return smallest\n\n\n冒泡\n123456789101112class Solution(object):    def minNumber(self, nums: List[int]) -&gt; str:        if not nums:            return None        for i in range(len(nums)):            nums[i] = str(nums[i])        for i in range(len(nums)):            for j in range(i+1,len(nums)):                if nums[i] + nums[j] &gt; nums[j] + nums[i]:                    nums[i], nums[j] = nums[j], nums[i]                return class Solution(object):    def minNumber(self, nums: List[int]) -&gt; str:        if not nums:            return None        for i in range(len(nums)):            nums[i] = str(nums[i])        for i in range(len(nums)):            for j in range(i+1,len(nums)):                if nums[i] + nums[j] &gt; nums[j] + nums[i]:                    nums[i], nums[j] = nums[j], nums[i]                return ''.join(nums)\n\n\n386. 字典序排数给定一个整数&nbsp;n, 返回从&nbsp;1&nbsp;到&nbsp;n&nbsp;的字典顺序。\n例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。\n例子是1在10之前数字最高位是以1-9开头的，给你一个数字1，把这个数字开头的，并且不大于n的所有数字按照位数由低到高依次排列给你一个数字2，把这个数字开头的，并且不大于n的所有数字按照位数由低到高依次排列当两个数字最高位相同的时候，就需要比较其次高位，比较方式与最高位的比较方式是一致的，也就是递归下去。（这是我的理解，可能有点不太准确）\n将n个数按照一定的顺序构建成树，然后从左到右对每棵树进行dfs就行了\n1234567                    root            /           |            |          \\              1            2            3    ...     9        /      \\       \\       10        11       /  |   \\     /  |  |  \\ 100  101   109                     root            /           |            |          \\              1            2            3    ...     9        /      \\       \\       10        11       /  |   \\     /  |  |  \\ 100  101   109 110\n\n时间复杂度: O(N)，使用了递归，时间复杂度为进入递归函数的次数，我们遍历了每一个结点空间复杂度: O(1)\n1234567891011121314151617181920212223from typing import Listclass Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        res = []        def dfs(cur):  # N叉树 深度优先搜索 对每棵树进行dfs cur为根结点            if cur &gt; n:                return            res.append(cur)            for j in range(10):  # 遍历0 ~ 9                dfs(cur * 10 + j)        for i in range(1, 10):  # 遍历1 ~ 9            dfs(i)        return ress = Solution()print(s.lexicalOrder(13))# [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]print(s.lexicalOrder(0))  from typing import Listclass Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        res = []        def dfs(cur):  # N叉树 深度优先搜索 对每棵树进行dfs cur为根结点            if cur &gt; n:                return            res.append(cur)            for j in range(10):  # 遍历0 ~ 9                dfs(cur * 10 + j)        for i in range(1, 10):  # 遍历1 ~ 9            dfs(i)        return ress = Solution()print(s.lexicalOrder(13))# [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]print(s.lexicalOrder(0))  # []\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167n = 13res = []i = 1dfs(1)    cur = 1 &lt; n = 13    res.append(cur)    res= [1]    j = 0    dfs(cur * 10 + j)    dfs(1 * 10 + 0)    dfs(10)        cur = 10 &lt; n = 13        res.append(cur)        res= [1, 10]        j = 0        dfs(cur * 10 + j)        dfs(10 * 10 + 0)        dfs(100)            cur = 100 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(10 * 10 + 1)        dfs(101)            cur = 101 &gt; n = 13            return                ....        j = 9        dfs(cur * 10 + 9)        dfs(10 * 10 + 9)        dfs(109)            cur = 109 &gt; n = 13            return                   j = 1    dfs(cur * 10 + j)    dfs(1 * 10 + 1)    dfs(11)        cur = 11 &lt; n = 13        res.append(cur)        res= [1, 10, 11]        j = 0        dfs(cur * 10 + j)        dfs(11 * 10 + 0)        dfs(110)            cur = 110 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(11 * 10 + 1)        dfs(111)            cur = 111 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(11 * 10 + 9)        dfs(119)            cur = 119 &gt; n = 13            return          j = 2    dfs(cur * 10 + j)    dfs(1 * 10 + 2)    dfs(12)        cur = 12 &lt; n = 13        res.append(cur)        res= [1, 10, 11, 12]        j = 0        dfs(cur * 10 + j)        dfs(12 * 10 + 0)        dfs(120)            cur = 120 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(12 * 10 + 1)        dfs(121)            cur = 121 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(12 * 10 + 9)        dfs(129)            cur = 129 &gt; n = 13            return      j = 3    dfs(cur * 10 + j)    dfs(1 * 10 + 3)    dfs(13)        cur = 13 = n        res.append(cur)        res= [1, 10, 11, 12, 13]        j = 0        dfs(cur * 10 + j)        dfs(13 * 10 + 0)        dfs(130)            cur = 130 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(13 * 10 + 1)        dfs(131)            cur = 131 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(13 * 10 + 9)        dfs(139)            cur = 139 &gt; n = 13            return      j = 4    dfs(cur * 10 + j)    dfs(1 * 10 + 4)    dfs(14)        cur = 14 &gt; n = 13        return    j = 5    dfs(cur * 10 + j)    dfs(1 * 10 + 5)    dfs(15)        cur = 15 &gt; n = 13        return    ...    j = 9    dfs(cur * 10 + j)    dfs(1 * 10 + 9)    dfs(19)        cur = 19 &gt; n = 13        returni = 2dfs(2)    cur = 2 &lt; n = 13    res.append(cur)    res= [1, 10, 11, 12, 13, 2]    j = 0    dfs(cur * 10 + j)    dfs(2 * 10 + 0)    dfs(20)        cur = 20 &gt; n = 13        returni = 3dfs(3)    cur = 3 &lt; n = 13    res.append(cur)    res= [1, 10, 11, 13, 12, 2, 3]    j = 0    dfs(cur * 10 + j)    dfs(3 * 10 + 0)    dfs(30)        cur = 30 &gt; n = 13        n = 13res = []i = 1dfs(1)    cur = 1 &lt; n = 13    res.append(cur)    res= [1]    j = 0    dfs(cur * 10 + j)    dfs(1 * 10 + 0)    dfs(10)        cur = 10 &lt; n = 13        res.append(cur)        res= [1, 10]        j = 0        dfs(cur * 10 + j)        dfs(10 * 10 + 0)        dfs(100)            cur = 100 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(10 * 10 + 1)        dfs(101)            cur = 101 &gt; n = 13            return                ....        j = 9        dfs(cur * 10 + 9)        dfs(10 * 10 + 9)        dfs(109)            cur = 109 &gt; n = 13            return                   j = 1    dfs(cur * 10 + j)    dfs(1 * 10 + 1)    dfs(11)        cur = 11 &lt; n = 13        res.append(cur)        res= [1, 10, 11]        j = 0        dfs(cur * 10 + j)        dfs(11 * 10 + 0)        dfs(110)            cur = 110 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(11 * 10 + 1)        dfs(111)            cur = 111 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(11 * 10 + 9)        dfs(119)            cur = 119 &gt; n = 13            return          j = 2    dfs(cur * 10 + j)    dfs(1 * 10 + 2)    dfs(12)        cur = 12 &lt; n = 13        res.append(cur)        res= [1, 10, 11, 12]        j = 0        dfs(cur * 10 + j)        dfs(12 * 10 + 0)        dfs(120)            cur = 120 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(12 * 10 + 1)        dfs(121)            cur = 121 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(12 * 10 + 9)        dfs(129)            cur = 129 &gt; n = 13            return      j = 3    dfs(cur * 10 + j)    dfs(1 * 10 + 3)    dfs(13)        cur = 13 = n        res.append(cur)        res= [1, 10, 11, 12, 13]        j = 0        dfs(cur * 10 + j)        dfs(13 * 10 + 0)        dfs(130)            cur = 130 &gt; n = 13            return        j = 1        dfs(cur * 10 + j)        dfs(13 * 10 + 1)        dfs(131)            cur = 131 &gt; n = 13            return          ....        j = 9        dfs(cur * 10 + 9)        dfs(13 * 10 + 9)        dfs(139)            cur = 139 &gt; n = 13            return      j = 4    dfs(cur * 10 + j)    dfs(1 * 10 + 4)    dfs(14)        cur = 14 &gt; n = 13        return    j = 5    dfs(cur * 10 + j)    dfs(1 * 10 + 5)    dfs(15)        cur = 15 &gt; n = 13        return    ...    j = 9    dfs(cur * 10 + j)    dfs(1 * 10 + 9)    dfs(19)        cur = 19 &gt; n = 13        returni = 2dfs(2)    cur = 2 &lt; n = 13    res.append(cur)    res= [1, 10, 11, 12, 13, 2]    j = 0    dfs(cur * 10 + j)    dfs(2 * 10 + 0)    dfs(20)        cur = 20 &gt; n = 13        returni = 3dfs(3)    cur = 3 &lt; n = 13    res.append(cur)    res= [1, 10, 11, 13, 12, 2, 3]    j = 0    dfs(cur * 10 + j)    dfs(3 * 10 + 0)    dfs(30)        cur = 30 &gt; n = 13        return\n\n12345678910111213class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        self.n, self.res = n, []        def dfs(cur):             if cur &gt; self.n: return             self.res.append(cur)            for i in range(10):                dfs(10 * cur + i)        for i in range(1,10):            dfs(i)        class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        self.n, self.res = n, []        def dfs(cur):             if cur &gt; self.n: return             self.res.append(cur)            for i in range(10):                dfs(10 * cur + i)        for i in range(1,10):            dfs(i)        return self.res\n\n123class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        return sorted(range(1, n+class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        return sorted(range(1, n+1), key=str) \n\n123class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        return sorted(list(range(1,n+1)),key=class Solution:    def lexicalOrder(self, n: int) -&gt; List[int]:        return sorted(list(range(1,n+1)),key=lambda x:str(x))\n\n\n剑指 Offer 19. 正则表达式匹配请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n示例 1:\n12345输入:s = \"aa\"p = \"a\"输出: false输入:s = \"aa\"p = \"a\"输出: false解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n示例 2:\n12345输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n示例 3:\n12345输入:s = \"ab\"p = \".*\"输出: true输入:s = \"ab\"p = \".*\"输出: true解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n示例 4:\n12345输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n示例 5:\n1234输入:s = \"mississippi\"p = \"mis*is*p*.\"输入:s = \"mississippi\"p = \"mis*is*p*.\"输出: false\n\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 ，无连续的 ‘‘。\n\n解题思路：\n\n设 s 的长度为 n ， p 的长度为 m ；将 s 的第 i 个字符记为 s_i ，p 的第 j 个字符记为 p_j ，将 s 的前 i 个字符组成的子字符串记为 s[:i] , 同理将 p 的前 j 个字符组成的子字符串记为 p[:j] 。\n\n\n因此，本题可转化为求 s[:n] 是否能和 p[:m] 匹配。\n\n总体思路是从 s[:1] 和 p[:1] 是否能匹配开始判断，每轮添加一个字符并判断是否能匹配，直至添加完整个字符串 s 和 p 。展开来看，假设 s[:i] 与 p[:j] 可以匹配，那么下一状态有两种：\n\n添加一个字符 s_{i+1} 后是否能匹配？\n添加字符 p_{j+1} 后是否能匹配？\n\n因此，本题的状态共有 m×n 种，应定义状态矩阵 dp ，dp[i][j] 代表 s[:i] 与 p[:j] 是否可以匹配。\n做好状态定义，接下来就是根据 「普通字符」 , 「.」 , 「*」三种字符的功能定义，分析出动态规划的转移方程。\n动态规划解析：\n状态定义： 设动态规划矩阵 dp ， dp[i][j] 代表字符串 s 的前 i 个字符和 p 的前 j 个字符能否匹配。\n\n转移方程： 需要注意，由于 dp[0][0] 代表的是空字符的状态， 因此 dp[i][j] 对应的添加字符是 s[i - 1] 和 p[j - 1] 。\n\n\n当 p[j - 1] = '*' 时， dp[i][j] 在当以下任一情况为 truetrue 时等于 truetrue ：\ndp[i][j - 2]： 即将字符组合 p[j - 2] * 看作出现 0 次时，能否匹配；dp[i][j - 1]： 即将字符组合 p[j - 2] * 看作出现 1 次时，能否匹配；dp[i - 1][j] 且 s[i - 1] = p[j - 2]: 即让字符 p[j - 2] 多出现 1 次时，能否匹配；dp[i - 1][j] 且 p[j - 2] = ‘.’: 即让字符 ‘.’ 多出现 1 次时，能否匹配；当 p[j - 1] != ‘*’ 时， dp[i][j] 在当以下任一情况为 truetrue 时等于 truetrue ：\ndp[i - 1][j - 1] 且 s[i - 1] = p[j - 1]： 即让字符 p[j - 1] 多出现一次时，能否匹配；dp[i - 1][j - 1] 且 p[j - 1] = ‘.’： 即将字符 . 看作字符 s[i - 1] 时，能否匹配；初始化： 需要先初始化 dp 矩阵首行，以避免状态转移时索引越界。\n1234567891011121314151617181920212223242526272829303132333435363738394041```dp[0][j] = dp[0][j - 2]``` 且 ```p[j - 1] = '*'```： 首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）。- 返回值： ```dp``` 矩阵右下角字符，代表字符串 s 和 p 能否匹配。时间复杂度 O(MN) ： 其中 M, N 分别为 ```s``` 和 ```p``` 的长度，状态转移需遍历整个 ```dp``` 矩阵。空间复杂度 O(MN) ： 状态矩阵 ```dp``` 使用 O(MN) 的额外空间。```pyclass Solution:    def isMatch(self, s: str, p: str) -> bool:        m, n = len(s) + 1, len(p) + 1        dp = [[False] * n for _ in range(m)]        dp[0][0] = True        # 初始化首行        for j in range(2, n, 2):            dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'        # 状态转移        for i in range(1, m):            for j in range(1, n):                if p[j - 1] == '*':                    if dp[i][j - 2]:                        dp[i][j] = True  # 1.                    elif dp[i][j - 1]:                        dp[i][j] = True  # 2.                    elif dp[i - 1][j] and s[i - 1] == p[j - 2]:                        dp[i][j] = True  # 3.                    elif dp[i - 1][j] and p[j - 2] == '.':                        dp[i][j] = True  # 4.                else:                    if dp[i - 1][j - 1] and s[i - 1] == p[j - 1]:                        dp[i][j] = True  # 1.                    elif dp[i - 1][j - 1] and p[j - 1] == '.':                        dp[i][j] = True  # 2.        return dp[-1][-1]if __name__ == '__main__':    solution = Solution()    nums1 = 'aaa'    nums2 = 'ab*.*'    print(solution.isMatch(nums1, nums2))  # True\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108s = 'aaa'p = 'ab*.*'m = len(s) + 1 = 4n = len(p) + 1 = 6_ = 0dp = [    [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False]     ]dp[0][0] = Truedp = [    [True, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False]     ]j = 2   dp[0][j] = dp[0][j - 2]dp[0][2] = dp[0][2 - 2]dp[0][2] = dp[0][0]p[j - 1] == '*'p[2 - 1] == '*'p[1] == '*'j = 4dp[0][4] = dp[0][4 - 2]dp[0][4] = dp[0][2]p[j - 1] == '*'p[4 - 1] == '*'p[3] == '*'i = 1    j = 1    p[j - 1] == p[1 - 1] == p[0] = 'a' != '*'    dp[i - 1][j - 1] = dp[1 - 1][1 - 1]  = dp[0][0] = True    s[i - 1] = s[1 - 1] == s[0] = 'a' = p[1 - 1] = p[0]    dp[i][j] = dp[1][1] = True    dp = [        [True, False, False, False, False, False, False, False],         [False, True, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False]         ]    j = 2    p[j - 1] == p[2 - 1] == p[1] = 'b' != '*'    dp[i - 1][j - 1] = dp[1 - 1][2 - 1]  = dp[0][1] = True    s[i - 1] = s[1 - 1] == s[0] = 'a' != p[2 - 1] = p[1] = 'b'    False    dp[i - 1][j - 1] = dp[1 - 1][2 - 1] = dp[0][1] = False    j = 3    p[j - 1] == p[3 - 1] == p[2] = '*'    dp[i][j - 2] = dp[1][3 - 2] = dp[1][1] = True    dp[i][j] = dp[1][3] = True    dp = [        [True, False, False, False, False, False, False, False],         [False, True, False, True, False, False, False, False],         [False, False, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False]         ]    j = 4    p[j - 1] == p[4 - 1] == p[3] = '.' != '*'    dp[i - 1][j - 1] = dp[1 - 1][4 - 1] = dp[0][3] = False    j = 5    p[j - 1] == p[5 - 1] == p[4] = '*'    dp[i][j - 2] = dp[1][5 - 2] = dp[1][3] = True    dp[i][j] = dp[1][5] = True    dp = [        [True, False, False, False, False, False],         [False, True, False, True, False, True],         [False, False, False, False, False, False],         [False, False, False, False, False, False]         ]i = 2    j = 1    p[j - 1] == p[1 - 1] == p[0] = 'a' != '*'    dp[i - 1][j - 1] = dp[2 - 1][1 - 1]  = dp[1][0] = False    j = 2    p[j - 1] == p[2 - 1] == p[1] = 'b' != '*'    dp[i - 1][j - 1] = dp[2 - 1][2 - 1]  = dp[1][1] = True    s[i - 1] = s[2 - 1] = s[1] = 'a' != p[j - 1] = p[2 - 1] = p[1] = 'b'    False    p[j - 1] = p[2 - 1] = p[1] = 'b' != '.'    j = 3    dp[i][j - 2] = dp[2][3 - 2] = dp[2][1] = False    dp[i][j - 1] = dp[2][3 - 1] = dp[2][2] = False    dp[i - 1][j] = dp[2 - 1][3] = dp[1][3] = Falses = 'aaa'p = 'ab*.*'m = len(s) + 1 = 4n = len(p) + 1 = 6_ = 0dp = [    [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False]     ]dp[0][0] = Truedp = [    [True, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False],     [False, False, False, False, False, False, False, False]     ]j = 2   dp[0][j] = dp[0][j - 2]dp[0][2] = dp[0][2 - 2]dp[0][2] = dp[0][0]p[j - 1] == '*'p[2 - 1] == '*'p[1] == '*'j = 4dp[0][4] = dp[0][4 - 2]dp[0][4] = dp[0][2]p[j - 1] == '*'p[4 - 1] == '*'p[3] == '*'i = 1    j = 1    p[j - 1] == p[1 - 1] == p[0] = 'a' != '*'    dp[i - 1][j - 1] = dp[1 - 1][1 - 1]  = dp[0][0] = True    s[i - 1] = s[1 - 1] == s[0] = 'a' = p[1 - 1] = p[0]    dp[i][j] = dp[1][1] = True    dp = [        [True, False, False, False, False, False, False, False],         [False, True, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False]         ]    j = 2    p[j - 1] == p[2 - 1] == p[1] = 'b' != '*'    dp[i - 1][j - 1] = dp[1 - 1][2 - 1]  = dp[0][1] = True    s[i - 1] = s[1 - 1] == s[0] = 'a' != p[2 - 1] = p[1] = 'b'    False    dp[i - 1][j - 1] = dp[1 - 1][2 - 1] = dp[0][1] = False    j = 3    p[j - 1] == p[3 - 1] == p[2] = '*'    dp[i][j - 2] = dp[1][3 - 2] = dp[1][1] = True    dp[i][j] = dp[1][3] = True    dp = [        [True, False, False, False, False, False, False, False],         [False, True, False, True, False, False, False, False],         [False, False, False, False, False, False, False, False],         [False, False, False, False, False, False, False, False]         ]    j = 4    p[j - 1] == p[4 - 1] == p[3] = '.' != '*'    dp[i - 1][j - 1] = dp[1 - 1][4 - 1] = dp[0][3] = False    j = 5    p[j - 1] == p[5 - 1] == p[4] = '*'    dp[i][j - 2] = dp[1][5 - 2] = dp[1][3] = True    dp[i][j] = dp[1][5] = True    dp = [        [True, False, False, False, False, False],         [False, True, False, True, False, True],         [False, False, False, False, False, False],         [False, False, False, False, False, False]         ]i = 2    j = 1    p[j - 1] == p[1 - 1] == p[0] = 'a' != '*'    dp[i - 1][j - 1] = dp[2 - 1][1 - 1]  = dp[1][0] = False    j = 2    p[j - 1] == p[2 - 1] == p[1] = 'b' != '*'    dp[i - 1][j - 1] = dp[2 - 1][2 - 1]  = dp[1][1] = True    s[i - 1] = s[2 - 1] = s[1] = 'a' != p[j - 1] = p[2 - 1] = p[1] = 'b'    False    p[j - 1] = p[2 - 1] = p[1] = 'b' != '.'    j = 3    dp[i][j - 2] = dp[2][3 - 2] = dp[2][1] = False    dp[i][j - 1] = dp[2][3 - 1] = dp[2][2] = False    dp[i - 1][j] = dp[2 - 1][3] = dp[1][3] = False\n\n利用布尔运算实现简短长度\n12345678910111213class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s) + 1, len(p) + 1        dp = [[False] * n for _ in range(m)]        dp[0][0] = True        for j in range(2, n, 2):            dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i][j - 2] or dp[i][j - 1] or dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.') \\                           if p[j - 1] == '*' else \\                           dp[i - 1][j - 1] and (p[j - 1] == '.' or s[i - 1] == p[j - 1])        return dp[-1][class Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s) + 1, len(p) + 1        dp = [[False] * n for _ in range(m)]        dp[0][0] = True        for j in range(2, n, 2):            dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i][j - 2] or dp[i][j - 1] or dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.') \\                           if p[j - 1] == '*' else \\                           dp[i - 1][j - 1] and (p[j - 1] == '.' or s[i - 1] == p[j - 1])        return dp[-1][-1]\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"leetcode sql","url":"https://bubbleboy11.github.io/2020/08/21/leetcode-sql/","content":"正常情况下SELECT的书写顺序和执行顺序\n写法顺序：SELECT →FROM → JOIN → ON → WHERE → GROUP BY → HAVING → ORDER BY→ LIMIT\n123456789SELECT 查询列表                ⑦                    FROM 表 1                    ①                                      【连接类型】 JOIN 表 2        ③                           ON 连接条件                    ②WHERE 筛选条件                ④GROUP BY 分组列表            ⑤HAVING 分组后的筛选条件        ⑥ORDER BY 排序的字段            ⑧SELECT 查询列表                ⑦                    FROM 表 1                    ①                                      【连接类型】 JOIN 表 2        ③                           ON 连接条件                    ②WHERE 筛选条件                ④GROUP BY 分组列表            ⑤HAVING 分组后的筛选条件        ⑥ORDER BY 排序的字段            ⑧LIMIT 起始的条目索引，条目数;    ⑨\n\n执行顺序：FROM → ON → JOIN → WHERE → GROUP BY → with HAVING → SELECT → ORDER BY→ LIMITTOP\n若 每页显示条目数：pageSize，要显示的页数：page则有：\n1SELECT * FROM 表 LIMIT （pageSELECT * FROM 表 LIMIT （page-1）* pageSize,pageSize\n\n解题方法根据考题要搞清楚表的结果和多表之间的关系，根据想要的结果思考使用那种关联方式，通常把要查询的列先写出来，然后分析这些列都属于哪些表，才考虑使用关联查询\n其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤\n因为ON是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，WHERE也应该比HAVING快点的，因为它过滤数据后才进行SUM，在两个表联接时才用ON的，所以在一个表的时候，就剩下WHERE跟HAVING比较了。\n表连接，同时查询多张表格，效率高于子查询数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。\nfrom子句中on条件主要用来连接表，其他不属于连接表的条件可以使用where子句来指定；考虑联接优先顺序：join连接分为三种  外连接的outer 和内连接的inner 都可以省略：\n\n内连接 inner join ，默认，所以可以省略inner关键字，又叫等值连接，只返回两个表中不一定必须有同名字段，只要连接字段相等的行、公共数据、符合连接条件。查询条件放在&nbsp;on子句和where子句的返回的结果集是相同的。1SELECT * FROM A,B SELECT * FROM A,B WHERE A.id=B.id\n或者1SELECT * from a inner Join b SELECT * from a inner Join b on A.id=B.id\n1SELECT * from a Join b on A.id=B.id JOIN c SELECT * from a Join b on A.id=B.id JOIN c on B.id=c.id;\n\n\n\n自连接（自身连接）的本质是把一张表复制出多张一模一样的表来使用。\n12select 列名 from 表名 as 别名1,表名 as 别名select 列名 from 表名 as 别名1,表名 as 别名2;\n1SELECT * FROM A T1 INNER JOIN A T2 SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid\n\n\n外连接 outer join 是指的要保存未匹配信息 包括left join,在mysql是left outer join的简写 ，左外连接，左联结\n在使用&nbsp;left jion&nbsp;时，on&nbsp;和&nbsp;where&nbsp;条件的区别如下：• on&nbsp;条件是在生成临时表时使用的补充条件，以左表为主,先查询出左表,不管&nbsp;on&nbsp;上的条件是否为真，都会返回左表的全部数据都会在结果集中，左表有而右表中不匹配的行，右表选择字段列置为null• where&nbsp;条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有&nbsp;left join&nbsp;的含义（必须返回左边表的记录）了，条件不为真的就过滤掉，条件真假直接影响结果实际的执行效果相当于inner join .\n\n\nright join right outer join ，右外连接，结果表中除了匹配行外，还包括右表有而左表中不匹配的行，对于这样的行，左表选择列置为null \n\nfull join 是full outer join的简写，全连接，mysql不支持full outer join，Mysql可以用left join+union+right join来解决将多个查询语句的结果进行合并\n\n联合查询\n1SELECT FROM A UNION SELECT FROM B SELECT FROM A UNION SELECT FROM B UNION\n就是把多个结果集集中在一起, UNION前的结果为基准,需要注意的是联合查询的列数要相等,相同的记录行会合并,字段个数相同，结果集字段名称相同\nSELECT FRoM A left Join b on A id=B id UNIOnSELECT FRoM A RIGHT Join BoN A. id=Bid\n查询语句 union （查询语句）union （查询语句）如果使用 UNION ALL,不会合并重复的记录行,会显示重复的数据优化UNION查询 UNION ALL的效率高于UNION\nnatural join，自然连接，分为natural left outer join和natural right outer join，语义定义与inner join相同 \n3：cross join，交叉连接，没有任何关联条件,将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积，就是第一个表的行数乘以第二个表的行数。结果集会很大,没有意义,很少使用\n1SELECT * SELECT * FROM A B(,C)\n或者\n1SELECT * FROM A CROSS JOIN B (CROSS SELECT * FROM A CROSS JOIN B (CROSS JOIN C)\n\n在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。\n子查询是一种查询中嵌套在 where子句 from子句 select子句查询的语句，效率不好把握不能写在order子句\n当一个SQL语句的结果是作为另外一条SQL语句的条件时则需要用到子查询。\nfrom子查询不是相关子查询，把结果集作为一张表，与其他的数据表做表连接\n嵌套子查询：执行不依赖与外部的查询。优化子查询：用关联查询替代执行过程：先执行子查询再执行主查询（1）执行子查询总共执行一次，执行完毕后结果不被显示，而是=将值传递给外部查询，作为外部查询的条件使用。（2）执行外部查询，并显示整个结果。　　嵌套子查询一般可以分为：\n\n返回单值的子查询 单行子查询：返回一条记录查询底薪超过公司平均底薪的员工的信息12345WHERE 价格 &gt;  (    SELECT AVG(价格)    WHERE 价格 &gt;  (    SELECT AVG(价格)    FROM Books  )\n返回一个列表的子查询 ，多行子查询：返回多条记录，只能出现在where from子句select子句中其他字段的一条记录没办法和子查询的多条记录合并\n\n相关子查询，先执行主查询再执行子查询。外部查询执行一行，子查询就执行一次。执行依赖于外部查询。优化关联查询确定ON或者USING子句中是否有索引。确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。一般是子查询的WHERE子句中引用了外部查询的表。可以用IN、NOT IN、EXISTS、NOT EXISTS引入执行过程：（1）从外层查询中取出一个元组（即一行），将元组相关列的值传给内层查询。什么是元组？关系是一张表，表中的每行bai（即数据库中的每条记录）就是一个元组。（2）执行内层查询，得到子查询操作的值。（3）外查询根据子查询返回的结果或结果集得到满足条件的行。（4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。对于外部查询返回的每一行数据，内部查询都要执行一次。另外，在关联子查询中是信息流是双向的。外部查询的每行数据传递一个值给子查询，然后子查询为每一行数据执行一次并返回它的记录。然后，外部查询根据返回的记录做出决策。\n“选取出各商品种类中高于该商品种类的平均销售单价的商品。” 的关联子查询SELECT语句：\n1234567SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; (    SELECT AVG(sale_price)    FROM Product AS P2    GROUP SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; (    SELECT AVG(sale_price)    FROM Product AS P2    GROUP BY product_type    );\n这个语句是错误的，原因是sale_price是一行数据，子查询的结果是3行数据，无法进行比较。更无法得到我们想要的“选取出各商品种类中高于该商品种类的平均销售单价的商品。”这个结果。\n12345678SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; (    SELECT AVG(sale_price)    FROM Product AS P2    WHERE P1.product_type = P2.product_type    GROUP SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; (    SELECT AVG(sale_price)    FROM Product AS P2    WHERE P1.product_type = P2.product_type    GROUP BY product_type    );\n实际上，‘WHERE P1.product_type = P2.product_type’这个语句是关联子查询，关联子查询的执行逻辑和正常的SELECT语句执行逻辑完全不同下面，我们来说明一下上面的关联子查询代码的执行过程：\n先执行主查询， select 语句的 from，，把  Product 表里面每行数据查询出来，查询每一行数据，都要执行一次内层 select 语句，这个时候是完整的执行内层 select 语句，就是内层里面的 from … where … group by … select avg(sale_price)，作用是把和外层查询出来的一行数据里面的 type 相同的所有行取出来，算sale_price列的平均值，然后继续执行外层的 where 条件，最后选出需要的列数据\n12SELECT product_type , product_name, sale_priceFROM Product SELECT product_type , product_name, sale_priceFROM Product AS P1\n\n该子查询从主查询一个“product_type”的值。而这个值是个变量，随SQLSever检索Product表中的不同行而改变先将Product表中的第一条记录的“product_type”取第一个值=‘衣服’，通过WHERE P1.product_type = P2.product_type传入子查询，子查询变为：\n12345678SELECT     AVG(sale_price)FROM     Product AS P2WHERE     P2.product_type = ‘衣服’GROUP SELECT     AVG(sale_price)FROM     Product AS P2WHERE     P2.product_type = ‘衣服’GROUP BY    product_type);\n子查询得到的结果为该类product_type的平均价格，AVG(sale_price)=2500，返回主查询：\n123SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; 2500 SELECT product_type , product_name, sale_priceFROM Product AS P1WHERE sale_price &gt; 2500 AND product_type = ‘衣服’\n如果WHERE条件为True，则第一条结果包括在结果集中，则否不包括。\n然后，product _type取第二个值，得到整个语句的第二结果，依次类推，把product _type全取值一遍，所有行运行相同的过程，最后形成整个语句的的结果集及最后返回结果。\n事实上，所有关联子查询的执行过程都和上面的过程一样。（1）先从主查询的Product表中product _type列取出第一个值，进入子查询中，得到子查询结果，然后返回父查询，判断父查询的where子句条件，则返回整个语句的第1条结果。（2）重复上述操作，直到所有主查询中的Product表中product _type列记录取完为止。得出整个语句的结果集，就是最后的答案。\n12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; create table counttest(name char(1), age char(2));Query OK, 0 rows affected (0.03 sec) mysql&gt; insert into counttest values    -&gt; ('a', '14'),('a', '15'), ('a', '15'),     -&gt; ('b', NULL), ('b', '16'),     -&gt; ('c', '17'),    -&gt; ('d', null),     -&gt;('e', '');Query OK, 8 rows affected (0.01 sec)Records: 8  Duplicates: 0  Warnings: 0 mysql&gt; select * from counttest;+------+------+| name | age  |+------+------+| a    | 14   || a    | 15   || a    | 15   || b    | NULL || b    | 16   || c    | 17   || d    | NULL || e    |      |+------+------+8 rows in set (0.00 sec) mysql&gt; select name, count(name), count(1), count(*), count(age), count(distinct(age))    -&gt; from counttest    -&gt; group by name;+------+-------------+----------+----------+------------+----------------------+| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |+------+-------------+----------+----------+------------+----------------------+| a    |           3 |        3 |        3 |          3 |                    2 || b    |           2 |        2 |        2 |          1 |                    1 || c    |           1 |        1 |        1 |          1 |                    1 || d    |           1 |        1 |        1 |          0 |                    0 || e    |           1 |        1 |        1 |          1 |                    1 |+------+-------------+----------+----------+------------+----------------------+5 rows in set (mysql&gt; create table counttest(name char(1), age char(2));Query OK, 0 rows affected (0.03 sec) mysql&gt; insert into counttest values    -&gt; ('a', '14'),('a', '15'), ('a', '15'),     -&gt; ('b', NULL), ('b', '16'),     -&gt; ('c', '17'),    -&gt; ('d', null),     -&gt;('e', '');Query OK, 8 rows affected (0.01 sec)Records: 8  Duplicates: 0  Warnings: 0 mysql&gt; select * from counttest;+------+------+| name | age  |+------+------+| a    | 14   || a    | 15   || a    | 15   || b    | NULL || b    | 16   || c    | 17   || d    | NULL || e    |      |+------+------+8 rows in set (0.00 sec) mysql&gt; select name, count(name), count(1), count(*), count(age), count(distinct(age))    -&gt; from counttest    -&gt; group by name;+------+-------------+----------+----------+------------+----------------------+| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |+------+-------------+----------+----------+------------+----------------------+| a    |           3 |        3 |        3 |          3 |                    2 || b    |           2 |        2 |        2 |          1 |                    1 || c    |           1 |        1 |        1 |          1 |                    1 || d    |           1 |        1 |        1 |          0 |                    0 || e    |           1 |        1 |        1 |          1 |                    1 |+------+-------------+----------+----------+------------+----------------------+5 rows in set (0.00 sec)\n\n经典topN问题：每组最大的N条记录。涉及到“既要分组，又要排序”的情况，要能想到用窗口函数来实现。\n窗口函数，OLAP函数（Online Anallytical Processing，联机分析处理）1）同时具有分组（partition by）和排序（order by）的功能2）不减少原表的行数，所以经常用来在每组内排名group by分组汇总后改变了表的行数，一行只有一个类别。当一条sql语句没有group by的话，整张表的数据会自成一组。\n比如下面的业务需求：每组内排名问题：每个部门按业绩来排名topN问题：找出每个部门排名前N的员工进行奖励：\n12 over (partition by                 order by )\npartition子句可是省略，省略就是不指定分组排名&lt;窗口函数&gt;的位置，可以放以下两种函数：1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。2） 聚合函数，如sum. avg, count, max, min等\n因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。\n12345select *,   rank() over (order by 成绩 desc) as ranking,   dense_rank() over (order by 成绩 desc) as dese_rank,   row_number() over (order by 成绩 desc) as row_numselect *,   rank() over (order by 成绩 desc) as ranking,   dense_rank() over (order by 成绩 desc) as dese_rank,   row_number() over (order by 成绩 desc) as row_numfrom 班级\n专用窗口函数后面的括号不需要任何参数，保持()空着就可以。1）rank函数：如果有并列名次的行，会占用下一名次的位置，同薪同名重复但总排名不连续。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。 \n2）dense_rank函数：如果有并列名次的行，不占用下一名次的位置，同薪同名但总排名连续。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。 \n3）row_number函数：不考虑并列名次的情况，连续排名不重复，。比如前3名是并列的名次，排名是正常的1，2，3，4。每一条数据加一个序号，用于分页查询 例如薪水3000、2000、2000、1000排名结果为1-2-3-4，体现同薪不同名，排名类似于编号\n聚和窗口函数和上面提到的专用窗口函数用法完全相同，只需要把聚合函数写在窗口函数的位置即可，但是函数后面括号里面不能为空，需要指定聚合的列名。聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。想要知道所有人成绩的总和、平均等聚合结果，看最后一行即可。\n1234567select *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minselect *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minfrom 班级表\n\n查询结果排序，默认升序select 字段1，字段2 from 表名 order by 列名 ASC或者DESC;\n查询结果分页limit y offset x简写成limit x, y参数x为可选参数，表示查询结果跳过前 x 条数据，x 默认为 0，从第 x+1 条数据开始取，参数y为必选参数，表示取前 y 条(行)数据\neg1：\n1SELECT * FROM table LIMIT SELECT * FROM table LIMIT 5;     //检索前 5 个记录行\n等价于\n1SELECT * FROM table LIMIT 0,SELECT * FROM table LIMIT 0,5;     //检索前 5 个记录行,0可以省略不写\neg2：\n1SELECT * FROM table LIMIT 5,SELECT * FROM table LIMIT 5,10;  // 检索记录行 6-15\neg3：为了检索某行开始到最后的所有数据，可以设置第二个参数为-1\n1SELECT * FROM table LIMIT 95,SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last\n\n175. 组合两个表编写一个 SQL 查询，获取 Employee&nbsp;表中第二高的薪水（Salary）。表1: Person\n12345678+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+PersonId 是上表主键\n表2: Address\n123456789+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+AddressId 是上表主键\n编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供&nbsp;person 的以下信息：\n1FirstName, LastName, City, State\n\n使用 outer join算法\n因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。\n考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。所以是左连接保留所有的人名。right连接的话是会保留右表所有的地址信息注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。\n12345678910111213141516select FirstName, LastName, City, Statefrom Person left join Addresson Person.PersonId = Address.PersonId;```~```~sqlselect P.FirstName, P.LastName, A.City, A.Statefrom Person as P left join Address as A on (P.PersonId = A.PersonId);```~---select FirstName, LastName, City, Statefrom Person left join Addresson Person.PersonId = Address.PersonId;```~```~sqlselect P.FirstName, P.LastName, A.City, A.Statefrom Person as P left join Address as A on (P.PersonId = A.PersonId);```~---### 176. 第二高的薪水**编写一个 SQL 查询，获取 Employee&nbsp;表中第二高的薪水（Salary）。**\n+—-+——–+| Id | Salary |+—-+——–+| 1  | 100    || 2  | 200    || 3  | 300    |+—-+——–+\n12例如上述&nbsp;Employee&nbsp;表，SQL查询应该返回&nbsp;200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null例如上述&nbsp;Employee&nbsp;表，SQL查询应该返回&nbsp;200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。\n+———————+| SecondHighestSalary |+———————+| 200                 |+———————+\n1234567891011121314方法一：使用子查询和 LIMIT 子句  降序排列再返回第二条记录可以得到第二大的值。```distinct```排除掉多行数据并列第二的情况，例如只有两行记录都是 100，100，此时结果应当是null，如果不用distinct，得到结果就是100  关键是这个不存在返回null，不存在又分为表数据不够，比如表只有一行。或者另一种情况，薪水全部一样，则也不存在第二高的薪水，因此这题除了按薪水降序排序外，还需要筛掉薪水相同的记录。可以像下面这样写使用group by或者用distinct + order by```SQLSELECT     DISTINCT Salary AS SecondHighestSalaryFROM    EmployeeORDER BY Salary DESCLIMIT 1 OFFSET 方法一：使用子查询和 LIMIT 子句  降序排列再返回第二条记录可以得到第二大的值。```distinct```排除掉多行数据并列第二的情况，例如只有两行记录都是 100，100，此时结果应当是null，如果不用distinct，得到结果就是100  关键是这个不存在返回null，不存在又分为表数据不够，比如表只有一行。或者另一种情况，薪水全部一样，则也不存在第二高的薪水，因此这题除了按薪水降序排序外，还需要筛掉薪水相同的记录。可以像下面这样写使用group by或者用distinct + order by```SQLSELECT     DISTINCT Salary AS SecondHighestSalaryFROM    EmployeeORDER BY Salary DESCLIMIT 1 OFFSET 1;\n\n123456SELECT     Salary AS SecondHighestSalaryFROM    EmployeeGROUP BY Salary DESCLIMIT 1 OFFSET SELECT     Salary AS SecondHighestSalaryFROM    EmployeeGROUP BY Salary DESCLIMIT 1 OFFSET 1;\n\n然而，如果没有这样的第二最高工资，不存在第二高记录的话会返回为空的结果集。而不是null，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。 执行返回结果集不为空包含一行为NULL的记录，\nNULL```返回null值，可以不接from单独用，子查询数据出虚表嵌套查询虚表,如果查询不到会返回null。相当于查询的列。1234567891011在oracle中只写查询列没有查询表需要加上 from dual（伪表）。而mysql不用写```SQLSELECT    (SELECT DISTINCT            Salary        FROM            Employee        ORDER BY Salary DESC        LIMIT 1 OFFSET 1) AS SecondHighestSalary;\n\n12345678910SELECT(    SELECT         Salary    FROM        Employee    GROUP BY Salary     ORDER BY Salary DESC    LIMIT 1 OFFSET 1) SELECT(    SELECT         Salary    FROM        Employee    GROUP BY Salary     ORDER BY Salary DESC    LIMIT 1 OFFSET 1) AS SecondHighestSalary;\n\n12345678select (    select         Salary     from        Employee    group by Salary desc    limit 1,1) select (    select         Salary     from        Employee    group by Salary desc    limit 1,1) as SecondHighestSalary\n\n方法二：求最大值。一定要借助于MAX函数先去掉最大的，然后第二大的就是最大的了,考虑了扩展性，求第三，求第四呢?一直套\n123select max(Salary) SecondHighestSalary from Employeewhere Salary &lt; (select max(Salary) select max(Salary) SecondHighestSalary from Employeewhere Salary &lt; (select max(Salary) from Employee);\n\n方法三：使用 IFNULL 和 LIMIT 子句\nmysql中isnull,ifnull,nullif的用法如下：\nisnull(expr) 的用法： 如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。mysql&gt; select isnull(1+1);-&gt; 0mysql&gt; select isnull(1/0);-&gt; 1 使用= 的null 值对比通常是错误的。\nisnull() 函数同 is null比较操作符具有一些相同的特性。请参见有关is null 的说明。\nIFNULL(expr1,expr2)的用法：条件函数 写在查询条件里面里面判断是否为null的，不是判断是否为空。如下所示。假如expr1 不为 NULL，则 IFNULL() 的返回值为 expr1;假如expr1 为 NULL，其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。ifnull(x, null) 如果返回null值，不就已经说明 x 的值为null\n123456789mysql> SELECT IFNULL(1,0);-> 1mysql> SELECT IFNULL(NULL,10);-> 10mysql> SELECT IFNULL(1/0,10);-> 10mysql> SELECTIFNULL(1/0,'yes');->   'yes\n\n1234567SELECT    IFNULL(      (SELECT DISTINCT Salary       FROM Employee       ORDER BY Salary DESC        LIMIT 1 OFFSET 1),    NULL) SELECT    IFNULL(      (SELECT DISTINCT Salary       FROM Employee       ORDER BY Salary DESC        LIMIT 1 OFFSET 1),    NULL) AS SecondHighestSalary\n\n\n177. 第N高的薪水编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。\n1234567+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+\n例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。\n12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200                    |+------------------------+| getNthHighestSalary(2) |+------------------------+| 200                    |+------------------------+\n\n思路1：单表查询本题不存在分组排序，只需返回全局第N高的一个，所以自然想到的想法是用order by排序加limit限制得到。需要注意两个细节：\n\n同薪同名且不跳级的问题，解决办法是用group by按薪水分组后再order by\n排名第N高意味着要跳过N-1个薪水，由于无法直接用limit N-1，所以需先在函数开头用set把N赋值为N=N-1。调整下limit的起始点即可，注：这里不能直接用limit N-1,1，这样写要报语法错误，是因为limit和offset字段后面只接受正整数（意味着负数、小数都不行, limit的偏移从0开始。0是可以 但是没有啥意义）或者单一变量（意味着不能用表达式），也就是说想取一条，limit 2-1、limit 1.1这类的写法都是报错的。注：这种解法形式最为简洁直观，但仅适用于查询全局排名问题，如果要求各分组的每个第N名，则该方法不适用；而且也不能处理存在重复值的情况。\n\n第N个变成参数变量时，要改为N-1。不是数字。作者认为出题的目的是不使用变量的情况下解题\n123456789101112131415create function getNthHighestSalary(N int) returns intbegin    set n=N-1;  // sql 不区分到小写，所以只有一个N    return (        select(            select                 distinct Salary            from                 Employee            order by                 Salary desc            limit n,1        )    );create function getNthHighestSalary(N int) returns intbegin    set n=N-1;  // sql 不区分到小写，所以只有一个N    return (        select(            select                 distinct Salary            from                 Employee            order by                 Salary desc            limit n,1        )    );end\n\n\n1234567891011121314151617CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  set n = N-1;  RETURN (      select ifnull(          (          select               distinct Salary           from               Employee          order by               Salary desc          limit n, 1          )          , null)  );CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  set n = N-1;  RETURN (      select ifnull(          (          select               distinct Salary           from               Employee          order by               Salary desc          limit n, 1          )          , null)  );END\n\n窗口函数\n12345678910CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      select distinct Salary       from (select dense_rank() over(order by Salary desc) num,Salary from Employee      ) t       where t.num=N  );CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      select distinct Salary       from (select dense_rank() over(order by Salary desc) num,Salary from Employee      ) t       where t.num=N  );END\n\n法2：子查询排名第N的薪水意味着该表中存在N-1个比其更高的薪水注意这里的N-1个更高的薪水是指去重后的N-1个，实际对应人数可能不止N-1个最后返回的薪水也应该去重，因为可能不止一个薪水排名第N由于对于每个薪水的where条件都要执行一遍子查询，注定其效率低下\n对每一个薪水A，只要大于等于A的不同薪水个数等于N即可。子查询查找比当前薪资大与等于的个数，个数即排名。也就是在做查找当前记录的排名，对salary进行了排名，salary相同的排同一个名次\n假设现在给你一个分数X，如何算出它的排名Rank呢？我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。\n1234567891011121314151617CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (    select         distinct t1.Salary    from         Employee t1    where N = (        select             count(distinct t2.Salary)        from             Employee t2        where             t2.Salary &gt;= t1.Salary    )  );CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (    select         distinct t1.Salary    from         Employee t1    where N = (        select             count(distinct t2.Salary)        from             Employee t2        where             t2.Salary &gt;= t1.Salary    )  );END\n只用一个sql，那么要先查出前N薪水，然后取最小就好了，注意可能总数不够前N，count一下比较即可取的distinct后的前N条吧，去重以后就是N条，但是如果有重复的就会导至原本可能有N条，去重以后就小于 N条，所以最后的选择步骤会加上一个IF条件判断是否有到达第N个，达不到返回NULL。比如原本100个数，其中有60个是相同的，其余40个是不同的；要取第50大的，就会返回NULL，因为不重复的数只有41个，只对这41个数排序取值。\n里面的 列变量。12345678910111213```SQLCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (       SELECT  IF(count count 那么取 NULL 否者 取 min 的值  FROM    (SELECT MIN(Salary) AS min, COUNT(1) AS count    FROM      (SELECT DISTINCT Salary      FROM Employee ORDER BY Salary DESC LIMIT N) AS a    ) as b  );END\n\n\n1234567891011select case when count(*) &lt; N then NULL else min(Salary) end from (    select distinct Salary     from Employee     order by Salary desc     select case when count(*) &lt; N then NULL else min(Salary) end from (    select distinct Salary     from Employee     order by Salary desc     limit N)     temp\nmysql中自定义变量需要用@作为前缀符引导符，针对于当前会话（连接）有效，同于会话变量的作用域应用在任何地方定义@r表示排名信息(rank)，定义@p表示前一个薪水(previous) \n对用户变量赋值有两种方式，一种是直接用”=”号，另一种是用”:=”号。其区别在于使用set命令对用户变量进行赋值时，两种方式都可以使用；当使用select语句对用户变量进行赋值时，只能使用”:=”方式，因为在select语句中，”=”号被看作是比较操作符。“:=”用来给变量rank赋值\n\n178. 分数排名编写一个 SQL 查询来实现分数排名。\n如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n12345678910+----+-------+| Id | Score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  |+----+-------+| Id | Score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  | 3.65  |+----+-------+\n\n例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：\n12345678910+-------+------+| Score | Rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  |+-------+------+| Score | Rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  | 4    |+-------+------+\n重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 Rank rank是mysql的关键字不能使用\n123select score,        dense_rank() over(order by Score desc) as `Rank`select score,        dense_rank() over(order by Score desc) as `Rank`from Scores;\n\n法二：最后的结果包含两个部分，第一部分是降序排列的分数\n123select a.Score as Scorefrom Scores aorder by a.Score select a.Score as Scorefrom Scores aorder by a.Score DESC\n\n第二部分是每个分数对应的排名假设现在给你一个分数X，如何算出它的排名Rank呢？我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。先提取集合H：\n123456select     b.Score from     Scores b select     b.Score from     Scores b where     b.Score >= X;\n我们要的是集合H去重之后的元素个数就是X的排名，因此升级为：\n123456select     count(distinct b.Score) from     Scores b where     b.Score &gt;= X as select     count(distinct b.Score) from     Scores b where     b.Score &gt;= X as Rank;\n\n而从结果的角度来看，第二部分的Rank是对应第一部分的分数来的，所以这里的X就是上面的a.Score，把两部分结合在一起为：\n1234567891011121314select     a.Score as Score,    (        select             count(distinct b.Score)         from             Scores b         where             b.Score &gt;= a.Score        ) as 'Rank'from     Scores aorder by     a.Score select     a.Score as Score,    (        select             count(distinct b.Score)         from             Scores b         where             b.Score &gt;= a.Score        ) as 'Rank'from     Scores aorder by     a.Score DESC\n\n\n180. 连续出现的数字编写一个 SQL 查询，查找所有至少连续出现三次的数字。\n1234567891011+----+-----+| Id | Num |+----+-----+| 1  |  1  || 2  |  1  || 3  |  1  || 4  |  2  || 5  |  1  || 6  |  2  || 7  |+----+-----+| Id | Num |+----+-----+| 1  |  1  || 2  |  1  || 3  |  1  || 4  |  2  || 5  |  1  || 6  |  2  || 7  |  2  |+----+-----+\n例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。\n12345+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+\n\n思路：\n\n由于要获取至少连续三次出现的数字，看到这个题肯定是会变的，如果是至少连续出现四次呢(100次呢)，咱们连接四个表(连接一千个?)？这种方法肯定是不可取的。\n\n找规律，找出这连续起来的数字有什么规律呢，我们会发现连续的数字是相同的数字，但是id有可能不是连续的，工作的生产环境某一行记录经常会被删除,所以id=1之后下一个id可能是3也可以是10000，我们就需要通过对结果集进行再次编号，让其变成连续的。\n\n首先我们获取到对每条数据编号从1开始使用row_number()函数使用id来排序，row_number() over(order by id)4、然后我们通过另一种方式排序将，这些num值一样的进行排序，然后对其编号同样使用row_bumber()使用num来分组使用id排序 over(partition by num order by id)5、通过3、4步骤我们能得到什么呢，两个相减之后我们可以得到，只要是相等的，则相减的值是一样的。而且如果不连续的话相减值也不一样。\n\n\n123456789101112SELECT DISTINCT NUM As ConsecutiveNums FROM ( SELECT Num,count(*) as Num_count     FROM ( SELECT *,         row_number() over (ORDER BY id)        - row_number() over (            PARTITION by Num             ORDER BY id            )AS orde         FROM logs     ) as W GROUP BY Num,orde )as S WHERE Num_count&gt;=SELECT DISTINCT NUM As ConsecutiveNums FROM ( SELECT Num,count(*) as Num_count     FROM ( SELECT *,         row_number() over (ORDER BY id)        - row_number() over (            PARTITION by Num             ORDER BY id            )AS orde         FROM logs     ) as W GROUP BY Num,orde )as S WHERE Num_count&gt;=3; \n\n对应id的减的是row_number（）函数的排序号如果pre与t.num 相等，则cnt加1， 否则cnt重置为1\n法二定义为一张表：(select @pre:= null,@count:=1) as pcLogs与pc叉积，计算出与每行数字连续相同的数字个数。\n①首先遍历一遍整张表，找出每个数字的连续重复次数定义两个用户变量并初始化@pre：记录的是当前行的num值，在下一次循环里，pre和下一次循环if（）里的num值比较pre初始值最好不要赋值为一个数字，因为不确定赋值的数字是否会出现在测试表中。\n@count：记录上一个数字已经连续出现的次数。与前一行数据连续相同的个数，统计连续次数\n然后调用if()函数，与前一行数据比较的逻辑为：如果pre和当前行数字相同，count加1即为连续出现的次数；如果不同，意味着重新开始一个数字，count重新从1开始。最后，将当前的Num数字赋值给pre，开始下一行扫描。\n这些结果形成一张新表：a(Num,count,USELESS)。适用连续重复次数为n的情况，无论需要连续重复多少次，只需要改最后的数字就可以了，复用性很好。\n1234567select         Num,    #当前的Num 数字        if(@pre=Num,@count := @count+1,@count := 1) as nums, #判断 和 计数        @pre:=Num   #将当前Num赋值给pre    from Logs as l ,        (select @pre:= null,@count:=1) as pc #这里需要别名    select         Num,    #当前的Num 数字        if(@pre=Num,@count := @count+1,@count := 1) as nums, #判断 和 计数        @pre:=Num   #将当前Num赋值给pre    from Logs as l ,        (select @pre:= null,@count:=1) as pc #这里需要别名    #上面这段代码执行结果就是一张三列为Num,count as nums,pre的表。\n②将上面表的结果中，重复次数大于等于3的数字选出，再去重即为连续至少出现三次的数字。最终只要从a中取出count大于等于3的行。\n12345678910select     distinct Num as ConsecutiveNums from      (select Num,            if(@pre=Num,@count := @count+1,@count := 1) as count,            @pre:=Num        from Logs as l ,            (select @pre:= null,@count:=1) as pc    ) as nwhere count &gt;=select     distinct Num as ConsecutiveNums from      (select Num,            if(@pre=Num,@count := @count+1,@count := 1) as count,            @pre:=Num        from Logs as l ,            (select @pre:= null,@count:=1) as pc    ) as nwhere count &gt;=3;\n\nEvery derived table must have its own alias，进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果临时表必须要有一个别名，应该是一种规范吧！\n\n181. 超过经理收入的员工Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。\n12345678+----+-------+--------+-----------+| Id | Name  | Salary | ManagerId |+----+-------+--------+-----------+| 1  | Joe   | 70000  | 3         || 2  | Henry | 80000  | 4         || 3  | Sam   | 60000  | NULL      || 4  | Max   | 90000  |+----+-------+--------+-----------+| Id | Name  | Salary | ManagerId |+----+-------+--------+-----------+| 1  | Joe   | 70000  | 3         || 2  | Henry | 80000  | 4         || 3  | Sam   | 60000  | NULL      || 4  | Max   | 90000  | NULL      |+----+-------+--------+-----------+\n给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。\n12345+----------+| Employee |+----------+| Joe      |+----------+| Employee |+----------+| Joe      |+----------+\n\n”和自己的xxx比”这种问题基本都是自连接问题。方法 1：使用 WHERE 语句算法\n如下面表格所示，表格里存有每个雇员经理的信息，我们也许需要从这个表里获取两次信息。从两个表里使用 Select 语句可能会导致产生 笛卡尔乘积 。不指定两个表的连接方式、 没有关联条件，这种情况下就会产生笛卡尔积，这是笛卡尔积的定义在这种情况下，输出会产生 4*4=16 个记录。然而我们只对雇员工资高于经理的人感兴趣。所以我们应该用 WHERE 语句加 2 个判断条件。a表的经理Id=b表的员工Id，即b表中的人员都是a表的经理\n123456789SELECT    a.Name AS EmployeeFROM    Employee AS a,    Employee AS bWHERE    a.ManagerId = b.Id        SELECT    a.Name AS EmployeeFROM    Employee AS a,    Employee AS bWHERE    a.ManagerId = b.Id        AND a.Salary > b.Salary;\n\n方法 2：使用 JOIN 语句JOIN 是一个更常用也更有效的将表连起来的办法，我们使用 ON 来指明条件。因为JOIN 运算优先级高于逗号join相关联查语句，使用小表驱动大表，可以提高效率。\n123456SELECT     a.NAME AS EmployeeFROM Employee AS a JOIN Employee AS b     ON a.ManagerId = b.Id     SELECT     a.NAME AS EmployeeFROM Employee AS a JOIN Employee AS b     ON a.ManagerId = b.Id     AND a.Salary > b.Salary;\n\n\n12345select Name Employeefrom Employee E1where Salary &gt; (select Salary                from Employee                 where select Name Employeefrom Employee E1where Salary &gt; (select Salary                from Employee                 where Id = E1.ManagerId);\n\n12345select a.Name as Employee from Employee a where a.Salary &gt; (select b.Salary                     from Employee b                     select a.Name as Employee from Employee a where a.Salary &gt; (select b.Salary                     from Employee b                     where b.Id = a.ManagerId)\n\n\n182. 查找重复的电子邮箱编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。示例：\n1234567+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+\n根据以上输入，你的查询应返回以下结果：\n12345+---------+| Email   |+---------+| a@b.com |+---------+| Email   |+---------+| a@b.com |+---------+\n说明：所有电子邮箱都是小写字母。\n方法一：看到“找重复”的关键字眼，首先要用分组函数（group by），再用聚合函数中的计数函数count()给电子邮件列计数。\n分组汇总后，生成了一个如下的表。使用临时表\n从这个表里选出计数大于1的电子邮件，就是重复的电子邮件。重复的电子邮箱存在多次。要计算每封电子邮件的存在次数\n123select Email, count(Email) as numfrom Persongroup select Email, count(Email) as numfrom Persongroup by Email;\n\n1234| Email   | num ||---------|-----|| a@b.com | 2   || c@d.com || Email   | num ||---------|-----|| a@b.com | 2   || c@d.com | 1   |\n以此作为临时表，我们可以得到下面的解决方案。将“创建辅助表”的步骤放入子查询选出辅助表中计数大于1的姓名\n12345678select Email from(  select Email, count(Email) as num  from Person  group by Email) as statisticwhere num &gt; select Email from(  select Email, count(Email) as num  from Person  group by Email) as statisticwhere num &gt; 1;\n\n方法二：使用 GROUP BY 和 HAVING 条件向 GROUP BY 添加条件的一种更常用的方法是使用 HAVING 子句，该子句更为简单高效。在 SQL 中增加 HAVING 子句原因是，where后面不能接聚合函数，因为where子句的运行顺序排在group by之前，表还没有被分组。HAVING 子句对分组后的分组查询的结果进行筛选having子句即可包含聚合函数作用的字段也可包括普通的标量字段having子句必须于group&nbsp;by&nbsp;子句同时使用，不能单独使用where在分组前过滤，having在分组后过滤，两者之间不冲突。\n1234567select     Emailfrom     Persongroup by    Emailhaving count(Email)&gt;select     Emailfrom     Persongroup by    Emailhaving count(Email)&gt;1\n法三自联结。\n123select distinct p1.Email from Person as p1, Person as p2 where p1.Email =p2.Email select distinct p1.Email from Person as p1, Person as p2 where p1.Email =p2.Email and p1.Id!=p2.Id;\n\n\n183. 从不订购的客户某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。Customers 表：\n12345678+----+-------+| Id | Name  |+----+-------+| 1  | Joe   || 2  | Henry || 3  | Sam   || 4  | Max   |+----+-------+| Id | Name  |+----+-------+| 1  | Joe   || 2  | Henry || 3  | Sam   || 4  | Max   |+----+-------+\nOrders 表：\n123456+----+------------+| Id | CustomerId |+----+------------+| 1  | 3          || 2  | 1          |+----+------------+| Id | CustomerId |+----+------------+| 1  | 3          || 2  | 1          |+----+------------+\n例如给定上述表格，你的查询应返回：\n123456+-----------+| Customers |+-----------+| Henry     || Max       |+-----------+| Customers |+-----------+| Henry     || Max       |+-----------+\n方法：使用子查询和 NOT IN 子句如果我们有一份曾经订购过的客户名单，就很容易知道谁从未订购过。我们可以使用下面的代码来获得这样的列表。select customerid from orders;然后，我们可以使用 NOT IN 查询不在此列表中的客户。集合差定义：C=A-B。C中的元素等于在A中但是不在B中。因此，对A中的每个元素a，如果元素a不在B中，则元素a就是集合C的元素。\n123456789select     t1.name as Customersfrom     customers t1where t1.id not in(    select customerid     select     t1.name as Customersfrom     customers t1where t1.id not in(    select customerid     from orders    );\n\n法二：如果订单表orders太大，那么会导致使用in的时候，信息都放入内存，效率降低；使用left join只是做了个笛卡尔积运算，不占内存，求集合差的方法。\n1234SELECT t1.Name Customers FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId WHERE t2.CustomerId is SELECT t1.Name Customers FROM Customers t1 LEFT JOIN Orders t2 ON t1.Id = t2.CustomerId WHERE t2.CustomerId is null\n =后面要讲一个确定的值，而null不能算一个确定的值， 因为int型的可为null，varchar型的可为nul\n方法三EXISTS是布尔运算符，常用于测试子查询。当subquery返回任何行时，EXISTS返回true，否则返回false。\n123456SELECT     select_listFROM    a_tableWHERE    [NOT] SELECT     select_listFROM    a_tableWHERE    [NOT] EXISTS(subquery);\n\n\n1234567select C.name as `Customers`from Customers as C where not exists (    select distinct customerid    from Orders as O    select C.name as `Customers`from Customers as C where not exists (    select distinct customerid    from Orders as O    where O.customerid = C.id) ;\n\n\n184. 部门工资最高的员工Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。\n123456789+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Jim   | 90000  | 1            || 3  | Henry | 80000  | 2            || 4  | Sam   | 60000  | 2            || 5  | Max   | 90000  |+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Jim   | 90000  | 1            || 3  | Henry | 80000  | 2            || 4  | Sam   | 60000  | 2            || 5  | Max   | 90000  | 1            |+----+-------+--------+--------------+\nDepartment 表包含公司所有部门的信息。\n123456+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+\n编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。\n1234567+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Jim      | 90000  || Sales      | Henry    | 80000  |+------------+----------+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Jim      | 90000  || Sales      | Henry    | 80000  |+------------+----------+--------+\n解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。\n方法一：使用 JOIN 和 IN 语句\n首先对 DepartmentId 字段分组查询每个部门内查询最高工资。有可能有多个员工同时拥有最高工资，所以最好在这个查询中不包含雇员名字的信息，包含 Salary 和 DepartmentId 字段，例如技术部最高20k 但是客服部有个人20k 这样没有部门ID的话条件不足的\n12345SELECT    DepartmentId, MAX(Salary)FROM    EmployeeGROUP SELECT    DepartmentId, MAX(Salary)FROM    EmployeeGROUP BY DepartmentId;\n1234| DepartmentId | MAX(Salary) ||--------------|-------------|| 1            | 90000       || 2            || DepartmentId | MAX(Salary) ||--------------|-------------|| 1            | 90000       || 2            | 80000       |\n\n然后判断表中每条数据的分组和Salary是否和这个相等把表 Employee 和 Department 连接，再在这张临时表里用where或者IN语句筛选出 符合【工资=这个部门最高工资】 的员工信息。根据 Salary 和 DepartmentId 查找 Department.Name 字段\n当两列同时作为关键字段进行条件查询时，是将两列合成二元组(部门id,部门最高薪水)作为一个值来查找。，结合in判断 是否在已存在的组合中。比如这个案例里是(课程号,成绩) in，比如，“语文”和“90”合并为值“语文 90”。如果部门A的最高薪水和部门B第二高的薪水是一样的，此时不把DepartmentId对应起来的话，仅仅是通过薪水查询则会把部门A薪水第二高的员工也查询出来，这是不符合要求的。\n所以这两列的顺序要和子查询里列的顺序保持一致。如果列的段顺序不一样，比如“90 语文”和“语文 90”就匹配不上，那么查询结果就是空的了。\n123456789101112131415161718SELECT    Department.name AS 'Department',    Employee.name AS 'Employee',    SalaryFROM    EmployeeJOIN    Department ON Employee.DepartmentId = Department.IdWHERE    (Employee.DepartmentId , Salary) IN(        SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP SELECT    Department.name AS 'Department',    Employee.name AS 'Employee',    SalaryFROM    EmployeeJOIN    Department ON Employee.DepartmentId = Department.IdWHERE    (Employee.DepartmentId , Salary) IN(        SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY             DepartmentId    );\n\n使用left join 要注意 部门名字 不能是NULL 。所以，如果使用Left join在官方解答后面加上一句判断 AND Department.name is not null… 。两张表都有可能为空，所以不能left和right，departmentid是null，leftjoin就会保留null\n123456789101112131415161718SELECT    Department.name AS 'Department',    Employee.name AS 'Employee',    SalaryFROM    EmployeeLEFT JOIN    Department ON Employee.DepartmentId = Department.Id WHERE    (Employee.DepartmentId , Salary) IN    (   SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY DepartmentId    )AND Department.name is not SELECT    Department.name AS 'Department',    Employee.name AS 'Employee',    SalaryFROM    EmployeeLEFT JOIN    Department ON Employee.DepartmentId = Department.Id WHERE    (Employee.DepartmentId , Salary) IN    (   SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY DepartmentId    )AND Department.name is not null;\n\n法二连接临时表Employee和查询出来的每个分组的最大值连接。\n123456789select d.Name as Department, e.Name as Employee, e.Salaryfrom Employee e join Department d on e.DepartmentId = d.Id join (    select DepartmentId, max(Salary) as Salary    from Employee    group by DepartmentId    ) t     on e.DepartmentId = t.DepartmentId select d.Name as Department, e.Name as Employee, e.Salaryfrom Employee e join Department d on e.DepartmentId = d.Id join (    select DepartmentId, max(Salary) as Salary    from Employee    group by DepartmentId    ) t     on e.DepartmentId = t.DepartmentId and e.Salary = t.Salary;\n\n法三Employee和自身连接，on的条件为部门相同且同时约束Salary的大小。\n123456select d.Name as Department, e1.Name as Employee, e1.Salaryfrom Employee e1 join Department d on e1.DepartmentId = d.Id join Employee e2 on e1.DepartmentId = e2.DepartmentId and e1.Salary &lt;= e2.Salarygroup by e1.Idhaving count(distinct e2.Salary) = select d.Name as Department, e1.Name as Employee, e1.Salaryfrom Employee e1 join Department d on e1.DepartmentId = d.Id join Employee e2 on e1.DepartmentId = e2.DepartmentId and e1.Salary &lt;= e2.Salarygroup by e1.Idhaving count(distinct e2.Salary) = 1;\n\n\n\n185. 部门工资前三高的所有员工Employee 表包含所有员工信息，每个员工有其对应的工号&nbsp;Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。\n1234567891011+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 85000  | 1            || 2  | Henry | 80000  | 2            || 3  | Sam   | 60000  | 2            || 4  | Max   | 90000  | 1            || 5  | Janet | 69000  | 1            || 6  | Randy | 85000  | 1            || 7  | Will  | 70000  |+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 85000  | 1            || 2  | Henry | 80000  | 2            || 3  | Sam   | 60000  | 2            || 4  | Max   | 90000  | 1            || 5  | Janet | 69000  | 1            || 6  | Randy | 85000  | 1            || 7  | Will  | 70000  | 1            |+----+-------+--------+--------------+\nDepartment 表包含公司所有部门的信息。\n123456+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+\n编写一个&nbsp;SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：\n12345678910+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Randy    | 85000  || IT         | Joe      | 85000  || IT         | Will     | 70000  || Sales      | Henry    | 80000  || Sales      | Sam      |+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Randy    | 85000  || IT         | Joe      | 85000  || IT         | Will     | 70000  || Sales      | Henry    | 80000  || Sales      | Sam      | 60000  |+------------+----------+--------+\nIT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。\n感觉应该改为各部门工资级别前三的员工不能理解为前三名员工，如果拿90000的有四个人的话，你只取三个人，那怎么取都是错的了\n方法：使用 JOIN 和子查询公司里前 3 高的薪水意味着有不超过 3 个工资值比这些值大。\n统计了有多少人的工资比 e1.Salary 高\n12345678select e1.Name as 'Employee', e1.Salaryfrom Employee e1where (    select count(distinct e2.Salary)    from Employee e2    where e2.Salary &gt; e1.Salary    ) &lt; select e1.Name as 'Employee', e1.Salaryfrom Employee e1where (    select count(distinct e2.Salary)    from Employee e2    where e2.Salary &gt; e1.Salary    ) &lt; 3 ;\n样例的输出应该如下所示。\n123456| Employee | Salary ||----------|--------|| Joe      | 85000  || Henry    | 80000  || Max      | 90000  || Randy    || Employee | Salary ||----------|--------|| Joe      | 85000  || Henry    | 80000  || Max      | 90000  || Randy    | 85000  |\n当 &lt;3 改为 =0,第一高工资 比他高的工资 个数为0 \n123| Employee | Salary ||----------|--------|| Max      || Employee | Salary ||----------|--------|| Max      | 90000  |\n当 &lt;3 改为 =1，第二高工资 ,比他的高的 工资个数为1，\n1234| Employee | Salary ||----------|--------|| Joe      | 85000  || Randy    || Employee | Salary ||----------|--------|| Joe      | 85000  || Randy    | 85000  |\n当 &lt;3 改为 =2，有2个比某个数大，就是最3大，\n123| Employee | Salary ||----------|--------|| Henry    || Employee | Salary ||----------|--------|| Henry    | 80000  |\n\n题目要查出为同一部门的前三高工资，在同一部门内 其他的工资&gt;该员工的薪资 的个数小于3  ，即为子查询里面的条件把表 Employee 和表 Department 连接来获得部门信息。\n1234567891011121314151617181920工资是同一个部门里的，不加这个条件的话，就会所有部门比较了SQL查询e1表是按行查询的，每查询一行，执行一次where后面的内容，也就是拿这一行的salary跟e2表里同部门的所有salary作比较，得到不超过这一行里salary值的个数。```SQLSELECT    d.Name AS 'Department', e1.Name AS 'Employee', e1.SalaryFROM    Employee e1JOIN    Department d ON e1.DepartmentId = d.IdWHERE (SELECT            COUNT(DISTINCT e2.Salary)        FROM            Employee e2        WHERE            e2.Salary > e1.Salary                AND e1.DepartmentId = e2.DepartmentId        ) < 3 ;\n\n1234567891011121314# Write your MySQL query statement below/**解题思路:先对Employee表进行部门分组工资排名，再关联Department表查询部门名称，再使用WHERE筛选出排名小于等于3的数据（也就是每个部门排名前3的工资）。**/SELECT D.Name AS Department,A.Name AS Employee,A.SalaryFROM (SELECT DENSE_RANK() OVER (partition by DepartmentId order by Salary desc) AS ranking,DepartmentId,Name,Salary      FROM Employee) AS AJOIN Department AS D ON A.DepartmentId=D.idWHERE A.ranking&lt;=# Write your MySQL query statement below/**解题思路:先对Employee表进行部门分组工资排名，再关联Department表查询部门名称，再使用WHERE筛选出排名小于等于3的数据（也就是每个部门排名前3的工资）。**/SELECT D.Name AS Department,A.Name AS Employee,A.SalaryFROM (SELECT DENSE_RANK() OVER (partition by DepartmentId order by Salary desc) AS ranking,DepartmentId,Name,Salary      FROM Employee) AS AJOIN Department AS D ON A.DepartmentId=D.idWHERE A.ranking&lt;=3\n\n\n12345678910111213141516171819SELECTd.Name AS 'Department', e1.Name AS 'Employee', e1.SalaryFROM Employee e1JOINDepartment d ON e1.DepartmentId = d.IdWHERE#工资级别数量小于等于3，即最多只有3个工资级别，也就是前三高 3 &gt;= (SELECT COUNT(DISTINCT e2.Salary) FROMEmployee e2  WHERE#e2的工资级别大于等于e1的工资级别 e2.Salary &gt;= e1.Salary AND e1.DepartmentId = e2.DepartmentId )ORDER BY e1.DepartmentId,e1.Salary SELECTd.Name AS 'Department', e1.Name AS 'Employee', e1.SalaryFROM Employee e1JOINDepartment d ON e1.DepartmentId = d.IdWHERE#工资级别数量小于等于3，即最多只有3个工资级别，也就是前三高 3 &gt;= (SELECT COUNT(DISTINCT e2.Salary) FROMEmployee e2  WHERE#e2的工资级别大于等于e1的工资级别 e2.Salary &gt;= e1.Salary AND e1.DepartmentId = e2.DepartmentId )ORDER BY e1.DepartmentId,e1.Salary DESC;\n\n\n12345678910111213141516171819select     t2.Name as Department,    t1.Name as Employee,    t1.Salary as Salaryfrom    Employee as t1,    Department as t2where    t1.DepartmentId = t2.Id and    3 &gt; (            select                 count(distinct Salary)            from                Employee            where                Salary&gt;t1.Salary and                DepartmentId = t1.DepartmentId    )order by t2.Name,t1.Salary select     t2.Name as Department,    t1.Name as Employee,    t1.Salary as Salaryfrom    Employee as t1,    Department as t2where    t1.DepartmentId = t2.Id and    3 &gt; (            select                 count(distinct Salary)            from                Employee            where                Salary&gt;t1.Salary and                DepartmentId = t1.DepartmentId    )order by t2.Name,t1.Salary desc\n这一题做的有点混乱了，本来按自己的想法来说，前几前几这种问题，一般都是排好序之后用limit，但是好像很多题目都是两表连接，用比较符盒count判断，这个思路要学会转换。还有就是看了一些别人题解，发现也有用自定义变量等这些方法的，姿势还是很多的，哎，太菜了。\n为了记录足球比赛的结果，设计表如下：team：参赛队伍表match：赛程表match赛程表中的 hostTeamID与 guestTeamID都和team表中的 teamID关联,查询2006-6-1到2006-7-1之间举行的所有比赛,并且用以下形式列出:拜仁 2:0 不莱梅 2006-6-21首先列出需要查询的列：参赛队伍表 team字段名称 字段类型 描述teamID int 主键teamName varchar(20) 队伍名称赛程表match字段名称 字段类型 描述match ID int 主键hostTeamID int 主队的IDguestTeamID int 客队的IDmatchTime date   比赛开始时间matchResult varchar(20) 比赛结果，如（2:0）其次列出结果列：主队 结果 客对 时间\n12345678910111213141516#创建参赛队伍表CREATE TABLE team(teamID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, teamName VARCHAR(30) NOT NULL);#向参赛队伍表中插入记录INSERT INTO team(teamName) VALUES(' 拜 仁 '); INSERT INTO team(teamName) VALUES(' 不 莱 梅 '); INSERT INTO team(teamName) VALUES('皇家马德里'); INSERT INTO team(teamName) VALUES('巴塞罗那'); INSERT INTO team(teamName) VALUES(' 切 尔 西 '); INSERT INTO team(teamName) VALUES(' 曼 联 '); INSERT INTO team(teamName) VALUES('AC 米 兰 '); INSERT INTO team(teamName) VALUES('国际米兰');#创建 match 赛程表CREATE TABLE mat(matchID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEy,hostTeamID INT UNSIGNED NOT NULL, guestTeamID INT UNSIGNED NOT NULL,matchResult VARCHAR(20) NOT NULL, matchTime DATE NOT NULL);#向赛程表中插入几条记录INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(1,2,'3:1','2006-6-15');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(3,4,'2:2','2006-6-28');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(5,6,'0:2','2006-7-10');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(7,8,'5:3',#创建参赛队伍表CREATE TABLE team(teamID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, teamName VARCHAR(30) NOT NULL);#向参赛队伍表中插入记录INSERT INTO team(teamName) VALUES(' 拜 仁 '); INSERT INTO team(teamName) VALUES(' 不 莱 梅 '); INSERT INTO team(teamName) VALUES('皇家马德里'); INSERT INTO team(teamName) VALUES('巴塞罗那'); INSERT INTO team(teamName) VALUES(' 切 尔 西 '); INSERT INTO team(teamName) VALUES(' 曼 联 '); INSERT INTO team(teamName) VALUES('AC 米 兰 '); INSERT INTO team(teamName) VALUES('国际米兰');#创建 match 赛程表CREATE TABLE mat(matchID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEy,hostTeamID INT UNSIGNED NOT NULL, guestTeamID INT UNSIGNED NOT NULL,matchResult VARCHAR(20) NOT NULL, matchTime DATE NOT NULL);#向赛程表中插入几条记录INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(1,2,'3:1','2006-6-15');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(3,4,'2:2','2006-6-28');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(5,6,'0:2','2006-7-10');INSERT INTO mat(hostTeamID,guestTeamID,matchResult,matchTime) VALUES(7,8,'5:3','2006-5-30');\n\n1、先进行一次左连接 得到主队的名字\n12select hid,m1.tname,mres,gid,matime  from m left join t as m1 select hid,m1.tname,mres,gid,matime  from m left join t as m1 on m.hid= m1.tid;1、先进行一次左连接 得到主队的名字\n\n2、再进行一次左连接 得到客队的名字\n12select hid,m1.tname,mres,gid,t1.tname from m left join t as m1 on m.hid= m1.tid left join t as t1 select hid,m1.tname,mres,gid,t1.tname from m left join t as m1 on m.hid= m1.tid left join t as t1 on m.gid=t1.tid;1、先进行一次左连接 得到主队的名字\n\n通过外键联表，完成最终SQL：\n12345select t1.teamName,m.matchResult,t2.teamName,m.matchTime from match as m     left join team as t1 on m.hostTeamID = t1.teamID,     left join team as t2 on m.guestTeamID = t2.TeamID where matchTime between \"2006-6-1\" and select t1.teamName,m.matchResult,t2.teamName,m.matchTime from match as m     left join team as t1 on m.hostTeamID = t1.teamID,     left join team as t2 on m.guestTeamID = t2.TeamID where matchTime between \"2006-6-1\" and \"2006-7-1\"\n\n\n问题22：一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。\n1、如果A表TID是自增长,并且是连续的,B表的ID为索引\n1234select * from a,b where a.tid = b.id and a.tid&gt;50000 limit select * from a,b where a.tid = b.id and a.tid&gt;50000 limit 200;\n2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。\n123456select * from b ,     (select tid     from a     limit 50000,200) a select * from b ,     (select tid     from a     limit 50000,200) a where b.id = a .tid;\n\n拷贝表( 拷贝数据, 源表名：a 目标表名：b)\n1insert into b(a, b, c) select d,e,f insert into b(a, b, c) select d,e,f from a;\n\nStudent(S#,Sname,Sage,Ssex) 学生表 Course(C#,Cname,T#) 课程表 SC(S#,C#,score) 成绩表 Teacher(T#,Tname) 教师表 查询没学过“叶平”老师课的同学的学号、姓名\n12345select Student.S#,Student.Snamefrom Studentwhere S# not in (select distinct( SC.S#)     from SC,Course,Teacher     where SC.Cselect Student.S#,Student.Snamefrom Studentwhere S# not in (select distinct( SC.S#)     from SC,Course,Teacher     where SC.C#=Course.C# and Teacher.T#=Course.T# and Teacher.Tname=’叶平’);\n\n随机取出10条数据\n123456SELECT * FROM users WHERE id &gt;= (    (SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)    ) * RAND() + (SELECT MIN(id) FROM users) LIMIT SELECT * FROM users WHERE id &gt;= (    (SELECT MAX(id) FROM users)-(SELECT MIN(id) FROM users)    ) * RAND() + (SELECT MIN(id) FROM users) LIMIT 10\n#此方法效率比直接用高很多\n1SELECT * FROM users order by rand() LIMIT SELECT * FROM users order by rand() LIMIT 10\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["Markdown"],"tags":["Leetcode","sql"]},{"title":"剑指offer试题","url":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer-shi-ti/","content":"1.二维数组中的查找  [^本题考点 查找]​    题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution:    # array 二维列表    # 时间复杂度O(n^2) 291ms    def Find_1(self, target, array):        # write code here        for i in range(len(array)):            for j in range(len(array[i])):                if target == array[i][j]:                    return True        return False    # 时间复杂度O(n)    def Find_2(self, target, array):        # 行数为二维数组的长度        row_count = len(array)        i = 0        # 列数为任意一列的长度        column_count = len(array[0])        j = column_count - 1        # 当i小于行数（即行数,也就是此时的i,取值0--row_count-1）且列数-1大于等于0（即列数，也将就是此时的j,取值0--column_count-1）的时候，循环        while i &lt; row_count and 0 &lt; j:            value = array[i][j]            if value == target:                return True            elif value &lt; target:                i += 1            else:                j -= 1        return # -*- coding:utf-8 -*-class Solution:    # array 二维列表    # 时间复杂度O(n^2) 291ms    def Find_1(self, target, array):        # write code here        for i in range(len(array)):            for j in range(len(array[i])):                if target == array[i][j]:                    return True        return False    # 时间复杂度O(n)    def Find_2(self, target, array):        # 行数为二维数组的长度        row_count = len(array)        i = 0        # 列数为任意一列的长度        column_count = len(array[0])        j = column_count - 1        # 当i小于行数（即行数,也就是此时的i,取值0--row_count-1）且列数-1大于等于0（即列数，也将就是此时的j,取值0--column_count-1）的时候，循环        while i &lt; row_count and 0 &lt; j:            value = array[i][j]            if value == target:                return True            elif value &lt; target:                i += 1            else:                j -= 1        return False\n\n\n2.替换空格 [^本题考点 字符串]​    题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n1234567891011121314151617# -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        strLen = len(s)        # 定义空字符串准备接收        rep_str = ''        # 遍历，检测到空格就加上\"%20\"        for i in range(strLen):            if s[i].isspace():                rep_str += '%'                rep_str += '2'                rep_str += '0'            else:                rep_str += s[i]        # 返回辅助字符串        # -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        strLen = len(s)        # 定义空字符串准备接收        rep_str = ''        # 遍历，检测到空格就加上\"%20\"        for i in range(strLen):            if s[i].isspace():                rep_str += '%'                rep_str += '2'                rep_str += '0'            else:                rep_str += s[i]        # 返回辅助字符串        return rep_str\n\n\n3.从尾到头打印链表 [^本题考点 链表]​    题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\n12345678910111213141516# -*- coding:utf-8 -*-class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    # 返回从尾部到头部的列表值序列，例如[1,2,3]    def printListFromTailToHead(self, listNode):        output = []        pTmp = listNode        while pTmp:            output.insetr(0, pTmp.val)            pTmp = pTmp.next        # -*- coding:utf-8 -*-class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    # 返回从尾部到头部的列表值序列，例如[1,2,3]    def printListFromTailToHead(self, listNode):        output = []        pTmp = listNode        while pTmp:            output.insetr(0, pTmp.val)            pTmp = pTmp.next        return output\n\n\n4.重建二叉树 [^本题考点 二叉树]​    题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回构造的TreeNode根节点    def reConstructBinaryTree(self, pre, tin):        # write code here        if not pre or not tin:            return None        if len(pre) != len(tin):            return None        # 取出pre的值        root = pre[0]        # 新建一个根节点        rootNode = TreeNode(root)        # 在tin中找到pos的位置        pos = tin.index(root)        # 将tin以pos的位置分为左右两边（除去pos）        tinLeft = tin[: pos]        tinRight = tin[pos+1: ]        # 将pre以pos的位置分为左右两边（除去pos）        preLeft = pre[1: pos+1]        preRight = pre[pos+1: ]        # 将preLeft和tinLeft再次走一遍这个方法，递归下去        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)        # 将preRight和tinRight再次走一遍这个方法，递归下去        rightNode = self.reConstructBinaryTree(preRight, tinRight)        # 将leftNode赋值给rootNode的左节点        rootNode.left = leftNode        # 将rightNode赋值给rootNode的右节点        rootNode.right = rightNode        # 返回根节点        # -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    # 返回构造的TreeNode根节点    def reConstructBinaryTree(self, pre, tin):        # write code here        if not pre or not tin:            return None        if len(pre) != len(tin):            return None        # 取出pre的值        root = pre[0]        # 新建一个根节点        rootNode = TreeNode(root)        # 在tin中找到pos的位置        pos = tin.index(root)        # 将tin以pos的位置分为左右两边（除去pos）        tinLeft = tin[: pos]        tinRight = tin[pos+1: ]        # 将pre以pos的位置分为左右两边（除去pos）        preLeft = pre[1: pos+1]        preRight = pre[pos+1: ]        # 将preLeft和tinLeft再次走一遍这个方法，递归下去        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)        # 将preRight和tinRight再次走一遍这个方法，递归下去        rightNode = self.reConstructBinaryTree(preRight, tinRight)        # 将leftNode赋值给rootNode的左节点        rootNode.left = leftNode        # 将rightNode赋值给rootNode的右节点        rootNode.right = rightNode        # 返回根节点        return rootNode\n\n\n5.用两个栈实现队列 [^本题考点 队列  栈]​    题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.acceptStack = []        self.outputStack = []    def push(self, node):        # 入栈操作，实现队列的Push操作        self.acceptStack.append(node)    def pop(self):        # 要出的列表要是没有东西，就将两个的内容弹出，加入        if not self.outputStack:            while self.acceptStack:                self.outputStack.append(self.acceptStack.pop())        # 给出一个出栈的返回值，实现队列的POP操作        if self.outputStack:            return self.outputStack.pop()        else:            return # -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.acceptStack = []        self.outputStack = []    def push(self, node):        # 入栈操作，实现队列的Push操作        self.acceptStack.append(node)    def pop(self):        # 要出的列表要是没有东西，就将两个的内容弹出，加入        if not self.outputStack:            while self.acceptStack:                self.outputStack.append(self.acceptStack.pop())        # 给出一个出栈的返回值，实现队列的POP操作        if self.outputStack:            return self.outputStack.pop()        else:            return None\n\n\n6.旋转数组的最小数字 [^本题考点 查找]​    题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class Solution:    def minNumberInRotateArray(self, rotateArray):        # 时间复杂度O(n)        # minNum = 0        # for i in range(0, len(rotateArray)):        #     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]        #        # return minNum        # 时间复杂度O(logn)        # 若数组大小为0        if not rotateArray:            # 返回0            return 0        # 左侧索引        left = 0        # 右侧索引        right = len(rotateArray) - 1        # 当左侧索引小于右侧索引时循环        while left &lt;= right:  # 直至left&gt;right结束。            # 中间值为左侧索引和右侧索引求和再除以2，向下取整            mid = (left + right) &gt;&gt; 1  # (left + right) // 2            # 若中间索引对应的值小于它左侧一个的值，即为要取得值            if rotateArray[mid] &lt; rotateArray[mid - 1]:                # 返最小标值                return rotateArray[mid]            # 若中间索引对应的值小于右侧索引的值，最小值在左侧 51234            # 假如最小值在右边， 53214，那么不能构成非递减            elif rotateArray[mid] &lt; rotateArray[right]:                # 将右侧索引置为中间索引-1                right = mid - 1            # 若中间索引对应的值大于右侧索引的值，最小值在右侧，            # 假如最小值在左边，那么在非递减数组中间值就不会大于右边            # if(rotateArray[mid] &gt; rotateArray[left])            else:                # 将左侧索引置为中间索引+1                left = mid + # -*- coding:utf-8 -*-class Solution:    def minNumberInRotateArray(self, rotateArray):        # 时间复杂度O(n)        # minNum = 0        # for i in range(0, len(rotateArray)):        #     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]        #        # return minNum        # 时间复杂度O(logn)        # 若数组大小为0        if not rotateArray:            # 返回0            return 0        # 左侧索引        left = 0        # 右侧索引        right = len(rotateArray) - 1        # 当左侧索引小于右侧索引时循环        while left &lt;= right:  # 直至left&gt;right结束。            # 中间值为左侧索引和右侧索引求和再除以2，向下取整            mid = (left + right) &gt;&gt; 1  # (left + right) // 2            # 若中间索引对应的值小于它左侧一个的值，即为要取得值            if rotateArray[mid] &lt; rotateArray[mid - 1]:                # 返最小标值                return rotateArray[mid]            # 若中间索引对应的值小于右侧索引的值，最小值在左侧 51234            # 假如最小值在右边， 53214，那么不能构成非递减            elif rotateArray[mid] &lt; rotateArray[right]:                # 将右侧索引置为中间索引-1                right = mid - 1            # 若中间索引对应的值大于右侧索引的值，最小值在右侧，            # 假如最小值在左边，那么在非递减数组中间值就不会大于右边            # if(rotateArray[mid] &gt; rotateArray[left])            else:                # 将左侧索引置为中间索引+1                left = mid + 1     \n\n\n1234567891011121314151617class Solution:    def minNumberInRotateArray(self, rotateArray):        if rotateArray is None: return 0        start = 0        end = len(rotateArray) - 1        mid = (start + end) // 2        while start &lt; end:            if rotateArray[mid] &gt; rotateArray[end]:                start = mid + 1                mid = (start + end) // 2            elif rotateArray[mid] == rotateArray[end]:                end -= 1            else:                end = mid                mid = (start + end) // 2        class Solution:    def minNumberInRotateArray(self, rotateArray):        if rotateArray is None: return 0        start = 0        end = len(rotateArray) - 1        mid = (start + end) // 2        while start &lt; end:            if rotateArray[mid] &gt; rotateArray[end]:                start = mid + 1                mid = (start + end) // 2            elif rotateArray[mid] == rotateArray[end]:                end -= 1            else:                end = mid                mid = (start + end) // 2        return rotateArray[start]\n\n\n7.斐波那契数列  [^本题考点 递归，复杂度]​    题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39\n123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution:    # 时间复杂度 O(n)    def Fibonacci_1(self, n):        # write code here        a, b = 0, 1        for i in range(n):            a, b = b, a+b        return a        # 递归，时间复杂度 O(2^n)    def Fibonacci_2(n):        if n == 0:            return 0        if n == 1:            return 1        if n &gt; 1:            num = Fibonacci(n-1) + Fibonacci(n-2)            return num        return None# lambda 表达式版fibonacci = lambda n: n if n &lt; 2 else fibonacci(n-1) + fibonacci(n# -*- coding:utf-8 -*-class Solution:    # 时间复杂度 O(n)    def Fibonacci_1(self, n):        # write code here        a, b = 0, 1        for i in range(n):            a, b = b, a+b        return a        # 递归，时间复杂度 O(2^n)    def Fibonacci_2(n):        if n == 0:            return 0        if n == 1:            return 1        if n &gt; 1:            num = Fibonacci(n-1) + Fibonacci(n-2)            return num        return None# lambda 表达式版fibonacci = lambda n: n if n &lt; 2 else fibonacci(n-1) + fibonacci(n-2)\n\n\n8.跳台阶 [^本题考点 逻辑分析]​    题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution:    # 简单版    def jumpFloor_1(self, number):        if number == 1:            return 1        if number == 2:            return 2        reg = 0        a = 1        b = 2        for i in range(2, number): # 从2加到number-1            reg = a + b            a = b            b = reg        return reg    # 简化版    def jumpFloor_2(self, number):        a, b = 1, 1        for i in range(number):            a, b = b, a+b        return a# lambda 表达式版fibonacci = lambda n: n if n &lt;= 2 else fibonacci(n-1) + fibonacci(n# -*- coding:utf-8 -*-class Solution:    # 简单版    def jumpFloor_1(self, number):        if number == 1:            return 1        if number == 2:            return 2        reg = 0        a = 1        b = 2        for i in range(2, number): # 从2加到number-1            reg = a + b            a = b            b = reg        return reg    # 简化版    def jumpFloor_2(self, number):        a, b = 1, 1        for i in range(number):            a, b = b, a+b        return a# lambda 表达式版fibonacci = lambda n: n if n &lt;= 2 else fibonacci(n-1) + fibonacci(n-2)\n\n\n9.变态跳台阶 [^本题考点 逻辑分析]​    题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-'''分析：1 (1)2 (11,2)3 (111,21,3,12)4 (1111,22,13,31,211,112,121,4)    假设有n级台阶，青蛙从最后的第n级开始往前跳，可能性为：    f(n) = f(n-1) + f(n-2) + ... + f(2) + f(1)        ---&gt; ①    青蛙从最后的第n-1级开始往前跳，可能性为：    f(n-1) = f(n-2) + f(n-3) + ... + f(2) + f(1)    ---&gt; ②    将②式代入①式得：    f(n) = 2f(n-1)  n &gt; 1f(1) = 1 n = 1'''class Solution:    # 简单版    def jumpFloorII_1(self, number):        if number == 1:            return 1        if number == 2:            return 2        ret = 1        a = 1        for i in range(2, number+1):            ret = 2*ret            a = ret        return ret       # 简化版    def jumpFloorII_2(self, number):        a, b = 1, 2        for i in range(number-1):            a, b = b, b*2        # -*- coding:utf-8 -*-'''分析：1 (1)2 (11,2)3 (111,21,3,12)4 (1111,22,13,31,211,112,121,4)    假设有n级台阶，青蛙从最后的第n级开始往前跳，可能性为：    f(n) = f(n-1) + f(n-2) + ... + f(2) + f(1)        ---&gt; ①    青蛙从最后的第n-1级开始往前跳，可能性为：    f(n-1) = f(n-2) + f(n-3) + ... + f(2) + f(1)    ---&gt; ②    将②式代入①式得：    f(n) = 2f(n-1)  n &gt; 1f(1) = 1 n = 1'''class Solution:    # 简单版    def jumpFloorII_1(self, number):        if number == 1:            return 1        if number == 2:            return 2        ret = 1        a = 1        for i in range(2, number+1):            ret = 2*ret            a = ret        return ret       # 简化版    def jumpFloorII_2(self, number):        a, b = 1, 2        for i in range(number-1):            a, b = b, b*2        return a\n\n\n10.矩形覆盖 [^本题考点 逻辑分析]​    *题目：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2n的大矩形，总共有多少种方法？**\n123456789101112131415# -*- coding:utf-8 -*-'''    也是斐波那契数列的变形'''class Solution:    def rectCover(self, number):        # write code here        if number == 0:            return 0        a, b = 1, 2        for i in range(number-1):            a, b = b, a+b        # -*- coding:utf-8 -*-'''    也是斐波那契数列的变形'''class Solution:    def rectCover(self, number):        # write code here        if number == 0:            return 0        a, b = 1, 2        for i in range(number-1):            a, b = b, a+b        return a\n\n\n11.包含min函数的栈 [^本题考点 栈]​    题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding:utf-8 -*-'''如果用固定空间做不出时间上的优化，就用空间换时间'''# 第一种是self.stack和self.minValue的长度时刻保持一致class Solution:    def __init__(self):        self.stack = []        self.minValue = []            def push(self, node):        self.stack.append(node)        if self.minValue:            if node &lt; self.minValue[-1]:                self.minValue.append(node)            else:                self.minValue.append(self.minValue[-1])        else:            self.minValue.append(node)                def pop(self):        if not self.stack:            return None        self.minValue.pop()        return self.stack.pop()    def top(self):        if not self.stack:            return None        return self.stack[-1]    def min(self):        if not self.minValue:            return None        return self.minValue[-1]class Solution:    def __init__(self):        self.stack = []        self.minValue = []    def push(self, node):        self.stack.append(node)        if self.minValue:            if node &lt;= self.minValue[-1]:                self.minValue.append(node)        else:            self.minValue.append(node)                def pop(self):        if not self.stack:            return None        if self.stack[-1] == self.minValue[-1]:            self.minValue.pop()        return self.stack.pop()    def top(self):        if not self.stack:            return None        return self.stack[-1]    def min(self):        if not self.minValue:            return None        return self.minValue[# -*- coding:utf-8 -*-'''如果用固定空间做不出时间上的优化，就用空间换时间'''# 第一种是self.stack和self.minValue的长度时刻保持一致class Solution:    def __init__(self):        self.stack = []        self.minValue = []            def push(self, node):        self.stack.append(node)        if self.minValue:            if node &lt; self.minValue[-1]:                self.minValue.append(node)            else:                self.minValue.append(self.minValue[-1])        else:            self.minValue.append(node)                def pop(self):        if not self.stack:            return None        self.minValue.pop()        return self.stack.pop()    def top(self):        if not self.stack:            return None        return self.stack[-1]    def min(self):        if not self.minValue:            return None        return self.minValue[-1]class Solution:    def __init__(self):        self.stack = []        self.minValue = []    def push(self, node):        self.stack.append(node)        if self.minValue:            if node &lt;= self.minValue[-1]:                self.minValue.append(node)        else:            self.minValue.append(node)                def pop(self):        if not self.stack:            return None        if self.stack[-1] == self.minValue[-1]:            self.minValue.pop()        return self.stack.pop()    def top(self):        if not self.stack:            return None        return self.stack[-1]    def min(self):        if not self.minValue:            return None        return self.minValue[-1]\n\n\n12.栈的压入、弹出序列 [^本题考点 栈]​    题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution:    def IsPopOrder(self, pushV, popV):        # 语法错误，返回错误        if not pushV or len(pushV) != len(popV):            return False        stack = []        '''        1,2,3,4,5        4,5,3,2,1 √        4,3,5,1,2 ×  因为若是4为首位出栈的话，123必定还在栈中，无论5什么时候入栈和出栈，都不可能出现1在2前面的现象，所以错误        '''        for i in pushV:            stack.append(i)            while len(stack) and stack[-1] == popV[0]:                stack.pop()                popV.pop(0)        # 不能合理实现辅助列表和要判断的列表之间全部清空        if len(stack):            # 返回错误            return False        # 都满足，返回正确        return # -*- coding:utf-8 -*-class Solution:    def IsPopOrder(self, pushV, popV):        # 语法错误，返回错误        if not pushV or len(pushV) != len(popV):            return False        stack = []        '''        1,2,3,4,5        4,5,3,2,1 √        4,3,5,1,2 ×  因为若是4为首位出栈的话，123必定还在栈中，无论5什么时候入栈和出栈，都不可能出现1在2前面的现象，所以错误        '''        for i in pushV:            stack.append(i)            while len(stack) and stack[-1] == popV[0]:                stack.pop()                popV.pop(0)        # 不能合理实现辅助列表和要判断的列表之间全部清空        if len(stack):            # 返回错误            return False        # 都满足，返回正确        return True\n\n\n13.数组中只出现一次的数字 [^本题考点 数组]​    一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。\n12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding:utf-8 -*-class Solution:    # 返回[a,b] 其中ab是出现一次的两个数字    def FindNumsAppearOnce(self, array):        if len(array) &lt; 2:            return None        # 如果两个数相同，那么这两个数的异或操作就相同        # 两个数异或的结果初始值        twoNumXor = None        # 循环array，找到两个数异或的最终结果        for num in array:            if twoNumXor == None:                twoNumXor = num            else:                twoNumXor = twoNumXor ^ num        # 找到这两个数是从第几位开始不一样的（找到第一个1）        count = 0        while twoNumXor % 2 == 0:            twoNumXor //= 2            count += 1        # 设置mask为第一个1往后加count个0        mask = 1 &lt;&lt; count        # 第一个出现一次的数        firstNum = None        # 第二次出现一次的数        secondNum = None        # 再次循环array        for num in array:            # 第一波数，其中会有第一个出现一次的数            if mask &amp; num == 0:                if firstNum == None:                    firstNum = num                else:                    firstNum = firstNum ^ num            # 第二波数，其中会有第二个出现一次的数            else:                if secondNum == None:                    secondNum = num                else:                    secondNum = secondNum ^ num        # 返回这两个只出现一次的数        # -*- coding:utf-8 -*-class Solution:    # 返回[a,b] 其中ab是出现一次的两个数字    def FindNumsAppearOnce(self, array):        if len(array) &lt; 2:            return None        # 如果两个数相同，那么这两个数的异或操作就相同        # 两个数异或的结果初始值        twoNumXor = None        # 循环array，找到两个数异或的最终结果        for num in array:            if twoNumXor == None:                twoNumXor = num            else:                twoNumXor = twoNumXor ^ num        # 找到这两个数是从第几位开始不一样的（找到第一个1）        count = 0        while twoNumXor % 2 == 0:            twoNumXor //= 2            count += 1        # 设置mask为第一个1往后加count个0        mask = 1 &lt;&lt; count        # 第一个出现一次的数        firstNum = None        # 第二次出现一次的数        secondNum = None        # 再次循环array        for num in array:            # 第一波数，其中会有第一个出现一次的数            if mask &amp; num == 0:                if firstNum == None:                    firstNum = num                else:                    firstNum = firstNum ^ num            # 第二波数，其中会有第二个出现一次的数            else:                if secondNum == None:                    secondNum = num                else:                    secondNum = secondNum ^ num        # 返回这两个只出现一次的数        return firstNum, secondNum\n\n\n14.链表中倒数第k个结点 [^本题考点 链表]​    题目：输入一个链表，输出该链表中倒数第k个结点。\n12345678910111213141516171819class Solution:    def FindKthToTail(self, head, k):        # 定义第一个游标        firstPoint = head        # 定义第二个游标        secondPoint = head        # 循环，让第一个游标增加k个单位的长度        for i in range(k):            # 在循环中若是游标为None，则达到临界条件，            # 说明k比该链表的长度还要长，即返回None            if firstPoint == None:                return None            firstPoint = firstPoint.next        # 当第一个节点不是None，就一直循环，让两个节点同时往后移动，当第一个节点移动到最后为None的时候，第二个节点即为我们要返回的结点        while firstPoint != None:            firstPoint = firstPoint.next            secondPoint = secondPoint.next        # 返回最终倒数第K个节点        class Solution:    def FindKthToTail(self, head, k):        # 定义第一个游标        firstPoint = head        # 定义第二个游标        secondPoint = head        # 循环，让第一个游标增加k个单位的长度        for i in range(k):            # 在循环中若是游标为None，则达到临界条件，            # 说明k比该链表的长度还要长，即返回None            if firstPoint == None:                return None            firstPoint = firstPoint.next        # 当第一个节点不是None，就一直循环，让两个节点同时往后移动，当第一个节点移动到最后为None的时候，第二个节点即为我们要返回的结点        while firstPoint != None:            firstPoint = firstPoint.next            secondPoint = secondPoint.next        # 返回最终倒数第K个节点        return secondPoint\n\n\n15.反转链表 [^本题考点 链表]​    题目：输入一个链表，反转链表后，输出新链表的表头。\n123456789101112131415161718192021class Solution:    def ReverseList(self, pHead):        # 如果旧链表为空或者没有旧链表长度为1，就直接返回，无需反转        if not pHead or not pHead.next:            return pHead        newHead = None        # 只要旧链表不为空，就一直循环        while pHead:            # 在循环过程中，让旧链表的表头的下一个结点等于新表头，            # 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环                        # 容易搞清的写法            # temp = pHead.next            # pHead.next = newHead            # newHead = pHead            # pHead = temp                        # 简单写法            pHead.next, newHead, pHead = newHead, pHead, pHead.next        # 最终就达到了翻转链表的效果，返回newHead即为新链表的表头        class Solution:    def ReverseList(self, pHead):        # 如果旧链表为空或者没有旧链表长度为1，就直接返回，无需反转        if not pHead or not pHead.next:            return pHead        newHead = None        # 只要旧链表不为空，就一直循环        while pHead:            # 在循环过程中，让旧链表的表头的下一个结点等于新表头，            # 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环                        # 容易搞清的写法            # temp = pHead.next            # pHead.next = newHead            # newHead = pHead            # pHead = temp                        # 简单写法            pHead.next, newHead, pHead = newHead, pHead, pHead.next        # 最终就达到了翻转链表的效果，返回newHead即为新链表的表头        return newHead\n\n\n16.合并两个排序的链表 [^本题考点 链表]​    题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回合并后列表    def Merge(self, pHead1, pHead2):        # 若pHead1为空，直接输出pHead2        if pHead1 == None:            return pHead2        # 若pHead2为空，直接输出pHead1        if pHead2 == None:            return pHead1        # 新链表头（第一个指针）选取两个值小的        newHead = pHead1 if pHead1.val &lt; pHead2.val else pHead2        # 再定两个指针，用于后续循环中判断大小        pTmp1 = pHead1        pTmp2 = pHead2        # 如果新链表头是pHead1，就将指针pTmp1往后移动        if newHead == pHead1:            pTmp1 = pTmp1.next        # 如果新链表头是pHead2，就将指针pTmp2往后移动        else:            pTmp2 = pTmp2.next        # 第四个指针为两个指针比较完之后的值，不断往后延续        previous_Pointer = newHead        # 当两个指针都不为空的时候循环        while pTmp1 and pTmp2:            # 如果pTmp1的值小于pTmp2的值，就将第四个指针指向pTmp1，且将地址个指针的值也更新为pTmp1，方便下次接着延续            if pTmp1.val &lt; pTmp2.val:                previous_Pointer.next = pTmp1                previous_Pointer = pTmp1                pTmp1 = pTmp1.next            # 反之亦然            else:                previous_Pointer.next = pTmp2                previous_Pointer = pTmp2                pTmp2 = pTmp2.next        # 循环结束后，若pTmp1为空，则说明pTmp2有剩余，name就将pTmp2剩余的接到指针previous_Pointer之后即可        if pTmp1 == None:            previous_Pointer.next = pTmp2        # 反之亦然        else:            previous_Pointer.next = pTmp1        # 最终返回拼接好的第一个指针newHead        # class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回合并后列表    def Merge(self, pHead1, pHead2):        # 若pHead1为空，直接输出pHead2        if pHead1 == None:            return pHead2        # 若pHead2为空，直接输出pHead1        if pHead2 == None:            return pHead1        # 新链表头（第一个指针）选取两个值小的        newHead = pHead1 if pHead1.val &lt; pHead2.val else pHead2        # 再定两个指针，用于后续循环中判断大小        pTmp1 = pHead1        pTmp2 = pHead2        # 如果新链表头是pHead1，就将指针pTmp1往后移动        if newHead == pHead1:            pTmp1 = pTmp1.next        # 如果新链表头是pHead2，就将指针pTmp2往后移动        else:            pTmp2 = pTmp2.next        # 第四个指针为两个指针比较完之后的值，不断往后延续        previous_Pointer = newHead        # 当两个指针都不为空的时候循环        while pTmp1 and pTmp2:            # 如果pTmp1的值小于pTmp2的值，就将第四个指针指向pTmp1，且将地址个指针的值也更新为pTmp1，方便下次接着延续            if pTmp1.val &lt; pTmp2.val:                previous_Pointer.next = pTmp1                previous_Pointer = pTmp1                pTmp1 = pTmp1.next            # 反之亦然            else:                previous_Pointer.next = pTmp2                previous_Pointer = pTmp2                pTmp2 = pTmp2.next        # 循环结束后，若pTmp1为空，则说明pTmp2有剩余，name就将pTmp2剩余的接到指针previous_Pointer之后即可        if pTmp1 == None:            previous_Pointer.next = pTmp2        # 反之亦然        else:            previous_Pointer.next = pTmp1        # 最终返回拼接好的第一个指针newHead        return newHead\n\n\n17.两个链表的第一个公共结点 [^本题考点 链表]​    题目：输入两个链表，找出它们的第一个公共结点。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution:    def FindFirstCommonNode(self, pHead1, pHead2):        # 第一个参数给比较短的那个链表        # 第二个参数是比较长的那个链表        # 第三个参数是比较短的那个链表头        # 第四个参数是比较长的那个链表头        def find_equal(shortPointer, longPointer, shortHead, longHead):            k = 0            # 寻找出链表长度之间的差值            while longPointer:                longPointer = longPointer.next                k += 1            # 先让长的那个走K步            shortPointer = shortHead            longPointer = longHead            for i in range(k):                longPointer = longPointer.next            while shortPointer != longPointer:                shortPointer = shortPointer.next                longPointer = longPointer.next            return shortPointer        pTmp1 = pHead1        pTmp2 = pHead2        while pTmp1 and pTmp2:            # 当两个链表一样长的时候，直接返回            if pTmp1 == pTmp2:                return pTmp1            pTmp1 = pTmp1.next            pTmp2 = pTmp2.next        if pTmp1:            '''            k = 0            # 寻找出链表长度之间的差值            while pTmp1:                pTmp1 = pTmp1.next                k += 1            # 先让长的那个走K步            pTmp1 = pHead1            pTmp2 = pHead2            for i in range(k):                pTmp1 = pTmp1.next            while pTmp1 != pTmp2:                pTmp1 = pTmp1.next                pTmp2 = pTmp2.next            return pTmp1            '''            return find_equal(pTmp2, pTmp1, pHead1, pHead2)        if pTmp2:            '''            k = 0            # 寻找出链表长度之间的差值            while pTmp2:                pTmp2 = pTmp2.next                k += 1            # 先让长的那个走K步            pTmp1 = pHead1            pTmp2 = pHead2            for i in range(k):                pTmp2 = pTmp2.next            while pTmp1 != pTmp2:                pTmp1 = pTmp1.next                pTmp2 = pTmp2.next            return pTmp1            '''            class Solution:    def FindFirstCommonNode(self, pHead1, pHead2):        # 第一个参数给比较短的那个链表        # 第二个参数是比较长的那个链表        # 第三个参数是比较短的那个链表头        # 第四个参数是比较长的那个链表头        def find_equal(shortPointer, longPointer, shortHead, longHead):            k = 0            # 寻找出链表长度之间的差值            while longPointer:                longPointer = longPointer.next                k += 1            # 先让长的那个走K步            shortPointer = shortHead            longPointer = longHead            for i in range(k):                longPointer = longPointer.next            while shortPointer != longPointer:                shortPointer = shortPointer.next                longPointer = longPointer.next            return shortPointer        pTmp1 = pHead1        pTmp2 = pHead2        while pTmp1 and pTmp2:            # 当两个链表一样长的时候，直接返回            if pTmp1 == pTmp2:                return pTmp1            pTmp1 = pTmp1.next            pTmp2 = pTmp2.next        if pTmp1:            '''            k = 0            # 寻找出链表长度之间的差值            while pTmp1:                pTmp1 = pTmp1.next                k += 1            # 先让长的那个走K步            pTmp1 = pHead1            pTmp2 = pHead2            for i in range(k):                pTmp1 = pTmp1.next            while pTmp1 != pTmp2:                pTmp1 = pTmp1.next                pTmp2 = pTmp2.next            return pTmp1            '''            return find_equal(pTmp2, pTmp1, pHead1, pHead2)        if pTmp2:            '''            k = 0            # 寻找出链表长度之间的差值            while pTmp2:                pTmp2 = pTmp2.next                k += 1            # 先让长的那个走K步            pTmp1 = pHead1            pTmp2 = pHead2            for i in range(k):                pTmp2 = pTmp2.next            while pTmp1 != pTmp2:                pTmp1 = pTmp1.next                pTmp2 = pTmp2.next            return pTmp1            '''            return find_equal(pTmp1, pTmp2, pHead1, pHead2)\n\n\n18.孩子们的游戏 [^本题考点 模拟]​    题目：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)\n1234567891011121314# -*- coding:utf-8 -*-class Solution:    def LastRemaining_Solution(self, n, m):        # 通过推倒公式可得 f(n) = (f(n-1) + m) + n        if n &lt; 1 or m &lt; 1:            return -1        if n == 1:            return 0        value = 0        for index in range(2, n+1):            currentValue = (value + m) % index            value = currentValue        # -*- coding:utf-8 -*-class Solution:    def LastRemaining_Solution(self, n, m):        # 通过推倒公式可得 f(n) = (f(n-1) + m) + n        if n &lt; 1 or m &lt; 1:            return -1        if n == 1:            return 0        value = 0        for index in range(2, n+1):            currentValue = (value + m) % index            value = currentValue        return value\n\n\n19.链表中环的入口结点 [^本题考点 链表]​    题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def EntryNodeOfLoop(self, pHead):        # 需要定义两个指针，其中一个条两部，一个跳一步        # 循环跳        # 要么是快的指针为空（没有环），要么是快慢终又一次相等（有环）        if pHead == None:            return None        fastPointer = pHead        slowPointer = pHead        while fastPointer and fastPointer.next:            fastPointer = fastPointer.next.next            slowPointer = slowPointer.next            if fastPointer == slowPointer:                break        if fastPointer == None or fastPointer.next == None:            return None        # 如果slow走了l的长度，那么fast就走了2l的长度        # 假设从开始到入口点的长度为s，slow在环里面走的长度是d        # 那么 l = s + d        # 假设 slow没走的长度是m，fast走的长度是多少        # fast走的长度就是 n*(m+d) + d + s = 2l        # 代入 n*(m+d) + d + s = (m+d) * 2        # n(m+d) = s+d        # s = nm + (n-1)d        # s = m + (n-1)(m+d)        fastPointer = pHead        while fastPointer != slowPointer:            fastPointer = fastPointer.next            slowPointer = slowPointer.next        # -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def EntryNodeOfLoop(self, pHead):        # 需要定义两个指针，其中一个条两部，一个跳一步        # 循环跳        # 要么是快的指针为空（没有环），要么是快慢终又一次相等（有环）        if pHead == None:            return None        fastPointer = pHead        slowPointer = pHead        while fastPointer and fastPointer.next:            fastPointer = fastPointer.next.next            slowPointer = slowPointer.next            if fastPointer == slowPointer:                break        if fastPointer == None or fastPointer.next == None:            return None        # 如果slow走了l的长度，那么fast就走了2l的长度        # 假设从开始到入口点的长度为s，slow在环里面走的长度是d        # 那么 l = s + d        # 假设 slow没走的长度是m，fast走的长度是多少        # fast走的长度就是 n*(m+d) + d + s = 2l        # 代入 n*(m+d) + d + s = (m+d) * 2        # n(m+d) = s+d        # s = nm + (n-1)d        # s = m + (n-1)(m+d)        fastPointer = pHead        while fastPointer != slowPointer:            fastPointer = fastPointer.next            slowPointer = slowPointer.next        return fastPointer\n\n\n20.二进制中1的个数 [^本题考点 位运算]​    题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution:    def NumberOf1(self, n):        # 补码：正数不变，负数是它的整数的反码+1        n = 0xFFFFFFFF &amp; n        # 第一种        # count = 0        # for i in str(bin(n)):        #     if i == '1':        #         count +=1        # return count        # 第二种        # count = 0        # for i in range(32):        #     mask = 1 &lt;&lt; i        #     if n &amp; mask != 0:        #         count += 1        # return count        # 第三种        count = 0        while n:            n = n &amp; (n-1)            count += 1            n = 0xFFFFFFFF &amp; n        # -*- coding:utf-8 -*-class Solution:    def NumberOf1(self, n):        # 补码：正数不变，负数是它的整数的反码+1        n = 0xFFFFFFFF &amp; n        # 第一种        # count = 0        # for i in str(bin(n)):        #     if i == '1':        #         count +=1        # return count        # 第二种        # count = 0        # for i in range(32):        #     mask = 1 &lt;&lt; i        #     if n &amp; mask != 0:        #         count += 1        # return count        # 第三种        count = 0        while n:            n = n &amp; (n-1)            count += 1            n = 0xFFFFFFFF &amp; n        return count\n\n\n21.不用加减乘除做加法 [^本题考点 发散思维能力]​    *写一个函数，求两个整数之和，要求在函数体内不得使用+、-、、/四则运算符号。**\n12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution:    def Add(self, num1, num2):        # 两数进行异或操作        xorNum = num1 ^ num2        # 两数进行与操作        andNum = (num1 &amp; num2) &lt;&lt; 1        # 当两数的与不为0就一直循环        while andNum:            # 继续进行 异或操作数和与操作数的异或操作            tmp1 = xorNum ^ andNum            # 继续进行 异或操作数和与操作数的与操作            tmp2 = (xorNum &amp; andNum) &lt;&lt; 1            # 限制tmp1为32位            tmp1 = tmp1 &amp; 0xFFFFFFFF            # 将tmp1重新赋值为xorNum            xorNum = tmp1            # 将tmp2重新赋值为andNum            andNum = tmp2        # 若是整数就返回xorNum，若是负数就得先限制位数再转为负数        return xorNum if xorNum &lt;= 0x7FFFFFFF else ~(xorNum ^ # -*- coding:utf-8 -*-class Solution:    def Add(self, num1, num2):        # 两数进行异或操作        xorNum = num1 ^ num2        # 两数进行与操作        andNum = (num1 &amp; num2) &lt;&lt; 1        # 当两数的与不为0就一直循环        while andNum:            # 继续进行 异或操作数和与操作数的异或操作            tmp1 = xorNum ^ andNum            # 继续进行 异或操作数和与操作数的与操作            tmp2 = (xorNum &amp; andNum) &lt;&lt; 1            # 限制tmp1为32位            tmp1 = tmp1 &amp; 0xFFFFFFFF            # 将tmp1重新赋值为xorNum            xorNum = tmp1            # 将tmp2重新赋值为andNum            andNum = tmp2        # 若是整数就返回xorNum，若是负数就得先限制位数再转为负数        return xorNum if xorNum &lt;= 0x7FFFFFFF else ~(xorNum ^ 0xFFFFFFFF)\n\n\n22.数组中出现次数超过一半的数字 [^本题考点 数组]​    题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。\n123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class Solution:    def MoreThanHalfNum_Solution(self, numbers):        # 时间复杂度O(n), 空间复杂度O(n)        # numCount = {}        # numLen = len(numbers)        # for num in numbers:        #     if num in numCount:        #         numCount[num] += 1        #     else:        #         numCount[num] = 1        #     if numCount[num] &gt; (numLen &gt;&gt; 1):        #         return num        # return 0        # 想要空间复杂度为O(1)，时间复杂度O(n)        # 思路：遇到不相同的数据就相互抵消掉，最终剩下的数字就可能是大于一半的数字        numLen = len(numbers)        last = 0        lastCount = 0        for num in numbers:            if lastCount == 0:                last = num                lastCount = 1            else:                if num == last:                    lastCount += 1                else:                    lastCount -= 1        if lastCount == 0:            return 0        else:            # 这种情况是last可能是大于一半的数字            lastCount = 0            for num in numbers:                if num == last:                    lastCount += 1            if lastCount &gt; (numLen &gt;&gt; 1):                return last        return # -*- coding:utf-8 -*-class Solution:    def MoreThanHalfNum_Solution(self, numbers):        # 时间复杂度O(n), 空间复杂度O(n)        # numCount = {}        # numLen = len(numbers)        # for num in numbers:        #     if num in numCount:        #         numCount[num] += 1        #     else:        #         numCount[num] = 1        #     if numCount[num] &gt; (numLen &gt;&gt; 1):        #         return num        # return 0        # 想要空间复杂度为O(1)，时间复杂度O(n)        # 思路：遇到不相同的数据就相互抵消掉，最终剩下的数字就可能是大于一半的数字        numLen = len(numbers)        last = 0        lastCount = 0        for num in numbers:            if lastCount == 0:                last = num                lastCount = 1            else:                if num == last:                    lastCount += 1                else:                    lastCount -= 1        if lastCount == 0:            return 0        else:            # 这种情况是last可能是大于一半的数字            lastCount = 0            for num in numbers:                if num == last:                    lastCount += 1            if lastCount &gt; (numLen &gt;&gt; 1):                return last        return 0\n\n\n23.整数中1出现的次数（从1到n整数中1出现的次数） [^本题考点 时间效率]​    求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-class Solution:    def NumberOf1Between1AndN_Solution(self, n):        # 第一种，不考虑时间复杂度        # count = 0        # for i in range(1, n + 1):        #     for j in str(i):        #         if j == '1':        #             count += 1        # return count        # 第二种，简化事件复杂度        # 起始参数的设定，从第一个开始，之后每次往右移动1个，即*10        precise = 1        # 参数位左侧的可能数量        highValue = 1        # 位数，用作乘方运算        count = 0        # 最后的要返回的总数量        sumNum = 0        # 当参数位左侧不为0时循环        while highValue != 0:            # 取出高位            highValue = n // (precise * 10)            # 取出参数位（每循环一次变一下）            midValue = (n // precise) % 10            # 取出低位            lowValue = n % precise            # 每次都*10            precise = precise * 10            # 参数位分三种情况            # 第一种，参数位等于0，若是该位想为1的话，只能进1，向左侧的可能性借1，右侧为10^count种可能性            if midValue == 0:                num = (highValue -1 +1) * pow(10, count)            # 第二种，参数位大于1，就不用向左侧去借位，右侧为10^count种可能性            elif midValue &gt; 1:                num = (highValue + 1) * pow(10, count)            # 第三种，参数位就是1，有lowValue + 1个是需要进位的，其余不需要进位            else:                num = highValue * pow(10, count) + lowValue + 1            # 每次循环都更新总数量的值            sumNum += num            # 更新count            count += 1        # 返回结果        # -*- coding:utf-8 -*-class Solution:    def NumberOf1Between1AndN_Solution(self, n):        # 第一种，不考虑时间复杂度        # count = 0        # for i in range(1, n + 1):        #     for j in str(i):        #         if j == '1':        #             count += 1        # return count        # 第二种，简化事件复杂度        # 起始参数的设定，从第一个开始，之后每次往右移动1个，即*10        precise = 1        # 参数位左侧的可能数量        highValue = 1        # 位数，用作乘方运算        count = 0        # 最后的要返回的总数量        sumNum = 0        # 当参数位左侧不为0时循环        while highValue != 0:            # 取出高位            highValue = n // (precise * 10)            # 取出参数位（每循环一次变一下）            midValue = (n // precise) % 10            # 取出低位            lowValue = n % precise            # 每次都*10            precise = precise * 10            # 参数位分三种情况            # 第一种，参数位等于0，若是该位想为1的话，只能进1，向左侧的可能性借1，右侧为10^count种可能性            if midValue == 0:                num = (highValue -1 +1) * pow(10, count)            # 第二种，参数位大于1，就不用向左侧去借位，右侧为10^count种可能性            elif midValue &gt; 1:                num = (highValue + 1) * pow(10, count)            # 第三种，参数位就是1，有lowValue + 1个是需要进位的，其余不需要进位            else:                num = highValue * pow(10, count) + lowValue + 1            # 每次循环都更新总数量的值            sumNum += num            # 更新count            count += 1        # 返回结果        return sumNum\n\n\n24.丑数（从1到n整数中1出现的次数） [^本题考点 时间空间效率的平衡]​    题目：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-class Solution:    def GetUglyNumber_Solution(self, index):        # write code here        if index &lt;= 0:            return 0        # 2的指针        twoPointer = 0        # 3的指针        threePointer = 0        # 5的指针        fivePointer = 0        # 丑数列表        uglyList = [1]        # uglyList的计数        count = 1        # 当计数小于index，就一直循环        while count &lt; index:            # 找到三者中的最小值            minValue = min(uglyList[twoPointer] * 2,                           uglyList[threePointer] * 3,                           uglyList[fivePointer] * 5)            # 添加进uglyList            uglyList.append(minValue)            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*2，就将2的指针往后移动一个            if uglyList[-1] == uglyList[twoPointer] * 2:                twoPointer += 1            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*3，就将3的指针往后移动一个            if uglyList[-1] == uglyList[threePointer] * 3:                threePointer += 1            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*5，就将5的指针往后移动一个            if uglyList[-1] == uglyList[fivePointer] * 5:                fivePointer += 1            # count自增1            count += 1        # 最终返回丑数列表的最后一个值即为第index个丑数        return uglyList[# -*- coding:utf-8 -*-class Solution:    def GetUglyNumber_Solution(self, index):        # write code here        if index &lt;= 0:            return 0        # 2的指针        twoPointer = 0        # 3的指针        threePointer = 0        # 5的指针        fivePointer = 0        # 丑数列表        uglyList = [1]        # uglyList的计数        count = 1        # 当计数小于index，就一直循环        while count &lt; index:            # 找到三者中的最小值            minValue = min(uglyList[twoPointer] * 2,                           uglyList[threePointer] * 3,                           uglyList[fivePointer] * 5)            # 添加进uglyList            uglyList.append(minValue)            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*2，就将2的指针往后移动一个            if uglyList[-1] == uglyList[twoPointer] * 2:                twoPointer += 1            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*3，就将3的指针往后移动一个            if uglyList[-1] == uglyList[threePointer] * 3:                threePointer += 1            # 若是当前uglyList的最后一个值等于uglyList[twoPointer]*5，就将5的指针往后移动一个            if uglyList[-1] == uglyList[fivePointer] * 5:                fivePointer += 1            # count自增1            count += 1        # 最终返回丑数列表的最后一个值即为第index个丑数        return uglyList[-1]\n\n\n25.调整数组顺序使奇数位于偶数前面 [^本题考点 数组]​    题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n12345678910# -*- coding:utf-8 -*-class Solution:    def reOrderArray(self, array):        n = len(array)        for i in range(n-1):            for j in range(n-i-1):                if array[j] % 2 == 0 and array[j+1] % 2 == 1:                    array[j], array[j+1] = array[j+1], array[j]        # -*- coding:utf-8 -*-class Solution:    def reOrderArray(self, array):        n = len(array)        for i in range(n-1):            for j in range(n-i-1):                if array[j] % 2 == 0 and array[j+1] % 2 == 1:                    array[j], array[j+1] = array[j+1], array[j]        return array\n\n\n26.树的子结构 [^本题考点 树]​    题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution:    def HasSubtree(self, pRoot1, pRoot2):        # 若两个结点有一个为空，不符合要求        if pRoot2 == None or pRoot1 == None:            return False        def hasEqual(pRoot1, pRoot2):            # 若是右侧为空，肯定符合要求            if pRoot2 == None:                return True            # 如果左侧为空，肯定不合适            if pRoot1 == None:                return False            if pRoot1.val == pRoot2.val:                # 如果一个结点的左结点为空，左侧肯定符合要求                if pRoot2.left == None:                    leftEqual = True                # 如果不是就继续递归判断                else:                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)                # 如果一个结点的右结点为空，右侧肯定符合要求                if pRoot2.right == None:                    rightEqual = True                # 如果不是就继续递归判断                else:                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)                # 返回左右两侧的判断情况                return leftEqual and rightEqual            # 都不符合就返回False            return False        # 如果两个节点相等，就进行判断左右两个分支相不相等        if pRoot1.val == pRoot2.val:            ret = hasEqual(pRoot1, pRoot2)            if ret:                return True        #判断左侧结点        ret = self.HasSubtree(pRoot1.left, pRoot2)        if ret:            return True        # 判断右侧结点        ret = self.HasSubtree(pRoot1.right, pRoot2)        class Solution:    def HasSubtree(self, pRoot1, pRoot2):        # 若两个结点有一个为空，不符合要求        if pRoot2 == None or pRoot1 == None:            return False        def hasEqual(pRoot1, pRoot2):            # 若是右侧为空，肯定符合要求            if pRoot2 == None:                return True            # 如果左侧为空，肯定不合适            if pRoot1 == None:                return False            if pRoot1.val == pRoot2.val:                # 如果一个结点的左结点为空，左侧肯定符合要求                if pRoot2.left == None:                    leftEqual = True                # 如果不是就继续递归判断                else:                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)                # 如果一个结点的右结点为空，右侧肯定符合要求                if pRoot2.right == None:                    rightEqual = True                # 如果不是就继续递归判断                else:                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)                # 返回左右两侧的判断情况                return leftEqual and rightEqual            # 都不符合就返回False            return False        # 如果两个节点相等，就进行判断左右两个分支相不相等        if pRoot1.val == pRoot2.val:            ret = hasEqual(pRoot1, pRoot2)            if ret:                return True        #判断左侧结点        ret = self.HasSubtree(pRoot1.left, pRoot2)        if ret:            return True        # 判断右侧结点        ret = self.HasSubtree(pRoot1.right, pRoot2)        return ret\n\n\n\n\n27.二叉树的镜像 [^本题考点 树]​    题目：操作给定的二叉树，将其变换为源二叉树的镜像。\n123456789101112class Solution:    # 返回镜像树的根节点    def Mirror(self, root):        if root == None:            return None        # 处理根节点        root.left, root.right = root.right, root.left        # 处理左子树        self.Mirror(root.left)        class Solution:    # 返回镜像树的根节点    def Mirror(self, root):        if root == None:            return None        # 处理根节点        root.left, root.right = root.right, root.left        # 处理左子树        self.Mirror(root.left)        # 处理右子树        self.Mirror(root.right)\n\n\n28.从上往下打印二叉树 [^本题考点 树]​    题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n1234567891011121314151617181920212223class Solution:    def PrintFromTopToBottom(self, root):        # 如果根结点为空，直接返回空列表        if root == None:            return []        support = [root]        ret = []        # 当support不为空时一直循环        while support:            # 取出support中的第一个结点            tmpNode = support[0]            # 将此结点的值添加到ret            ret.append(tmpNode.val)            # 如果取出的当前结点有左子结点就将其添加到support            if tmpNode.left:                support.append(tmpNode.left)            # 如果取出的当前结点有右子结点就将其添加到support            if tmpNode.right:                support.append(tmpNode.right)            # 删除掉support中的第一个用过的值            support.pop(0)        # 返回最后的结果        class Solution:    def PrintFromTopToBottom(self, root):        # 如果根结点为空，直接返回空列表        if root == None:            return []        support = [root]        ret = []        # 当support不为空时一直循环        while support:            # 取出support中的第一个结点            tmpNode = support[0]            # 将此结点的值添加到ret            ret.append(tmpNode.val)            # 如果取出的当前结点有左子结点就将其添加到support            if tmpNode.left:                support.append(tmpNode.left)            # 如果取出的当前结点有右子结点就将其添加到support            if tmpNode.right:                support.append(tmpNode.right)            # 删除掉support中的第一个用过的值            support.pop(0)        # 返回最后的结果        return ret\n\n\n29.二叉搜索树的后序遍历序列 [^本题考点 举例让抽象具体化]​    题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution:    def VerifySquenceOfBST(self, sequence):        if sequence == []:            # 此处按照二叉搜索树的定义应为True，但是为了跑通程序写了False            return False        # 找到根结点        rootNum = sequence.pop()        # 删除掉根结点        # del sequence[-1]        # 定义第一个大于根结点值索引位置        index = None        # 循环sequence        for i in range(len(sequence)):            # 找到第一个大于根结点值索引位置            if index == None and rootNum &lt; sequence[i]:                index = i            # 如果找到之后还有比根结点的值小的值，就返回错误            if sequence[i] &lt; rootNum and index != None:                return False        if sequence[:index] == []:            return True        if sequence[index: ] == []:            return True        # 继续查找左子树        leftRet = self.VerifySquenceOfBST(sequence[ :index])        # 继续查找右子树        rightRet = self.VerifySquenceOfBST(sequence[index: ])        # 返回左与右        return leftRet # -*- coding:utf-8 -*-class Solution:    def VerifySquenceOfBST(self, sequence):        if sequence == []:            # 此处按照二叉搜索树的定义应为True，但是为了跑通程序写了False            return False        # 找到根结点        rootNum = sequence.pop()        # 删除掉根结点        # del sequence[-1]        # 定义第一个大于根结点值索引位置        index = None        # 循环sequence        for i in range(len(sequence)):            # 找到第一个大于根结点值索引位置            if index == None and rootNum &lt; sequence[i]:                index = i            # 如果找到之后还有比根结点的值小的值，就返回错误            if sequence[i] &lt; rootNum and index != None:                return False        if sequence[:index] == []:            return True        if sequence[index: ] == []:            return True        # 继续查找左子树        leftRet = self.VerifySquenceOfBST(sequence[ :index])        # 继续查找右子树        rightRet = self.VerifySquenceOfBST(sequence[index: ])        # 返回左与右        return leftRet and rightRet\n\n\n30.二叉树中和为某一值的路径 [^本题考点 举例让抽象具体化]​    题目：输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution:    # 返回二维列表，内部每个列表表示找到的路径    def FindPath(self, root, expectNumber):        # 若根结点为空，就返回空列表        if root == None:            return []        # 定义最终返回列表        ret = []        # 定义保存路径的二维列表        supportArrayList = [[root.val]]        # 定义广度优先遍历的列表        support = [root]        # 当support中有值时一直循环        while support:            # 取出support中的第一个值，结点            tmpNode = support[0]            # 取出supportArrayList中的第一个值，列表，存放路径            tmpArrayList = supportArrayList[0]            # 如果取出的节点为叶子叶节点，就判断tmpArrayList的和是否和目标值相等，若相等就将其列表（路径）添加到返回列表当中            if tmpNode.left == None and tmpNode.right == None:                if sum(tmpArrayList) == expectNumber:                    ret.insert(0, tmpArrayList)            # 如果有左子结点，就执行下面            if tmpNode.left:                # 将左子结点添加到广度优先列表中                support.append(tmpNode.left)                # 将tmpArrayList进行浅拷贝得到newTmpArrayList                newTmpArrayList = copy.copy(tmpArrayList)                # 给newTmpArrayList添加左子结点的值                newTmpArrayList.append(tmpNode.left.val)                # 将newTmpArrayList添加到supportArrayList                supportArrayList.append(newTmpArrayList)            # 如果有右子结点，就执行下面            if tmpNode.right:                # 将右子结点添加到广度优先列表中                support.append(tmpNode.right)                # 将tmpArrayList进行浅拷贝得到newTmpArrayList                newTmpArrayList = copy.copy(tmpArrayList)                # 给newTmpArrayList添加左子结点的值                newTmpArrayList.append(tmpNode.right.val)                # 将newTmpArrayList添加到supportArrayList                supportArrayList.append(newTmpArrayList)            # 删除广度优先的列表的第一个值            support.pop(0)            # 删除保存路径的二维列表的第一个值            supportArrayList.pop(0)        # 返回最终结果        class Solution:    # 返回二维列表，内部每个列表表示找到的路径    def FindPath(self, root, expectNumber):        # 若根结点为空，就返回空列表        if root == None:            return []        # 定义最终返回列表        ret = []        # 定义保存路径的二维列表        supportArrayList = [[root.val]]        # 定义广度优先遍历的列表        support = [root]        # 当support中有值时一直循环        while support:            # 取出support中的第一个值，结点            tmpNode = support[0]            # 取出supportArrayList中的第一个值，列表，存放路径            tmpArrayList = supportArrayList[0]            # 如果取出的节点为叶子叶节点，就判断tmpArrayList的和是否和目标值相等，若相等就将其列表（路径）添加到返回列表当中            if tmpNode.left == None and tmpNode.right == None:                if sum(tmpArrayList) == expectNumber:                    ret.insert(0, tmpArrayList)            # 如果有左子结点，就执行下面            if tmpNode.left:                # 将左子结点添加到广度优先列表中                support.append(tmpNode.left)                # 将tmpArrayList进行浅拷贝得到newTmpArrayList                newTmpArrayList = copy.copy(tmpArrayList)                # 给newTmpArrayList添加左子结点的值                newTmpArrayList.append(tmpNode.left.val)                # 将newTmpArrayList添加到supportArrayList                supportArrayList.append(newTmpArrayList)            # 如果有右子结点，就执行下面            if tmpNode.right:                # 将右子结点添加到广度优先列表中                support.append(tmpNode.right)                # 将tmpArrayList进行浅拷贝得到newTmpArrayList                newTmpArrayList = copy.copy(tmpArrayList)                # 给newTmpArrayList添加左子结点的值                newTmpArrayList.append(tmpNode.right.val)                # 将newTmpArrayList添加到supportArrayList                supportArrayList.append(newTmpArrayList)            # 删除广度优先的列表的第一个值            support.pop(0)            # 删除保存路径的二维列表的第一个值            supportArrayList.pop(0)        # 返回最终结果        return ret\n\n\n31.二叉树与双向链表 [^本题考点 分解让复杂问题简单]​    题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Convert(self, pRootOfTree):        # 定义寻找最右结点的函数        def find_right(node):            # 如果结点右子结点不为空就循环            while node.right:                # 一直往右找                node = node.right            # 返回最右侧的结点            return node        # 如果pRootOfTree为空，返回空        if pRootOfTree == None:            return None        # 递归寻找左子结点        leftNode = self.Convert(pRootOfTree.left)        # 递归寻找右子结点        rightNode = self.Convert(pRootOfTree.right)        # 要返回的结点为最左子结点        retNode = leftNode        # 如果左结点存在，就找到它最右边的结点        if leftNode:            leftNode = find_right(leftNode)        # 如果没有左子结点,返回的结点就是pRootOfTree        else:            retNode = pRootOfTree        # pRootOfTree的左子结点链上leftNode        pRootOfTree.left = leftNode        # pRootOfTree的右子结点链上右子结点        pRootOfTree.right = rightNode        # 如果左子结点不为空        if leftNode:            # 此处为左子结点的最右侧链上pRootOfTree            leftNode.right = pRootOfTree        # 如果右子结点不为空        if rightNode:            # 此处为右子结点的最左侧链上pRootOfTree            rightNode.left = pRootOfTree        # 返回最左侧结点        # -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Convert(self, pRootOfTree):        # 定义寻找最右结点的函数        def find_right(node):            # 如果结点右子结点不为空就循环            while node.right:                # 一直往右找                node = node.right            # 返回最右侧的结点            return node        # 如果pRootOfTree为空，返回空        if pRootOfTree == None:            return None        # 递归寻找左子结点        leftNode = self.Convert(pRootOfTree.left)        # 递归寻找右子结点        rightNode = self.Convert(pRootOfTree.right)        # 要返回的结点为最左子结点        retNode = leftNode        # 如果左结点存在，就找到它最右边的结点        if leftNode:            leftNode = find_right(leftNode)        # 如果没有左子结点,返回的结点就是pRootOfTree        else:            retNode = pRootOfTree        # pRootOfTree的左子结点链上leftNode        pRootOfTree.left = leftNode        # pRootOfTree的右子结点链上右子结点        pRootOfTree.right = rightNode        # 如果左子结点不为空        if leftNode:            # 此处为左子结点的最右侧链上pRootOfTree            leftNode.right = pRootOfTree        # 如果右子结点不为空        if rightNode:            # 此处为右子结点的最左侧链上pRootOfTree            rightNode.left = pRootOfTree        # 返回最左侧结点        return retNode\n\n\n32.最小的K个数 [^本题考点 时间效率]​    输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding:utf-8 -*-class Solution:    def GetLeastNumbers_Solution(self, tinput, k):        # 第一种        # if len(tinput) &lt; k:        #     return []        # ret = sorted(tinput)        # return ret[:k]        # 第二种,使用最大堆        # 创建或者是插入最大堆        def createMaxHeap(num):            maxHeap.append(num)            currentIndex = len(maxHeap) - 1            while currentIndex != 0:                parentIndex = (currentIndex - 1) &gt;&gt; 1                if maxHeap[parentIndex] &lt; maxHeap[currentIndex]:                    maxHeap[parentIndex], maxHeap[currentIndex] = maxHeap[currentIndex], maxHeap[parentIndex]                    currentIndex = parentIndex                else:                    break        # 调整最大堆，头节点发生改变        def adjustMaxHeap(num):            if num &lt; maxHeap[0]:                maxHeap[0] = num            maxHeapLen = len(maxHeap)            index = 0            while index &lt; maxHeapLen:                leftIndex = index * 2 + 1                rightIndex = index * 2 + 2                if rightIndex &lt; maxHeapLen:                    if maxHeap[rightIndex] &lt; maxHeap[leftIndex]:                        largerIndex = leftIndex                    else:                        largerIndex = rightIndex                elif leftIndex &lt; maxHeapLen:                    largerIndex = leftIndex                else:                    break                if maxHeap[index] &lt; maxHeap[largerIndex]:                    maxHeap[index], maxHeap[largerIndex] = maxHeap[largerIndex], maxHeap[index]                index = largerIndex        maxHeap = []        tinputLen = len(tinput)        if tinputLen &lt; k or k &lt;= 0:            return []        for i in range(tinputLen):            if i &lt; k:                createMaxHeap(tinput[i])            else:                adjustMaxHeap(tinput[i])        # -*- coding:utf-8 -*-class Solution:    def GetLeastNumbers_Solution(self, tinput, k):        # 第一种        # if len(tinput) &lt; k:        #     return []        # ret = sorted(tinput)        # return ret[:k]        # 第二种,使用最大堆        # 创建或者是插入最大堆        def createMaxHeap(num):            maxHeap.append(num)            currentIndex = len(maxHeap) - 1            while currentIndex != 0:                parentIndex = (currentIndex - 1) &gt;&gt; 1                if maxHeap[parentIndex] &lt; maxHeap[currentIndex]:                    maxHeap[parentIndex], maxHeap[currentIndex] = maxHeap[currentIndex], maxHeap[parentIndex]                    currentIndex = parentIndex                else:                    break        # 调整最大堆，头节点发生改变        def adjustMaxHeap(num):            if num &lt; maxHeap[0]:                maxHeap[0] = num            maxHeapLen = len(maxHeap)            index = 0            while index &lt; maxHeapLen:                leftIndex = index * 2 + 1                rightIndex = index * 2 + 2                if rightIndex &lt; maxHeapLen:                    if maxHeap[rightIndex] &lt; maxHeap[leftIndex]:                        largerIndex = leftIndex                    else:                        largerIndex = rightIndex                elif leftIndex &lt; maxHeapLen:                    largerIndex = leftIndex                else:                    break                if maxHeap[index] &lt; maxHeap[largerIndex]:                    maxHeap[index], maxHeap[largerIndex] = maxHeap[largerIndex], maxHeap[index]                index = largerIndex        maxHeap = []        tinputLen = len(tinput)        if tinputLen &lt; k or k &lt;= 0:            return []        for i in range(tinputLen):            if i &lt; k:                createMaxHeap(tinput[i])            else:                adjustMaxHeap(tinput[i])        return sorted(maxHeap)\n\n\n33.数据流中的中位数 [^本题考点 树]​    题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182# -*- coding:utf-8 -*-'''如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。'''# 未封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createMaxHeap(self, num):        self.littleValueMaxHeap.append(num)        tmpIndex = len(self.littleValueMaxHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.littleValueMaxHeap[parentIndex] &lt; self.littleValueMaxHeap[tmpIndex]:                self.littleValueMaxHeap[parentIndex], self.littleValueMaxHeap[tmpIndex] = self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMaxHeap(self, num):        if num &lt; self.littleValueMaxHeap[0]:            self.littleValueMaxHeap[0] = num        maxHeapLen = len(self.littleValueMaxHeap)        tmpIndex = 0        while tmpIndex &lt; maxHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; maxHeapLen:                largerIndex = rightIndex if self.littleValueMaxHeap[leftIndex] &lt; self.littleValueMaxHeap[rightIndex] else leftIndex            elif leftIndex &lt; maxHeapLen:                largerIndex = leftIndex            else:                break            if self.littleValueMaxHeap[tmpIndex] &lt; self.littleValueMaxHeap[largerIndex]:                self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[largerIndex] = self.littleValueMaxHeap[largerIndex], self.littleValueMaxHeap[tmpIndex]                tmpIndex = largerIndex            else:                break    def createMinHeap(self, num):        self.bigValueMinHeap.append(num)        tmpIndex = len(self.bigValueMinHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.bigValueMinHeap[tmpIndex] &lt; self.bigValueMinHeap[parentIndex]:                self.bigValueMinHeap[parentIndex], self.bigValueMinHeap[tmpIndex] = self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMinHeap(self, num):        if num &lt; self.bigValueMinHeap[0]:            self.littleValueMaxHeap[0] = num        minHeapLen = len(self.bigValueMinHeap)        tmpIndex = 0        while tmpIndex &lt; minHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; minHeapLen:                smallerIndex = rightIndex if self.bigValueMinHeap[rightIndex] &lt; self.bigValueMinHeap[leftIndex] else leftIndex            elif leftIndex &lt; minHeapLen:                smallerIndex = leftIndex            else:                break            if self.bigValueMinHeap[smallerIndex] &lt; self.bigValueMinHeap[tmpIndex]:                self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[smallerIndex] = self.bigValueMinHeap[smallerIndex], self.bigValueMinHeap[tmpIndex]                tmpIndex = smallerIndex            else:                break    def Insert(self, num):        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustMaxHeap(num)                self.createMinHeap(tmpNum)            else:                self.createMinHeap(num)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createMaxHeap(num)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustMinHeap(num)                    self.createMaxHeap(tmpNum)                else:                    self.createMaxHeap(num)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2# 封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createHeap(self, num, heap, cmpFunc):        heap.append(num)        tmpIndex = len(heap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if cmpFunc(heap[tmpIndex], heap[parentIndex]):                heap[parentIndex], heap[tmpIndex] = heap[tmpIndex], heap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustHeap(self, num, heap, cmpFunc):        if num &lt; heap[0]:            heap[0] = num        heapLen = len(heap)        tmpIndex = 0        while tmpIndex &lt; heapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; heapLen:                largerIndex = rightIndex if cmpFunc(heap[rightIndex], heap[leftIndex]) else leftIndex            elif leftIndex &lt; heapLen:                largerIndex = leftIndex            else:                break            if cmpFunc(heap[largerIndex], heap[tmpIndex]):                heap[tmpIndex], heap[largerIndex] = heap[largerIndex], heap[tmpIndex]                tmpIndex = largerIndex            else:                break    def Insert(self, num):        def cmpMaxHeap(a, b):            return b &lt; a        def cmpMinHeap(a, b):            return a &lt; b        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustHeap(num, self.littleValueMaxHeap, cmpMaxHeap)                self.createHeap(tmpNum, self.bigValueMinHeap, cmpMinHeap)            else:                self.createHeap(num, self.bigValueMinHeap, cmpMinHeap)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustHeap(num, self.bigValueMinHeap, cmpMinHeap)                    self.createHeap(tmpNum, self.littleValueMaxHeap, cmpMaxHeap)                else:                    self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2                if __name__ == '__main__':    s = Solution()    for i in [5,2,3,4,1,6,7,0,# -*- coding:utf-8 -*-'''如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。'''# 未封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createMaxHeap(self, num):        self.littleValueMaxHeap.append(num)        tmpIndex = len(self.littleValueMaxHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.littleValueMaxHeap[parentIndex] &lt; self.littleValueMaxHeap[tmpIndex]:                self.littleValueMaxHeap[parentIndex], self.littleValueMaxHeap[tmpIndex] = self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMaxHeap(self, num):        if num &lt; self.littleValueMaxHeap[0]:            self.littleValueMaxHeap[0] = num        maxHeapLen = len(self.littleValueMaxHeap)        tmpIndex = 0        while tmpIndex &lt; maxHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; maxHeapLen:                largerIndex = rightIndex if self.littleValueMaxHeap[leftIndex] &lt; self.littleValueMaxHeap[rightIndex] else leftIndex            elif leftIndex &lt; maxHeapLen:                largerIndex = leftIndex            else:                break            if self.littleValueMaxHeap[tmpIndex] &lt; self.littleValueMaxHeap[largerIndex]:                self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[largerIndex] = self.littleValueMaxHeap[largerIndex], self.littleValueMaxHeap[tmpIndex]                tmpIndex = largerIndex            else:                break    def createMinHeap(self, num):        self.bigValueMinHeap.append(num)        tmpIndex = len(self.bigValueMinHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.bigValueMinHeap[tmpIndex] &lt; self.bigValueMinHeap[parentIndex]:                self.bigValueMinHeap[parentIndex], self.bigValueMinHeap[tmpIndex] = self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMinHeap(self, num):        if num &lt; self.bigValueMinHeap[0]:            self.littleValueMaxHeap[0] = num        minHeapLen = len(self.bigValueMinHeap)        tmpIndex = 0        while tmpIndex &lt; minHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; minHeapLen:                smallerIndex = rightIndex if self.bigValueMinHeap[rightIndex] &lt; self.bigValueMinHeap[leftIndex] else leftIndex            elif leftIndex &lt; minHeapLen:                smallerIndex = leftIndex            else:                break            if self.bigValueMinHeap[smallerIndex] &lt; self.bigValueMinHeap[tmpIndex]:                self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[smallerIndex] = self.bigValueMinHeap[smallerIndex], self.bigValueMinHeap[tmpIndex]                tmpIndex = smallerIndex            else:                break    def Insert(self, num):        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustMaxHeap(num)                self.createMinHeap(tmpNum)            else:                self.createMinHeap(num)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createMaxHeap(num)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustMinHeap(num)                    self.createMaxHeap(tmpNum)                else:                    self.createMaxHeap(num)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2# 封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createHeap(self, num, heap, cmpFunc):        heap.append(num)        tmpIndex = len(heap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if cmpFunc(heap[tmpIndex], heap[parentIndex]):                heap[parentIndex], heap[tmpIndex] = heap[tmpIndex], heap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustHeap(self, num, heap, cmpFunc):        if num &lt; heap[0]:            heap[0] = num        heapLen = len(heap)        tmpIndex = 0        while tmpIndex &lt; heapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; heapLen:                largerIndex = rightIndex if cmpFunc(heap[rightIndex], heap[leftIndex]) else leftIndex            elif leftIndex &lt; heapLen:                largerIndex = leftIndex            else:                break            if cmpFunc(heap[largerIndex], heap[tmpIndex]):                heap[tmpIndex], heap[largerIndex] = heap[largerIndex], heap[tmpIndex]                tmpIndex = largerIndex            else:                break    def Insert(self, num):        def cmpMaxHeap(a, b):            return b &lt; a        def cmpMinHeap(a, b):            return a &lt; b        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustHeap(num, self.littleValueMaxHeap, cmpMaxHeap)                self.createHeap(tmpNum, self.bigValueMinHeap, cmpMinHeap)            else:                self.createHeap(num, self.bigValueMinHeap, cmpMinHeap)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustHeap(num, self.bigValueMinHeap, cmpMinHeap)                    self.createHeap(tmpNum, self.littleValueMaxHeap, cmpMaxHeap)                else:                    self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2                if __name__ == '__main__':    s = Solution()    for i in [5,2,3,4,1,6,7,0,8]:        s.Insert(i)        print(s.GetMedian())\n\n\n34.二叉树的下一个结点 [^本题考点 树]​    题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class TreeLinkNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None        self.next = Noneclass Solution:    def GetNext(self, pNode):        # 1.寻找右子树，如果存在就一直找到右子树的最左边，就是下一个节点        # 2.没有右子树，就寻找他的父节点，一直找到它是父节点的左子树，打印父节点        if pNode.right:            tmpNode = pNode.right            while tmpNode.left:                tmpNode = tmpNode.left            return tmpNode        else:            tmpNode = pNode            while tmpNode.next:                if tmpNode.next.left == tmpNode:                    return tmpNode.next                tmpNode = tmpNode.next            return # -*- coding:utf-8 -*-class TreeLinkNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None        self.next = Noneclass Solution:    def GetNext(self, pNode):        # 1.寻找右子树，如果存在就一直找到右子树的最左边，就是下一个节点        # 2.没有右子树，就寻找他的父节点，一直找到它是父节点的左子树，打印父节点        if pNode.right:            tmpNode = pNode.right            while tmpNode.left:                tmpNode = tmpNode.left            return tmpNode        else:            tmpNode = pNode            while tmpNode.next:                if tmpNode.next.left == tmpNode:                    return tmpNode.next                tmpNode = tmpNode.next            return None\n\n\n35.对称的二叉树 [^本题考点 树]​    题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。\n1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def isSymmetrical(self, pRoot):        # 定义判断是否镜像的函数        def isMirror(left, right):            # 如果两侧都为空，则是镜像的了            if left == None and right == None:                return True            # 若有一侧不为空，则不是镜像的            elif left == None or right == None:                return False            # 如果左侧的值不等于右侧额值，就不是镜像的            if left.val != right.val:                return False            # 递归判断左侧的左侧和右侧的右侧            ret1 = isMirror(left.left, right.right)            # 递归判断左侧的右侧和右侧的左侧            ret2 = isMirror(left.right, right.left)            # 返回这两个返回值的与            return ret1 and ret2        # 如果此二叉树为空，则其也是对称的        if pRoot == None:            return True        # 返回判断此二叉树的左侧和右侧        # -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def isSymmetrical(self, pRoot):        # 定义判断是否镜像的函数        def isMirror(left, right):            # 如果两侧都为空，则是镜像的了            if left == None and right == None:                return True            # 若有一侧不为空，则不是镜像的            elif left == None or right == None:                return False            # 如果左侧的值不等于右侧额值，就不是镜像的            if left.val != right.val:                return False            # 递归判断左侧的左侧和右侧的右侧            ret1 = isMirror(left.left, right.right)            # 递归判断左侧的右侧和右侧的左侧            ret2 = isMirror(left.right, right.left)            # 返回这两个返回值的与            return ret1 and ret2        # 如果此二叉树为空，则其也是对称的        if pRoot == None:            return True        # 返回判断此二叉树的左侧和右侧        return isMirror(pRoot.left, pRoot.right)\n\n\n36.按之字形顺序打印二叉树 [^本题考点 树]​    题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# -*- coding:utf-8 -*-# 未封装版class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Print(self, pRoot):        # 如果二叉树为空，就返回空        if pRoot == None:            return []        # 定义奇数行，从左到右        stack1 = [pRoot]        # 定义偶数行，从右到左        stack2 = []        # 定义返回的顺序列表        ret = []        # 当奇数行或者偶数行都不为空时循环        while stack1 or stack2:            # 如果奇数行有值            if stack1:                # 临时列表                tmpRet = []                # 如果奇数行有值，就一直循环                while stack1:                    # 临时弹出数据                    tmpNode = stack1.pop()                    # 临时列表里面添加临时数据的值                    tmpRet.append(tmpNode.val)                    # 如果有临时数据的左节点                    if tmpNode.left:                        # 就在偶数行添加临时数据的左节点                        stack2.append(tmpNode.left)                    # 如果有临时数据的右节点                    if tmpNode.right:                        # 就在偶数行添加临时数据的右节点                        stack2.append(tmpNode.right)                # 在返回的顺利列表里面添加临时列表                ret.append(tmpRet)            # 如果偶数行有值            if stack2:                # 临时列表                tmpRet = []                # 如果奇数行有值，就一直循环                while stack2:                    # 临时弹出数据                    tmpNode = stack2.pop()                    # 临时列表里面添加临时数据的值                    tmpRet.append(tmpNode.val)                    # 如果有临时数据的右节点                    if tmpNode.right:                        # 就在偶数行添加临时数据的右节点                        stack1.append(tmpNode.right)                    # 如果有临时数据的左节点                    if tmpNode.left:                        # 就在偶数行添加临时数据的左节点                        stack1.append(tmpNode.left)                # 在返回的顺利列表里面添加临时列表                ret.append(tmpRet)        # 返回顺序列表        return ret# 封装版class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Print(self, pRoot):        # 定义偶数行的添加        def oddAppend(tmpNode, stack2):            # 如果有临时数据的左节点            if tmpNode.left:                # 就在偶数行添加临时数据的左节点                stack2.append(tmpNode.left)            # 如果有临时数据的右节点            if tmpNode.right:                # 就在偶数行添加临时数据的右节点                stack2.append(tmpNode.right)        # 定义奇数行的添加        def evenAppend(tmpNode, stack2):            # 如果有临时数据的右节点            if tmpNode.right:                # 就在偶数行添加临时数据的右节点                stack2.append(tmpNode.right)            # 如果有临时数据的左节点            if tmpNode.left:                # 就在偶数行添加临时数据的左节点                stack2.append(tmpNode.left)        def dataAppend(stack, stack2, appendFunc):            # 临时列表            tmpRet = []            # 如果奇数行有值，就一直循环            while stack:                # 临时弹出数据                tmpNode = stack.pop()                # 临时列表里面添加临时数据的值                tmpRet.append(tmpNode.val)                appendFunc(tmpNode, stack2)            # 在返回的顺利列表里面添加临时列表            ret.append(tmpRet)        # 如果二叉树为空，就返回空        if pRoot == None:            return []        # 定义奇数行，从左到右        stack1 = [pRoot]        # 定义偶数行，从右到左        stack2 = []        # 定义返回的顺序列表        ret = []        while stack1 or stack2:            # 如果奇数行有值            if stack1:                dataAppend(stack1, stack2, oddAppend)            # 如果偶数行有值            if stack2:                dataAppend(stack2, stack1, evenAppend)        # 返回顺序列表        # -*- coding:utf-8 -*-# 未封装版class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Print(self, pRoot):        # 如果二叉树为空，就返回空        if pRoot == None:            return []        # 定义奇数行，从左到右        stack1 = [pRoot]        # 定义偶数行，从右到左        stack2 = []        # 定义返回的顺序列表        ret = []        # 当奇数行或者偶数行都不为空时循环        while stack1 or stack2:            # 如果奇数行有值            if stack1:                # 临时列表                tmpRet = []                # 如果奇数行有值，就一直循环                while stack1:                    # 临时弹出数据                    tmpNode = stack1.pop()                    # 临时列表里面添加临时数据的值                    tmpRet.append(tmpNode.val)                    # 如果有临时数据的左节点                    if tmpNode.left:                        # 就在偶数行添加临时数据的左节点                        stack2.append(tmpNode.left)                    # 如果有临时数据的右节点                    if tmpNode.right:                        # 就在偶数行添加临时数据的右节点                        stack2.append(tmpNode.right)                # 在返回的顺利列表里面添加临时列表                ret.append(tmpRet)            # 如果偶数行有值            if stack2:                # 临时列表                tmpRet = []                # 如果奇数行有值，就一直循环                while stack2:                    # 临时弹出数据                    tmpNode = stack2.pop()                    # 临时列表里面添加临时数据的值                    tmpRet.append(tmpNode.val)                    # 如果有临时数据的右节点                    if tmpNode.right:                        # 就在偶数行添加临时数据的右节点                        stack1.append(tmpNode.right)                    # 如果有临时数据的左节点                    if tmpNode.left:                        # 就在偶数行添加临时数据的左节点                        stack1.append(tmpNode.left)                # 在返回的顺利列表里面添加临时列表                ret.append(tmpRet)        # 返回顺序列表        return ret# 封装版class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def Print(self, pRoot):        # 定义偶数行的添加        def oddAppend(tmpNode, stack2):            # 如果有临时数据的左节点            if tmpNode.left:                # 就在偶数行添加临时数据的左节点                stack2.append(tmpNode.left)            # 如果有临时数据的右节点            if tmpNode.right:                # 就在偶数行添加临时数据的右节点                stack2.append(tmpNode.right)        # 定义奇数行的添加        def evenAppend(tmpNode, stack2):            # 如果有临时数据的右节点            if tmpNode.right:                # 就在偶数行添加临时数据的右节点                stack2.append(tmpNode.right)            # 如果有临时数据的左节点            if tmpNode.left:                # 就在偶数行添加临时数据的左节点                stack2.append(tmpNode.left)        def dataAppend(stack, stack2, appendFunc):            # 临时列表            tmpRet = []            # 如果奇数行有值，就一直循环            while stack:                # 临时弹出数据                tmpNode = stack.pop()                # 临时列表里面添加临时数据的值                tmpRet.append(tmpNode.val)                appendFunc(tmpNode, stack2)            # 在返回的顺利列表里面添加临时列表            ret.append(tmpRet)        # 如果二叉树为空，就返回空        if pRoot == None:            return []        # 定义奇数行，从左到右        stack1 = [pRoot]        # 定义偶数行，从右到左        stack2 = []        # 定义返回的顺序列表        ret = []        while stack1 or stack2:            # 如果奇数行有值            if stack1:                dataAppend(stack1, stack2, oddAppend)            # 如果偶数行有值            if stack2:                dataAppend(stack2, stack1, evenAppend)        # 返回顺序列表        return ret\n\n\n37.把二叉树打印成多行 [^本题考点 树]​    题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。\n1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 返回二维列表[[1,2],[4,5]]    def Print(self, pRoot):        if pRoot == None:            return []        queue1 = [pRoot]        queue2 = []        ret = []        while queue1 or queue2:            if queue1:                tmpRet = []                while queue1:                    tmpNode = queue1[0]                    tmpRet.append(tmpNode.val)                    queue1.pop(0)                    if tmpNode.left:                        queue2.append(tmpNode.left)                    if tmpNode.right:                        queue2.append(tmpNode.right)                ret.append(tmpRet)            if queue2:                tmpRet = []                while queue2:                    tmpNode = queue2[0]                    tmpRet.append(tmpNode.val)                    queue2.pop(0)                    if tmpNode.left:                        queue1.append(tmpNode.left)                    if tmpNode.right:                        queue1.append(tmpNode.right)                ret.append(tmpRet)        # -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 返回二维列表[[1,2],[4,5]]    def Print(self, pRoot):        if pRoot == None:            return []        queue1 = [pRoot]        queue2 = []        ret = []        while queue1 or queue2:            if queue1:                tmpRet = []                while queue1:                    tmpNode = queue1[0]                    tmpRet.append(tmpNode.val)                    queue1.pop(0)                    if tmpNode.left:                        queue2.append(tmpNode.left)                    if tmpNode.right:                        queue2.append(tmpNode.right)                ret.append(tmpRet)            if queue2:                tmpRet = []                while queue2:                    tmpNode = queue2[0]                    tmpRet.append(tmpNode.val)                    queue2.pop(0)                    if tmpNode.left:                        queue1.append(tmpNode.left)                    if tmpNode.right:                        queue1.append(tmpNode.right)                ret.append(tmpRet)        return ret\n\n\n38.二叉搜索树的第k个结点 [^本题考点 树]​    题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。\n12345678910111213141516171819202122232425262728293031323334353637class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 返回对应节点TreeNode    def KthNode(self, pRoot, k):        retList = []        # 先定义中序遍历的函数        # 递归中序法        # def midOrder(pRoot):        #     if pRoot == None:        #         return None        #     midOrder(pRoot.left)        #     retList.append(pRoot)        #     midOrder(pRoot.right)        # 非递归中序法        def midOrder(pRoot):            if pRoot == None:                return None            stack = []            tmpNode = pRoot            while tmpNode or stack:                while tmpNode:                    stack.append(tmpNode)                    tmpNode = tmpNode.left                node = stack.pop()                retList.append(node)                tmpNode = node.right        midOrder(pRoot)        if len(retList) &lt; k or k &lt; 1:            return None        return retList[kclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 返回对应节点TreeNode    def KthNode(self, pRoot, k):        retList = []        # 先定义中序遍历的函数        # 递归中序法        # def midOrder(pRoot):        #     if pRoot == None:        #         return None        #     midOrder(pRoot.left)        #     retList.append(pRoot)        #     midOrder(pRoot.right)        # 非递归中序法        def midOrder(pRoot):            if pRoot == None:                return None            stack = []            tmpNode = pRoot            while tmpNode or stack:                while tmpNode:                    stack.append(tmpNode)                    tmpNode = tmpNode.left                node = stack.pop()                retList.append(node)                tmpNode = node.right        midOrder(pRoot)        if len(retList) &lt; k or k &lt; 1:            return None        return retList[k-1]\n\n\n39.序列化二叉树 [^本题考点 树]​    题目：请实现两个函数，分别用来序列化和反序列化二叉树\n1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 序列化    def Serialize(self, root):        retList = []        def preOrder(root):            if root == None:                retList.append('#')                return            retList.append(str(root.val))            preOrder(root.left)            preOrder(root.right)        preOrder(root)        return ' '.join(retList)    # 反序列化    def Deserialize(self, s):        retList = s.split()        def dePreOrder():            if retList == []:                return None            rootVal = retList.pop(0)            if rootVal == '#':                return None            node = TreeNode(int(rootVal))            leftNode = dePreOrder()            rightNode = dePreOrder()            node.left = leftNode            node.right = rightNode            return node        pRoot = dePreOrder()        # -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 序列化    def Serialize(self, root):        retList = []        def preOrder(root):            if root == None:                retList.append('#')                return            retList.append(str(root.val))            preOrder(root.left)            preOrder(root.right)        preOrder(root)        return ' '.join(retList)    # 反序列化    def Deserialize(self, s):        retList = s.split()        def dePreOrder():            if retList == []:                return None            rootVal = retList.pop(0)            if rootVal == '#':                return None            node = TreeNode(int(rootVal))            leftNode = dePreOrder()            rightNode = dePreOrder()            node.left = leftNode            node.right = rightNode            return node        pRoot = dePreOrder()        return pRoot\n\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"旅游网景点详细页面","url":"https://bubbleboy11.github.io/2020/08/21/lu-you-wang-jing-dian-xiang-xi-ye-mian/","content":"旅游网景点详细页面Vue.js\n面向组件方式编程\n单页面应用\n\n如何在Vue项目中实现“多页面”VueRouter用来在单页面应用中实现“多页面”通过url的规则进行匹配，满足url规则1，展示组件1的内容满足url规则2，展示组件2的内容满足url规则3，展示组件3的内容\nVue中的路由管理\nVue Router是Vue.js官方的路由管理器\n\n新建项目\n\n\n12&gt;&gt; cd C:/Vue&gt;&gt; npm create &gt;&gt; cd C:/Vue&gt;&gt; npm create test\n\n\n安装1>> cnpm install vue-router -S\n\n\n\n路由的使用\n新建/src/router.js\n\n1234import Vue from 'vue'// VueRouter是Vue.js的一个插件import VueRouter from 'vue-router'Vue.use(VueRouter)  import Vue from 'vue'// VueRouter是Vue.js的一个插件import VueRouter from 'vue-router'Vue.use(VueRouter)  // 使用这个插件\n\n\n设置路由规则/src/router.js123456const routes = [  // 页面1 匹配指定规则，匹配/home在对应的组件中显示首页的内容  {path: '/home', component: HomePage, name: 'home'},  // 页面2  {path: '/about', const routes = [  // 页面1 匹配指定规则，匹配/home在对应的组件中显示首页的内容  {path: '/home', component: HomePage, name: 'home'},  // 页面2  {path: '/about', component: AboutPage}]\n配置路由规则/src/router.js1234567const router = new VueRouter({  routes // (缩写) 相当于 routes: routes})new Vue({  el: const router = new VueRouter({  routes // (缩写) 相当于 routes: routes})new Vue({  el: '#app',  router})\n\n\n\n/src/router.js\n1export export default route\n\n/src/main.js\n123456import router from './router'new Vue({  // router: router,  router,}).$mount(import router from './router'new Vue({  // router: router,  router,}).$mount('#app')\n\n\n设置路由切换后页面的显示位置在模板中指定路由切换后组件的渲染位置&lt;router-view&gt;&lt;/router-view&gt;/src/App.vue&gt;\n123456            \n\n在模板中实现路由跳转 转换成html的a标签&lt;router-link to=\"/about\"&gt;&lt;/router-link&gt;\n12345678```/src/App.vue>``````vue      首页 |     关于  \n\n\n\nVue.js中的路由中的参数传递景点详情的路由如何设计？\n\nget参数通过问号/detail?id=1/detail?id=2/detail?id=3\n\ndjango里的url设计原则/detail/1/detail/2/detail/3\n\n\n动态路由匹配\n设置动态匹配规则\n动态路由参数/src/router.js12345678import DetailPage from './views/Detail.vue'const router = new VueRouter({  routes: [    // http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=asc    {path: '/d/:id/:types', import DetailPage from './views/Detail.vue'const router = new VueRouter({  routes: [    // http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=asc    {path: '/d/:id/:types', component: DetailPage}    ]})\n等同于123456789// http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=ascconst routes = [  {path: '/d/:id/:types', component: DetailPage}]const route = new VueRouter({  // routes: routes  routes // http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=ascconst routes = [  {path: '/d/:id/:types', component: DetailPage}]const route = new VueRouter({  // routes: routes  routes // (缩写) 相当于 routes: routes})\n\n\n\n\n\nApp.vue\n1234567891011export default {  data () {    return {      id: '',      name: '',      type: ''    }  }}    \n\n新建/test/src/views/Detail.vue\n\n在组件中获取匹配参数和查询\n\n在JS中获取参数\n``` 获取当前路由123456789```Detial.vue``````vueexport default {  created () {    let id = this.$route.params.id  }}\n\n响应参数的变化Detial.vue\n12345678910111213141516export default {  watch: {    $route(to, from) {      // 对路由变化作出响应...      console.log('to:', to)      console.log('from:', from)      this.id = this.$route.params.id    },    id (to, from) {      console.log('to-id:', to)      console.log('from-id:', from)    }  }}  \n\n\n\nURL中的查询参数/sight/list?name=ashe\n\n获取方式Detail.vue\n1234567891011  详情页：{{ id }} : {{ name }} : {{ type }}export default {  created () {    let name = this.$route.query.name  }}\n\n\n\n路由的跳转\n在模板中标签跳转 router-linkApp.vue12345678      详情1|    <!--  -->          \n在浏览器点击点我回到详情1跳转http://localhost:8080/#/d/123/type1\n\n\n路由命名 方便URL修改rounter.js\n123456789import DetailPage from './views/Detail.vue'// 定义路由规则const routes = [  {path: '/home', component: HomePage, name: 'home'},  {path: '/about', component: AboutPage},  // http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=asc  {path: '/d/:id/:types', component: DetailPage, name: import DetailPage from './views/Detail.vue'// 定义路由规则const routes = [  {path: '/home', component: HomePage, name: 'home'},  {path: '/about', component: AboutPage},  // http://localhost:8080/#/detail/1234/type1?name=ashe&amp;sort=asc  {path: '/d/:id/:types', component: DetailPage, name: 'detail-page'}]\n\n按照名称跳转\n12345678910111213141516171819202122      详情2|    详情3|    详情4|      // import HelloWorld from './components/HelloWorld.vue'export default {  name: 'App',  data () {    return {      id: 456,      types: 'type2'    }  }}\n在浏览器点击点我回到详情2跳转http://localhost:8080/#/d/456/type2在浏览器点击点我回到详情3跳转http://localhost:8080/#/d/456/type2?name=abc&amp;sort=desc在浏览器点击点我回到详情4跳转http://localhost:8080/#/d/abc123/type3?name=abc&amp;sort=desc\n\n\n\n在JS中事件跳转vue```得到的实例1234567891011121314>传参是 ```router```，接收参数是 ```route``````$router```表示vue实例上所挂载的在```main.js```的```new vue```中的```router```这个对象，跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。```App.vue``````vue          this.$router.push('/home')          this.$router.push({path:'/home'})  \n\n\n\n③ query 传参，相当于get请求，页面跳转时参数会在地址栏中显示，通过this.$route.query.id获取\n1234567// 变成 /user?id=2this.$router.push({     path:'/user',    query:{        id:// 变成 /user?id=2this.$router.push({     path:'/user',    query:{        id:this.id    }})\n④ params 传参，相当于post请求，页面跳转时参数不会在地址栏中显示,通过this.$route.params.id获取\n123456this.$router.push({     path:'/user',    params:{        id:this.$router.push({     path:'/user',    params:{        id:this.id    }})\n\n123456789101112131415161718192021222324      点我跳转  export default {  name: 'App',  data () {    return {      id: 456,      types: 'type2'    }  },  methods: {    goHome () {      this.$router.push('/home')      // this.$router.push({name: 'home'})      // this.$router.push({name: \"detail-page\", params: {id: \"abc123\", types: \"type3\"}, query: {name: \"abc\", sort: \"desc\"}})    }  }}\n\n在浏览器点击点我回到首页跳转http://localhost:8080/#/home\n路由的跳转方式\n页面跳转\n\nthis.$router.push(location, onComplete?, onAbort?)\n\n页面前进或后退this.$router.go(n)n可为正数可为负数。正数返回上一个页面。123456789101112// 在浏览器记录中前进1步，相当于history.forward()this.$router.go(1)// 后退一步记录，等同于history.back()this.$router.go(-1)// 前进三步记录this.$router.go(3)// 如果history记录不够用，就会失败this.$router.go(100)this.$router.go(// 在浏览器记录中前进1步，相当于history.forward()this.$router.go(1)// 后退一步记录，等同于history.back()this.$router.go(-1)// 前进三步记录this.$router.go(3)// 如果history记录不够用，就会失败this.$router.go(100)this.$router.go(-100)\n\n\n\n12345678910111213141516171819202122      点我跳转  export default {  name: 'App',  data () {    return {      id: 456,      types: 'type2'    }  },  methods: {    goBack () {      this.$router.go(-1)    }  }}\n\n\n替换浏览历史记录同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。场景是用户登录了后退，支付成功后退，不能回到原来的页面\n\nthis.$router.replace(location, onComplete?, onAbort?)\n12345678910111213141516export default {  name: 'App',  data () {    return {      id: 456,      types: 'type2'    }  },  methods: {    goHome () {      this.$router.replace({name: 'home'})    }  }}\n\n景点搜索页面实现步骤\n\n查找Vant中可以使用的组件\n实现组件模板部分\n模型层准备数据\n模拟数据，实现效果\n\n使用Vant中可用的组件复用景点列表组件结合VueRouter实现页面跳转\n新建/src/views/Search.vue\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667            <van-nav-bar title=\"搜索景点\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"      v-if=\"isHome\"/>        <van-search      v-model=\"sightName\"      show-action      label=\"景点\"      placeholder=\"请输入搜索关键词\"      @search=\"onSearch\"    >              搜索                        <sight-item v-for=\"item in dataList\"        :key=\"item.id\"        :item=\"item\"/>            <van-pagination v-model=\"currentPage\"    :total-items=\"totalItems\"    :items-per-page=\"perPage\" />          // 景点列表的每一项import SightItem from '@/components/common/ListSight'// 底部导航import TripFooter from '@/components/common/Footer'export default {  data () {    return {      // 景点名称      sightName: '',      // 景点列表的数据      dataList: [],      // 总记录数      totalItems: 0,      // 当前的页码      currentPage: 1,      // 每页数据的大小      perPage: 5    }  },  components: {    SightItem,    TripFooter  },  methods: {    onSearch () {      console.log('onSearch ')    }  }}\n\n/src/router/index.js\n123456789import Search from '../views/Search.vue'const routes = [  {    path: '/search',    name: import Search from '../views/Search.vue'const routes = [  {    path: '/search',    name: 'Search',    component: Search  }]\n\n点击底部导航跳转到搜索/src/components/common/Footer.vue\n123456789                  首页      搜索      \n\n搭建前端详情页实现步骤\n设计URL路由规则/src/router/index.js\n1234567891011121314151617181920212223242526272829303132333435363738import SightList from '../views/sight/SightList.vue'import SightDetail from '../views/sight/SightDetail.vue'import SightInfo from '../views/sight/SightInfo.vue'import SightComment from '../views/sight/SightComment.vue'import SightImage from '../views/sight/SightImage.vue'const routes = [  // 景点列表  {    path: '/sight/list',    name: 'SightList',    component: SightList  },  // 景点详情  {    path: '/sight/detail/:id',    name: 'SightDetail',    component: SightDetail  },  // 景点介绍  {    path: '/sight/info/:id',    name: 'SightInfo',    component: SightInfo  },  // 评论列表  {    path: '/sight/comment/:id',    name: 'SightComment',    component: SightComment  },  // 景点下的图片  {    path: '/sight/image/:id',    name: import SightList from '../views/sight/SightList.vue'import SightDetail from '../views/sight/SightDetail.vue'import SightInfo from '../views/sight/SightInfo.vue'import SightComment from '../views/sight/SightComment.vue'import SightImage from '../views/sight/SightImage.vue'const routes = [  // 景点列表  {    path: '/sight/list',    name: 'SightList',    component: SightList  },  // 景点详情  {    path: '/sight/detail/:id',    name: 'SightDetail',    component: SightDetail  },  // 景点介绍  {    path: '/sight/info/:id',    name: 'SightInfo',    component: SightInfo  },  // 评论列表  {    path: '/sight/comment/:id',    name: 'SightComment',    component: SightComment  },  // 景点下的图片  {    path: '/sight/image/:id',    name: 'SightImage',    component: SightImage  }]\n\n新建详情页页面\n\n新建目录/src/views/sight\n\n新建/src/views/sight/SightList.vue\n1234    \n\n新建/src/views/sight/SightDetail.vue\n1234    \n\n新建/src/views/sight/SightInfo.vue\n1234    \n\n新建/src/views/sight/SightComment.vue\n1234    \n新建/src/views/sight/SightImage.vue\n1234    \n\n\n\n修改景点列表组件，支持路由跳转从景点列表跳到景点详情/src/components/common/ListSight.vue\n12345  <router-link class=\"sight-item\"    :to=\"{name: 'SightDetail', params: {id: item.id}}\">      \n\n\n\n从标题热门景点和更多跳到景点列表从热门景点的地点跳到对应景点详情/src/components/home/Hot.vue\n1234567891011121314151617            <van-cell      :to=\"{name: 'SightList', query: {name: '热门推荐'}}\"/>                  <router-link class=\"hot-item\"        :to=\"{name: 'SightDetail', params: {id: item.id}}\">                        \n\n从标题精选景点和更多跳到景点列表从精选景点的地点跳到对应景点列表/src/components/home/Fine.vue\n1234567891011121314151617            <van-cell      title=\"精选景点\"      :to=\"{name: 'SightList', query: {name: '精选景点'}}\"/>                  <sight-item v-for=\"item in dataList\"        :key=\"item.id\"        :item=\"item\"/>                    \n\n\n拆分详情页组件/src/views/sight/SightDetail.vue123456789101112131415161718192021222324252627282930313233343536373839            <van-nav-bar    left-text=\"返回\"    left-arrow    fixed    @click-left=\"goBack\"  />                                          export default {  methods: {    goBack () {      this.$router.go(-1)    }  }}.page-sight-detail {  // 导航栏    .van-nav-bar {    background-color: transparent;  }}\n\n\n\n景点大图部分实现步骤\n查找Vant中可以使用的组件\n实现组件模板部分123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 大图 --&gt;    &lt;div class=\"sight-banner\"&gt;      &lt;van-image src=\"/static/home/hot/h1_max.jpg\" width=\"100%\" height=\"100%\"/&gt;      &lt;div class=\"tips\"&gt;        &lt;router-link class=\"pic-sts\" :to=\"{name: 'SightImage', params: {id: 123}}\"&gt;          &lt;van-icon name=\"video-o\" /&gt;          &lt;span&gt;10 图片&lt;/span&gt;        &lt;/router-link&gt;        &lt;div class=\"title\"&gt;景点标题&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //大图 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 景点大图  .sight-banner{    position: relative;    .tips {      position: absolute;      left: 10px;      bottom: 10px;      font-size: 16px;      color: #fff;      .pic-sts {        color: #fff;        border-radius: 30px;        font-size: 14px;        background-color: rgba(0,0,0,0.4);      }    }  }}&lt;/&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 大图 --&gt;    &lt;div class=\"sight-banner\"&gt;      &lt;van-image src=\"/static/home/hot/h1_max.jpg\" width=\"100%\" height=\"100%\"/&gt;      &lt;div class=\"tips\"&gt;        &lt;router-link class=\"pic-sts\" :to=\"{name: 'SightImage', params: {id: 123}}\"&gt;          &lt;van-icon name=\"video-o\" /&gt;          &lt;span&gt;10 图片&lt;/span&gt;        &lt;/router-link&gt;        &lt;div class=\"title\"&gt;景点标题&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //大图 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 景点大图  .sight-banner{    position: relative;    .tips {      position: absolute;      left: 10px;      bottom: 10px;      font-size: 16px;      color: #fff;      .pic-sts {        color: #fff;        border-radius: 30px;        font-size: 14px;        background-color: rgba(0,0,0,0.4);      }    }  }}&lt;/style>\n模型层准备数据\n模拟数据，实现效果\n\n评分、景点介绍实现步骤\n查找Vant中可以使用的组件\n实现组件模板部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 评分、景点介绍 --&gt;    &lt;div class=\"sight-info\"&gt;      &lt;div class=\"left\"&gt;        &lt;div class=\"info-title\"&gt;          &lt;strong&gt;5分&lt;/strong&gt;          &lt;small&gt;很棒&lt;/small&gt;        &lt;/div&gt;        &lt;div class=\"info-tips\"&gt;50 评论&lt;/div&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/div&gt;      &lt;div class=\"right\"&gt;        &lt;div class=\"info-title\"&gt;          &lt;span&gt;景点介绍&lt;/span&gt;        &lt;/div&gt;        &lt;div class=\"info-tips\"&gt;开放时间、贴士&lt;/div&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //评分、景点介绍 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 评分、景点介绍  .sight-info {    display: flex;    background-color: #fff;    border-bottom: 1px solid #f6f6f6;    &amp; &gt; div {      flex: 1;      position: relative;    }    .right {      border-left: 1px solid #f6f6f6;    }    .info-title {      text-align: left;      padding: 5px 10px;      strong {        color: #ff8300;      }    }    .info-tips {      color: #999;      font-size: 12px;      text-align: left;      padding: 5px 10px;    }    .van-icon {      position: absolute;      right: 5px;      top: 5px    }  }}&lt;/&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 评分、景点介绍 --&gt;    &lt;div class=\"sight-info\"&gt;      &lt;div class=\"left\"&gt;        &lt;div class=\"info-title\"&gt;          &lt;strong&gt;5分&lt;/strong&gt;          &lt;small&gt;很棒&lt;/small&gt;        &lt;/div&gt;        &lt;div class=\"info-tips\"&gt;50 评论&lt;/div&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/div&gt;      &lt;div class=\"right\"&gt;        &lt;div class=\"info-title\"&gt;          &lt;span&gt;景点介绍&lt;/span&gt;        &lt;/div&gt;        &lt;div class=\"info-tips\"&gt;开放时间、贴士&lt;/div&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //评分、景点介绍 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 评分、景点介绍  .sight-info {    display: flex;    background-color: #fff;    border-bottom: 1px solid #f6f6f6;    &amp; &gt; div {      flex: 1;      position: relative;    }    .right {      border-left: 1px solid #f6f6f6;    }    .info-title {      text-align: left;      padding: 5px 10px;      strong {        color: #ff8300;      }    }    .info-tips {      color: #999;      font-size: 12px;      text-align: left;      padding: 5px 10px;    }    .van-icon {      position: absolute;      right: 5px;      top: 5px    }  }}&lt;/style>\n模型层准备数据\n模拟数据，实现效果\n\n地址信息实现步骤\n查找Vant中可以使用的组件\n实现组件模板部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 地址信息 --&gt;    &lt;van-cell title=\"广东省广州市番禺区番禺大道\" icon=\"location-o\"      is-link      :title-style=\"{'text-align': 'left'}\"&gt;      &lt;template #right-icon&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/template&gt;    &lt;/van-cell&gt;    &lt;!-- //地址信息 --&gt;  &lt;/div&gt;&lt;/template&gt;```   ### 门票列表#### 实现步骤- 查找Vant中可以使用的组件- 实现组件模板部分```html&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 门票列表 --&gt;    &lt;div class=\"sight-ticket\"&gt;      &lt;van-cell title=\"门票\" icon=\"bookmark-o\" title-style=\"text-align:left\"/&gt;      &lt;div class=\"ticket-item\" v-for=\"i in 5\" :key=\"i\"&gt;        &lt;div class=\"left\"&gt;          &lt;div class=\"title\"&gt;成人票&lt;/div&gt;          &lt;div class=\"tips\"&gt;            &lt;van-icon name=\"clock-o\" /&gt;            &lt;span&gt;7点之前可以预定&lt;/span&gt;          &lt;/div&gt;          &lt;div class=\"tags\"&gt;            &lt;van-tag mark type=\"primary\"&gt;标签1&lt;/van-tag&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=\"right\"&gt;          &lt;div class=\"price\"&gt;            &lt;span&gt;￥&lt;/span&gt;            &lt;strong&gt;65&lt;/strong&gt;          &lt;/div&gt;          &lt;router-link to=\"#\"&gt;            &lt;van-button type=\"warning\" size=\"small\"&gt;预定&lt;/van-button&gt;          &lt;/router-link&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //门票列表 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 门票列表  .sight-ticket {    margin-top: 10px;    background-color: #fff;    .ticket-item {      display: flex;      border-bottom: 1px solid #f6f6f6;      padding-bottom: 10px;      .left {        flex: 1;        text-align: left;        padding: 5px 10px;        .title {          padding: 5px 0;        }        .tips {          font-size: 12px;        }      }      .right {        width: 100px;        .price {          color: #ff9800;          strong {            font-size: 20px;          }        }      }    }  }}&lt;/&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 地址信息 --&gt;    &lt;van-cell title=\"广东省广州市番禺区番禺大道\" icon=\"location-o\"      is-link      :title-style=\"{'text-align': 'left'}\"&gt;      &lt;template #right-icon&gt;        &lt;van-icon name=\"arrow\" /&gt;      &lt;/template&gt;    &lt;/van-cell&gt;    &lt;!-- //地址信息 --&gt;  &lt;/div&gt;&lt;/template&gt;```   ### 门票列表#### 实现步骤- 查找Vant中可以使用的组件- 实现组件模板部分```html&lt;template&gt;  &lt;!-- 景点详情 --&gt;  &lt;div class=\"page-sight-detail\"&gt;    &lt;!-- 门票列表 --&gt;    &lt;div class=\"sight-ticket\"&gt;      &lt;van-cell title=\"门票\" icon=\"bookmark-o\" title-style=\"text-align:left\"/&gt;      &lt;div class=\"ticket-item\" v-for=\"i in 5\" :key=\"i\"&gt;        &lt;div class=\"left\"&gt;          &lt;div class=\"title\"&gt;成人票&lt;/div&gt;          &lt;div class=\"tips\"&gt;            &lt;van-icon name=\"clock-o\" /&gt;            &lt;span&gt;7点之前可以预定&lt;/span&gt;          &lt;/div&gt;          &lt;div class=\"tags\"&gt;            &lt;van-tag mark type=\"primary\"&gt;标签1&lt;/van-tag&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class=\"right\"&gt;          &lt;div class=\"price\"&gt;            &lt;span&gt;￥&lt;/span&gt;            &lt;strong&gt;65&lt;/strong&gt;          &lt;/div&gt;          &lt;router-link to=\"#\"&gt;            &lt;van-button type=\"warning\" size=\"small\"&gt;预定&lt;/van-button&gt;          &lt;/router-link&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- //门票列表 --&gt;  &lt;/div&gt;&lt;/template&gt;```    ```vue&lt;style lang=\"less\"&gt;.page-sight-detail {  // 门票列表  .sight-ticket {    margin-top: 10px;    background-color: #fff;    .ticket-item {      display: flex;      border-bottom: 1px solid #f6f6f6;      padding-bottom: 10px;      .left {        flex: 1;        text-align: left;        padding: 5px 10px;        .title {          padding: 5px 0;        }        .tips {          font-size: 12px;        }      }      .right {        width: 100px;        .price {          color: #ff9800;          strong {            font-size: 20px;          }        }      }    }  }}&lt;/style>\n模型层准备数据\n模拟数据，实现效果\n\n用户评价列表实现步骤\n查找Vant中可以使用的组件\n实现组件模板部分\n\n当key=value，key:value等同于keyparams: {id: id}等同于params: {id}/src/views/sight/SightDetail.vue\n123456789101112                              查看更多          \n点击查看更多跳到景点评价\n123456789101112131415161718192021222324252627282930export default {  data () {    return {      id: ''    }  },  created () {    this.id = this.$route.params.id  }  // 查看更多  .link-more {    display: block;    color: #666;    padding: 10px;  }}    ```    ```vue.page-sight-detail {  // 评论列表  .sight-comment {    margin-top: 10px;    background-color: #fff;  }}\n\n评价列表只在景点模块的详情页和查看更多复用新建目录/src/components/sight新建/src/components/sight/CommentItem.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748                      <van-rate v-model=\"value\"        allow-half        readonly        void-icon=\"star\"        void-color=\"#eee\" />            张三*** 2021-3-19              评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容评论内容                                            第{{ index + 1 }}页          export default {  data () {    return {      show: false,      index: 0,      images: [        'https://img.yzcdn.cn/vant/apple-1.jpg',        'https://img.yzcdn.cn/vant/apple-2.jpg'      ],      value: 4.5    }  },  methods: {    onChange (index) {      this.index = index    }  }}\n\n详情/src/views/sight/SightDetail.vue引入评价模块&lt;comment-item/&gt;等同于&lt;CommentItem/&gt;\n1234567891011121314151617181920                            // 评论项组件import CommentItem from '@/components/sight/CommentItem'export default {  components: {    CommentItem  }}\n\n模型层准备数据\n模拟数据，实现效果\n\nORM模型设计开发步骤\n\n分析并设计模型pdman工具\n完成ORM模型编码新建一个packageutils1234567891011from django.db import modelsclass CommonModel(models.Model):    \"\"\" 模型公共类 \"\"\"    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        abstract = from django.db import modelsclass CommonModel(models.Model):    \"\"\" 模型公共类 \"\"\"    is_valid = models.BooleanField('是否有效', default=True)    created_at = models.DateTimeField('创建时间', auto_now_add=True)    updated_at = models.DateTimeField('修改时间', auto_now=True)    class Meta:        abstract = True\n\n\n\n1C:\\django\\trip>python manage.py startapp accounts\n\naccounts/models.py  \n1234567891011121314from django.db import modelsfrom utils.models import CommonModelclass User(CommonModel):    \"\"\" 用户模型 \"\"\"    username = models.CharField('用户名', max_length=32, unique=True)    password = models.CharField('密码', max_length=256)    avatar = models.ImageField('用户头像', upload_to='avatar/%Y%m', null=True, blank=True)    nickname = models.CharField('昵称', max_length=32, unique=True)    class Meta:        db_table = from django.db import modelsfrom utils.models import CommonModelclass User(CommonModel):    \"\"\" 用户模型 \"\"\"    username = models.CharField('用户名', max_length=32, unique=True)    password = models.CharField('密码', max_length=256)    avatar = models.ImageField('用户头像', upload_to='avatar/%Y%m', null=True, blank=True)    nickname = models.CharField('昵称', max_length=32, unique=True)    class Meta:        db_table = 'account_user'\n\ntrip\\setting.py\n1234INSTALLED_APPS = [    # 用户账户    INSTALLED_APPS = [    # 用户账户    'accounts.apps.AccountsConfig']\n\nsystem/models.py和sight/models.py删掉\n123is_valid = models.BooleanField('是否有效', default=True)created_at = models.DateTimeField('创建时间', auto_now_add=True)updated_at = models.DateTimeField('修改时间', auto_now=is_valid = models.BooleanField('是否有效', default=True)created_at = models.DateTimeField('创建时间', auto_now_add=True)updated_at = models.DateTimeField('修改时间', auto_now=True)\n\nsystem/models.py\n12345678910111213141516class ImageRelated(CommonModel):    \"\"\" 图片关联 \"\"\"    img = models.ImageField('图片', upload_to='%Y%m/file/', max_length=256)    summary = models.CharField('图片说明', max_length=32, null=True, blank=True)    user = models.ForeignKey(User,                             on_delete=models.SET(None),                             related_name='upload_images',                             verbose_name='上传的用户',                             null=True)    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)    object_id = models.IntegerField('关联的模型')    # 查到某一个图片要得到关联的某一个模型的对象    content_object = GenericForeignKey('content_type', 'object_id')    class Meta:        db_table = class ImageRelated(CommonModel):    \"\"\" 图片关联 \"\"\"    img = models.ImageField('图片', upload_to='%Y%m/file/', max_length=256)    summary = models.CharField('图片说明', max_length=32, null=True, blank=True)    user = models.ForeignKey(User,                             on_delete=models.SET(None),                             related_name='upload_images',                             verbose_name='上传的用户',                             null=True)    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)    object_id = models.IntegerField('关联的模型')    # 查到某一个图片要得到关联的某一个模型的对象    content_object = GenericForeignKey('content_type', 'object_id')    class Meta:        db_table = 'system_image_related'\n\nsight/models.py\n12345678910111213141516171819202122232425262728293031323334from django.contrib.contenttypes.fields import GenericRelationfrom django.db import modelsfrom system.models import ImageRelatedfrom utils.models import CommonModelclass Sight(CommonModel):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    # 反向关联，景点和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             # 通过一个景点的模型对象，找到对应id的记录，转换为sight的对象，                             # 通过其属性找到它的图片                             related_query_name='rel_sight_iamges')    class Meta:        db_table = 'sight'        ordering = [from django.contrib.contenttypes.fields import GenericRelationfrom django.db import modelsfrom system.models import ImageRelatedfrom utils.models import CommonModelclass Sight(CommonModel):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    # 反向关联，景点和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             # 通过一个景点的模型对象，找到对应id的记录，转换为sight的对象，                             # 通过其属性找到它的图片                             related_query_name='rel_sight_iamges')    class Meta:        db_table = 'sight'        ordering = ['-updated_at']\n\n新建sight/choices.py\n123456789101112131415161718from django.db import  modelsclass TicketTypes(models.IntegerChoices):    ADULT = 11, '成人票'    CHILD = 12, '儿童票'class TicketStatus(models.IntegerChoices):    \"\"\" 门票的状态 \"\"\"    OPEN = 1, '开放购买'    CLOSED = 0, '暂未开放'class EntryWay(models.IntegerChoices):    \"\"\" 入园方式 \"\"\"    BY_TICKET = 0, '短信换票入园'    BY_CODE = 1, from django.db import  modelsclass TicketTypes(models.IntegerChoices):    ADULT = 11, '成人票'    CHILD = 12, '儿童票'class TicketStatus(models.IntegerChoices):    \"\"\" 门票的状态 \"\"\"    OPEN = 1, '开放购买'    CLOSED = 0, '暂未开放'class EntryWay(models.IntegerChoices):    \"\"\" 入园方式 \"\"\"    BY_TICKET = 0, '短信换票入园'    BY_CODE = 1, '凭借验证码入园'\n\n\n检测ORM模型\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495python manage.py check``` - 第四步，模型同步```bashpython manage.py makemigrationspython manage.py migrate```  ### 重构响应对象#### 开发步骤- 设计响应单个对象的基类  接口返回统一的封装对象转为字典，再转为json对象新建```utils/serializers.py```定义两种接口所响应的数据类型， 一个是详情，直接返回响应对象 ，一个是列表，有```meta```和```object```的结构```pythonclass BaseSerializer(object):    def __init__(self, obj):        self.obj = obj    def to_dict(self):        return {}class MetaSerializer(object):    \"\"\" 分页元数据 \"\"\"    def __init__(self, page, page_count, total_count, **kwargs):        \"\"\"        :param page: 当前页        :param page_count: 总页数        :param total_count: 总记录数        \"\"\"        self.page = page        self.page_count = page_count        self.total_count = total_count    def to_dict(self):        return {            'total_count': self.total_count,            'page_count': self.page_count,            'current_page': self.page        }class BaseListPageSerializer(object):    \"\"\" 分页类封装 \"\"\"    def __init__(self, page_obj, paginator=None, object_list=[]):        \"\"\"        :param page_obj: 当前页的对象        :param paginator: 分页器的对象        :param object_list: 当前页的数据列表        \"\"\"        self.page_obj = page_obj        self.paginator = paginator if paginator else page_obj.paginator        self.object_list = object_list if object_list else page_obj.object_list    def get_object(self, obj):        \"\"\" 对象的内容，子类重写 \"\"\"        return {}    def to_dict(self):        page = self.page_obj.number  # 当前页        page_count = self.paginator.num_pages  # 总页数        total_count = self.paginator.count  # 总记录数        meta = MetaSerializer(page=page, page_count=page_count, total_count=total_count).to_dict()        objects = []        for obj in self.object_list:            objects.append(self.get_object(obj))        return {            'meta': meta,            'objects': objects        }```  ```sight/serializers.py``````pyfrom utils.serializers import BaseListPageSerializerclass SightListSerializer(BaseListPageSerializer):    \"\"\" 景点列表 \"\"\"    def get_object(self, obj):        return {            'id': obj.id,            'name': obj.name,            'main_img': obj.main_img.url,            'score': obj.score,            'province': obj.province,            'min_price': obj.min_price,            'city': obj.city,            # TODO 评论数量暂时无法获取            python manage.py check``` - 第四步，模型同步```bashpython manage.py makemigrationspython manage.py migrate```  ### 重构响应对象#### 开发步骤- 设计响应单个对象的基类  接口返回统一的封装对象转为字典，再转为json对象新建```utils/serializers.py```定义两种接口所响应的数据类型， 一个是详情，直接返回响应对象 ，一个是列表，有```meta```和```object```的结构```pythonclass BaseSerializer(object):    def __init__(self, obj):        self.obj = obj    def to_dict(self):        return {}class MetaSerializer(object):    \"\"\" 分页元数据 \"\"\"    def __init__(self, page, page_count, total_count, **kwargs):        \"\"\"        :param page: 当前页        :param page_count: 总页数        :param total_count: 总记录数        \"\"\"        self.page = page        self.page_count = page_count        self.total_count = total_count    def to_dict(self):        return {            'total_count': self.total_count,            'page_count': self.page_count,            'current_page': self.page        }class BaseListPageSerializer(object):    \"\"\" 分页类封装 \"\"\"    def __init__(self, page_obj, paginator=None, object_list=[]):        \"\"\"        :param page_obj: 当前页的对象        :param paginator: 分页器的对象        :param object_list: 当前页的数据列表        \"\"\"        self.page_obj = page_obj        self.paginator = paginator if paginator else page_obj.paginator        self.object_list = object_list if object_list else page_obj.object_list    def get_object(self, obj):        \"\"\" 对象的内容，子类重写 \"\"\"        return {}    def to_dict(self):        page = self.page_obj.number  # 当前页        page_count = self.paginator.num_pages  # 总页数        total_count = self.paginator.count  # 总记录数        meta = MetaSerializer(page=page, page_count=page_count, total_count=total_count).to_dict()        objects = []        for obj in self.object_list:            objects.append(self.get_object(obj))        return {            'meta': meta,            'objects': objects        }```  ```sight/serializers.py``````pyfrom utils.serializers import BaseListPageSerializerclass SightListSerializer(BaseListPageSerializer):    \"\"\" 景点列表 \"\"\"    def get_object(self, obj):        return {            'id': obj.id,            'name': obj.name,            'main_img': obj.main_img.url,            'score': obj.score,            'province': obj.province,            'min_price': obj.min_price,            'city': obj.city,            # TODO 评论数量暂时无法获取            'comment_count': 0        }\n\n设计响应列表对象的基类\n\n设计错误基础类utils/response.py\n1234567891011121314from django.http import JsonResponseclass NotFoundJsonResponse(JsonResponse):    \"\"\" 400 对应JSON响应 \"\"\"    status_code = 400    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"404000\",            \"error_msg\": from django.http import JsonResponseclass NotFoundJsonResponse(JsonResponse):    \"\"\" 400 对应JSON响应 \"\"\"    status_code = 400    def __init__(self, *args, **kwargs):        data = {            \"error_code\": \"404000\",            \"error_msg\": \"您访问的内容不存在或已被删除。\"        }        super().__init__(data, *args, **kwargs)\n\n\n\nsight/views.py\n12345678910111213141516171819202122232425262728293031323334353637from django import httpfrom django.db.models import Qfrom django.shortcuts import renderfrom django.views.generic import ListViewfrom sight import serializersfrom sight.models import Sightfrom utils.response import NotFoundJsonResponseclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 1. 热门景点        is_hot = self.request.GET.get('is_hot', None)        if is_hot:            query = query &amp; Q(is_hot=True)        # 2. 精选景点        is_top = self.request.GET.get('is_top', None)        if is_top:            query = query &amp; Q(is_top=True)        # TODO 3. 景点名称搜索        queryset = Sight.objects.filter(query)        return queryset    def render_to_response(self, context, **response_kwargs):        page_obj = context['page_obj']  # 当前页的对象        if page_obj:            data = serializers.SightListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        else:            from django import httpfrom django.db.models import Qfrom django.shortcuts import renderfrom django.views.generic import ListViewfrom sight import serializersfrom sight.models import Sightfrom utils.response import NotFoundJsonResponseclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 1. 热门景点        is_hot = self.request.GET.get('is_hot', None)        if is_hot:            query = query &amp; Q(is_hot=True)        # 2. 精选景点        is_top = self.request.GET.get('is_top', None)        if is_top:            query = query &amp; Q(is_top=True)        # TODO 3. 景点名称搜索        queryset = Sight.objects.filter(query)        return queryset    def render_to_response(self, context, **response_kwargs):        page_obj = context['page_obj']  # 当前页的对象        if page_obj:            data = serializers.SightListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        else:            return NotFoundJsonResponse()\n\n景点详情接口开发开发步骤\n设计接口返回内容及字段\n\n编写接口代码sight/urls.py  \n12345678from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.2 景点详细信息    path('sight/detail/&lt;int:pk&gt;/', views.SightDetailView.as_view(), name=from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.2 景点详细信息    path('sight/detail/&lt;int:pk&gt;/', views.SightDetailView.as_view(), name=\"sight_detail\"),]\nsight/serializers.py  \n1234567891011121314151617181920212223from utils.serializers import BaseSerializerclass SightDetailSerializer(BaseSerializer):    \"\"\" 景点详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'id': obj.id,            'name': obj.name,            'desc': obj.desc,            'img': obj.banner_img.url,            'content': obj.content,            'score': obj.score,            'min_price': obj.min_price,            'province': obj.province,            'city': obj.city,            'area': obj.area,            'town': obj.town,            # TODO 评论数量暂时无法获取            'comment_count': from utils.serializers import BaseSerializerclass SightDetailSerializer(BaseSerializer):    \"\"\" 景点详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'id': obj.id,            'name': obj.name,            'desc': obj.desc,            'img': obj.banner_img.url,            'content': obj.content,            'score': obj.score,            'min_price': obj.min_price,            'province': obj.province,            'city': obj.city,            'area': obj.area,            'town': obj.town,            # TODO 评论数量暂时无法获取            'comment_count': 0        }\n\n\n\nsight/views.py  \n123456789101112131415161718from django.views.generic import DetailViewfrom sight.models import Sightclass SightDetailView(DetailView):    \"\"\" 2.2 景点详细信息 \"\"\"    def get_queryset(self):        # return Sight.objects.filter(is_valid=True)        return Sight.objects.all()    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            if not page_obj.is_valid:                return NotFoundJsonResponse()            data = serializers.SightDetailSerializer(page_obj).to_dict()            return http.JsonResponse(data)        from django.views.generic import DetailViewfrom sight.models import Sightclass SightDetailView(DetailView):    \"\"\" 2.2 景点详细信息 \"\"\"    def get_queryset(self):        # return Sight.objects.filter(is_valid=True)        return Sight.objects.all()    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            if not page_obj.is_valid:                return NotFoundJsonResponse()            data = serializers.SightDetailSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()\n\n\n模拟HTTP请求，测试验证接口\n\n景点评论列表接口开发开发步骤\n设计接口返回内容及字段sight/urls.py  123456789101112131415161718192021222324from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.3 景点下的评论列表    path('comment/list/&lt;int:pk&gt;/', views.SightCommentListView.as_view(), name=\"sight_comment_list\"),]```  新建```system/serializers.py``````pythonfrom utils.serializers import BaseSerializerclass BaseImageSerializer(BaseSerializer):    \"\"\" 序列化基础图片：其它列表需要引用到时使用 \"\"\"    def to_dict(self):        image = self.obj        return {            'img': image.img.url,            from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.3 景点下的评论列表    path('comment/list/&lt;int:pk&gt;/', views.SightCommentListView.as_view(), name=\"sight_comment_list\"),]```  新建```system/serializers.py``````pythonfrom utils.serializers import BaseSerializerclass BaseImageSerializer(BaseSerializer):    \"\"\" 序列化基础图片：其它列表需要引用到时使用 \"\"\"    def to_dict(self):        image = self.obj        return {            'img': image.img.url,            'summary': image.summary        }\n\n\n\nsight/serializers.py  \n12345678910111213141516171819202122232425from system.serializers import BaseImageSerializerfrom utils.serializers import BaseListPageSerializerclass CommentListSerializer(BaseListPageSerializer):    \"\"\" 评论列表 \"\"\"    def get_object(self, obj):        user = obj.user        images = []        for image in obj.images.filter(is_valid=True):            images.append(BaseImageSerializer(image).to_dict())        return {            'user': {                'pk': user.pk,                'nickname': user.nickname            },            'pk': obj.pk,            'content': obj.content,            'is_top': obj.is_top,            'love_count': obj.love_count,            'score': obj.score,            'is_public': obj.is_public,            'images': images,            'created_at': obj.created_at.strftime(from system.serializers import BaseImageSerializerfrom utils.serializers import BaseListPageSerializerclass CommentListSerializer(BaseListPageSerializer):    \"\"\" 评论列表 \"\"\"    def get_object(self, obj):        user = obj.user        images = []        for image in obj.images.filter(is_valid=True):            images.append(BaseImageSerializer(image).to_dict())        return {            'user': {                'pk': user.pk,                'nickname': user.nickname            },            'pk': obj.pk,            'content': obj.content,            'is_top': obj.is_top,            'love_count': obj.love_count,            'score': obj.score,            'is_public': obj.is_public,            'images': images,            'created_at': obj.created_at.strftime('%Y-%m-%d')        }\n\n\n编写接口代码sight/views.py  1234567891011121314151617181920212223from sight.models import Commentclass SightCommentListView(ListView):    \"\"\" 2.3 景点下的评论列表 \"\"\"    paginate_by = 10    def get_queryset(self):        # 根据景点ID查询景点        sight_id = self.kwargs.get('pk', None)        sight = Sight.objects.filter(pk=sight_id, is_valid=True).first()        if sight:            # return Comment.objects.filter(is_valid=True, sight=sight)            return sight.comments.filter(is_valid=True)        return Comment.objects.none()    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回 \"\"\"        page_obj = context['page_obj']  # 分页的某一页对象        if page_obj:            data = serializers.CommentListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        from sight.models import Commentclass SightCommentListView(ListView):    \"\"\" 2.3 景点下的评论列表 \"\"\"    paginate_by = 10    def get_queryset(self):        # 根据景点ID查询景点        sight_id = self.kwargs.get('pk', None)        sight = Sight.objects.filter(pk=sight_id, is_valid=True).first()        if sight:            # return Comment.objects.filter(is_valid=True, sight=sight)            return sight.comments.filter(is_valid=True)        return Comment.objects.none()    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回 \"\"\"        page_obj = context['page_obj']  # 分页的某一页对象        if page_obj:            data = serializers.CommentListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()\n模拟HTTP请求，测试验证接口\n\n门票列表接口开发开发步骤\n设计接口返回内容及字段sight/urls.py  \n12345678910111213141516171819202122232425262728from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.4 景点下的门票列表    path('ticket/list/&lt;int:pk&gt;/', views.SightTicketListView.as_view(), name=\"sight_ticket_list\"),]```  ```sight/serializers.py```  ```pythonfrom utils.serializers import BaseListPageSerializerclass TicketListSerializer(BaseListPageSerializer):    \"\"\" 门票列表 \"\"\"    def get_object(self, obj):        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'discount': obj.discount,            'total_stock': obj.total_stock,            from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.4 景点下的门票列表    path('ticket/list/&lt;int:pk&gt;/', views.SightTicketListView.as_view(), name=\"sight_ticket_list\"),]```  ```sight/serializers.py```  ```pythonfrom utils.serializers import BaseListPageSerializerclass TicketListSerializer(BaseListPageSerializer):    \"\"\" 门票列表 \"\"\"    def get_object(self, obj):        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'discount': obj.discount,            'total_stock': obj.total_stock,            'remain_stock': obj.remain_stock        }\n\n编写接口代码sight/views.py  \n1234567891011121314151617181920from sight.models import Ticketclass SightTicketListView(ListView):    \"\"\" 2.4 景点下的门票列表 \"\"\"    paginate_by = 10    def get_queryset(self):        # 根据景点ID查询景点        sight_id = self.kwargs.get('pk', None)        return Ticket.objects.filter(is_valid=True, sight__id=sight_id)    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回 \"\"\"        page_obj = context['page_obj']        if page_obj is not None:            data = serializers.TicketListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        from sight.models import Ticketclass SightTicketListView(ListView):    \"\"\" 2.4 景点下的门票列表 \"\"\"    paginate_by = 10    def get_queryset(self):        # 根据景点ID查询景点        sight_id = self.kwargs.get('pk', None)        return Ticket.objects.filter(is_valid=True, sight__id=sight_id)    def render_to_response(self, context, **response_kwargs):        \"\"\" 重写响应的返回 \"\"\"        page_obj = context['page_obj']        if page_obj is not None:            data = serializers.TicketListSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()\n模拟HTTP请求，测试验证接口\n\n\n景点介绍接口开发开发步骤\n设计接口返回内容及字段sight/urls.py  \n1234567891011121314151617181920212223242526from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.5 景点介绍    path('sight/info/&lt;int:pk&gt;/', views.SightInfoDetailView.as_view(), name=\"sight_info\"),]```  ```sight/serializers.py```  ```pythonfrom utils.serializers import BaseListPageSerializerclass SightInfoSerializer(BaseSerializer):    \"\"\" 景点介绍 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.sight.pk,  # 景点ID            'entry_explain': obj.entry_explain,            'play_way': obj.play_way,            'tips': obj.tips,            from django.urls import pathfrom sight import viewsurlpatterns = [    # 2.5 景点介绍    path('sight/info/&lt;int:pk&gt;/', views.SightInfoDetailView.as_view(), name=\"sight_info\"),]```  ```sight/serializers.py```  ```pythonfrom utils.serializers import BaseListPageSerializerclass SightInfoSerializer(BaseSerializer):    \"\"\" 景点介绍 \"\"\"    def to_dict(self):        obj = self.obj        return {            'pk': obj.sight.pk,  # 景点ID            'entry_explain': obj.entry_explain,            'play_way': obj.play_way,            'tips': obj.tips,            'traffic': obj.traffic,        }\n\n编写接口代码sight/views.py  \n12345678910111213141516from sight.models import Infoclass SightInfoDetailView(DetailView):    \"\"\" 2.5 景点介绍 \"\"\"    slug_field = 'sight__pk'  # url传递过来的这个变化的参数指代的是哪个字段    def get_queryset(self):        return Info.objects.all()    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            data = serializers.SightInfoSerializer(page_obj).to_dict()            return http.JsonResponse(data)        from sight.models import Infoclass SightInfoDetailView(DetailView):    \"\"\" 2.5 景点介绍 \"\"\"    slug_field = 'sight__pk'  # url传递过来的这个变化的参数指代的是哪个字段    def get_queryset(self):        return Info.objects.all()    def render_to_response(self, context, **response_kwargs):        page_obj = context['object']        if page_obj:            data = serializers.SightInfoSerializer(page_obj).to_dict()            return http.JsonResponse(data)        return NotFoundJsonResponse()\n模拟HTTP请求，测试验证接口\n\n\n景点搜索接口联调实现步骤\n修改景点列表接口，支持搜索sight/views.py  \n12345678910111213141516171819202122from django.db.models import Qfrom django.views.generic import ListViewclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 3. 景点名称搜索        name = self.request.GET.get('name', None)  # 从前端获取搜索字段        if name:            query = query &amp; Q(name__icontains=name)  # 景点名称是否包含搜索字段        queryset = Sight.objects.filter(query)        return queryset    def get_paginate_by(self, queryset):        \"\"\" 从前端控制每一页的分页大小 \"\"\"        page_size = self.request.GET.get('limit', None)        return page_size from django.db.models import Qfrom django.views.generic import ListViewclass SightListView(ListView):    \"\"\" 景点列表 \"\"\"    # 每页放5条数据    paginate_by = 5    def get_queryset(self):        \"\"\" 重写查询方法 \"\"\"        query = Q(is_valid=True)        # 3. 景点名称搜索        name = self.request.GET.get('name', None)  # 从前端获取搜索字段        if name:            query = query &amp; Q(name__icontains=name)  # 景点名称是否包含搜索字段        queryset = Sight.objects.filter(query)        return queryset    def get_paginate_by(self, queryset):        \"\"\" 从前端控制每一页的分页大小 \"\"\"        page_size = self.request.GET.get('limit', None)        return page_size or self.paginate_by   \n\n配置接口地址从首页底部点击搜索，保留底部组件，查询所有从首页点击热门推荐和精选节点更多，去掉底部组件，增加左上角返回按钮，只查询热门推荐和精选景点\n\n\nsrc\\components\\home\\Hot.vue\n1234567891011121314            <van-cell      title=\"热门推荐\"      icon=\"/static/home/hot/fire.png\"      is-link      title-style=\"text-align:left\"      value=\"全部榜单\"      :to=\"{name: 'Search', query: {isHot: 1}}\"/>      \n\nsrc\\components\\home\\Fine.vue\n1234567891011121314            <van-cell      title=\"精选景点\"      icon=\"location-o\"      is-link      title-style=\"text-align:left\"      value=\"更多\"      :to=\"{name: 'Search', query: {isTop: 1}}\"/>      \n\nsrc\\views\\Search.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135            <van-nav-bar title=\"搜索景点\"      left-text=\"返回\"      left-arrow      @click-left=\"goBack\"      v-if=\"isHome\"/>            <van-search      v-model=\"sightName\"      show-action      label=\"景点\"      placeholder=\"请输入搜索关键词\"      @search=\"onSearch\"      @clear=\"clear\"    >              搜索              热门推荐    精选景点              <sight-item v-for=\"item in dataList\"        :key=\"item.id\"        :item=\"item\"/>            <van-pagination    v-model=\"currentPage\"    :total-items=\"totalItems\"    :items-per-page=\"perPage\"    @change=\"pageChange\" />          import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'// 景点列表的每一项import SightItem from '@/components/common/ListSight'// 底部导航import TripFooter from '@/components/common/Footer'export default {  data () {    return {      // 景点名称      sightName: '',      // 景点列表的数据      dataList: [],      // 总记录数      totalItems: 0,      // 当前的页码      currentPage: 1,      // 每页数据的大小      perPage: 4,      // 热门景点和精选景点      isHot: '',      isTop: ''    }  },  components: {    SightItem,    TripFooter  },  computed: {    /**     * 是否从首页过来     */    isHome () {      return this.isHot || this.isTop    }  },  methods: {    goBack () {      this.$router.go(-1)    },    /**     * 景点列表接口     */    getDataList () {      ajax.get(SightApis.sightListUrl, {        params: {          page: this.currentPage,          name: this.sightName,          limit: this.perPage,          is_top: this.isTop,          is_hot: this.isHot        }      }).then(({ data: { meta, objects } }) => {        this.dataList = objects        // 总记录数        this.totalItems = meta.total_count      })    },    clear () {      this.dataList = []      this.currentPage = 1      this.getDataList()    },    /**     * 页码发生变化后调用     */    pageChange () {      this.getDataList()    },    onSearch () {      console.log('onSearch ')      // 判断搜索内容是否为空      if (!this.sightName) {        this.$toast('请输入搜索词') // 弹框提示        return      }      // 重置数据      this.dataList = []      this.currentPage = 1      // 执行查询      this.getDataList()    }  },    mounted () {    // 热门景点和精选景点    this.isHot = this.$route.query.isHot    this.isTop = this.$route.query.isTop    this.getDataList()  }}\n\n使用axios获取数据\n将数据设置到模型层\n\n景点详情和评论接口联调实现步骤\n阅读接口文档\n配置接口地址src\\utils\\apis.js1234567891011/** * 景点模块 */const SightApis = {  // 景点列表  sightListUrl: apiHost + '/sight/sight/list/',  // 景点详情  sightDetailUrl: apiHost + '/sight/sight/detail/#{id}/',  // 门票列表  sightTicketUrl: apiHost + /** * 景点模块 */const SightApis = {  // 景点列表  sightListUrl: apiHost + '/sight/sight/list/',  // 景点详情  sightDetailUrl: apiHost + '/sight/sight/detail/#{id}/',  // 门票列表  sightTicketUrl: apiHost + '/sight/ticket/list/#{id}/'}\n\n\n\nsrc\\views\\sight\\SightDetail.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128                                                    {{ sightDetail.image_count }} 图片                {{ sightDetail.name }}                                              {{ sightDetail.score }}分          很棒                {{ sightDetail.comment_count }} 评论                                      景点介绍                开放时间、贴士                                                            {{ item.name }}                                  {{ item.desc }}                                标签1                                                ￥            {{ item.sell_price }}                                预定                                  import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'// 评论项组件import CommentItem from '@/components/sight/CommentItem'export default {  data () {    return {      id: '',      // 景点详细信息      sightDetail: {},      // 门票列表      ticketList: []    }  },  components: {    CommentItem  },  computed: {    /**     * 地址的全部信息     */    fullArea () {      let area = this.sightDetail.province + this.sightDetail.city      if (this.sightDetail.area) {        area += this.sightDetail.area      }      if (this.sightDetail.town) {        area += this.sightDetail.town      }      return area    }  },  methods: {    goBack () {      this.$router.go(-1)    },    /**     * 获取景点详细信息     */    getSightDetail () {      const url = SightApis.sightDetailUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data }) => {        this.sightDetail = data      })    },    /**      * 门票列表      */    getTicketList () {      const url = SightApis.sightTicketUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data: { objects } }) => {        this.ticketList = objects      })    }  },  created () {    this.id = this.$route.params.id    // 获取景点详细信息    this.getSightDetail()    // 获取门票列表    this.getTicketList()  }}\n\n详情页的图片数量和评论数量sight/models.py\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126from django.contrib.contenttypes.fields import GenericRelationfrom django.db import modelsfrom accounts.models import Userfrom system.models import ImageRelatedfrom sight.choices import TicketTypes, EntryWay, TicketStatusfrom utils.models import CommonModelclass Sight(CommonModel):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    # 反向关联，景点和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             # 通过一个景点的模型对象，找到对应id的记录，转换为sight的对象，                             # 通过其属性找到它的图片                             related_query_name='rel_sight_iamges')    class Meta:        db_table = 'sight'        ordering = ['-updated_at']    @property    def comment_count(self):        \"\"\" 评论总数 \"\"\"        return self.comments.filter(is_valid=True).count()    @property    def image_count(self):        \"\"\" 景点图片的数量 \"\"\"        return self.images.filter(is_valid=True).count()class Info(models.Model):    \"\"\" 景点详情 \"\"\"    sight = models.OneToOneField(Sight, on_delete=models.CASCADE)    entry_explain = models.CharField('入园参考', max_length=1024, null=True, blank=True)    play_way = models.TextField('特色玩法', null=True, blank=True)    tips = models.TextField('温馨提示', null=True, blank=True)    traffic = models.TextField('交通到达', null=True, blank=True)    class Meta:        db_table = 'sight_info'class Ticket(CommonModel):    \"\"\" 门票 \"\"\"    sight = models.ForeignKey(Sight, related_name='tickets', verbose_name='景点门票',                              on_delete=models.PROTECT)    name = models.CharField('名称', max_length=128)    desc = models.CharField('描述', max_length=64, null=True, blank=True)    types = models.SmallIntegerField('类型',                                     choices=TicketTypes.choices,                                     default=TicketTypes.ADULT,                                     help_text='默认为成人票')    price = models.FloatField('价格（原价）')    discount = models.FloatField('折扣', default=10)    total_stock = models.PositiveIntegerField('总库存', default=0)    remain_stock = models.PositiveIntegerField('剩余库存', default=0)    expire_date = models.IntegerField('有效期', default=1)    return_policy = models.CharField('退改政策', max_length=64, default='条件退')    has_invoice = models.BooleanField('是否提供发票', default=True)    entry_way = models.SmallIntegerField('入园方式',                                         choices=EntryWay.choices,                                         default=EntryWay.BY_TICKET)    tips = models.TextField('预定须知', null=True, blank=True)    remark = models.TextField('其他说明', null=True, blank=True)    status = models.SmallIntegerField('状态',                                      choices=TicketStatus.choices,                                      default=TicketStatus.OPEN)    class Meta:        db_table = 'sight_ticket'    @property    def sell_price(self):        \"\"\" 销售价 = 原价 x 折扣 \"\"\"        return self.price * self.discount / 10class Comment(CommonModel):    \"\"\" 评论及回复 \"\"\"    # 评论关联到用户    user = models.ForeignKey(User, verbose_name='评论人',                             related_name='comments',                             on_delete=models.CASCADE)    # 评论关联到景点    sight = models.ForeignKey(Sight, verbose_name='景点',                              related_name='comments',                              on_delete=models.CASCADE)    content = models.TextField('评论内容', blank=True, null=True)    is_top = models.BooleanField('是否置顶', default=False)    love_count = models.IntegerField('点赞次数', default=0)    score = models.FloatField('评分', default=5)    ip_address = models.CharField('IP地址', blank=True, null=True, max_length=64)    is_public = models.SmallIntegerField('是否公开', default=1)    reply = models.ForeignKey(        'self', blank=True, null=True,        related_name='reply_comment',        verbose_name='回复',        on_delete=models.CASCADE)    # 反向关联，评论和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             related_query_name=\"rel_comment_images\")    class Meta:        db_table = 'sight_comment'        ordering = ['-love_count', from django.contrib.contenttypes.fields import GenericRelationfrom django.db import modelsfrom accounts.models import Userfrom system.models import ImageRelatedfrom sight.choices import TicketTypes, EntryWay, TicketStatusfrom utils.models import CommonModelclass Sight(CommonModel):    \"\"\" 景点基础信息 \"\"\"    name = models.CharField('名称', max_length=64)    desc = models.CharField('描述', max_length=256)    main_img = models.ImageField('主图', upload_to='%Y%m/sight/', max_length=256)    banner_img = models.ImageField('详情主图', upload_to='%Y%m/sight/', max_length=256)    content = models.TextField('详细')    score = models.FloatField('评分', default=5)    min_price = models.FloatField('最低价格', default=0)    province = models.CharField('省份', max_length=32)    city = models.CharField('市区', max_length=32)    area = models.CharField('区/县', max_length=32, null=True)    town = models.CharField('乡镇', max_length=32, null=True)    is_top = models.BooleanField('是否为精选景点', default=False)    is_hot = models.BooleanField('是否为热门景点', default=False)    # 反向关联，景点和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             # 通过一个景点的模型对象，找到对应id的记录，转换为sight的对象，                             # 通过其属性找到它的图片                             related_query_name='rel_sight_iamges')    class Meta:        db_table = 'sight'        ordering = ['-updated_at']    @property    def comment_count(self):        \"\"\" 评论总数 \"\"\"        return self.comments.filter(is_valid=True).count()    @property    def image_count(self):        \"\"\" 景点图片的数量 \"\"\"        return self.images.filter(is_valid=True).count()class Info(models.Model):    \"\"\" 景点详情 \"\"\"    sight = models.OneToOneField(Sight, on_delete=models.CASCADE)    entry_explain = models.CharField('入园参考', max_length=1024, null=True, blank=True)    play_way = models.TextField('特色玩法', null=True, blank=True)    tips = models.TextField('温馨提示', null=True, blank=True)    traffic = models.TextField('交通到达', null=True, blank=True)    class Meta:        db_table = 'sight_info'class Ticket(CommonModel):    \"\"\" 门票 \"\"\"    sight = models.ForeignKey(Sight, related_name='tickets', verbose_name='景点门票',                              on_delete=models.PROTECT)    name = models.CharField('名称', max_length=128)    desc = models.CharField('描述', max_length=64, null=True, blank=True)    types = models.SmallIntegerField('类型',                                     choices=TicketTypes.choices,                                     default=TicketTypes.ADULT,                                     help_text='默认为成人票')    price = models.FloatField('价格（原价）')    discount = models.FloatField('折扣', default=10)    total_stock = models.PositiveIntegerField('总库存', default=0)    remain_stock = models.PositiveIntegerField('剩余库存', default=0)    expire_date = models.IntegerField('有效期', default=1)    return_policy = models.CharField('退改政策', max_length=64, default='条件退')    has_invoice = models.BooleanField('是否提供发票', default=True)    entry_way = models.SmallIntegerField('入园方式',                                         choices=EntryWay.choices,                                         default=EntryWay.BY_TICKET)    tips = models.TextField('预定须知', null=True, blank=True)    remark = models.TextField('其他说明', null=True, blank=True)    status = models.SmallIntegerField('状态',                                      choices=TicketStatus.choices,                                      default=TicketStatus.OPEN)    class Meta:        db_table = 'sight_ticket'    @property    def sell_price(self):        \"\"\" 销售价 = 原价 x 折扣 \"\"\"        return self.price * self.discount / 10class Comment(CommonModel):    \"\"\" 评论及回复 \"\"\"    # 评论关联到用户    user = models.ForeignKey(User, verbose_name='评论人',                             related_name='comments',                             on_delete=models.CASCADE)    # 评论关联到景点    sight = models.ForeignKey(Sight, verbose_name='景点',                              related_name='comments',                              on_delete=models.CASCADE)    content = models.TextField('评论内容', blank=True, null=True)    is_top = models.BooleanField('是否置顶', default=False)    love_count = models.IntegerField('点赞次数', default=0)    score = models.FloatField('评分', default=5)    ip_address = models.CharField('IP地址', blank=True, null=True, max_length=64)    is_public = models.SmallIntegerField('是否公开', default=1)    reply = models.ForeignKey(        'self', blank=True, null=True,        related_name='reply_comment',        verbose_name='回复',        on_delete=models.CASCADE)    # 反向关联，评论和系统的图片关联上    images = GenericRelation(ImageRelated,                             verbose_name='关联的图片',                             related_query_name=\"rel_comment_images\")    class Meta:        db_table = 'sight_comment'        ordering = ['-love_count', '-created_at']\n\nsight/serializers.py\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class SightListSerializer(BaseListPageSerializer):    \"\"\" 景点列表 \"\"\"    def get_object(self, obj):        return {            'id': obj.id,            'name': obj.name,            'main_img': obj.main_img.url,            'score': obj.score,            'province': obj.province,            'min_price': obj.min_price,            'city': obj.city,            'comment_count': obj.comment_count        }class SightDetailSerializer(BaseSerializer):    \"\"\" 景点详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'id': obj.id,            'name': obj.name,            'desc': obj.desc,            'img': obj.banner_img.url,            'content': obj.content,            'score': obj.score,            'min_price': obj.min_price,            'province': obj.province,            'city': obj.city,            'area': obj.area,            'town': obj.town,            'comment_count': obj.comment_count,            'image_count': obj.image_count,        }class TicketListSerializer(BaseListPageSerializer):    \"\"\" 门票列表 \"\"\"    def get_object(self, obj):        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'sell_price': obj.sell_price,            'discount': obj.discount,            'total_stock': obj.total_stock,            class SightListSerializer(BaseListPageSerializer):    \"\"\" 景点列表 \"\"\"    def get_object(self, obj):        return {            'id': obj.id,            'name': obj.name,            'main_img': obj.main_img.url,            'score': obj.score,            'province': obj.province,            'min_price': obj.min_price,            'city': obj.city,            'comment_count': obj.comment_count        }class SightDetailSerializer(BaseSerializer):    \"\"\" 景点详情 \"\"\"    def to_dict(self):        obj = self.obj        return {            'id': obj.id,            'name': obj.name,            'desc': obj.desc,            'img': obj.banner_img.url,            'content': obj.content,            'score': obj.score,            'min_price': obj.min_price,            'province': obj.province,            'city': obj.city,            'area': obj.area,            'town': obj.town,            'comment_count': obj.comment_count,            'image_count': obj.image_count,        }class TicketListSerializer(BaseListPageSerializer):    \"\"\" 门票列表 \"\"\"    def get_object(self, obj):        return {            'pk': obj.pk,            'name': obj.name,            'desc': obj.desc,            'types': obj.types,            'price': obj.price,            'sell_price': obj.sell_price,            'discount': obj.discount,            'total_stock': obj.total_stock,            'remain_stock': obj.remain_stock        }\n\n使用axios获取数据\n将数据设置到模型层\n\n景点评论接口联调实现步骤\n阅读接口文档\n配置接口地址评论的每一项在景点详情、单独的评论列表，封装成公共组件，获取里面内容在详情页url发生变化的时候，watch监听路由变化，重新获取数据\n\nsrc\\utils\\filters.js\n1234567891011121314/** * 用户名称脱敏处理 * @param {*} name 用户名 */function unameFormat (name) {  if (!name) {    return name  }  return name.substr(0, 2) + '***'}/** * 用户名称脱敏处理 * @param {*} name 用户名 */function unameFormat (name) {  if (!name) {    return name  }  return name.substr(0, 2) + '***'}export {  unameFormat}\n\nsrc\\utils\\apis.js\n1234const SightApis = {  // 评论列表  sightCommentUrl: apiHost + const SightApis = {  // 评论列表  sightCommentUrl: apiHost + '/sight/comment/list/#{id}/'}\n\nsrc\\views\\sight\\SightComment.vue\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950            <van-nav-bar      left-text=\"返回\"      title=\"景点评论\"      left-arrow      @click-left=\"goBack\"    />                import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'// 评论项组件import CommentItem from '@/components/sight/CommentItem'export default {  components: {    CommentItem  },  data () {    return {      // 评论列表      commentList: []    }  },  methods: {    goBack () {      this.$router.go(-1)    },    /**     * 评论列表     */    getCommentList () {      const url = SightApis.sightCommentUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data: { objects } }) => {        this.commentList = objects      })    }  },  mounted () {    this.id = this.$route.params.id    this.getCommentList()  }}\n\nsrc\\views\\sight\\SightDetail.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130                                          {{ item.name }}                                  {{ item.desc }}                                标签1                                                ￥            {{ item.sell_price }}                                预定                                                          查看更多          import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'// 评论项组件import CommentItem from '@/components/sight/CommentItem'export default {  data () {    return {      id: '',      // 景点详细信息      sightDetail: {},      // 门票列表      ticketList: [],      // 评论列表      commentList: []    }  },  components: {    CommentItem  },  computed: {    /**     * 地址的全部信息     */    fullArea () {      let area = this.sightDetail.province + this.sightDetail.city      if (this.sightDetail.area) {        area += this.sightDetail.area      }      if (this.sightDetail.town) {        area += this.sightDetail.town      }      return area    }  },  watch: {    $route () {      this.loadData()    }  },  methods: {    /**     * 跳转到评论列表     */    goPage () {      this.$router.push({name: 'SightComment', params: {id: this.id}})    },    loadData () {      this.id = this.$route.params.id      // 获取景点详细信息      this.getSightDetail()      // 门票列表      this.getTicketList()      // 评论列表      this.getCommentList()    },    goBack () {      this.$router.go(-1)    },    /**     * 获取景点详细信息     */    getSightDetail () {      const url = SightApis.sightDetailUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data }) => {        this.sightDetail = data      })    },    /**     * 门票列表     */    getTicketList () {      const url = SightApis.sightTicketUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data: { objects } }) => {        this.ticketList = objects      })    },    /**     * 评论列表     */    getCommentList () {      const url = SightApis.sightCommentUrl.replace('#{id}', this.id)      ajax.get(url).then(({ data: { objects } }) => {        this.commentList = objects      })    }  },  created () {    this.loadData()  }}\n\n\n使用axios获取数据\n将数据设置到模型层\n\n前端代码优化\n添加loading动画和添加请求拦截12345window.app = new Vue({  router,  store,  render: h => h(App)}).$mount('#app')\n\n\n\nsrc\\utils\\ajax.js\n1234567891011121314151617181920212223242526272829303132333435363738import axios from 'axios'ajax.interceptors.request.use(function (config) {  // 在发送请求之前做些什么  console.log('请求拦截到了')  window.app.$toast.loading({    message: '加载中...',    forbidClick: true,    loadingType: 'spinner'  })  return config}, function (error) {  // 对请求错误做些什么  window.app.$toast.clear()  return Promise.reject(error)})ajax.interceptors.response.use(function (response) {  // 对响应数据做点什么  console.log('响应拦截到了')  window.app.$toast.clear()  return response}, function (error) {  // 对响应错误做点什么  if (error.response) {    if (error.response.status === 401) {      window.alert('未登录，即将跳转到登录页面')    } else if (error.response.status === 500) {      window.app.$notify({        message: '服务器正忙，请稍后重试',        type: 'danger'      })      // window.alert('服务器正忙，请稍后重试')    }  }  window.app.$toast.clear()  return import axios from 'axios'ajax.interceptors.request.use(function (config) {  // 在发送请求之前做些什么  console.log('请求拦截到了')  window.app.$toast.loading({    message: '加载中...',    forbidClick: true,    loadingType: 'spinner'  })  return config}, function (error) {  // 对请求错误做些什么  window.app.$toast.clear()  return Promise.reject(error)})ajax.interceptors.response.use(function (response) {  // 对响应数据做点什么  console.log('响应拦截到了')  window.app.$toast.clear()  return response}, function (error) {  // 对响应错误做点什么  if (error.response) {    if (error.response.status === 401) {      window.alert('未登录，即将跳转到登录页面')    } else if (error.response.status === 500) {      window.app.$notify({        message: '服务器正忙，请稍后重试',        type: 'danger'      })      // window.alert('服务器正忙，请稍后重试')    }  }  window.app.$toast.clear()  return Promise.reject(error)})\n\n\n修改页面标题public\\index.html\n12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"\"&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;    &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;    &lt;title&gt;旅游网&lt;/title&gt;  &lt;/head&gt;&lt;/&lt;!DOCTYPE html&gt;&lt;html lang=\"\"&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;    &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;    &lt;title&gt;旅游网&lt;/title&gt;  &lt;/head&gt;&lt;/html>\n\n添加滚动加载，请求失败，点击重新加载和下拉刷新，在评论列表的场景添加src\\views\\sight\\SightComment.vue\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394              <van-list        class=\"sight-comment\"        v-model=\"loading\"        :finished=\"finished\"        finished-text=\"没有更多了\"        :error.sync=\"error\"        error-text=\"请求失败，点击重新加载\"        @load=\"getCommentList\"      >                    import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'// 评论项组件import CommentItem from '@/components/sight/CommentItem'export default {  components: {    CommentItem  },  data () {    return {      // 评论列表      commentList: [],      // 当前的页码      currentPage: 1,      // 正在加载中      loading: false,      // 所有的内容加载完      finished: false,      // 请求失败      error: false,      // 是否正在下拉刷新中      refreshing: false    }  },  methods: {    goBack () {      this.$router.go(-1)    },    /**     * 下拉刷新执行     */    onRefresh () {      // 清空数据      this.commentList = []      this.currentPage = 1      this.finished = false      this.error = false      // 重新加载数据      this.getCommentList()    },    /**     * 评论列表     */    getCommentList () {      const url = SightApis.sightCommentUrl.replace('#{id}', this.id)      ajax.get(url, {        params: {          page: this.currentPage        }      }).then(({ data: { meta, objects } }) => {        this.commentList = this.commentList.concat(objects)        // 加载状态结束        this.loading = false        // 设置下一页的页码        this.currentPage = meta.current_page + 1        // 数据全部加载完成： 当前页面 == 总页数        if (meta.current_page === meta.page_count) {          this.finished = true        }        this.refreshing = false      }).catch(() => {        this.loading = false        this.error = true        this.refreshing = false      })    }  },  mounted () {    this.id = this.$route.params.id    // this.getCommentList()  }}\n\n\n\n实现图片列表接口src\\views\\sight\\SightImage.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126                          <van-list        class=\"sight-image\"        v-model=\"loading\"        :finished=\"finished\"        finished-text=\"没有更多了\"        :error.sync=\"error\"        error-text=\"请求失败，点击重新加载\"        @load=\"getImageList\"      >                                                                            第{{ index + 1 }}页 / 共{{ imageList.length }}张          import { ajax } from '@/utils/ajax'import { SightApis } from '@/utils/apis'export default {  components: {},  data () {    return {      // 图片列表      imageList: [],      // 图片预览      index: 0,      showPreview: false,      // 当前的页码      currentPage: 1,      // 正在加载中      loading: false,      // 所有的内容加载完      finished: false,      // 请求失败      error: false,      // 是否正在下拉刷新中      refreshing: false    }  },  methods: {    /**     * 预览切换图片     */    onChange (index) {      this.index = index    },    goBack () {      this.$router.go(-1)    },    /**     * 下拉刷新执行     */    onRefresh () {      // 清空数据      this.imageList = []      this.currentPage = 1      this.finished = false      this.error = false    },    /**     * 图片列表     */    getImageList () {      const url = SightApis.sightImageUrl.replace('#{id}', this.id)      ajax.get(url, {        params: {          page: this.currentPage        }      }).then(({ data: { meta, objects } }) => {        this.imageList = this.imageList.concat(objects)        // 加载状态结束        this.loading = false        // 设置下一页的页码        this.currentPage = meta.current_page + 1        // 数据全部加载完成： 当前页面 == 总页数        if (meta.current_page === meta.page_count) {          this.finished = true        }        this.refreshing = false      }).catch(() => {        this.loading = false        this.error = true        this.refreshing = false      })    }  },  computed: {    /**     * 图片地址     */    imgUrlList () {      return this.imageList.map(item => item.img)    }  },  mounted () {    this.id = this.$route.params.id  }}.page-sight-image {  padding: 5px;  .van-col {    padding: 5px;  }}\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["旅游网项目"],"tags":["剑指offer","Vue"]},{"title":"六大基本排序","url":"https://bubbleboy11.github.io/2020/08/21/liu-da-ji-ben-pai-xu/","content":"排序算法 Sorting algorithm是一种能将一串数据依照特定顺序进行排列的一种算法。进行从小到大进行排序，内置排序函数sort()\n1.冒泡排序 Bubble Sort （了解）首先是相邻的两个数据进行比较，当左面的大于右面的时候，进行互换位置，当小于的时候，都不动。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。\n外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。一趟排序完成后，则无序区减少一个数，有序区增加一个数\n冒泡排序算法的运作如下：\n\n比较相邻的元素。如果第一个比第二个大（升序），就交换这两个。\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。时间复杂度 O(n^2)空间复杂度：O(1) 使用到常数个临时变量。稳定性：稳定\n\n1234567891011121314151617def bubbleSort(array):    # 遍历所有数组元素，每一个都要找到没排好序的最大值    for i in range(len(array)):  # 第i趟      # for i in range(len(array) - 1):  # 第i趟，减去1也不影响        for j in range(len(array) - i - 1):            # j 表示每次遍历需要比较的次数，是逐渐减小的            # 将 没有排好序的数组 找最大值， 并一直将最大值换到最顶端            # 判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。            if array[j] &gt; array[j + 1]:                array[j], array[j + 1] = array[j + 1], array[j]    return arrayif __name__ == '__main__':    array = [4, 3, 1, 2]    print(bubbleSort(array))    def bubbleSort(array):    # 遍历所有数组元素，每一个都要找到没排好序的最大值    for i in range(len(array)):  # 第i趟      # for i in range(len(array) - 1):  # 第i趟，减去1也不影响        for j in range(len(array) - i - 1):            # j 表示每次遍历需要比较的次数，是逐渐减小的            # 将 没有排好序的数组 找最大值， 并一直将最大值换到最顶端            # 判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。            if array[j] &gt; array[j + 1]:                array[j], array[j + 1] = array[j + 1], array[j]    return arrayif __name__ == '__main__':    array = [4, 3, 1, 2]    print(bubbleSort(array))    # [1, 2, 3, 4]\n\n12345678910111213141516171819202122232425262728293031323334354 3 1 2len(array) = 4i = 0 len(array) - i - 1 = 3    j = 0    array[0] = 4 &gt; array[0 + 1] = 3    array[0] = array[0 + 1] = 3    array[0 + 1] = array[0] = 4    [3, 4, 1, 2]    j = 1    array[1] = 4 &gt; array[1 + 1] = 1    array[1] = array[1 + 1] = 1    array[1 + 1] = array[1] = 4    [3, 1, 4, 2]    j = 2    array[2] = 4 &gt; array[2 + 1] = 2    [3, 1, 2, 4]i = 1     len(array) - i - 1 = 2    j = 0    array[0] = 3 &gt; array[0 + 1] = 1    array[0] = array[0 + 1] = 1    array[0 + 1] = array[0] = 3    [1, 3, 2, 4]    j = 1    array[1] = 3 &gt; array[1 + 1] = 2    array[1] = array[1 + 1] = 2    array[1 + 1] = array[1] = 3    [1, 2, 3, 4]i = 2     len(array) - i - 1 = 1    j = 0    array[0] = 1 &lt; array[0 + 1] = 2    [1, 2, 3, 4 3 1 2len(array) = 4i = 0 len(array) - i - 1 = 3    j = 0    array[0] = 4 &gt; array[0 + 1] = 3    array[0] = array[0 + 1] = 3    array[0 + 1] = array[0] = 4    [3, 4, 1, 2]    j = 1    array[1] = 4 &gt; array[1 + 1] = 1    array[1] = array[1 + 1] = 1    array[1 + 1] = array[1] = 4    [3, 1, 4, 2]    j = 2    array[2] = 4 &gt; array[2 + 1] = 2    [3, 1, 2, 4]i = 1     len(array) - i - 1 = 2    j = 0    array[0] = 3 &gt; array[0 + 1] = 1    array[0] = array[0 + 1] = 1    array[0 + 1] = array[0] = 3    [1, 3, 2, 4]    j = 1    array[1] = 3 &gt; array[1 + 1] = 2    array[1] = array[1 + 1] = 2    array[1 + 1] = array[1] = 3    [1, 2, 3, 4]i = 2     len(array) - i - 1 = 1    j = 0    array[0] = 1 &lt; array[0 + 1] = 2    [1, 2, 3, 4]\n\n\n123456def bubble_sort(array):    for i in range(len(array)):        for j in range(i + 1, len(array)):            if array[i] &gt; array[j]:                array[i], array[j] = array[j], array[i]    def bubble_sort(array):    for i in range(len(array)):        for j in range(i + 1, len(array)):            if array[i] &gt; array[j]:                array[i], array[j] = array[j], array[i]    return array\n\n123456789101112131415161718192021222324252627282930313233344 3 1 2len(array) = 4i = 0     j = 1    array[0] = 4 &gt; array[0 + 1] = 3    array[0] = array[0 + 1] = 3    array[0 + 1] = array[0] = 4    [3, 4, 1, 2]    j = 2    array[0] = 3 &gt; array[2] = 1    array[0] = array[2] = 1    array[2] = array[0] = 3    [1, 4, 3, 2]    j = 3    array[0] = 1 &lt; array[3] = 2    [1, 4, 3, 2]i = 1         j = 2    array[1] = 4 &gt; array[2] = 3    array[1] = array[2] = 3    array[2] = array[1] = 4    [1, 3, 4, 2]    j = 3    array[1] = 3 &gt; array[3] = 2    array[1] = array[3] = 2    array[3] = array[1] = 3    [1, 2, 4, 3]i = 2         j = 3    array[2] = 4 &gt; array[3] = 3    array[1] = array[3] = 2    array[3] = array[1] = 3    [1, 2, 3, 4 3 1 2len(array) = 4i = 0     j = 1    array[0] = 4 &gt; array[0 + 1] = 3    array[0] = array[0 + 1] = 3    array[0 + 1] = array[0] = 4    [3, 4, 1, 2]    j = 2    array[0] = 3 &gt; array[2] = 1    array[0] = array[2] = 1    array[2] = array[0] = 3    [1, 4, 3, 2]    j = 3    array[0] = 1 &lt; array[3] = 2    [1, 4, 3, 2]i = 1         j = 2    array[1] = 4 &gt; array[2] = 3    array[1] = array[2] = 3    array[2] = array[1] = 4    [1, 3, 4, 2]    j = 3    array[1] = 3 &gt; array[3] = 2    array[1] = array[3] = 2    array[3] = array[1] = 3    [1, 2, 4, 3]i = 2         j = 3    array[2] = 4 &gt; array[3] = 3    array[1] = array[3] = 2    array[3] = array[1] = 3    [1, 2, 3, 4]\n\n优化的冒泡如果在某一趟过程中没有发生交换，说明已经结束排序。\n12345678910class Solution:    def bubble_sort(array):        for i in range(len(array) - 1):              flag = False  # 优化后的冒泡，设置一个交换标志位            for j in range(len(array) - i - 1):                  if array[j] &gt; array[j + 1]:                    array[j], array[j + 1] = array[j + 1], array[j]                    flag = True            if not flag:                return array  class Solution:    def bubble_sort(array):        for i in range(len(array) - 1):              flag = False  # 优化后的冒泡，设置一个交换标志位            for j in range(len(array) - i - 1):                  if array[j] &gt; array[j + 1]:                    array[j], array[j + 1] = array[j + 1], array[j]                    flag = True            if not flag:                return array  # 代表计算机偷懒成功\n\n2.插入排序 Insertion Sort （熟悉）每次将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加1 的有序数据，用于少量数据的排序，首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序。\n通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。优化：「将一个数字插入一个有序的数组」这一步，可以不使用逐步交换，使用先赋值给「临时变量」，然后「适当的元素」后移，空出一个位置，最后把「临时变量」赋值给这个空位的策略（就是上面那张图的意思）。编码的时候如果不小心，可能会把数组的值修改，建议多调试；\n特点：「插入排序」可以提前终止内层循环（体现在 nums[j - 1] &gt; temp 不满足时），在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 O(N)；\n由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。\n时间复杂度 O(n^2)空间复杂度：O(1) 使用到常数个临时变量。稳定性：稳定\n12345678910def insert_sort(ilist):    for i in range(len(ilist)):        for j in range(i):            if ilist[i] &lt; ilist[j]:                ilist.insert(j, ilist.pop(i))                break    return ilistprint(insert_sort([4,6,7,3,2,1,8,0]))def insert_sort(ilist):    for i in range(len(ilist)):        for j in range(i):            if ilist[i] &lt; ilist[j]:                ilist.insert(j, ilist.pop(i))                break    return ilistprint(insert_sort([4,6,7,3,2,1,8,0]))# [0, 1, 2, 3, 4, 6, 7, 8]\n\n12345678910111213141516171819202122232425264 3 1 2len(array) = 4i = 0     j 为空i = 1    j = 0    array[1] = 3 &lt; array[0] = 4    [4, 1, 2]    [3, 4, 1, 2]    breaki = 2        j = 0    array[2] = 1 &lt; array[0] = 3    [3, 4, 2]    [1, 3, 4, 2]    breaki = 3         j = 0    array[3] = 2 &gt; array[0] = 1    [1, 3, 4, 2]    j = 1    array[3] = 2 &lt; array[1] = 3    [1, 3, 4]    [1, 2, 3, 4]    4 3 1 2len(array) = 4i = 0     j 为空i = 1    j = 0    array[1] = 3 &lt; array[0] = 4    [4, 1, 2]    [3, 4, 1, 2]    breaki = 2        j = 0    array[2] = 1 &lt; array[0] = 3    [3, 4, 2]    [1, 3, 4, 2]    breaki = 3         j = 0    array[3] = 2 &gt; array[0] = 1    [1, 3, 4, 2]    j = 1    array[3] = 2 &lt; array[1] = 3    [1, 3, 4]    [1, 2, 3, 4]    break\n\n\n12345678910def insert_sort(alist):    # 从第二个位置，即下标为1的元素开始向前插入    for i in range(1, len(alist)):        # 从第i个元素开始向前比较，如果小于前一个元素，交换位置        for j in range(i, 0, -1):            if alist[j] &lt; alist[j-1]:                alist[j], alist[j-1] = alist[j-1], alist[j]alist = [54,26,93,17,77,31,44,55,def insert_sort(alist):    # 从第二个位置，即下标为1的元素开始向前插入    for i in range(1, len(alist)):        # 从第i个元素开始向前比较，如果小于前一个元素，交换位置        for j in range(i, 0, -1):            if alist[j] &lt; alist[j-1]:                alist[j], alist[j-1] = alist[j-1], alist[j]alist = [54,26,93,17,77,31,44,55,20]print(insert_sort(alist))\n1234567891011121314def insert_sort(li):    \"\"\"        插入排序，将无序区的数据依次取出，与有序区数据比较，然后放在合理的位置        li: 无序列表    \"\"\"    for i in range(1, len(li)):  # 无序列表第一个数        temp = li[i]        j = i - 1        while j &gt;= 0 and li[j] &gt; temp: #如果有序区的数依次与无序列表第一个数比较，直到找到对应位置            li[j+1] = li[j]            j -= 1        li[j+1] = temp    def insert_sort(li):    \"\"\"        插入排序，将无序区的数据依次取出，与有序区数据比较，然后放在合理的位置        li: 无序列表    \"\"\"    for i in range(1, len(li)):  # 无序列表第一个数        temp = li[i]        j = i - 1        while j &gt;= 0 and li[j] &gt; temp: #如果有序区的数依次与无序列表第一个数比较，直到找到对应位置            li[j+1] = li[j]            j -= 1        li[j+1] = temp    return li\n\n\n3.选择排序 Selection sort （了解）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。第一趟，在待排序记录r1 …r(n)中选出最小的记录，将它与r1 交换，第二趟，在待排序记录r2 ~ r(n) 中选出最小的记录，将它与 r2 交换，以此类推，第i趟在待排序记录 r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。\n算法思想 1：贪心算法：每一次决策只看当前，当前最优，则全局最优。注意：这种思想不是任何时候都适用。\n算法思想 2：减治思想：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。\n优点：交换次数最少。\n时间复杂度 O(n^2)空间复杂度：O(1)稳定性：不稳定\n12345678910111213141516def select_sort(array):    # 外层循环控制循环次数    for i in range(len(array)):  # 第i趟    # for i in range(len(array) - 1):  # 第i趟        min_index = i  # 假设找到的最小元素下标，无序区第一个数开始查找        # 寻找最小元素的过程        for j in range(i, len(array)):        # for j in range(i + 1, len(array)):          # 加1也不影响 从i+1位置到末尾选择出最小数据            # 假设最小下标的值，大于循环中一个元素，那么就改变最小值的下标            if array[j] &lt; array[min_index]:                min_index = j        # 循环一开始就假设把最小值的下标赋值给变量 min_index        # 在不停的循环中，不停的交换两个不一样大小的值        array[i], array[min_index] = array[min_index], array[i]    def select_sort(array):    # 外层循环控制循环次数    for i in range(len(array)):  # 第i趟    # for i in range(len(array) - 1):  # 第i趟        min_index = i  # 假设找到的最小元素下标，无序区第一个数开始查找        # 寻找最小元素的过程        for j in range(i, len(array)):        # for j in range(i + 1, len(array)):          # 加1也不影响 从i+1位置到末尾选择出最小数据            # 假设最小下标的值，大于循环中一个元素，那么就改变最小值的下标            if array[j] &lt; array[min_index]:                min_index = j        # 循环一开始就假设把最小值的下标赋值给变量 min_index        # 在不停的循环中，不停的交换两个不一样大小的值        array[i], array[min_index] = array[min_index], array[i]    return array\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051524 3 1 2len(array) = 4i = 0 min_index = 0    j = 0    array[0] = 4 = array[0] = 4    j = 1    array[1] = 3 &lt; array[0] = 4    min_index = 1    j = 2    array[2] = 1 &lt; array[1] = 3    min_index = 2    j = 3    array[3] = 2 &gt; array[2] = 1    min_index = 2    slist[0] = slist[2] = 1    slist[2]  = slist[0] = 4    slist = [1, 3, 4, 2]i = 1min_index = 1    j = 1,  j 从i开始，不是从0开始    array[1] = 3 = array[1] = 3    j = 2    array[2] = 4 &gt; array[1] = 3    j = 3    array[3] = 2 &lt; array[1] = 3    min_index = 3    slist[1] = slist[3] = 2    slist[3]  = slist[1] = 3    slist = [1, 2, 4, 3]    i = 2  min_index = 2      j = 2,  j 从i开始，不是从0开始    array[2] = 4 = array[2] = 4    j = 3    array[3] = 3 &lt; array[2] = 4    min_index = 3    slist[2] = slist[3] = 3    slist[3]  = slist[2] = 4    slist = [1, 2, 3, 4]i = 3     min_index = 3     j = 3    array[3] = 3 = array[3] = 3    [1, 3, 4]    [1, 2, 3, 4]    4 3 1 2len(array) = 4i = 0 min_index = 0    j = 0    array[0] = 4 = array[0] = 4    j = 1    array[1] = 3 &lt; array[0] = 4    min_index = 1    j = 2    array[2] = 1 &lt; array[1] = 3    min_index = 2    j = 3    array[3] = 2 &gt; array[2] = 1    min_index = 2    slist[0] = slist[2] = 1    slist[2]  = slist[0] = 4    slist = [1, 3, 4, 2]i = 1min_index = 1    j = 1,  j 从i开始，不是从0开始    array[1] = 3 = array[1] = 3    j = 2    array[2] = 4 &gt; array[1] = 3    j = 3    array[3] = 2 &lt; array[1] = 3    min_index = 3    slist[1] = slist[3] = 2    slist[3]  = slist[1] = 3    slist = [1, 2, 4, 3]    i = 2  min_index = 2      j = 2,  j 从i开始，不是从0开始    array[2] = 4 = array[2] = 4    j = 3    array[3] = 3 &lt; array[2] = 4    min_index = 3    slist[2] = slist[3] = 3    slist[3]  = slist[2] = 4    slist = [1, 2, 3, 4]i = 3     min_index = 3     j = 3    array[3] = 3 = array[3] = 3    [1, 3, 4]    [1, 2, 3, 4]    break\n\n\n4.希尔排序 Shell Sort（不建议多花时间了解）是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。\n是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好被分成一组，算法终止\n将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。\n时间复杂度 O(n^2)空间复杂度：O(nlogn)稳定性：不稳定\n1234567891011121314151617181920212223242526272829303132333435363738394041def shell_sort(slist):    count = len(slist)    step = 2    group = count // step    while group &gt; 0:        for i in range(group):            j = i + group            while j &lt; count:                key = slist[j]                k = j - group                while k &gt;= 0:                    if slist[k] &gt; key:                        slist[k+group] = slist[k]                        slist[k] = key                    k = k - group                j = j + group        group = group // step    return slist# print(shell_sort([4,5,7,3,2,6,9,8,0]))def ShellSort(arrList):    arrayLen = len(arrList)    h = 1    while h &lt; arrayLen//3:        h = h * 3 + 1        #插入排序的方法，判断是不是后一个比前一个要小        #如果是则交换    while h &gt;= 1:        for i in range(h,arrayLen):            j = i            while j &gt;= h and arrList[j] &lt; arrList[j-h]:                arrList[j] ,arrList[j-h] = arrList[j-h],arrList[j]                j -= h        h  //= 3if __name__ == '__main__':    arrList = [14,33,27,10,35,19,42,def shell_sort(slist):    count = len(slist)    step = 2    group = count // step    while group &gt; 0:        for i in range(group):            j = i + group            while j &lt; count:                key = slist[j]                k = j - group                while k &gt;= 0:                    if slist[k] &gt; key:                        slist[k+group] = slist[k]                        slist[k] = key                    k = k - group                j = j + group        group = group // step    return slist# print(shell_sort([4,5,7,3,2,6,9,8,0]))def ShellSort(arrList):    arrayLen = len(arrList)    h = 1    while h &lt; arrayLen//3:        h = h * 3 + 1        #插入排序的方法，判断是不是后一个比前一个要小        #如果是则交换    while h &gt;= 1:        for i in range(h,arrayLen):            j = i            while j &gt;= h and arrList[j] &lt; arrList[j-h]:                arrList[j] ,arrList[j-h] = arrList[j-h],arrList[j]                j -= h        h  //= 3if __name__ == '__main__':    arrList = [14,33,27,10,35,19,42,44]    ShellSort(arrList)    print(arrList)\n\n123456789101112131415161718def shell_sort(alist):    n = len(alist)    # 初始步长    gap = n / 2    while gap &gt; 0:        # 按步长进行插入排序        for i in range(gap, n):            j = i            # 插入排序            while j&gt;=gap and alist[j-gap] &gt; alist[j]:                alist[j-gap], alist[j] = alist[j], alist[j-gap]                j -= gap        # 得到新的步长        gap = gap / 2alist = [54,26,93,17,77,31,44,55,def shell_sort(alist):    n = len(alist)    # 初始步长    gap = n / 2    while gap &gt; 0:        # 按步长进行插入排序        for i in range(gap, n):            j = i            # 插入排序            while j&gt;=gap and alist[j-gap] &gt; alist[j]:                alist[j-gap], alist[j] = alist[j], alist[j-gap]                j -= gap        # 得到新的步长        gap = gap / 2alist = [54,26,93,17,77,31,44,55,20]shell_sort(alist)print(alist)\n\n排序数组给你一个整数数组 nums，请你将该数组升序排列。\n示例 1：\n12输入：nums = [5,2,3,1]输出：[1,2,3,输入：nums = [5,2,3,1]输出：[1,2,3,5]\n示例 2：\n12输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]\n\n\n5.归并排序  Merge_Sort （重点）算法思想：分而治之（分治思想）（Divide and Conquer）。形象理解是「曹冲称象」、MapReduce，在一定情况下可以并行化。\n算法描述：把长度为n的输入序列中待排序数字分分成长度 n/2的子序列；一直重复直到每个子序列只包含一个数字，长度为一的数组是有序的对两个子序列采用归并排序，合并为一个有序序列反复归并，将若干个组两两合并，所有子序列。\n直到只剩下一组，最后把另一个数组的剩余部分复制过来即可\n让子序列有序，再将子序列间有序，\n基本思路：是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，\n例如：「力扣」第 88 题：合并两个有序数组。\n「归并排序」是理解「递归思想」的非常好的学习材料，大家可以通过理解：递归完成以后，合并两个有序数组的这一步骤，想清楚程序的执行流程。即「递归函数执行完成以后，我们还可以做点事情」。\n时间复杂度：O(nlogn)空间复杂度：O(1)稳定性：稳定\n当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。\n思路归并排序利用了分治的思想来对序列进行排序。对一个长为 n 的待排序的序列，我们将其分解成两个长度为 n/2 的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。\n算法\n定义 mergeSort(nums, l, r) 函数表示对 nums 数组里 [l,r] 的部分进行排序，整个函数流程如下：\n\n递归调用函数 mergeSort(nums, l, mid) 对 nums 数组里 [l,mid] 部分进行排序。\n\n递归调用函数 mergeSort(nums, mid + 1, r) 对 nums 数组里 [mid+1,r] 部分进行排序。\n\n此时 nums 数组里 [l,mid] 和 [mid+1,r] 两个区间已经有序，我们对两个有序区间线性归并即可使 nums 数组里 [l,r] 的部分有序。\n\n\n线性归并的过程，由于两个区间均有序，所以我们维护两个指针 i 和 j 表示当前考虑到 [l,mid] 里的第 i 个位置和 [mid+1,r] 的第 j 个位置。\n如果 nums[i] &lt; nums[j] ，那么我们就将 nums[i] 放入临时数组 tmp 中并让 i += 1 ，即指针往后移。否则我们就将 nums[j] 放入临时数组 tmp 中并让 j += 1 。如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入 tmp 数组中即可。\n这样能保证我们每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后 [l,r] 即为有序的。\n函数递归调用的入口为 mergeSort(nums, 0, nums.length - 1)，递归结束当且仅当 l &gt;= r。\n时间复杂度：O(nlogn)。由于归并排序每次都将当前待排序的序列折半成两个子序列递归调用，然后再合并两个有序的子序列，而每次合并两个有序的子序列需要 O(n) 的时间复杂度，所以我们可以列出归并排序运行时间 T(n) 的递归表达式：T(n)=2T(n/2}) + O(n)根据主定理我们可以得出归并排序的时间复杂度为 O(nlogn)。\n空间复杂度：O(n)。我们需要额外 O(n) 空间的 tmp 数组，且归并排序递归调用的层数最深为 \\log_2 ，所以我们还需要额外的 O(logn) 的栈空间，所需的空间复杂度即为 O(n+logn)=O(n)\n\n12345678910111213141516171819202122232425262728293031from typing import Listclass Solution:    def merge_sort(self, nums, l, r):        if l == r:            return        mid = (l + r) // 2        self.merge_sort(nums, l, mid)        self.merge_sort(nums, mid + 1, r)        tmp = []        i, j = l, mid + 1        while i &lt;= mid or j &lt;= r:            if i &gt; mid or (j &lt;= r and nums[j] &lt; nums[i]):                tmp.append(nums[j])                j += 1            else:                tmp.append(nums[i])                i += 1        nums[l:r + 1] = tmp    def sortArray(self, nums: List[int]) -&gt; List[int]:        self.merge_sort(nums, 0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [1, 2, 3, 2, 5, 6]    print(solution.sortArray(array))    from typing import Listclass Solution:    def merge_sort(self, nums, l, r):        if l == r:            return        mid = (l + r) // 2        self.merge_sort(nums, l, mid)        self.merge_sort(nums, mid + 1, r)        tmp = []        i, j = l, mid + 1        while i &lt;= mid or j &lt;= r:            if i &gt; mid or (j &lt;= r and nums[j] &lt; nums[i]):                tmp.append(nums[j])                j += 1            else:                tmp.append(nums[i])                i += 1        nums[l:r + 1] = tmp    def sortArray(self, nums: List[int]) -&gt; List[int]:        self.merge_sort(nums, 0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [1, 2, 3, 2, 5, 6]    print(solution.sortArray(array))    # [1, 2, 2, 3, 5, 6]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252nums = [1, 2, 3, 2, 5, 6]len(nums) - 1 = 6 - 1 = 5l = 0r = 5mid = (0 + 5) // 2 = 2    merge_sort(nums, l, mid)    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]        merge_sort(nums, l, mid)        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]            merge_sort(nums, l, mid)            l = r = 0            [1]            return            递归到最深层        回到上一层的结果        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]            merge_sort(nums, mid + 1, r)            l = 0 + 1 = 1 = r            [2]            return            递归到最深层        回到上一层的结果        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]        tmp = []        i = l = 0 = mid         j = mid + 1 = 0 + 1 = 1 = r         num[j] = nums[1] = 2 &gt; nums[i] = nums[0] = 1        tmp.append(nums[i])        tmp = [1]        i = i + 1 = 1 &gt; mid = 0        j = r        tmp.append(nums[j])        tmp = [1, 2]        j = j + 1 = 2 &gt; r = 1        nums[l:r + 1] = tmp = [1, 2]  # 切片左闭右开         l = 0        r + 1 = 1 + 1 = 2        nums[0:2] = [1, 2]  # 切片左闭右开         递归到最深层    回到上一层的结果    merge_sort(nums, l, mid)    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]        self.merge_sort(nums, l, mid)        已经执行过，不再执行        self.merge_sort(nums, mid + 1, r)        l = mid + 1 = 1 + 1 = 2 = r        [3]        return          递归到最深层    回到上一层的结果    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]    tmp = []    i = l = 0 &lt; mid = 1    j = mid + 1 = 2 = r    num[j] = nums[2] = 3 &gt; nums[i] = nums[0] = 1    tmp.append(nums[i])    tmp = [1]    i = i + 1 = 1 = mid    tmp.append(nums[i])    tmp = [1, 2]    i = i + 1 = 2 &gt; mid    tmp.append(nums[j])    tmp = [1, 2, 3]    j = j + 1 = 3 &gt; r 退出循环    nums[l:r + 1] = tmp     l = 0    r + 1 = 2 + 1 = 3    nums[0:3] = [1, 2, 3]    递归到最深层回到上一层的结果nums = [1, 2, 3, 2, 5, 6]l = 0r = 5mid = (0 + 5) // 2 = 2    self.merge_sort(nums, l, mid)    不执行    self.merge_sort(nums, mid + 1, r)    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]        self.merge_sort(nums, l, mid)        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]            self.merge_sort(nums, l, mid)            l = 3 = r             [2]            return              递归到最深层        回到上一层的结果        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]            self.merge_sort(nums, l, mid)            不执行            self.merge_sort(nums, mid + 1, r)            l = mid + 1 = 3 + 1 = 4 = r             [5]            return              递归到最深层        回到上一层的结果        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]        tmp = []        i = l = 3 = mid         j = mid + 1 = 3 + 1 = 4 = r         num[j] = nums[4] = 5 &gt; nums[i] = nums[3] = 2        tmp.append(nums[i])        tmp = [2]        i = i + 1 = 3 + 1 = 4 &gt; mid = 3        tmp.append(nums[j])        tmp = [2, 5]        j = j + 1 = 4 + 1 = 5 &gt; r = 4        跳出循环        nums[l:r + 1] = tmp  # 切片左闭右开         l = 3        r + 1 = 4 + 1 = 5        nums[3:5] = [2, 5]  # 切片左闭右开        递归到最深层    回到上一层    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]        self.merge_sort(nums, l, mid)        不再执行        self.merge_sort(nums, mid + 1, r)        l = mid + 1 = 4 + 1 = 5 = r         [6]        return        递归到最深层    回到上一层    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]    tmp = []    i = l = 3 &lt; mid = 4    j = mid + 1 = 4 + 1 = 5 = r     num[j] = nums[5] = 6 &gt; nums[i] = nums[3] = 2    tmp.append(nums[i])    tmp = [2]    i = i + 1 = 3 + 1 = 4 = mid = 4    tmp.append(nums[i])    tmp = [2, 5]    i = i + 1 = 4 + 1 = 5 &gt; mid = 4    tmp.append(nums[i])    tmp = [2, 5, 6]        j = j + 1 = 6 &gt; r    nums[l:r + 1] = tmp  # 切片左闭右开      l = 3    r + 1 = 5 + 1 = 6    nums[3:6] = [2, 5, 6]  # 切片左闭右开    递归到最深层回到上一层的结果nums = [1, 2, 3, 2, 5, 6]l = 0r = 5mid = (0 + 5) // 2 = 2tmp = []i = l = 0 &lt; mid = 2j = mid + 1 = 2 + 1 = 3 &lt; r = 5num[j] = nums[3] = 2 &gt; nums[i] = nums[0] = 1tmp.append(nums[i])tmp = [1]i = i + 1 = 0 + 1 = 1 &lt; mid = 2tmp.append(nums[i])tmp = [1, 2]i = i + 1 = 1 + 1 = 2 = mid = 2tmp.append(nums[j])tmp = [1, 2, 2]j = j + 1 = 3 + 1 = 4 &lt; r = 5num[j] = nums[4] = 5 &gt; nums[i] = nums[4] = 5tmp.append(nums[i])tmp = [1, 2, 2, 3]i = i + 1 = 2 + 1 = 3 &gt; mid = 2tmp.append(nums[j])tmp = [1, 2, 2, 3, 5]j = j + 1 = 4 + 1 = 5 = r = 5num[j] = nums[5] = 6 &gt; nums[i] = nums[3] = 2tmp.append(nums[j])tmp = [1, 2, 2, 3, 5, 6]j = j + 1 = 5 + 1 = 6 &gt; r = 5跳出循环nums[l:r + 1] = tmp  # 切片左闭右开 l = 0r + 1 = 5 + 1 = 6nums[0:6] = [1, 2, 2, 3, 5, nums = [1, 2, 3, 2, 5, 6]len(nums) - 1 = 6 - 1 = 5l = 0r = 5mid = (0 + 5) // 2 = 2    merge_sort(nums, l, mid)    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]        merge_sort(nums, l, mid)        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]            merge_sort(nums, l, mid)            l = r = 0            [1]            return            递归到最深层        回到上一层的结果        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]            merge_sort(nums, mid + 1, r)            l = 0 + 1 = 1 = r            [2]            return            递归到最深层        回到上一层的结果        l = 0        r = 1        mid = (0 + 1) // 2 = 0        [1, 2]        tmp = []        i = l = 0 = mid         j = mid + 1 = 0 + 1 = 1 = r         num[j] = nums[1] = 2 &gt; nums[i] = nums[0] = 1        tmp.append(nums[i])        tmp = [1]        i = i + 1 = 1 &gt; mid = 0        j = r        tmp.append(nums[j])        tmp = [1, 2]        j = j + 1 = 2 &gt; r = 1        nums[l:r + 1] = tmp = [1, 2]  # 切片左闭右开         l = 0        r + 1 = 1 + 1 = 2        nums[0:2] = [1, 2]  # 切片左闭右开         递归到最深层    回到上一层的结果    merge_sort(nums, l, mid)    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]        self.merge_sort(nums, l, mid)        已经执行过，不再执行        self.merge_sort(nums, mid + 1, r)        l = mid + 1 = 1 + 1 = 2 = r        [3]        return          递归到最深层    回到上一层的结果    l = 0    r = 2    mid = (0 + 2) // 2 = 1    [1, 2, 3]    tmp = []    i = l = 0 &lt; mid = 1    j = mid + 1 = 2 = r    num[j] = nums[2] = 3 &gt; nums[i] = nums[0] = 1    tmp.append(nums[i])    tmp = [1]    i = i + 1 = 1 = mid    tmp.append(nums[i])    tmp = [1, 2]    i = i + 1 = 2 &gt; mid    tmp.append(nums[j])    tmp = [1, 2, 3]    j = j + 1 = 3 &gt; r 退出循环    nums[l:r + 1] = tmp     l = 0    r + 1 = 2 + 1 = 3    nums[0:3] = [1, 2, 3]    递归到最深层回到上一层的结果nums = [1, 2, 3, 2, 5, 6]l = 0r = 5mid = (0 + 5) // 2 = 2    self.merge_sort(nums, l, mid)    不执行    self.merge_sort(nums, mid + 1, r)    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]        self.merge_sort(nums, l, mid)        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]            self.merge_sort(nums, l, mid)            l = 3 = r             [2]            return              递归到最深层        回到上一层的结果        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]            self.merge_sort(nums, l, mid)            不执行            self.merge_sort(nums, mid + 1, r)            l = mid + 1 = 3 + 1 = 4 = r             [5]            return              递归到最深层        回到上一层的结果        l = 3         r = 4        mid = (3 + 4) // 2 = 3        [2, 5]        tmp = []        i = l = 3 = mid         j = mid + 1 = 3 + 1 = 4 = r         num[j] = nums[4] = 5 &gt; nums[i] = nums[3] = 2        tmp.append(nums[i])        tmp = [2]        i = i + 1 = 3 + 1 = 4 &gt; mid = 3        tmp.append(nums[j])        tmp = [2, 5]        j = j + 1 = 4 + 1 = 5 &gt; r = 4        跳出循环        nums[l:r + 1] = tmp  # 切片左闭右开         l = 3        r + 1 = 4 + 1 = 5        nums[3:5] = [2, 5]  # 切片左闭右开        递归到最深层    回到上一层    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]        self.merge_sort(nums, l, mid)        不再执行        self.merge_sort(nums, mid + 1, r)        l = mid + 1 = 4 + 1 = 5 = r         [6]        return        递归到最深层    回到上一层    l = mid + 1 = 2 + 1 = 3     r = 5    mid = (3 + 5) // 2 = 4    [2, 5, 6]    tmp = []    i = l = 3 &lt; mid = 4    j = mid + 1 = 4 + 1 = 5 = r     num[j] = nums[5] = 6 &gt; nums[i] = nums[3] = 2    tmp.append(nums[i])    tmp = [2]    i = i + 1 = 3 + 1 = 4 = mid = 4    tmp.append(nums[i])    tmp = [2, 5]    i = i + 1 = 4 + 1 = 5 &gt; mid = 4    tmp.append(nums[i])    tmp = [2, 5, 6]        j = j + 1 = 6 &gt; r    nums[l:r + 1] = tmp  # 切片左闭右开      l = 3    r + 1 = 5 + 1 = 6    nums[3:6] = [2, 5, 6]  # 切片左闭右开    递归到最深层回到上一层的结果nums = [1, 2, 3, 2, 5, 6]l = 0r = 5mid = (0 + 5) // 2 = 2tmp = []i = l = 0 &lt; mid = 2j = mid + 1 = 2 + 1 = 3 &lt; r = 5num[j] = nums[3] = 2 &gt; nums[i] = nums[0] = 1tmp.append(nums[i])tmp = [1]i = i + 1 = 0 + 1 = 1 &lt; mid = 2tmp.append(nums[i])tmp = [1, 2]i = i + 1 = 1 + 1 = 2 = mid = 2tmp.append(nums[j])tmp = [1, 2, 2]j = j + 1 = 3 + 1 = 4 &lt; r = 5num[j] = nums[4] = 5 &gt; nums[i] = nums[4] = 5tmp.append(nums[i])tmp = [1, 2, 2, 3]i = i + 1 = 2 + 1 = 3 &gt; mid = 2tmp.append(nums[j])tmp = [1, 2, 2, 3, 5]j = j + 1 = 4 + 1 = 5 = r = 5num[j] = nums[5] = 6 &gt; nums[i] = nums[3] = 2tmp.append(nums[j])tmp = [1, 2, 2, 3, 5, 6]j = j + 1 = 5 + 1 = 6 &gt; r = 5跳出循环nums[l:r + 1] = tmp  # 切片左闭右开 l = 0r + 1 = 5 + 1 = 6nums[0:6] = [1, 2, 2, 3, 5, 6]  # 切片左闭右开\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def MergeSort(arrayList):    arrayLen = len(arrayList)    #判断输入参数的正确性,如果长度小于1，就说明为1    if arrayLen &lt;= 1:        return arrayList    # 二分分解    midIndex = arrayLen // 2    #左边的部分去做 MergeSort    leftArray = MergeSort(arrayList[:midIndex])    #右边的去做 MergeSort    rightArray = MergeSort(arrayList[midIndex:])    #将左右两边合并，称为一个新的数组，并已经排序成功    retArray = MergeCore(leftArray, rightArray)    return retArraydef MergeCore(leftArray, rightArray):    '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''    #首先需要定义两个指针,这两个指针，分别指向这两个数组的第一个元素    leftIndex = 0    rightIndex = 0    #获取两个数组的长度，用于指出上面两个指针的边界是什么    leftLen = len(leftArray)    rightLen = len(rightArray)    #定义一个返回的列表,这一步就代表空间复杂度至少是 O(n)    retList = []    #循环两个数组寻找最小值加入到返回值的数组中    while leftIndex &lt; leftLen and rightIndex &lt; rightLen:        if leftArray[leftIndex] &lt; rightArray[rightIndex]:            retList.append(leftArray[leftIndex])            leftIndex += 1        else:            retList.append(rightArray[rightIndex])            rightIndex += 1    #下面的代码是将剩余的数组中内容放置在返回的数组中    retList.extend(leftArray[leftIndex:])    # while leftIndex &lt; leftLen:    #     retList.append(leftArray[leftIndex])    #     leftIndex += 1    retList.extend(rightArray[rightIndex:])    # while rightIndex &lt; rightLen:    #     retList.append(rightArray[rightIndex])    #     rightIndex += 1    return retListif __name__ == '__main__':    retList = MergeSort([14, 33, 27, 10, 35, 19, 42, 44])    print(retList)  def MergeSort(arrayList):    arrayLen = len(arrayList)    #判断输入参数的正确性,如果长度小于1，就说明为1    if arrayLen &lt;= 1:        return arrayList    # 二分分解    midIndex = arrayLen // 2    #左边的部分去做 MergeSort    leftArray = MergeSort(arrayList[:midIndex])    #右边的去做 MergeSort    rightArray = MergeSort(arrayList[midIndex:])    #将左右两边合并，称为一个新的数组，并已经排序成功    retArray = MergeCore(leftArray, rightArray)    return retArraydef MergeCore(leftArray, rightArray):    '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''    #首先需要定义两个指针,这两个指针，分别指向这两个数组的第一个元素    leftIndex = 0    rightIndex = 0    #获取两个数组的长度，用于指出上面两个指针的边界是什么    leftLen = len(leftArray)    rightLen = len(rightArray)    #定义一个返回的列表,这一步就代表空间复杂度至少是 O(n)    retList = []    #循环两个数组寻找最小值加入到返回值的数组中    while leftIndex &lt; leftLen and rightIndex &lt; rightLen:        if leftArray[leftIndex] &lt; rightArray[rightIndex]:            retList.append(leftArray[leftIndex])            leftIndex += 1        else:            retList.append(rightArray[rightIndex])            rightIndex += 1    #下面的代码是将剩余的数组中内容放置在返回的数组中    retList.extend(leftArray[leftIndex:])    # while leftIndex &lt; leftLen:    #     retList.append(leftArray[leftIndex])    #     leftIndex += 1    retList.extend(rightArray[rightIndex:])    # while rightIndex &lt; rightLen:    #     retList.append(rightArray[rightIndex])    #     rightIndex += 1    return retListif __name__ == '__main__':    retList = MergeSort([14, 33, 27, 10, 35, 19, 42, 44])    print(retList)  # [10, 14, 19, 27, 33, 35, 42, 44]\n\n6.快速排序 Quick sort通过一趟排序划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用此方法对这两部分序列分别进行快速排序，以此使整个序列达到有序。\n快速排序没有指定应如何具体实现第一步，不论是选择主元 pivot 的过程还是划分的过程，都有不止一种实现方法。\n步骤为：\n\n在每一次 partition 之前，选一个元素作为切分元素 pivot，称为“基准”“主元”“分界点”，可以选择nums[left] 或随机交换它与第 1 个或最后 1 个元素的位置，随机元素作为左端“标定点”元素的原因是为了避免极端测试用例，避免递归树加深、达不到减治的效果：\n\n\n性能和「划分」出的子数组的长度密切相关。\n\n最差的情况就是 pivot 被选在了数组的两侧。顺序数组与倒序数组就是这种最差的情况，此时递归树画出来是链表，排序的“递归结构”就变成了“线性结构”，这个时候就很像选择排序，或者是冒泡排序了， 《算法4》这本书上有说，也可以取三个元素的中位数。例如：例如“顺序数组” [1, 2, 3, 4, 5] 的 partition 过程，就是线性搜索，如果找第 1 大元素，就得一个一个地看，看到末尾。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n - 1，每次递归的时候又向 n−1 的集合中递归，而导致时间复杂度退化为 O(N)，快速排序的最坏运行情况是 O(n ^ 2)出现最坏情况的概率是： 1/1 * 1/2 * 1/3 * … 1/n，这个值非常小了。讨论最坏情况意义不大，所以引入随机化来加速这个过程，它的时间代价的期望是 O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。快速排序的 平摊期望时间复杂度是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。对绝大多数顺序性较弱的随机数列而言，是目前基于比较的内部排序中被认为是最好的方法，\n\n最理想的情况是 快速排序每一次选择的 pivot 它最后会被交换到数组中间的部分，这样后面递归的部分，每一个小组的数据不用跟另外小组的数据比较，需要比较的元素就会减少，因此速度较快\n\n\n\n算法思想：分而治之（分治思想），不像「归并排序」无脑地一分为二，把问题规模转化到一个更小的范围里，这样的思想叫做 “减而治之”（是 “分而治之” 思想的特例）。\n\n\npartition 切分、分区：将数组 nums[left⋯right] 分成两个子数组 nums[left⋯j−1]、nums[j+1⋯right]，使得 \n\nnums[left⋯j−1] 中的每个元素小于等于 nums[j]，分割点左侧的数全部不大于基准值\n\nnums[j] 小于等于 nums[j+1⋯right] 中的每个元素。右侧的数全部不小于分割点的数。\n\n计算下标 j 也是「划分」过程的一部分。\n\n解决：通过递归调用快速排序，对子数组 nums[left⋯j−1] 和 nums[j+1⋯right] 进行排序。\n\n因为子数组都是原址排序的，所以没有「合」的合并操作，nums[left⋯right] 已经完全有序。已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。\n\n\n\n\n即基准元素 pivot = nums[j] 每次经过 partition 切分操作以后会放置在它 “最终应该放置的地方”索引为 j，\n\n至于 a[left⋯j−1] 和 a[j+1⋯right] 是否是有序的，我们不关心。\n\n切分过程可以不借助额外的数组空间，仅通过交换数组元素实现。\n\n递归（recursive）地处理左右两段，把小于基准值元素的子数列和大于基准值元素的子数列排序。递归的最底部情形，是数列的大小是零或一，即直至排序区间为 0 时完成排序，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去，使数组中的每个数成为基准。\n\n快排一轮递归，再对分割点左右两侧的子数组成为独立两组数据，分别再像之前一样定一个pivot，比较，分组，如此类推。\n保持「循环不变量」，即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，这个性质是人为根据问题特点定义的。「循环不变量」是证明算法有效性的基础，更是写对代码的保证，是不是该写等于号，先交换还是先 ++ ，就会特别清楚，绝对不会写错，快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」\n法一\n选中列表第一个元素nums[start] 为基准值 pivot，定义两个左右指针 left 指向左边表头和 right 指向右边表尾，\n\n因为分界点选的第一个是最左边，所以不从左边开始而是从右向左找比这个值要大的数，找到就停止，否则指针继续向左移动一个位置，直到找到或者已经比左指针位置小。首先从 right 所指位置起向前 (表头方向)直到搜索出第一个小于关键字元素和pivot基准值相互交换；\n\n从左向右找比这个值要小的数，找到就停止，否则指针继续向右移动一个位置，直到找到或者已经比右指针位置大。然后从 left 所指位置起向后 (表尾方向)直到搜索出第一个大于基准值元素和pivot基准值相互交换。重复这两步知道 left=right为止。\n\n然后交换这两个数字的位置。重复2 3 4 步骤，直到左指针位置已经不再小于右指针位置\n\n然后将中值和现在的左指针或者右指针位置的数 交换位置此时这个数组，就已经以中值为界限，中值左边的均小于中值，中值右边的均大于中值\n\n最后递归重复以上的所有步骤 即可将一个无序数组完整的排序。分别递归左侧列表，右侧列表while里面套两个while循环，从左往右一个while，从右往左一个while将所有大于 nums[start] 的数放到 nums[start] 右边，所有小于 nums[start] 的数放到 nums[start] 左边\n\n\n跟 start 还是 end 比取决于我们把哪个元素看作”哨兵“，跟 end 比也可以，如果要用 end ，哨兵 i, j 的移动先后顺序也要对换因为最后要把 nums[i], nums[start] 交换，因此要保证 ``nums[i] &gt; nums[start]` （和 end 的情况正好相反），这样交换后才符合快排定义。\n维护一前一后两个指针 p 和 q ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针  遇到了一个比  小的数，那么可以交换  和  位置上的数，再把  向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from typing import Listclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        # nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1        def partition(start, end):            # 递归过程中发现start和end一致时，停止递归，直接返回列表            if start &gt;= end:                return            # 设定待排数组第一个元素为要寻找位置的基准元素            pivot = nums[start]            # left为序列左边的由左向右移动的指针            left = start            # right为序列右边的由右向左移动的指针            right = end            while left &lt; right:  # 当left = right，退出循环                # 如果left与right未重合，right指向的元素不比基准元素小                while left &lt; right and nums[right] &gt;= pivot:                    # right先往左移，直到找到一个比基准值小的元素                    right -= 1                # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上                nums[left] = nums[right]                # 如果left与right未重合，left指向的元素比基准元素小，                while left &lt; right and nums[left] &lt; pivot:                    # 则left向右移动，直到找到一个比基准值大的元素                    left += 1                # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上                nums[right] = nums[left]            # 退出循环后，left与right重合，用哪个都一样，            nums[left] = pivot  # 此时所指位置为基准元素的正确位置            return left        def quick_sort(left, right):            if left &lt; right:                pivot = partition(left, right)                # 对基准元素左边的子序列进行快速排序                quick_sort(left, pivot - 1)                # 对基准元素右边的子序列进行快速排序                quick_sort(pivot + 1, right)        quick_sort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    from typing import Listclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        # nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1        def partition(start, end):            # 递归过程中发现start和end一致时，停止递归，直接返回列表            if start &gt;= end:                return            # 设定待排数组第一个元素为要寻找位置的基准元素            pivot = nums[start]            # left为序列左边的由左向右移动的指针            left = start            # right为序列右边的由右向左移动的指针            right = end            while left &lt; right:  # 当left = right，退出循环                # 如果left与right未重合，right指向的元素不比基准元素小                while left &lt; right and nums[right] &gt;= pivot:                    # right先往左移，直到找到一个比基准值小的元素                    right -= 1                # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上                nums[left] = nums[right]                # 如果left与right未重合，left指向的元素比基准元素小，                while left &lt; right and nums[left] &lt; pivot:                    # 则left向右移动，直到找到一个比基准值大的元素                    left += 1                # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上                nums[right] = nums[left]            # 退出循环后，left与right重合，用哪个都一样，            nums[left] = pivot  # 此时所指位置为基准元素的正确位置            return left        def quick_sort(left, right):            if left &lt; right:                pivot = partition(left, right)                # 对基准元素左边的子序列进行快速排序                quick_sort(left, pivot - 1)                # 对基准元素右边的子序列进行快速排序                quick_sort(pivot + 1, right)        quick_sort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    # [1, 2, 3, 4, 5, 6]\n\n1234567891011121314151617181920212223242526272829303132333435363738# nums待排序列表，start第一个元素下标值为0，end最后一个元素下标值len(nums)-1def quick_sort(nums, start, end):    # 递归过程中发现start和end一致时，停止递归，直接返回列表    if start &gt;= end:        return    # 设定待排数组第一个元素为要寻找位置的基准元素    pivot = nums[start]    # left为序列左边的由左向右移动的指针    left = start    # right为序列右边的由右向左移动的指针    right = end    while left &lt; right:  # 当left = right，退出循环        # 如果left与right未重合，right指向的元素不比基准元素小        while left &lt; right and nums[right] &gt;= pivot:            # right往左移,直到找到一个比基准值小的元素            right -= 1   # 先移动 right        # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上        nums[left] = nums[right]        # 如果left与right未重合，left指向的元素比基准元素小，        while left &lt; right and nums[left] &lt; pivot:            # 则left向右移动，直到找到一个比基准值大的元素            left += 1        # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上        nums[right] = nums[left]    # 退出循环后，left与right重合用哪个都一样，    nums[left] = pivot  # 此时所指位置为基准元素的正确位置    # 对基准元素左边的子序列进行快速排序    quick_sort(nums, start, left - 1)    # 对基准元素右边的子序列进行快速排序    quick_sort(nums, left + 1, end)nums = [3, 4, 6, 1, 2, 5]quick_sort(nums, 0, len(nums) - 1)print(nums)# nums待排序列表，start第一个元素下标值为0，end最后一个元素下标值len(nums)-1def quick_sort(nums, start, end):    # 递归过程中发现start和end一致时，停止递归，直接返回列表    if start &gt;= end:        return    # 设定待排数组第一个元素为要寻找位置的基准元素    pivot = nums[start]    # left为序列左边的由左向右移动的指针    left = start    # right为序列右边的由右向左移动的指针    right = end    while left &lt; right:  # 当left = right，退出循环        # 如果left与right未重合，right指向的元素不比基准元素小        while left &lt; right and nums[right] &gt;= pivot:            # right往左移,直到找到一个比基准值小的元素            right -= 1   # 先移动 right        # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上        nums[left] = nums[right]        # 如果left与right未重合，left指向的元素比基准元素小，        while left &lt; right and nums[left] &lt; pivot:            # 则left向右移动，直到找到一个比基准值大的元素            left += 1        # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上        nums[right] = nums[left]    # 退出循环后，left与right重合用哪个都一样，    nums[left] = pivot  # 此时所指位置为基准元素的正确位置    # 对基准元素左边的子序列进行快速排序    quick_sort(nums, start, left - 1)    # 对基准元素右边的子序列进行快速排序    quick_sort(nums, left + 1, end)nums = [3, 4, 6, 1, 2, 5]quick_sort(nums, 0, len(nums) - 1)print(nums)# [1, 2, 3, 4, 5, 6]\n\n12345678910111213141516171819202122232425262728293031323334353637383940[3, 4, 6, 1, 2, 5]pivot = nums[start] = nums[0] = 3left = start = 0right = end = 5 进入外循环    nums[right] = nums[5] = 5 &gt; pivot = 3:        right = right - 1 = 1 = 4        nums[right] = nums[4] = 2 &lt; pivot = 3:        不进入子循环    nums[left] = nums[right] = nums[0] = nums[4] = 2    [2, 4, 6, 1, 2, 5]    nums[left] = nums[0] = 2 &lt; pivot = 3        left = left + 1 = 1        nums[left] = nums[1] = 4 &gt; pivot = 3        不进入子循环    nums[right] = nums[left] = nums[4] = nums[1] = 4    [2, 4, 6, 1, 4, 5]    nums[right] = nums[4] = 4 &gt; pivot = 3:        right = right - 1 = 1 = 3        nums[right] = nums[3] = 1 &lt; pivot = 3:        不进入子循环    nums[left] = nums[right] = nums[1] = nums[3] = 1    [2, 1, 6, 1, 4, 5]    nums[left] = nums[1] = 1 &lt; pivot = 3        left = left + 1 = 2        nums[left] = nums[2] = 6 &gt; pivot = 3        不进入子循环    nums[right] = nums[left] = nums[3] = nums[2] = 6    [2, 1, 6, 6, 4, 5]    nums[right] = nums[3] = 6 &gt; pivot = 3:        right = right - 1 = 1 = 2 = left退出外循环nums[left] = pivot = nums[2] = 3  [2, 1, 3, 6, 4, 5]切分元素 pivot = [3, 4, 6, 1, 2, 5]pivot = nums[start] = nums[0] = 3left = start = 0right = end = 5 进入外循环    nums[right] = nums[5] = 5 &gt; pivot = 3:        right = right - 1 = 1 = 4        nums[right] = nums[4] = 2 &lt; pivot = 3:        不进入子循环    nums[left] = nums[right] = nums[0] = nums[4] = 2    [2, 4, 6, 1, 2, 5]    nums[left] = nums[0] = 2 &lt; pivot = 3        left = left + 1 = 1        nums[left] = nums[1] = 4 &gt; pivot = 3        不进入子循环    nums[right] = nums[left] = nums[4] = nums[1] = 4    [2, 4, 6, 1, 4, 5]    nums[right] = nums[4] = 4 &gt; pivot = 3:        right = right - 1 = 1 = 3        nums[right] = nums[3] = 1 &lt; pivot = 3:        不进入子循环    nums[left] = nums[right] = nums[1] = nums[3] = 1    [2, 1, 6, 1, 4, 5]    nums[left] = nums[1] = 1 &lt; pivot = 3        left = left + 1 = 2        nums[left] = nums[2] = 6 &gt; pivot = 3        不进入子循环    nums[right] = nums[left] = nums[3] = nums[2] = 6    [2, 1, 6, 6, 4, 5]    nums[right] = nums[3] = 6 &gt; pivot = 3:        right = right - 1 = 1 = 2 = left退出外循环nums[left] = pivot = nums[2] = 3  [2, 1, 3, 6, 4, 5]切分元素 pivot = 3 交换到它排序以后最终确定的位置上\n\n跟 l 还是 r 比取决于我们把哪个元素看作”哨兵“，如果要用 r ，哨兵 i, j 的移动先后顺序也要对换因为最后要把 strs[i], strs[r] 交换，因此要保证 ``strs[i] &gt; strs[r]` （和 l 的情况正好相反），这样交换后才符合快排定义。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from typing import Listclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        # nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1        def partition(start, end):            # 递归过程中发现start和end一致时，停止递归，直接返回列表            if start &gt;= end:                return            # 设定待排数组第一个元素为要寻找位置的基准元素            pivot = nums[end]            # left为序列左边的由左向右移动的指针            left = start            # right为序列右边的由右向左移动的指针            right = end            while left &lt; right:  # 当left = right，退出循环                # 如果left与right未重合，left指向的元素比基准元素小，                while left &lt; right and nums[left] &lt; pivot:                    # 则left向右移动，直到找到一个比基准值大的元素                    left += 1                # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上                nums[right] = nums[left]                                # 如果left与right未重合，right指向的元素不比基准元素小                while left &lt; right and nums[right] &gt;= pivot:                    # right先往左移，直到找到一个比基准值小的元素                    right -= 1                # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上                nums[left] = nums[right]            # 退出循环后，left与right重合，用哪个都一样，            nums[left] = pivot  # 此时所指位置为基准元素的正确位置            return left        def quick_sort(left, right):            if left &lt; right:                pivot = partition(left, right)                # 对基准元素左边的子序列进行快速排序                quick_sort(left, pivot - 1)                # 对基准元素右边的子序列进行快速排序                quick_sort(pivot + 1, right)        quick_sort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    from typing import Listclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        # nums待排序列表，第一个元素start下标值为0，最后一个元素end下标值len(nums)-1        def partition(start, end):            # 递归过程中发现start和end一致时，停止递归，直接返回列表            if start &gt;= end:                return            # 设定待排数组第一个元素为要寻找位置的基准元素            pivot = nums[end]            # left为序列左边的由左向右移动的指针            left = start            # right为序列右边的由右向左移动的指针            right = end            while left &lt; right:  # 当left = right，退出循环                # 如果left与right未重合，left指向的元素比基准元素小，                while left &lt; right and nums[left] &lt; pivot:                    # 则left向右移动，直到找到一个比基准值大的元素                    left += 1                # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上                nums[right] = nums[left]                                # 如果left与right未重合，right指向的元素不比基准元素小                while left &lt; right and nums[right] &gt;= pivot:                    # right先往左移，直到找到一个比基准值小的元素                    right -= 1                # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上                nums[left] = nums[right]            # 退出循环后，left与right重合，用哪个都一样，            nums[left] = pivot  # 此时所指位置为基准元素的正确位置            return left        def quick_sort(left, right):            if left &lt; right:                pivot = partition(left, right)                # 对基准元素左边的子序列进行快速排序                quick_sort(left, pivot - 1)                # 对基准元素右边的子序列进行快速排序                quick_sort(pivot + 1, right)        quick_sort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    # [1, 2, 3, 4, 5, 6]\n\n12345678910111213141516171819202122232425262728293031323334353637def quick_sort(nums, start, end):    # 递归过程中发现start和end一致时，停止递归，直接返回列表    if start &gt;= end:        return    # 设定待排数组倒数第一个元素为要寻找位置的基准元素    pivot = nums[end]    # left为序列左边的由左向右移动的指针    left = start    # right为序列右边的由右向左移动的指针    right = end    while left &lt; right:  # 当left = right，退出循环        # 如果left与right未重合，left指向的元素比基准元素小，        while left &lt; right and nums[left] &lt; pivot:            # 则left向右移动，直到找到一个比基准值大的元素            left += 1   # 先移动 left        # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上        nums[right] = nums[left]        # 如果left与right未重合，right指向的元素不比基准元素小        while left &lt; right and nums[right] &gt;= pivot:            # right往左移,直到找到一个比基准值小的元素            right -= 1        # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上        nums[left] = nums[right]    # 退出循环后，left与right重合用哪个都一样，    nums[left] = pivot  # 此时所指位置为基准元素的正确位置    # 对基准元素左边的子序列进行快速排序    quick_sort(nums, start, left - 1)    # 对基准元素右边的子序列进行快速排序    quick_sort(nums, left + 1, end)nums = [3, 4, 6, 1, 2, 5]quick_sort(nums, 0, len(nums) - 1)print(nums)def quick_sort(nums, start, end):    # 递归过程中发现start和end一致时，停止递归，直接返回列表    if start &gt;= end:        return    # 设定待排数组倒数第一个元素为要寻找位置的基准元素    pivot = nums[end]    # left为序列左边的由左向右移动的指针    left = start    # right为序列右边的由右向左移动的指针    right = end    while left &lt; right:  # 当left = right，退出循环        # 如果left与right未重合，left指向的元素比基准元素小，        while left &lt; right and nums[left] &lt; pivot:            # 则left向右移动，直到找到一个比基准值大的元素            left += 1   # 先移动 left        # 当 nums[left] &gt; pivot, 将left指向的元素放到right的位置上        nums[right] = nums[left]        # 如果left与right未重合，right指向的元素不比基准元素小        while left &lt; right and nums[right] &gt;= pivot:            # right往左移,直到找到一个比基准值小的元素            right -= 1        # 当 nums[left] &lt; pivot 将right指向的元素放到left的位置上        nums[left] = nums[right]    # 退出循环后，left与right重合用哪个都一样，    nums[left] = pivot  # 此时所指位置为基准元素的正确位置    # 对基准元素左边的子序列进行快速排序    quick_sort(nums, start, left - 1)    # 对基准元素右边的子序列进行快速排序    quick_sort(nums, left + 1, end)nums = [3, 4, 6, 1, 2, 5]quick_sort(nums, 0, len(nums) - 1)print(nums)# [1, 2, 3, 4, 5, 6]\n\n法二\n123456789101112131415161718192021222324252627282930313233343536373839404142from typing import Listimport randomclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        def partition(left, right):            randidx = random.randint(left, right)            nums[left], nums[randidx] = nums[randidx], nums[left]            pivot = nums[left]            l = left + 1            r = right            while l &lt;= r:                while l &lt;= r and nums[l] &lt;= pivot:                    # l 指向数字肯定比 pivot 大                    l += 1                while l &lt;= r and nums[r] &gt;= pivot:                    # r 指向数字肯定比 pivot 小                    r -= 1                if l &gt; r:                    break                nums[l], nums[r] = nums[r], nums[l]            # r 和 left 互换, r为 pivot            nums[r], nums[left] = nums[left], nums[r]            return r        def quicksort(left, right):            if left &lt; right:                pivot = partition(left, right)                quicksort(left, pivot - 1)                quicksort(pivot + 1, right)        quicksort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    from typing import Listimport randomclass Solution:    def sortArray(self, nums: List[int]) -&gt; List[int]:        def partition(left, right):            randidx = random.randint(left, right)            nums[left], nums[randidx] = nums[randidx], nums[left]            pivot = nums[left]            l = left + 1            r = right            while l &lt;= r:                while l &lt;= r and nums[l] &lt;= pivot:                    # l 指向数字肯定比 pivot 大                    l += 1                while l &lt;= r and nums[r] &gt;= pivot:                    # r 指向数字肯定比 pivot 小                    r -= 1                if l &gt; r:                    break                nums[l], nums[r] = nums[r], nums[l]            # r 和 left 互换, r为 pivot            nums[r], nums[left] = nums[left], nums[r]            return r        def quicksort(left, right):            if left &lt; right:                pivot = partition(left, right)                quicksort(left, pivot - 1)                quicksort(pivot + 1, right)        quicksort(0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [3, 4, 6, 1, 2, 5]    print(solution.sortArray(array))    # [1, 2, 3, 4, 5, 6]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109[3, 4, 6, 1, 2, 5]quicksort(0, len(nums) - 1)quicksort(0, 6 - 1)quicksort(0, 5)left = 0 &lt; right = 5partition(left, right)randidx = 0  随机取到最左边nums[left] = nums[randidx] = nums[0] = nums[0] = 3nums[randidx] = nums[left] = nums[0] = nums[0] = 3pivot = nums[left] = 3l = left + 1 = 0 + 1 = 1r = right = 5l = 1 &lt; r = 5:    while l = 1 &lt; r = 5 and nums[l] = nums[1] = 4 &gt; pivot = 3        不进入循环    while l = 1 &lt; r = 5 and nums[r] = nums[5] = 5 &gt; pivot = 3:        r = r - 1 = 4        while l = 1 &lt; r = 4 and nums[r] = nums[4] = 2 &lt; pivot = 3:        退出子循环    nums[l] = nums[r] = nums[1] = nums[4] = 2    nums[r] = nums[l] = nums[4] = nums[1] = 4    [3, 2, 6, 1, 4, 5]    while l = 1 &lt; r = 4 and nums[l] = nums[1] = 2 &lt; pivot = 3    l = l + 1 = 1 + 1 = 2    while l = 2 &lt; r = 4 and nums[l] = nums[2] = 6 &gt; pivot = 3        不进入循环    while l = 2 &lt; r = 4 and nums[r] = nums[4] = 4 &gt; pivot = 3:        r = r - 1 = 3        while l = 2 &lt; r = 3 and nums[r] = nums[3] = 1 &lt; pivot = 3:        退出子循环    nums[l] = nums[r] = nums[2] = nums[3] = 1    nums[r] = nums[l] = nums[3] = nums[2] = 6    [3, 2, 1, 6, 4, 5]    while l = 2 &lt; r = 3 and nums[l] = nums[2] = 1 &lt; pivot = 3    l = l + 1 = 2 + 1 = 3    while l = 3 = r and nums[l] = nums[3] = 6 &gt; pivot = 3        不进入循环    while l = 3 = r and nums[r] = nums[3] = 6 &gt; pivot = 3:        r = r - 1 = 2        while l = 3 &gt; r = 2 and nums[r] = nums[2] = 1 &lt; pivot = 3:        退出子循环l = 3 &gt; r = 2break        nums[r] = nums[left] = nums[2] = nums[0] = 3nums[left] = nums[r] = nums[0] = nums[2] = 1[1, 2, 3, 6, 4, 5]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return r = 2pivot = 2quicksort(left, pivot - 1)    quicksort(0, 2 - 1)    quicksort(0, 1)    partition(0, 1)    left = 0     right = 1    randidx = random.randint(left, right)    randidx = random.randint(0, 1) 取不到后面的2~5    randidx = 0  随机取到最左边    nums[left] = nums[randidx] = nums[0] = nums[0] = 1    nums[randidx] = nums[left] = nums[0] = nums[0] = 1    pivot = nums[left] = 1    l = left + 1 = 0 + 1 = 1    r = right = 1    l = 1 = r:    while l = 1 = r and nums[l] = nums[1] = 2 &gt; pivot = 1        不进入循环    while l = 1 = r and nums[r] = nums[1] = 2 &gt; pivot = 1:        r = r - 1 = 0 &lt; l = 1    l = 1 &gt; r = 0    break        nums[r] = nums[left] = nums[0] = nums[0] = 1    nums[left] = nums[r] = nums[0] = nums[0] = 1    [1, 2, 3, 6, 4, 5]    切分元素 pivot = 1 交换到它排序以后最终确定的位置上    return r = 0    pivot = 0    quicksort(left, pivot - 1)        quicksort(0, 0 - 1)        quicksort(0, -1)        left = 0 &gt; right = -1    quicksort(pivot + 1, right)        quicksort(0 + 1, 1)        left = 1 = rightquicksort(pivot + 1, right)    quicksort(2 + 1, 5)    quicksort(3, 5)    partition(3, 5)    randidx = random.randint(left, right)    randidx = random.randint(3, 5)区间，取不到前面的0~[3, 4, 6, 1, 2, 5]quicksort(0, len(nums) - 1)quicksort(0, 6 - 1)quicksort(0, 5)left = 0 &lt; right = 5partition(left, right)randidx = 0  随机取到最左边nums[left] = nums[randidx] = nums[0] = nums[0] = 3nums[randidx] = nums[left] = nums[0] = nums[0] = 3pivot = nums[left] = 3l = left + 1 = 0 + 1 = 1r = right = 5l = 1 &lt; r = 5:    while l = 1 &lt; r = 5 and nums[l] = nums[1] = 4 &gt; pivot = 3        不进入循环    while l = 1 &lt; r = 5 and nums[r] = nums[5] = 5 &gt; pivot = 3:        r = r - 1 = 4        while l = 1 &lt; r = 4 and nums[r] = nums[4] = 2 &lt; pivot = 3:        退出子循环    nums[l] = nums[r] = nums[1] = nums[4] = 2    nums[r] = nums[l] = nums[4] = nums[1] = 4    [3, 2, 6, 1, 4, 5]    while l = 1 &lt; r = 4 and nums[l] = nums[1] = 2 &lt; pivot = 3    l = l + 1 = 1 + 1 = 2    while l = 2 &lt; r = 4 and nums[l] = nums[2] = 6 &gt; pivot = 3        不进入循环    while l = 2 &lt; r = 4 and nums[r] = nums[4] = 4 &gt; pivot = 3:        r = r - 1 = 3        while l = 2 &lt; r = 3 and nums[r] = nums[3] = 1 &lt; pivot = 3:        退出子循环    nums[l] = nums[r] = nums[2] = nums[3] = 1    nums[r] = nums[l] = nums[3] = nums[2] = 6    [3, 2, 1, 6, 4, 5]    while l = 2 &lt; r = 3 and nums[l] = nums[2] = 1 &lt; pivot = 3    l = l + 1 = 2 + 1 = 3    while l = 3 = r and nums[l] = nums[3] = 6 &gt; pivot = 3        不进入循环    while l = 3 = r and nums[r] = nums[3] = 6 &gt; pivot = 3:        r = r - 1 = 2        while l = 3 &gt; r = 2 and nums[r] = nums[2] = 1 &lt; pivot = 3:        退出子循环l = 3 &gt; r = 2break        nums[r] = nums[left] = nums[2] = nums[0] = 3nums[left] = nums[r] = nums[0] = nums[2] = 1[1, 2, 3, 6, 4, 5]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return r = 2pivot = 2quicksort(left, pivot - 1)    quicksort(0, 2 - 1)    quicksort(0, 1)    partition(0, 1)    left = 0     right = 1    randidx = random.randint(left, right)    randidx = random.randint(0, 1) 取不到后面的2~5    randidx = 0  随机取到最左边    nums[left] = nums[randidx] = nums[0] = nums[0] = 1    nums[randidx] = nums[left] = nums[0] = nums[0] = 1    pivot = nums[left] = 1    l = left + 1 = 0 + 1 = 1    r = right = 1    l = 1 = r:    while l = 1 = r and nums[l] = nums[1] = 2 &gt; pivot = 1        不进入循环    while l = 1 = r and nums[r] = nums[1] = 2 &gt; pivot = 1:        r = r - 1 = 0 &lt; l = 1    l = 1 &gt; r = 0    break        nums[r] = nums[left] = nums[0] = nums[0] = 1    nums[left] = nums[r] = nums[0] = nums[0] = 1    [1, 2, 3, 6, 4, 5]    切分元素 pivot = 1 交换到它排序以后最终确定的位置上    return r = 0    pivot = 0    quicksort(left, pivot - 1)        quicksort(0, 0 - 1)        quicksort(0, -1)        left = 0 &gt; right = -1    quicksort(pivot + 1, right)        quicksort(0 + 1, 1)        left = 1 = rightquicksort(pivot + 1, right)    quicksort(2 + 1, 5)    quicksort(3, 5)    partition(3, 5)    randidx = random.randint(left, right)    randidx = random.randint(3, 5)区间，取不到前面的0~1\n\n方法三我们定义函数 randomized_quicksort(nums, l, r) 为对 nums 数组里 [l,r] 的部分进行排序，每次先调用 randomized_partition 函数对 nums 数组里 [l,r] 的部分进行划分，并返回分界值的下标 pos，然后按上述将的递归调用 randomized_quicksort(nums, l, pos - 1) 和 randomized_quicksort(nums, pos + 1, r) 即可。\n这里我们采用随机的方式，对当前划分区间 [l,r] 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分。\n整个划分函数 partition 主要涉及两个指针 i 和 j，一开始 i = l - 1，j = l。实时维护两个指针使得任意时候对于任意数组下标 k，我们有如下条件成立：\n\nl ≤ k ≤ i 时，nums[k] ≤ pivot。\ni+1 ≤ k ≤ j−1 时，nums[k] &gt; pivot。\nk == r 时，nums[k] = pivot。\n\n我们每次移动指针 j ，如果 nums[j] &gt; pivot，我们只需要继续移动指针 j ，即能使上述三个条件成立，否则我们需要将指针 i 加一，然后交换 nums[i] 和 nums[j]，再移动指针 j 才能使得三个条件成立。\n当 j 移动到 r−1 时结束循环，此时我们可以由上述三个条件知道 [l,i] 的数都小于等于主元 pivot，[i+1,r−1] 的数都大于主元 pivot，那么我们只要交换 nums[i+1] 和 nums[r] ，即能使得 [l,i+1] 区间的数都小于 [i+2,r] 区间的数，完成一次划分，且分界值下标为 i+1，返回即可。\n如下的动图展示了一次划分的过程，刚开始随机选了 4 作为主元，与末尾元素交换后开始划分：\n时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 n 为数组的长度。详细证明过程可以见《算法导论》第七章\n空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为 nlogn，空间复杂度为 O(logn)。\n1234567891011121314151617181920212223242526272829303132333435363738394041from typing import Listimport randomclass Solution:    def randomized_partition(self, nums, l, r):        pivot = random.randint(l, r)        nums[pivot], nums[r] = nums[r], nums[pivot]        # 设置一个 左边的指针位置 为 左侧的 前一个        i = l - 1        # 双指针同时往后，一趟for循环，遍历 除 基准数之外的 数        for j in range(l, r):  # range左闭右开            # 比较 遍历的当前数 和 基准数 ，若是小于基准数 则 换到数组前面去            # 交换位置，将遍历的比 基准数小的数 放到 我们指针 的 后一个上，然后 这个时候指针向后移一位。当遍历的数大于我们的基准数的时候，不移动，而且 指针也不发生变化，那么 当我们遍历完一圈以后，把 我们的基准数 放到 索引i 的后一个 位置，那么就形成了 一个 基准数 左边都是比它小的数，基准数右边 都是比它大的数 这样的模式。然后要把 索引 i 的后一个位置 作为基准数 与 原基准数 交换位置，进而可以第二次来 遍历比较。            if nums[j] &lt; nums[r]:                i += 1                nums[j], nums[i] = nums[i], nums[j]        # 遍历完后，将 ？数 和 right 上的数互换位置，就 重置 基准数了。        i += 1        nums[i], nums[r] = nums[r], nums[i]        # 返回基准的下标        return i    def randomized_quicksort(self, nums, l, r):        if l &gt;= r:            return        mid = self.randomized_partition(nums, l, r)        self.randomized_quicksort(nums, l, mid - 1)        self.randomized_quicksort(nums, mid + 1, r)    # 函数入口    def sortArray(self, nums: List[int]) -&gt; List[int]:        self.randomized_quicksort(nums, 0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [2, 8, 4, 1, 3, 5, 6, 7]    print(solution.sortArray(array))    from typing import Listimport randomclass Solution:    def randomized_partition(self, nums, l, r):        pivot = random.randint(l, r)        nums[pivot], nums[r] = nums[r], nums[pivot]        # 设置一个 左边的指针位置 为 左侧的 前一个        i = l - 1        # 双指针同时往后，一趟for循环，遍历 除 基准数之外的 数        for j in range(l, r):  # range左闭右开            # 比较 遍历的当前数 和 基准数 ，若是小于基准数 则 换到数组前面去            # 交换位置，将遍历的比 基准数小的数 放到 我们指针 的 后一个上，然后 这个时候指针向后移一位。当遍历的数大于我们的基准数的时候，不移动，而且 指针也不发生变化，那么 当我们遍历完一圈以后，把 我们的基准数 放到 索引i 的后一个 位置，那么就形成了 一个 基准数 左边都是比它小的数，基准数右边 都是比它大的数 这样的模式。然后要把 索引 i 的后一个位置 作为基准数 与 原基准数 交换位置，进而可以第二次来 遍历比较。            if nums[j] &lt; nums[r]:                i += 1                nums[j], nums[i] = nums[i], nums[j]        # 遍历完后，将 ？数 和 right 上的数互换位置，就 重置 基准数了。        i += 1        nums[i], nums[r] = nums[r], nums[i]        # 返回基准的下标        return i    def randomized_quicksort(self, nums, l, r):        if l &gt;= r:            return        mid = self.randomized_partition(nums, l, r)        self.randomized_quicksort(nums, l, mid - 1)        self.randomized_quicksort(nums, mid + 1, r)    # 函数入口    def sortArray(self, nums: List[int]) -&gt; List[int]:        self.randomized_quicksort(nums, 0, len(nums) - 1)        return numsif __name__ == '__main__':    solution = Solution()    array = [2, 8, 4, 1, 3, 5, 6, 7]    print(solution.sortArray(array))    # [1, 2, 3, 4, 5, 6, 7, 8]\n\n调试1\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[3, 4, 6, 1, 2, 5]randomized_quicksort(nums, 0, len(nums) - 1)randomized_quicksort(nums, 0, 6 - 1)randomized_quicksort(nums, 0, 5)l = 0 &lt; r = 5randomized_partition(nums, l, r)pivot = random.randint(l, r) = 0nums[pivot] = nums[r] = nums[0] = nums[5] = 5nums[r] = nums[pivot] = nums[5] = nums[0] = 3[5, 4, 6, 1, 2, 3] i = l - 1 = 0 - 1 = -1j = 0num[0] = 5 &gt; num[5] = 3j = 1nums[1] = 4 &gt; num[5] = 3j = 2nums[2] = 6 &gt; num[5] = 3j = 3nums[3] = 1 &lt; num[5] = 3i = i + 1 = 0nums[j] = nums[i] = nums[3] = nums[0] = 5 nums[i] = nums[j] = nums[0] = nums[3] = 1 [1, 4, 6, 5, 2, 3] j = 4nums[4] = 2 &lt; num[5] = 3i = i + 1 = 1nums[j] = nums[i] = nums[4] = nums[1] = 4 nums[i] = nums[j] = nums[1] = nums[4] = 2 [1, 2, 6, 5, 4, 3] i = i + 1 = 2nums[i] = nums[r] = nums[2] = nums[5] = 4 nums[r] = nums[i] = nums[5] = nums[2] = 6[1, 2, 3, 5, 4, 6] 切分元素 nums[pivot] = 3 交换到它排序以后最终确定的位置上mid = i = 2 返回原来下标为2的元素3的最终位置在下标2 self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 2 - 1)self.randomized_quicksort(nums, 0, 1)    l = 0 &lt; r = 1    randomized_partition(nums, l, r)    pivot = random.randint(l, r) = 0    nums[pivot] = nums[r] = nums[0] = nums[1] = 2    nums[r] = nums[pivot] = nums[1] = nums[0] = 1    [2, 1, 3, 5, 4, 6]     i = l - 1 = 0 - 1 = -1    j = 0    num[0] = 2 &gt; num[1] = 1    i = i + 1 = 0    nums[i] = nums[r] = nums[0] = nums[1] = 1     nums[r] = nums[i] = nums[1] = nums[0] = 2    [1, 2, 3, 5, 4, 6]     切分元素 nums[pivot] = 1 交换到它排序以后最终确定的位置上    mid = i = 0 返回原来下标为0的元素1的最终位置在下标0     self.randomized_quicksort(nums, l, mid - 1)    self.randomized_quicksort(nums, 0, 0 - 1)    self.randomized_quicksort(nums, 0, -1)        l = 0 &gt; r = -1        return    self.randomized_quicksort(nums, mid + 1, r)    self.randomized_quicksort(nums, 0 + 1, 1)        l = 1 = r        returnself.randomized_quicksort(nums, mid + 1, r)self.randomized_quicksort(nums, 2 + 1, 5)self.randomized_quicksort(nums, 3, 5)    l = 3 &lt; r = 5    randomized_partition(nums, l, r)    pivot = random.randint(l, r) = 3    nums[pivot] = nums[r] = nums[3] = nums[5] = 6    nums[r] = nums[pivot] = nums[5] = nums[3] = 5    [1, 2, 3, 6, 4, 5]     i = l - 1 = 3 - 1 = 2    j = 3    num[3] = 6 &gt; num[5] = 5    j = 4    num[4] = 4 &lt; num[5] = 5    i = i + 1 = 3    nums[j] = nums[i] = nums[4] = nums[3] = 6     nums[i] = nums[j] = nums[3] = nums[4] = 4     [1, 2, 3, 4, 6, 5]     i = i + 1 = 4    nums[i] = nums[r] = nums[4] = nums[5] = 6     nums[r] = nums[i] = nums[5] = nums[4] = 5    [1, 2, 3, 4, 5, 6]    切分元素 nums[pivot] = 5 交换到它排序以后最终确定的位置上    mid = i = 4 返回原来下标为3的元素5的最终位置在下标4     self.randomized_quicksort(nums, l, mid - 1)    self.randomized_quicksort(nums, 3, 4 - 1)    self.randomized_quicksort(nums, 3, 3)        l = 3 = r        return    self.randomized_quicksort(nums, mid + 1, r)    self.randomized_quicksort(nums, 4 + 1, 5)        l = 5 = r        [3, 4, 6, 1, 2, 5]randomized_quicksort(nums, 0, len(nums) - 1)randomized_quicksort(nums, 0, 6 - 1)randomized_quicksort(nums, 0, 5)l = 0 &lt; r = 5randomized_partition(nums, l, r)pivot = random.randint(l, r) = 0nums[pivot] = nums[r] = nums[0] = nums[5] = 5nums[r] = nums[pivot] = nums[5] = nums[0] = 3[5, 4, 6, 1, 2, 3] i = l - 1 = 0 - 1 = -1j = 0num[0] = 5 &gt; num[5] = 3j = 1nums[1] = 4 &gt; num[5] = 3j = 2nums[2] = 6 &gt; num[5] = 3j = 3nums[3] = 1 &lt; num[5] = 3i = i + 1 = 0nums[j] = nums[i] = nums[3] = nums[0] = 5 nums[i] = nums[j] = nums[0] = nums[3] = 1 [1, 4, 6, 5, 2, 3] j = 4nums[4] = 2 &lt; num[5] = 3i = i + 1 = 1nums[j] = nums[i] = nums[4] = nums[1] = 4 nums[i] = nums[j] = nums[1] = nums[4] = 2 [1, 2, 6, 5, 4, 3] i = i + 1 = 2nums[i] = nums[r] = nums[2] = nums[5] = 4 nums[r] = nums[i] = nums[5] = nums[2] = 6[1, 2, 3, 5, 4, 6] 切分元素 nums[pivot] = 3 交换到它排序以后最终确定的位置上mid = i = 2 返回原来下标为2的元素3的最终位置在下标2 self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 2 - 1)self.randomized_quicksort(nums, 0, 1)    l = 0 &lt; r = 1    randomized_partition(nums, l, r)    pivot = random.randint(l, r) = 0    nums[pivot] = nums[r] = nums[0] = nums[1] = 2    nums[r] = nums[pivot] = nums[1] = nums[0] = 1    [2, 1, 3, 5, 4, 6]     i = l - 1 = 0 - 1 = -1    j = 0    num[0] = 2 &gt; num[1] = 1    i = i + 1 = 0    nums[i] = nums[r] = nums[0] = nums[1] = 1     nums[r] = nums[i] = nums[1] = nums[0] = 2    [1, 2, 3, 5, 4, 6]     切分元素 nums[pivot] = 1 交换到它排序以后最终确定的位置上    mid = i = 0 返回原来下标为0的元素1的最终位置在下标0     self.randomized_quicksort(nums, l, mid - 1)    self.randomized_quicksort(nums, 0, 0 - 1)    self.randomized_quicksort(nums, 0, -1)        l = 0 &gt; r = -1        return    self.randomized_quicksort(nums, mid + 1, r)    self.randomized_quicksort(nums, 0 + 1, 1)        l = 1 = r        returnself.randomized_quicksort(nums, mid + 1, r)self.randomized_quicksort(nums, 2 + 1, 5)self.randomized_quicksort(nums, 3, 5)    l = 3 &lt; r = 5    randomized_partition(nums, l, r)    pivot = random.randint(l, r) = 3    nums[pivot] = nums[r] = nums[3] = nums[5] = 6    nums[r] = nums[pivot] = nums[5] = nums[3] = 5    [1, 2, 3, 6, 4, 5]     i = l - 1 = 3 - 1 = 2    j = 3    num[3] = 6 &gt; num[5] = 5    j = 4    num[4] = 4 &lt; num[5] = 5    i = i + 1 = 3    nums[j] = nums[i] = nums[4] = nums[3] = 6     nums[i] = nums[j] = nums[3] = nums[4] = 4     [1, 2, 3, 4, 6, 5]     i = i + 1 = 4    nums[i] = nums[r] = nums[4] = nums[5] = 6     nums[r] = nums[i] = nums[5] = nums[4] = 5    [1, 2, 3, 4, 5, 6]    切分元素 nums[pivot] = 5 交换到它排序以后最终确定的位置上    mid = i = 4 返回原来下标为3的元素5的最终位置在下标4     self.randomized_quicksort(nums, l, mid - 1)    self.randomized_quicksort(nums, 3, 4 - 1)    self.randomized_quicksort(nums, 3, 3)        l = 3 = r        return    self.randomized_quicksort(nums, mid + 1, r)    self.randomized_quicksort(nums, 4 + 1, 5)        l = 5 = r        return\n\n调试2\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[2, 8, 4, 1, 3, 5, 6, 7] len(nums) - 1 = 7pivot = random.randint(l, r) = 2nums[pivot] = 4 nums[pivot] = nums[r] = nums[2] = nums[7] = 7nums[r] = nums[pivot] = nums[3] = nums[2] = 4[2, 8, 7, 1, 3, 5, 6, 4]i = l - 1 = 0 - 1 = -1j = 0num[0] = 2 &lt; num[7] = 4i = i + 1 = 0nums[j] = nums[i] = nums[0] = nums[0] = 2 nums[i] = nums[j] = nums[0] = nums[0] = 2 [2, 8, 7, 1, 3, 5, 6, 4]j = 1nums[1] = 8 &gt; num[7] = 4j = 2nums[2] = 7 &gt; num[7] = 4j = 3nums[3] = 1 &lt; num[7] = 4i = i + 1 = 1nums[j] = nums[i] = nums[3] = nums[1] = 8 nums[i] = nums[j] = nums[1] = nums[3] = 1 [2, 1, 7, 8, 3, 5, 6, 4]j = 4nums[4] = 3 &lt; num[7] = 4i = i + 1 = 2nums[j] = nums[i] = nums[4] = nums[2] = 3 nums[i] = nums[j] = nums[2] = nums[4] = 7 [2, 1, 3, 8, 7, 5, 6, 4]j = 5nums[5] = 5 &gt; num[7] = 4j = 6nums[6] = 6 &gt; num[7] = 4i = i + 1 = 3nums[i] = nums[r] = nums[3] = nums[7] = 4 nums[r] = nums[i] = nums[7] = nums[1] = 8 [2, 1, 3, 4, 7, 5, 6, 8]切分元素 pivot = 4 交换到它排序以后最终确定的位置上mid = i = 3 返回原来下标为2的元素3的最终位置在下标3 self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 1 - 1)self.randomized_quicksort(nums, 0, 1)self.randomized_quicksort(nums, mid + 1, r)self.randomized_quicksort(nums, 3 + 1, [2, 8, 4, 1, 3, 5, 6, 7] len(nums) - 1 = 7pivot = random.randint(l, r) = 2nums[pivot] = 4 nums[pivot] = nums[r] = nums[2] = nums[7] = 7nums[r] = nums[pivot] = nums[3] = nums[2] = 4[2, 8, 7, 1, 3, 5, 6, 4]i = l - 1 = 0 - 1 = -1j = 0num[0] = 2 &lt; num[7] = 4i = i + 1 = 0nums[j] = nums[i] = nums[0] = nums[0] = 2 nums[i] = nums[j] = nums[0] = nums[0] = 2 [2, 8, 7, 1, 3, 5, 6, 4]j = 1nums[1] = 8 &gt; num[7] = 4j = 2nums[2] = 7 &gt; num[7] = 4j = 3nums[3] = 1 &lt; num[7] = 4i = i + 1 = 1nums[j] = nums[i] = nums[3] = nums[1] = 8 nums[i] = nums[j] = nums[1] = nums[3] = 1 [2, 1, 7, 8, 3, 5, 6, 4]j = 4nums[4] = 3 &lt; num[7] = 4i = i + 1 = 2nums[j] = nums[i] = nums[4] = nums[2] = 3 nums[i] = nums[j] = nums[2] = nums[4] = 7 [2, 1, 3, 8, 7, 5, 6, 4]j = 5nums[5] = 5 &gt; num[7] = 4j = 6nums[6] = 6 &gt; num[7] = 4i = i + 1 = 3nums[i] = nums[r] = nums[3] = nums[7] = 4 nums[r] = nums[i] = nums[7] = nums[1] = 8 [2, 1, 3, 4, 7, 5, 6, 8]切分元素 pivot = 4 交换到它排序以后最终确定的位置上mid = i = 3 返回原来下标为2的元素3的最终位置在下标3 self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 1 - 1)self.randomized_quicksort(nums, 0, 1)self.randomized_quicksort(nums, mid + 1, r)self.randomized_quicksort(nums, 3 + 1, 7)\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[2, 8, 4, 1, 3, 5, 6, 7] r = len(nums) - 1 = 7pivot = random.randint(l, r) = 7 随机取到最右边nums[pivot] = 7 nums[pivot] = nums[r] = nums[7] = nums[7] = 7nums[r] = nums[pivot] = nums[7] = nums[7] = 7[2, 8, 4, 1, 3, 5, 6, 7]i = l - 1 = 0 - 1 = -1j = 0num[0] = 2 &lt; num[7] = 7i = i + 1 = 0nums[j] = nums[i] = nums[0] = nums[0] = 2 nums[i] = nums[j] = nums[0] = nums[0] = 2 [2, 8, 4, 1, 3, 5, 6, 7]j = 1nums[1] = 8 &gt; num[7] = 7j = 2nums[2] = 4 &lt; num[7] = 7i = i + 1 = 1nums[j] = nums[i] = nums[2] = nums[1] = 8 nums[i] = nums[j] = nums[1] = nums[2] = 4 [2, 4, 8, 1, 3, 5, 6, 7]j = 3nums[3] = 1 &lt; num[7] = 7i = i + 1 = 2nums[j] = nums[i] = nums[3] = nums[2] = 8 nums[i] = nums[j] = nums[2] = nums[3] = 1 [2, 4, 1, 8, 3, 5, 6, 7]j = 4nums[4] = 3 &lt; num[7] = 7i = i + 1 = 3nums[j] = nums[i] = nums[4] = nums[3] = 8 nums[i] = nums[j] = nums[3] = nums[4] = 3 [2, 4, 1, 3, 8, 5, 6, 7]j = 5nums[5] = 5 &lt; num[7] = 7i = i + 1 = 4nums[j] = nums[i] = nums[5] = nums[4] = 8 nums[i] = nums[j] = nums[4] = nums[5] = 5 [2, 4, 1, 3, 5, 8, 6, 7]j = 6nums[6] = 6 &lt; num[7] = 7i = i + 1 = 5nums[j] = nums[i] = nums[6] = nums[5] = 8 nums[i] = nums[j] = nums[5] = nums[6] = 6 [2, 4, 1, 3, 5, 6, 8, 7]i = i + 1 = 6nums[i] = nums[r] = nums[6] = nums[7] = 8 nums[r] = nums[i] = nums[7] = nums[1] = 7 [2, 4, 1, 3, 5, 6, 7, 8]切分元素 nums[pivot] = 7 交换到它排序以后最终确定的位置上return i = 6mid = i = 6 ，则原来下标为7的元素7的位置确定在下标6self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 6 - 1)self.randomized_quicksort(nums, 0, [2, 8, 4, 1, 3, 5, 6, 7] r = len(nums) - 1 = 7pivot = random.randint(l, r) = 7 随机取到最右边nums[pivot] = 7 nums[pivot] = nums[r] = nums[7] = nums[7] = 7nums[r] = nums[pivot] = nums[7] = nums[7] = 7[2, 8, 4, 1, 3, 5, 6, 7]i = l - 1 = 0 - 1 = -1j = 0num[0] = 2 &lt; num[7] = 7i = i + 1 = 0nums[j] = nums[i] = nums[0] = nums[0] = 2 nums[i] = nums[j] = nums[0] = nums[0] = 2 [2, 8, 4, 1, 3, 5, 6, 7]j = 1nums[1] = 8 &gt; num[7] = 7j = 2nums[2] = 4 &lt; num[7] = 7i = i + 1 = 1nums[j] = nums[i] = nums[2] = nums[1] = 8 nums[i] = nums[j] = nums[1] = nums[2] = 4 [2, 4, 8, 1, 3, 5, 6, 7]j = 3nums[3] = 1 &lt; num[7] = 7i = i + 1 = 2nums[j] = nums[i] = nums[3] = nums[2] = 8 nums[i] = nums[j] = nums[2] = nums[3] = 1 [2, 4, 1, 8, 3, 5, 6, 7]j = 4nums[4] = 3 &lt; num[7] = 7i = i + 1 = 3nums[j] = nums[i] = nums[4] = nums[3] = 8 nums[i] = nums[j] = nums[3] = nums[4] = 3 [2, 4, 1, 3, 8, 5, 6, 7]j = 5nums[5] = 5 &lt; num[7] = 7i = i + 1 = 4nums[j] = nums[i] = nums[5] = nums[4] = 8 nums[i] = nums[j] = nums[4] = nums[5] = 5 [2, 4, 1, 3, 5, 8, 6, 7]j = 6nums[6] = 6 &lt; num[7] = 7i = i + 1 = 5nums[j] = nums[i] = nums[6] = nums[5] = 8 nums[i] = nums[j] = nums[5] = nums[6] = 6 [2, 4, 1, 3, 5, 6, 8, 7]i = i + 1 = 6nums[i] = nums[r] = nums[6] = nums[7] = 8 nums[r] = nums[i] = nums[7] = nums[1] = 7 [2, 4, 1, 3, 5, 6, 7, 8]切分元素 nums[pivot] = 7 交换到它排序以后最终确定的位置上return i = 6mid = i = 6 ，则原来下标为7的元素7的位置确定在下标6self.randomized_quicksort(nums, l, mid - 1)self.randomized_quicksort(nums, 0, 6 - 1)self.randomized_quicksort(nums, 0, 5)\n\n\n各种排序的复杂度对比：\n\n算法执行的时间：\n\n排序的内存使用：\n148. 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n示例 1:\n12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4\n示例 2:\n12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5\n\n解答一：归并排序 递归的向下递推过程实际上是在切分链表。\n\n题目要求时间空间复杂度分别为O(nlogn)和O(1)，根据时间复杂度我们自然想到二分法，从而联想到归并排序；\n\n对数组做归并排序的空间复杂度为 O(n)，分别由新开辟数组O(n)和递归函数调用O(logn)组成，而根据链表特性：\n\n数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；\n递归额外空间：递归调用函数将带来O(logn)的空间复杂度，因此若希望达到O(1)空间复杂度，则不能使用递归。二分是二叉树状结构，深度为 log N ~切分链表时向下“二分”，因此递归树的高度是 O(log n) ，每层都需遍历整个链表，占用 O(n) ，因此总体为 O(n log n) ~\n\n\n\n每次找到中间节点的时间复杂度度是n,排序也是n,但是他们是在一个函数前后执行的还是n,复杂度线性累加 还是原复杂度，只有内外嵌套才会升级为 N^2 ~\n\n通过递归实现链表归并排序，有以下两个环节：\n分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；\n我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。\n找到中点 slow 后，执行 slow.next = None 将链表切断。\n递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 mid(因为链表是从 slow 切断的)。\ncut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。\n\n\n合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。\n双指针法合并，建立辅助ListNode h 作为头部。\n设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。\n返回辅助ListNode h 作为头部的下个节点 h.next。\n时间复杂度 O(l + r)，l, r 分别代表两个链表长度。\n\n\n当题目输入的 head == None 时，直接返回None。\n\n\n\n1234567891011121314151617181920212223242526272829303132333435class Solution:    def sortList(self, head: ListNode) -&gt; ListNode:        # 递归结束条件        # 当题目输入的 head == None 时，直接返回None。        # 当head.next == None时，说明只有一个节点了，直接返回此节点。        if not head or not head.next:             return head # termination.        # cut the LinkedList at the mid index.        # 每次慢指针+1，快指针都相当于+2，        # 所以当快指针到终点，慢指针到达中点        slow, fast = head, head.next        while fast and fast.next:  # 快            fast, slow = fast.next.next, slow.next        mid, slow.next = slow.next, None # save and cut.        # recursive for cutting.        # left, right 分别指向两链表头部，比较两指针处节点值大小，        left, right = self.sortList(head), self.sortList(mid)        # merge `left` and `right` linked list and return it.        # res 是新建listNode，可以理解为新建一个头结点保留头指针，未创建新的链表，只是修改了原链表的节点指向，res指向的是h指针，这个h就是dummy亚指针，并不是合并后的头结点，而是它的前一个节点        # 因为原头指针 h 在合并排序链表的时候会变化        h = res = ListNode(0)        while left and right:            if left.val &lt; right.val:                h.next, left = left, left.next            else:                h.next, right = right, right.next            h = h.next        #  前面while排序后, 如果左右子链表长度相同 ，        # left和right都应该指向了左右子链表的最后一个node.next都是None        # 但实际上长度可能不同，比如总长为 7 的链表，        # 只能被分为7 = 3+4, 3 = 1+2……        # 此时就需要把没走完的链表再加到尾部了。        h.next = left if left else right        # h.next = left or right 更加 pythonic        return res.next  class Solution:    def sortList(self, head: ListNode) -&gt; ListNode:        # 递归结束条件        # 当题目输入的 head == None 时，直接返回None。        # 当head.next == None时，说明只有一个节点了，直接返回此节点。        if not head or not head.next:             return head # termination.        # cut the LinkedList at the mid index.        # 每次慢指针+1，快指针都相当于+2，        # 所以当快指针到终点，慢指针到达中点        slow, fast = head, head.next        while fast and fast.next:  # 快            fast, slow = fast.next.next, slow.next        mid, slow.next = slow.next, None # save and cut.        # recursive for cutting.        # left, right 分别指向两链表头部，比较两指针处节点值大小，        left, right = self.sortList(head), self.sortList(mid)        # merge `left` and `right` linked list and return it.        # res 是新建listNode，可以理解为新建一个头结点保留头指针，未创建新的链表，只是修改了原链表的节点指向，res指向的是h指针，这个h就是dummy亚指针，并不是合并后的头结点，而是它的前一个节点        # 因为原头指针 h 在合并排序链表的时候会变化        h = res = ListNode(0)        while left and right:            if left.val &lt; right.val:                h.next, left = left, left.next            else:                h.next, right = right, right.next            h = h.next        #  前面while排序后, 如果左右子链表长度相同 ，        # left和right都应该指向了左右子链表的最后一个node.next都是None        # 但实际上长度可能不同，比如总长为 7 的链表，        # 只能被分为7 = 3+4, 3 = 1+2……        # 此时就需要把没走完的链表再加到尾部了。        h.next = left if left else right        # h.next = left or right 更加 pythonic        return res.next  # 保存归并的结果的\n\n在 cut 到链表长度为 2 时，如果 fast, slow 都指向头部 head ，那么fast会走两步，slow走一步，cut点是不对的。 如果fast先走一步到 head.next ，就会避免长度为 2 时出现的特殊错误情况。[3, 2]slow = = head = 3fast = = head.next = 2fast.next = None不进入循环mid = slow.next = 3slow.next = None [3 | 2]\n如果初始化时令fast=head，slow=headslow = head = 3fast.next != None进入循环\nslow = slow.next = 2fast = fast.next.next =Nonemid = slow.next = Noneslow.next = None \n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778793 2 4 6slow = 3fast = 2slow = 2fast = 6  mid = 4 slow.next = None 切断  [3, 2 | 4, 6]left = self.sortList(head)  [3, 2]slow = 3fast = 2fast.next = None 不进入循环mid = slow.next = 2slow.next = None    [3 | 2]left = self.sortList(head)head = 3head.next = Nonereturn head left = 3right = self.sortList(mid)head = 2head.next = Nonereturn head right = 2独立的 3 和 2 合并3 &gt; 2h.next = right = 2right = right.next = Noneh = h.next = 2跳出循环h.next = left = 3---right = self.sortList(mid)  [4, 6]slow = 4fast = 6fast.next = None 不进入循环mid = slow.next = 6slow.next = None    [4 | 6]left = self.sortList(head) head = 4head.next = Nonereturn head left = 4right = self.sortList(mid)head = 6head.next = Nonereturn head right = 6独立的 4 和 6 合并4 &lt; 6          h.next = left = 4left = left.next = None h = h.next = 4跳出循环h.next = left = 6---独立的 [2, 3] 和 [4, 6] 合并2 &lt; 4         h.next = left = 2left = left.next = 3h = h.next = 2再循环3 &lt; 4h.next = left = 3left = left.next = Noneh = h.next = 3h.next = right = 4 right只是链表的头节点，会指向后面排序好的节点6h指向2 3 4 63 2 4 6slow = 3fast = 2slow = 2fast = 6  mid = 4 slow.next = None 切断  [3, 2 | 4, 6]left = self.sortList(head)  [3, 2]slow = 3fast = 2fast.next = None 不进入循环mid = slow.next = 2slow.next = None    [3 | 2]left = self.sortList(head)head = 3head.next = Nonereturn head left = 3right = self.sortList(mid)head = 2head.next = Nonereturn head right = 2独立的 3 和 2 合并3 &gt; 2h.next = right = 2right = right.next = Noneh = h.next = 2跳出循环h.next = left = 3---right = self.sortList(mid)  [4, 6]slow = 4fast = 6fast.next = None 不进入循环mid = slow.next = 6slow.next = None    [4 | 6]left = self.sortList(head) head = 4head.next = Nonereturn head left = 4right = self.sortList(mid)head = 6head.next = Nonereturn head right = 6独立的 4 和 6 合并4 &lt; 6          h.next = left = 4left = left.next = None h = h.next = 4跳出循环h.next = left = 6---独立的 [2, 3] 和 [4, 6] 合并2 &lt; 4         h.next = left = 2left = left.next = 3h = h.next = 2再循环3 &lt; 4h.next = left = 3left = left.next = Noneh = h.next = 3h.next = right = 4 right只是链表的头节点，会指向后面排序好的节点6h指向2 3 4 6，ok\n\n一次方法的调用和返回代表着一个栈帧的入栈和出栈，栈帧出栈后，该栈帧中的临时变量所占用的空间都会得到释放。 对于数组的归并排序之所以空间复杂度是O(n)，是因为数组归并排序使用了一个创建了一个辅助数组。这里每个栈帧创建的只是辅助节点，出栈后就释放了。空间复杂度应该是O(1)若算法执行所需要的辅助空间相对于输入数据n而言是一个常数，则称这个算法空间复杂度辅助空间为o（1）；递归算法空间复杂度：递归深度n*每次递归所要的辅助空间，如果每次递归所需要的辅助空间为常数，则递归空间复杂度o（n）。\n递归栈的空间复杂度和递归函数调用的 深度 有关（即在某时刻有多少个递归函数 “尚未返回”）。在返回后，系统会释放栈空间的。递归调用次数多，空间复杂度不一定更高~\n偶數個數的時候 mid 有偏左和偏右兩個。如果直接從 fast 開始，slow 永遠會走到偏右的那個，會進入無窮迴圈。所以我們要的是偏左那個 mid，一開始要先多走一步如果不令fast初始化为head.next，则在链表长度n为偶数的情况下返回第n/2 + 1个数，题意需要的是第n/2个数因为起点一样的话,拆分到只剩两个节点的时候,这两个节点永远拆分不开\n\n法二：归并排序（从底至顶直接合并）\n\n\n对于非递归的归并排序，需要使用迭代的方式替换cut环节：\n\n我们知道，cut环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。\n每一轮合并merge操作针对的单元都有固定长度intv，例如：\n第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。\n第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。\n以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。\n\n\n据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如:\n当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。\n\n当intv = 2时，将链表第1-2和第3-4节点排序合并（第一组小片段），第5-6和第7-8节点排序合并（第二组小片段），……。，\n\n当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。\n\n\n\n\n\n此方法时间复杂度O(nlogn)，空间复杂度O(1)。\n\n模拟上述的多轮排序合并：\n\n统计链表长度length，用于通过判断intv &lt; length判定是否完成排序；\n额外声明一个节点root，作为头部后面接整个链表，用于：\nintv *= 2即切换到下一轮合并时，可通过root.next找到链表头部cur；\n执行排序合并时，需要一个辅助节点作为头部，而root则作为链表头部排序合并时的辅助头部merge_point；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。\n\n\n在每轮intv下的合并流程：\n根据intv找到合并单元1和单元2的头部h1, h2。由于链表长度可能不是2^n，需要考虑边界条件：\n在找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并；\n若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为len2 = intv - intv_residue_2。\n\n\n合并长度为len1, len2的h1, h2链表，其中：\n合并完后，需要修改新的合并单元的尾部merge_point指针指向下一个合并单元头部current。（在寻找h1, h2环节中，current指针已经被移动到下一个单元头部）\n合并单元尾部同时也作为下次合并的辅助头部merge_point。\n\n\n当current == None，代表此轮intv合并完成，跳出。\n\n\n每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution:    def sortList(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        cur, length = head, 0        #  遍历链表求长度，时间复杂度就是On了,        #  O(nlogn)复杂度高于线性低于平方,所以有个O(n)没关系        while cur:            cur, length = cur.next, length + 1        root = ListNode(0)        root.next = head        intv = 1  # 每次合并的规模        # 根据不同的链表切片规模，每一次都从头进行归并        while intv &lt; length:            merge_point, current = root, root.next            while current:  # 根据当前的合并规模，将链表内的链表切片两两归并                # 获取当前需要归并的子链表 h1                h1, intv_residue_1 = current, intv                while intv_residue_1 and current:                    current, intv_residue_1 = current.next, intv_residue_1 - 1                if intv_residue_1:                    # h2 在这种情况下不存在，所以本轮不需要合并                    break                # 获取当前需要归并的子链表 h2                h2, intv_residue_2 = current, intv                while intv_residue_2 and current:                    current, intv_residue_2 = current.next, intv_residue_2 - 1                # len2 的长度可能比 intv 小                len1, len2 = intv, intv - intv_residue_2                # 归并排序                # len1或len2一定有一个是等于0的，链接剩下的被切割剩下的一个链表                while len1 and len2:                    if h1.val &lt; h2.val:                        merge_point.next, h1, len1 = h1, h1.next, len1 - 1                    else:                        merge_point.next, h2, len2 = h2, h2.next, len2 - 1                    merge_point = merge_point.next                # 归并排序处理一下没有被归并的剩余值                if len1:                    merge_point.next = h1                else:                    merge_point.next = h2                # merge_point.next=h1 or h2 只是完成了第一组内部小片段最后一个节点的连接，例如此时 h1 = 2, h2 = 3，把2 和 3 连上                 # merge_point指向的元素不一定是当前链表切片的末尾                # merge_point还应该继续后移，直到指向当前链表切片末尾（即下一次链表切片的开头）                while len1 &gt; 0 or len2 &gt; 0:                    merge_point, len1, len2 = merge_point.next, len1 - 1, len2 - 1                # 把归并后的链表切片第一小组片段尾跟原链表h2之第二小组的头拼起来                # 一次合并后有可能最后一个结点顺序被打乱而不是下一次合并的起点                # [2 3] 要连上 还未排序的[4 6]                merge_point.next = current            intv *= 2        class Solution:    def sortList(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        cur, length = head, 0        #  遍历链表求长度，时间复杂度就是On了,        #  O(nlogn)复杂度高于线性低于平方,所以有个O(n)没关系        while cur:            cur, length = cur.next, length + 1        root = ListNode(0)        root.next = head        intv = 1  # 每次合并的规模        # 根据不同的链表切片规模，每一次都从头进行归并        while intv &lt; length:            merge_point, current = root, root.next            while current:  # 根据当前的合并规模，将链表内的链表切片两两归并                # 获取当前需要归并的子链表 h1                h1, intv_residue_1 = current, intv                while intv_residue_1 and current:                    current, intv_residue_1 = current.next, intv_residue_1 - 1                if intv_residue_1:                    # h2 在这种情况下不存在，所以本轮不需要合并                    break                # 获取当前需要归并的子链表 h2                h2, intv_residue_2 = current, intv                while intv_residue_2 and current:                    current, intv_residue_2 = current.next, intv_residue_2 - 1                # len2 的长度可能比 intv 小                len1, len2 = intv, intv - intv_residue_2                # 归并排序                # len1或len2一定有一个是等于0的，链接剩下的被切割剩下的一个链表                while len1 and len2:                    if h1.val &lt; h2.val:                        merge_point.next, h1, len1 = h1, h1.next, len1 - 1                    else:                        merge_point.next, h2, len2 = h2, h2.next, len2 - 1                    merge_point = merge_point.next                # 归并排序处理一下没有被归并的剩余值                if len1:                    merge_point.next = h1                else:                    merge_point.next = h2                # merge_point.next=h1 or h2 只是完成了第一组内部小片段最后一个节点的连接，例如此时 h1 = 2, h2 = 3，把2 和 3 连上                 # merge_point指向的元素不一定是当前链表切片的末尾                # merge_point还应该继续后移，直到指向当前链表切片末尾（即下一次链表切片的开头）                while len1 &gt; 0 or len2 &gt; 0:                    merge_point, len1, len2 = merge_point.next, len1 - 1, len2 - 1                # 把归并后的链表切片第一小组片段尾跟原链表h2之第二小组的头拼起来                # 一次合并后有可能最后一个结点顺序被打乱而不是下一次合并的起点                # [2 3] 要连上 还未排序的[4 6]                merge_point.next = current            intv *= 2        return root.next\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361373 2 4 6current = 3length = 0进入循环current = current.next = 2length = 1current = current.next = 4length = 2current = current.next = 6length = 3current = current.next = Nonelength = 4退出循环root.next = headintv = 1  intv = 1 &lt; length = 4merge_point = root current = root.next = head = 3进入循环h1 = current = 3intv_residue_1 = intv = 1进入子循环current = current.next = 2intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 2intv_residue_2 = intv = 1进入子循环                    current = current.next = 4intv_residue_2 = intv_residue_2 - 1 = 0退出子循环len1 = intv = 1len2 = intv - intv_residue_2 = 1  进入子循环3 &gt; 2merge_point.next = h2 = 2h2 = h2.next = 4len2 = len2 - 1 = 0merge_point = merge_point.next = 2跳出子循环merge_point.next = h1 = 3  merge_point = merge_point.next = 3len1 = len1 - 1 = 0len2 = len2 - 1 = -1merge_point.next = current = 4h1 = current = 4intv_residue_1 = intv = 1进入子循环current = current.next = 6intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 6intv_residue_2 = intv = 1进入子循环                    current = current.next = Noneintv_residue_2 = intv_residue_2 - 1 = 0退出子循环len1 = intv = 1len2 = intv - intv_residue_2 = 1进入子循环4 &lt; 6merge_point.next = h1 = 4h1 = h1.next = 6len1 = len1 - 1 = 0merge_point = merge_point.next = 4跳出循环merge_point.next = h2 = 6merge_point = merge_point.next = 6len1 = len1 - 1 = -1len2 = len2 - 1 = 0merge_point.next = current = Noneintv = intv * 2 =  2merge_point = rootcurrent = root.next = head = 2进入循环h1 = current = 2intv_residue_1 = intv = 2进入子循环current = current.next = 3intv_residue_1 = intv_residue_1 - 1 = 1再循环current = current.next = 4intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 4intv_residue_2 = intv = 2进入子循环                    current = current.next = 6intv_residue_2 = intv_residue_2 - 1 = 1退出子循环len1 = intv = 2len2 = intv - intv_residue_2 = 1进入子循环2 &lt; 4merge_point.next = h1 = 2h1 = h1.next = 3 len1 = len1 - 1 = 1merge_point = merge_point.next = 23 &lt; 4merge_point.next = h1 = 3h1 = h1.next = 4 len1 = len1 - 1 = 0merge_point = merge_point.next = 3merge_point.next = h2 = 4merge_point = merge_point.next = 4len1 = len1 - 1 = -1len2 = len2 - 1 = 0merge_point.next = current = 6intv = intv * 2 = 3 2 4 6current = 3length = 0进入循环current = current.next = 2length = 1current = current.next = 4length = 2current = current.next = 6length = 3current = current.next = Nonelength = 4退出循环root.next = headintv = 1  intv = 1 &lt; length = 4merge_point = root current = root.next = head = 3进入循环h1 = current = 3intv_residue_1 = intv = 1进入子循环current = current.next = 2intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 2intv_residue_2 = intv = 1进入子循环                    current = current.next = 4intv_residue_2 = intv_residue_2 - 1 = 0退出子循环len1 = intv = 1len2 = intv - intv_residue_2 = 1  进入子循环3 &gt; 2merge_point.next = h2 = 2h2 = h2.next = 4len2 = len2 - 1 = 0merge_point = merge_point.next = 2跳出子循环merge_point.next = h1 = 3  merge_point = merge_point.next = 3len1 = len1 - 1 = 0len2 = len2 - 1 = -1merge_point.next = current = 4h1 = current = 4intv_residue_1 = intv = 1进入子循环current = current.next = 6intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 6intv_residue_2 = intv = 1进入子循环                    current = current.next = Noneintv_residue_2 = intv_residue_2 - 1 = 0退出子循环len1 = intv = 1len2 = intv - intv_residue_2 = 1进入子循环4 &lt; 6merge_point.next = h1 = 4h1 = h1.next = 6len1 = len1 - 1 = 0merge_point = merge_point.next = 4跳出循环merge_point.next = h2 = 6merge_point = merge_point.next = 6len1 = len1 - 1 = -1len2 = len2 - 1 = 0merge_point.next = current = Noneintv = intv * 2 =  2merge_point = rootcurrent = root.next = head = 2进入循环h1 = current = 2intv_residue_1 = intv = 2进入子循环current = current.next = 3intv_residue_1 = intv_residue_1 - 1 = 1再循环current = current.next = 4intv_residue_1 = intv_residue_1 - 1 = 0退出子循环h2 = current = 4intv_residue_2 = intv = 2进入子循环                    current = current.next = 6intv_residue_2 = intv_residue_2 - 1 = 1退出子循环len1 = intv = 2len2 = intv - intv_residue_2 = 1进入子循环2 &lt; 4merge_point.next = h1 = 2h1 = h1.next = 3 len1 = len1 - 1 = 1merge_point = merge_point.next = 23 &lt; 4merge_point.next = h1 = 3h1 = h1.next = 4 len1 = len1 - 1 = 0merge_point = merge_point.next = 3merge_point.next = h2 = 4merge_point = merge_point.next = 4len1 = len1 - 1 = -1len2 = len2 - 1 = 0merge_point.next = current = 6intv = intv * 2 = 4 = length 跳出循环\nroot.next = head不写成root = headhead指向的头节点在排序过程中是变化的顺序可能会被打乱，比如 4，3，2，1第一次完成后变为3，4，1，2，此时head指向了第二个节点，就不是头节点了，而dummy.next始终会指向每次归并完之后的新头节点，我觉得可以参照代码手推下更好理解了\n\n堆(Heap)是计算机科学中一类特殊的数据结构的统称，一般讨论的堆都是二叉堆。堆满足下列性质：\n\n堆中某个节点的值或索引总是不大于或不小于其父节点的值或索引。\n堆总是一棵完全二叉树，且该完全二叉树的深度为 k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边。\n\n把堆看作原生的Python list，数组的下标对应堆中节点的编号我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，heap[0] 表示访问最小的元素总是在根结点而不弹出它。，同时 heap.sort() 维护了堆的不变性！\n堆排序：利用堆的概念来排序的选择排序。先将待排序的序列建成分为两种：\n大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n−1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。\n小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\nPython 里的 heapq 模块python3标准库中提供了heapq，使用原地算法得到对小顶堆进行操作提供了堆队列算法的实现，也称为优先队列算法。一般我们刷题或者写业务代码的时候，使用这个内置的 heapq 模块就够用了\n实现 大顶堆 方法：小顶堆的插入和弹出操作均将元素 取反小顶堆[1,2,3]堆顶是1，如果想让3在堆顶的话，就只能是[-3,-2,-1]，堆顶是-3，然后每次heappop取出时，-3加上负号就变成3了，变相实现大顶堆\n1231          -3  /  \\       /  \\ 2    3     -2  1          -3  /  \\       /  \\ 2    3     -2  -1\n\n\nshift up ：如何向一个最大堆中添加元素\nshift down 如何从一个最大堆中取出一个元素，只能取出最大优先级的元素，也就是根节点，\n\n123456789101112131415161718192021222324252627282930313233343536373839404142              62            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 16把原来的 62 取出后，            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 16将数组最后一位数组放到根节点，此时不满足最大堆的定义。              16            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 调整的过程是将这个根节点 16 一步一步向下挪，16 比子节点都小，先比较子节点 52 和 30 哪个大，和大的交换位置。              52            /     \\           16      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 继续比较 16 的子节点 28 和 41，41 大，所以 16 和 41 交换位置。              52            /     \\           41      30         /   \\     / \\        28    16  22  13       /  \\      / \\      19  17 15 继续 16 和孩子节点 15 进行比较，              62            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 16把原来的 62 取出后，            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 16将数组最后一位数组放到根节点，此时不满足最大堆的定义。              16            /     \\           52      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 调整的过程是将这个根节点 16 一步一步向下挪，16 比子节点都小，先比较子节点 52 和 30 哪个大，和大的交换位置。              52            /     \\           16      30         /   \\     / \\        28    41  22  13       /  \\      / \\      19  17 15 继续比较 16 的子节点 28 和 41，41 大，所以 16 和 41 交换位置。              52            /     \\           41      30         /   \\     / \\        28    16  22  13       /  \\      / \\      19  17 15 继续 16 和孩子节点 15 进行比较，16 大，所以现在不需要进行交换，最后我们的 shift down 操作完成，维持了一个最大堆的性质。\n\n\n要创建一个堆 \n\n或者 heapq.heapify(list) ，将列表list原地转换成为最小二叉堆列表，具备最小堆特征 线性时间内，算法时间复杂度为 O(n)。Transform list x into a heap, in-place, in linear time.\n12345678910111213heap2 = [5, 8, 0, 3, 6, 7, 9, 1, 4, 2]heapq.heapify(heap2)print(heap2)# [0, 1, 5, 3, 2, 7, 9, 8, 4, 6]'''            0          /   \\         1     5        / \\   / \\       3   2  7  9      / \\ / \\     8  4 6heap2 = [5, 8, 0, 3, 6, 7, 9, 1, 4, 2]heapq.heapify(heap2)print(heap2)# [0, 1, 5, 3, 2, 7, 9, 8, 4, 6]'''            0          /   \\         1     5        / \\   / \\       3   2  7  9      / \\ / \\     8  4 6'''\n\n可以使用list来初始化为 []heapq.heappush(heap, item)将 item 的值加入 heap 中，保持堆的不变性。push后堆也应该是一棵完全二叉树，所以必须将元素追加到数组末尾\n\n\nheapq.heappop(heap)弹出并返回 heap 的最小的元素，保持堆的不变性。如果堆为空，抛出 IndexError 。\nheapq.heappushpop(heap, item)将 item 放入堆中，然后弹出并返回 heap 的最小元素。该组合操作比先调用  heappush() 再调用 heappop() 运行起来更有效率。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123从 iterable 所定义的数据集中返回前 n 个最小元素组成的列表。 如果提供了 key 则其应指定一个单参数的函数，用于从 iterable 的每个元素中提取比较键 (例如 key=str.lower)。 等价于: sorted(iterable, key=key)[:n]。。堆排序的原理是通过不断 交换元素 实现排序的：在数组中交换两个索引的元素时间复杂度为 O(1)，而链表 交换元素 本身是 O(N) 时间复杂度，若可以把此问题解决就可以用堆排。时间复杂度：O(nlogn)。初始化建堆的时间复杂度为 O(n)，建完堆以后需要进行 n-1 次调整，一次调整（即 maxHeapify） 的时间复杂度为 O(logn)，那么 n−1 次调整即需要 O(nlogn) 的时间复杂度。因此，总时间复杂度为 O(n+nlogn)=O(nlogn)。空间复杂度：O(1)。给一个未排序的数组arr，堆排序就地排序，不借用额外空间，仅在arr上调整元素位置完成排序。如果把原数组arr算上就是O(N)，但一般只计算使用到的额外空间，只需要常数的空间存放若干变量。```pyimport heapqdata = [3, 2, 6, 1]heap1 = []# 使用heapq库的heappush函数将数据堆入for i in data:    heapq.heappush(heap1, i)  # 数据堆入print(heap1)  # [1, 2, 6, 3]'''            1           /  \\          2    6         / \\  / \\        3'''heapq.heappush(heap1, 5)print(heap1)  # [1, 2, 6, 3, 5]'''            1           /  \\          2    6         / \\  / \\        3  5将元素追加到数组末尾，符合最小堆的规律        '''heapq.heappush(heap1, 0.5)print(heap1)# [0.5, 2, 1, 3, 5, 6]'''            1           /  \\          2    6         / \\  / \\        3  5 0.5将元素追加到数组末尾，不符合最小堆的规律，需要调整            1           /  \\          2    0.5         / \\  / \\        3  5 6            0.5           /  \\          2    1         / \\  / \\        3  5 6'''print(heapq.heappop(heap1))  # 0.5 将数组堆中的最小元素弹出print(heap1)  # [1, 2, 6, 3, 5]'''            0.5           /  \\          2    1         / \\  / \\        3  5 6第一步，先将根节点与编号最大节点的元素互换，并删除编号最大的节点。           /  \\          2    1         / \\  / \\        3  5 6            6           /  \\          2    1         / \\  / \\        3  5 此时堆仍然是一棵完全二叉树，但有可能不满足堆的性质一。所以我们需要对根节点的元素进行下沉操作，以大顶堆为例，设置一个游标 id, 初始指向根节点：如果id指向叶子节点，算法结束。如果id指向节点小于其左右子节点的值，算法结束。设id的左右子节点中，拥有较小值的编号为 p，交换 id 与 p 的值，并将 id 指向 p 节点。跳转步骤 1            1           /  \\          2    6         / \\  / \\        3  5 '''print(heapq.heappop(heap1))  # 1 将数组堆中的最小元素弹出print(heap1)  # [2, 3, 6, 5]'''            1           /  \\          2    6         / \\  / \\        3  5            /  \\          2    6         / \\  / \\        3  5             5           /  \\          2    6         / \\  / \\        3             2           /  \\          5    6         / \\  / \\        3              2           /  \\          3    6         / \\  / \\        5  '''\n\n\n12345678910111213141516171819202122232425262728class Solution:    def max_heapify(self, heap, root, heap_len):        p = root        while p * 2 + 1 &lt; heap_len:            l, r = p * 2 + 1, p * 2 + 2            if heap_len &lt;= r or heap[r] &lt; heap[l]:                nex = l            else:                nex = r            if heap[p] &lt; heap[nex]:                heap[p], heap[nex] = heap[nex], heap[p]                p = nex            else:                break            def build_heap(self, heap):        for i in range(len(heap) - 1, -1, -1):            self.max_heapify(heap, i, len(heap))    def heap_sort(self, nums):        self.build_heap(nums)        for i in range(len(nums) - 1, -1, -1):            nums[i], nums[0] = nums[0], nums[i]            self.max_heapify(nums, 0, i)                def sortArray(self, nums: List[int]) -&gt; List[int]:        self.heap_sort(nums)        class Solution:    def max_heapify(self, heap, root, heap_len):        p = root        while p * 2 + 1 &lt; heap_len:            l, r = p * 2 + 1, p * 2 + 2            if heap_len &lt;= r or heap[r] &lt; heap[l]:                nex = l            else:                nex = r            if heap[p] &lt; heap[nex]:                heap[p], heap[nex] = heap[nex], heap[p]                p = nex            else:                break            def build_heap(self, heap):        for i in range(len(heap) - 1, -1, -1):            self.max_heapify(heap, i, len(heap))    def heap_sort(self, nums):        self.build_heap(nums)        for i in range(len(nums) - 1, -1, -1):            nums[i], nums[0] = nums[0], nums[i]            self.max_heapify(nums, 0, i)                def sortArray(self, nums: List[int]) -&gt; List[int]:        self.heap_sort(nums)        return nums\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163[4, 6, 8, 5, 9]heap_sort(self, nums):self.build_heap(nums)    for i in range(len(heap) - 1, -1, -1):    for i in range(5 - 1, -1, -1):    i = 4    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 4, 5)    p = root = 4        p * 2 + 1 = 9 &gt; heap_len = 5        不进入循环        i = 3    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 3, 5)    p = root = 3        p * 2 + 1 = 7 &gt; heap_len = 5        不进入循环    i = 2    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 2, 5)    p = root = 2        p * 2 + 1 = 5 = heap_len = 5        不进入循环        i = 1    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 1, 5)    p = root = 1        p * 2 + 1 = 3 &lt; heap_len = 5        [4, 6, 8, 5, 9]        l = p * 2 + 1 = 1 * 2 + 1 = 3        r = p * 2 + 2 = 1 * 2 + 2 = 4        heap_len = 5 &gt; r = 4         heap[r] = heap[4] = 9 &gt; heap[l] = heap[3] = 5        nex = r = 4        heap[p] = heap[1] = 6 &lt; heap[nex] = heap[4] = 9:        heap[p] = heap[nex] = heap[1] = heap[4] = 9        heap[nex] = heap[p] = heap[4] = heap[1] = 6        [4, 9, 8, 5, 6]        p = nex = 4        p * 2 + 1 = 9 &gt; heap_len = 5    i = 0    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 0, 5)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 5        l = p * 2 + 1 = 1 * 2 + 1 = 1        r = p * 2 + 2 = 1 * 2 + 2 = 2        heap_len = 5 &gt; r = 2         heap[r] = heap[2] = 8 &lt; heap[l] = heap[1] = 9        nex = l = 1        heap[p] = heap[0] = 4 &lt; heap[nex] = heap[1] = 9        heap[p] = heap[nex] = heap[0] = heap[1] = 9        heap[nex] = heap[p] = heap[1] = heap[0] = 4        [9, 4, 8, 5, 6]        p = nex = 1        p * 2 + 1 = 3 &lt; heap_len = 5        再循环        l = p * 2 + 1 = 1 * 2 + 1 = 3        r = p * 2 + 2 = 1 * 2 + 2 = 4        heap_len = 5 &gt; r = 4         heap[r] = heap[4] = 6 &gt; heap[l] = heap[3] = 5        nex = r = 4        heap[p] = heap[1] = 4 &lt; heap[nex] = heap[4] = 6:        heap[p] = heap[nex] = heap[1] = heap[4] = 6        heap[nex] = heap[p] = heap[4] = heap[1] = 4        [9, 6, 8, 5, 4]        p = nex = 4        p * 2 + 1 = 9 &gt; heap_len = 5        退出循环    for i in range(len(nums) - 1, -1, -1):for i in range(5 - 1, -1, -1):for i in range(4, -1, -1):    i = 4    nums[4] = nums[0] = 9    nums[0] = nums[i] = 4    [4, 6, 8, 5, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 4)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 4        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 4 &gt; r = 2         heap[r] = heap[2] = 8 &gt; heap[l] = heap[1] = 6        nex = r = 2        heap[p] = heap[0] = 4 &lt; heap[nex] = heap[2] = 8        heap[p] = heap[nex] = heap[0] = heap[2] = 8        heap[nex] = heap[p] = heap[2] = heap[0] = 4        [8, 6, 4, 5, 9]        p = nex = 2        p * 2 + 1 = 5 &gt; heap_len = 4    i = 3    nums[i] = nums[3] = nums[0] = 8    nums[0] = nums[i] = nums[3] = 5    [5, 6, 4, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 3)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 3        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 3 &gt; r = 2         heap[r] = heap[2] = 4 &lt; heap[l] = heap[1] = 6        nex = l = 1         heap[p] = heap[0] = 5 &lt; heap[nex] = heap[1] = 6        heap[p] = heap[nex] = heap[0] = heap[1] = 6        heap[nex] = heap[p] = heap[1] = heap[0] = 5        [6, 5, 4, 8, 9]        p = nex = 1        p * 2 + 1 = 3 = heap_len = 3    i = 2    nums[i] = nums[2] = nums[0] = 6    nums[0] = nums[i] = nums[2] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 2)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 2        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 2 = r = 2         heap[r] = heap[2] = 6 &gt; heap[l] = heap[1] = 6        nex = l = 1         heap[p] = heap[0] = 4 &lt; heap[nex] = heap[1] = 5        heap[p] = heap[nex] = heap[0] = heap[1] = 5        heap[nex] = heap[p] = heap[1] = heap[0] = 4        [5, 4, 6, 8, 9]        p = nex = 1         p * 2 + 1 = 3 &gt; heap_len = 2        i = 1    nums[i] = nums[1] = nums[0] = 5    nums[0] = nums[i] = nums[1] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 1)    p = root = 0        p * 2 + 1 = 1 = heap_len = 1        i = 0    nums[i] = nums[0] = nums[0] = 4    nums[0] = nums[i] = nums[0] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 0)    p = root = 0        p * 2 + 1 = 1 &gt; heap_len = 0[4, 6, 8, 5, 9]heap_sort(self, nums):self.build_heap(nums)    for i in range(len(heap) - 1, -1, -1):    for i in range(5 - 1, -1, -1):    i = 4    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 4, 5)    p = root = 4        p * 2 + 1 = 9 &gt; heap_len = 5        不进入循环        i = 3    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 3, 5)    p = root = 3        p * 2 + 1 = 7 &gt; heap_len = 5        不进入循环    i = 2    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 2, 5)    p = root = 2        p * 2 + 1 = 5 = heap_len = 5        不进入循环        i = 1    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 1, 5)    p = root = 1        p * 2 + 1 = 3 &lt; heap_len = 5        [4, 6, 8, 5, 9]        l = p * 2 + 1 = 1 * 2 + 1 = 3        r = p * 2 + 2 = 1 * 2 + 2 = 4        heap_len = 5 &gt; r = 4         heap[r] = heap[4] = 9 &gt; heap[l] = heap[3] = 5        nex = r = 4        heap[p] = heap[1] = 6 &lt; heap[nex] = heap[4] = 9:        heap[p] = heap[nex] = heap[1] = heap[4] = 9        heap[nex] = heap[p] = heap[4] = heap[1] = 6        [4, 9, 8, 5, 6]        p = nex = 4        p * 2 + 1 = 9 &gt; heap_len = 5    i = 0    self.max_heapify(heap, i, len(heap))    self.max_heapify(heap, 0, 5)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 5        l = p * 2 + 1 = 1 * 2 + 1 = 1        r = p * 2 + 2 = 1 * 2 + 2 = 2        heap_len = 5 &gt; r = 2         heap[r] = heap[2] = 8 &lt; heap[l] = heap[1] = 9        nex = l = 1        heap[p] = heap[0] = 4 &lt; heap[nex] = heap[1] = 9        heap[p] = heap[nex] = heap[0] = heap[1] = 9        heap[nex] = heap[p] = heap[1] = heap[0] = 4        [9, 4, 8, 5, 6]        p = nex = 1        p * 2 + 1 = 3 &lt; heap_len = 5        再循环        l = p * 2 + 1 = 1 * 2 + 1 = 3        r = p * 2 + 2 = 1 * 2 + 2 = 4        heap_len = 5 &gt; r = 4         heap[r] = heap[4] = 6 &gt; heap[l] = heap[3] = 5        nex = r = 4        heap[p] = heap[1] = 4 &lt; heap[nex] = heap[4] = 6:        heap[p] = heap[nex] = heap[1] = heap[4] = 6        heap[nex] = heap[p] = heap[4] = heap[1] = 4        [9, 6, 8, 5, 4]        p = nex = 4        p * 2 + 1 = 9 &gt; heap_len = 5        退出循环    for i in range(len(nums) - 1, -1, -1):for i in range(5 - 1, -1, -1):for i in range(4, -1, -1):    i = 4    nums[4] = nums[0] = 9    nums[0] = nums[i] = 4    [4, 6, 8, 5, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 4)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 4        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 4 &gt; r = 2         heap[r] = heap[2] = 8 &gt; heap[l] = heap[1] = 6        nex = r = 2        heap[p] = heap[0] = 4 &lt; heap[nex] = heap[2] = 8        heap[p] = heap[nex] = heap[0] = heap[2] = 8        heap[nex] = heap[p] = heap[2] = heap[0] = 4        [8, 6, 4, 5, 9]        p = nex = 2        p * 2 + 1 = 5 &gt; heap_len = 4    i = 3    nums[i] = nums[3] = nums[0] = 8    nums[0] = nums[i] = nums[3] = 5    [5, 6, 4, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 3)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 3        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 3 &gt; r = 2         heap[r] = heap[2] = 4 &lt; heap[l] = heap[1] = 6        nex = l = 1         heap[p] = heap[0] = 5 &lt; heap[nex] = heap[1] = 6        heap[p] = heap[nex] = heap[0] = heap[1] = 6        heap[nex] = heap[p] = heap[1] = heap[0] = 5        [6, 5, 4, 8, 9]        p = nex = 1        p * 2 + 1 = 3 = heap_len = 3    i = 2    nums[i] = nums[2] = nums[0] = 6    nums[0] = nums[i] = nums[2] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 2)    p = root = 0        p * 2 + 1 = 1 &lt; heap_len = 2        l = p * 2 + 1 = 0 * 2 + 1 = 1        r = p * 2 + 2 = 0 * 2 + 2 = 2        heap_len = 2 = r = 2         heap[r] = heap[2] = 6 &gt; heap[l] = heap[1] = 6        nex = l = 1         heap[p] = heap[0] = 4 &lt; heap[nex] = heap[1] = 5        heap[p] = heap[nex] = heap[0] = heap[1] = 5        heap[nex] = heap[p] = heap[1] = heap[0] = 4        [5, 4, 6, 8, 9]        p = nex = 1         p * 2 + 1 = 3 &gt; heap_len = 2        i = 1    nums[i] = nums[1] = nums[0] = 5    nums[0] = nums[i] = nums[1] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 1)    p = root = 0        p * 2 + 1 = 1 = heap_len = 1        i = 0    nums[i] = nums[0] = nums[0] = 4    nums[0] = nums[i] = nums[0] = 4    [4, 5, 6, 8, 9]    self.max_heapify(nums, 0, i)    self.max_heapify(nums, 0, 0)    p = root = 0        p * 2 + 1 = 1 &gt; heap_len = 0return nums\n\n\n完全二叉树有个重要性质，对于第一个非叶子节点的索引是 n/2 取整数得到的索引值，其中 n 是元素个数(前提是数组索引从 1 开始计算)。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576建立大顶堆    4   /  \\  6    8 / \\  5   96 是第一个非叶子节点，从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作6 和 9 交换位置。满足最大堆的性质。    4   /  \\  9    8 / \\  5   6对根节点4 元素进行 shift down 操作    9   /  \\  4    8 / \\  5   6对6 元素进行 shift down 操作    9   /  \\  6    8 / \\  5   4此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。    4   /  \\  6    8 / \\  5   9    8   /  \\  6    4 / \\  5   9    5   / \\  6   4  / \\  8   9    6   / \\  5   4  / \\  8   9    4   / \\  5   6  / \\  8   9    5   / \\  4   6  / \\  8   9      4   / \\  5   6  / \\  8   建立大顶堆    4   /  \\  6    8 / \\  5   96 是第一个非叶子节点，从它开始逐一向前分别把每个元素作为根节点进行 shift down 操作6 和 9 交换位置。满足最大堆的性质。    4   /  \\  9    8 / \\  5   6对根节点4 元素进行 shift down 操作    9   /  \\  4    8 / \\  5   6对6 元素进行 shift down 操作    9   /  \\  6    8 / \\  5   4此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。    4   /  \\  6    8 / \\  5   9    8   /  \\  6    4 / \\  5   9    5   / \\  6   4  / \\  8   9    6   / \\  5   4  / \\  8   9    4   / \\  5   6  / \\  8   9    5   / \\  4   6  / \\  8   9      4   / \\  5   6  / \\  8   9\n\n法二\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546def heap_sort(nums):    # 调整堆    # 迭代写法    # def adjust_heap(nums, startpos, endpos):    #     newitem = nums[startpos]    #     pos = startpos    #     childpos = pos * 2 + 1    #     while childpos &lt; endpos:    #         rightpos = childpos + 1    #         if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:    #             childpos = rightpos    #         if newitem &lt; nums[childpos]:    #             nums[pos] = nums[childpos]    #             pos = childpos    #             childpos = pos * 2 + 1    #         else:    #             break    #     nums[pos] = newitem    # 递归写法    def adjust_heap(nums, startpos, endpos):        pos = startpos        chilidpos = pos * 2 + 1        if chilidpos &lt; endpos:            rightpos = chilidpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]:                chilidpos = rightpos            if nums[chilidpos] &gt; nums[pos]:                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]                adjust_heap(nums, pos, endpos)    n = len(nums)    # 建堆    for i in reversed(range(n // 2)):        adjust_heap(nums, i, n)    # 调整堆    for i in range(n - 1, -1, -1):        nums[0], nums[i] = nums[i], nums[0]        adjust_heap(nums, 0, i)    return numsalist = [4, 6, 8, 5, 9]heap_sort(alist)print(alist)def heap_sort(nums):    # 调整堆    # 迭代写法    # def adjust_heap(nums, startpos, endpos):    #     newitem = nums[startpos]    #     pos = startpos    #     childpos = pos * 2 + 1    #     while childpos &lt; endpos:    #         rightpos = childpos + 1    #         if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:    #             childpos = rightpos    #         if newitem &lt; nums[childpos]:    #             nums[pos] = nums[childpos]    #             pos = childpos    #             childpos = pos * 2 + 1    #         else:    #             break    #     nums[pos] = newitem    # 递归写法    def adjust_heap(nums, startpos, endpos):        pos = startpos        chilidpos = pos * 2 + 1        if chilidpos &lt; endpos:            rightpos = chilidpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]:                chilidpos = rightpos            if nums[chilidpos] &gt; nums[pos]:                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]                adjust_heap(nums, pos, endpos)    n = len(nums)    # 建堆    for i in reversed(range(n // 2)):        adjust_heap(nums, i, n)    # 调整堆    for i in range(n - 1, -1, -1):        nums[0], nums[i] = nums[i], nums[0]        adjust_heap(nums, 0, i)    return numsalist = [4, 6, 8, 5, 9]heap_sort(alist)print(alist)# [4, 5, 6, 8, 9]\n\nTop K 问题面试题中有这样一类问题，让求出大量数据中的top k 个元素，比如一亿个数字中最大的100个数字。对于这种问题有很多种解法，比如直接排序、mapreduce、trie 树、分治法等，当然如果内存够用直接排序是最简单的。如果内存不够用呢？ 这里我们提一下使用固定大小的堆来解决这个问题的方式。\n一开始的思路可能是，既然求最大的 k 个数，是不是应该维护一个包含 k 个元素的最大堆呢？稍微尝试下你会发现走不通。我们先用数组的前面 k 个元素建立最大堆，然后对剩下的元素进行比对，但是最大堆只能每次获取堆顶最大的一个元素，如果我们取下一个大于堆顶的值和堆顶替换，你会发现堆底部的小数一直不会被换掉。如果下一个元素小于堆顶就替换也不对，这样可能最大的元素就被我们丢掉了。\n相反我们用最小堆呢？先迭代前 k 个元素建立一个最小堆，之后的元素如果小于堆顶最小值，跳过，否则替换堆顶元素并重新调整堆。你会发现最小堆里慢慢就被替换成了最大的那些值，并且最后堆顶是最大的 topk 个值中的最小值。（比如1000个数找10个，最后堆里剩余的是 [990, 991, 992, 996, 994, 993, 997, 998, 999, 995]，第一个 990 最小)\n123456789101112131415161718192021222324252627282930313233343536373839404142434445import heapq class TopK:    '''    获取大量元素 topk 大个元素，固定内存    思路：    1.先放入元素前 K 个建立最小堆    2.迭代剩余元素：        如果当前元素小于堆顶元素，跳过该元素(肯定不是前 K 大)        否则替换堆顶元素为当前元素，并重新调整堆    '''        def __init__(self, iterable, k):        self.minheap = []         # 定义最小堆        self.capacity = k         # 最小堆容量为k个元素        self.iterable = iterable        def push(self, val):        if len(self.minheap) &gt;= self.capacity:            min_val = self.minheap[0]              if val &lt; min_val:                 # 当然你可以直接 if val &gt; min_val操作，这里我只是显示指出跳过这个元素                pass            else:                # 返回并且pop堆顶最小值，推入新的 val 值并调整堆                heapq.heapreplace(self.minheap, val)        else:            # 前面k个元素直接放入minheap            heapq.heappush(self.minheap, val)        def get_topk(self):        for val in self.iterable:            self.push(val)        return self.minheap            def test():    import random    i = list(range(100)) # 这里可以是一个可迭代元素，节省内存    # print(i)    random.shuffle(i)    _ = TopK(i, 10)    print(_.get_topk()) test()import heapq class TopK:    '''    获取大量元素 topk 大个元素，固定内存    思路：    1.先放入元素前 K 个建立最小堆    2.迭代剩余元素：        如果当前元素小于堆顶元素，跳过该元素(肯定不是前 K 大)        否则替换堆顶元素为当前元素，并重新调整堆    '''        def __init__(self, iterable, k):        self.minheap = []         # 定义最小堆        self.capacity = k         # 最小堆容量为k个元素        self.iterable = iterable        def push(self, val):        if len(self.minheap) &gt;= self.capacity:            min_val = self.minheap[0]              if val &lt; min_val:                 # 当然你可以直接 if val &gt; min_val操作，这里我只是显示指出跳过这个元素                pass            else:                # 返回并且pop堆顶最小值，推入新的 val 值并调整堆                heapq.heapreplace(self.minheap, val)        else:            # 前面k个元素直接放入minheap            heapq.heappush(self.minheap, val)        def get_topk(self):        for val in self.iterable:            self.push(val)        return self.minheap            def test():    import random    i = list(range(100)) # 这里可以是一个可迭代元素，节省内存    # print(i)    random.shuffle(i)    _ = TopK(i, 10)    print(_.get_topk()) test()# [90, 91, 93, 92, 97, 96, 94, 95, 98, 99]\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","排序"]},{"title":"剑指offer30~40题","url":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer30-40-ti/","content":"32.最小的K个数 [^本题考点 时间效率]​输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。示例1：\n12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]\n示例2\n12输入：arr = [0,1,2,1], k = 1输出：[输入：arr = [0,1,2,1], k = 1输出：[0]\n\n方法：快排思想思路和算法快排的划分函数 partition 每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边，不需要完全排完序再处理。\n我们定义函数 randomized_selected(arr, l, r, k)表示划分数组 arr 的 [l, r] 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），pviot 左子序列(包括pivot)长度即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：\n\n如果 pos - l + 1 == k，表示 pivot 就是第 k 小的数，则左边的pos个值均为序列中k小的值，后面的值大于 pivot，直接返回即可； \n\n如果 pos - l + 1 &lt; k，表示第 k 小的数在 pivot 的右侧，左边的pos个值为序列中k小的值的一部分，还有 k - pos 个值在右边。因此递归调用 randomized_selected(arr, pos + 1, r, k - (pos - l + 1))；\n\n如果 pos - l + 1 &gt; k，表示第 k 小的数在 pivot 的左侧，左边的k个值为序列中pos小的值的一部分。递归调用 randomized_selected(arr, l, pos - 1, k)。\n\n\n函数递归入口为 randomized_selected(arr, 0, arr.length - 1, k)在函数返回后，将前 k 个数放入答案数组返回即可。\n时间复杂度：期望为 O(n) ，由于证明过程很繁琐，所以不再这里展开讲。具体证明可以参考《算法导论》第 9 章第 2 小节。最坏情况下的时间复杂度为 O(n^2)。情况最差时，每次的划分点都是最大值或最小值，一共需要划分 n - 1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 O(n^2)\n空间复杂度：期望为 O(logn)，递归调用的期望深度为 O(logn)，每层需要的空间为 O(1)，只有常数个变量。\n最坏情况下的空间复杂度为 O(n)。最坏情况下需要划分 n 次，即 randomized_selected 函数递归调用最深 n - 1 层，而每层由于需要 O(1) 的空间，所以一共需要 O(n) 的空间复杂度。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445from typing import Listimport randomimport heapqclass Solution:    def partition(self, nums, l, r):        # 快排切分，返回下标i + 1，使得比nums[i+1]小的数都在 i + 1 的左边，比nums[i + 1]大的数都在i + 1的右边。        pivot = nums[r]        i = l - 1        for j in range(l, r):            if nums[j] &lt;= pivot:                i += 1                nums[i], nums[j] = nums[j], nums[i]        nums[i + 1], nums[r] = nums[r], nums[i + 1]        return i + 1    def randomized_partition(self, nums, l, r):        p = random.randint(l, r)        nums[r], nums[p] = nums[p], nums[r]        return self.partition(nums, l, r)    def randomized_selected(self, arr, l, r, k):        pos = self.randomized_partition(arr, l, r)        length = pos - l + 1  # pviot 左子序列(包括pivot)长度        if k &lt; length:            # 则说明 k 个最小值在当前基准左侧子序，继续切分左段            self.randomized_selected(arr, l, pos - 1, k)        elif k &gt; length:            # 在右子序找 k - length 最小元素，继续切分右段            self.randomized_selected(arr, pos + 1, r, k - length)        # k = length 则说明已经可以获取 k 个最小值了，找到排序后下标为pos的元素，就返回pos以及pos左边所有的数；    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:  # 特判            return list()        self.randomized_selected(arr, 0, len(arr) - 1, k)        return arr[:k]  # 取前 k 值if __name__ == '__main__':    solution = Solution()    array = [3, 7, 1, 5, 6, 2, 4]    print(solution.getLeastNumbers(array, 2))    from typing import Listimport randomimport heapqclass Solution:    def partition(self, nums, l, r):        # 快排切分，返回下标i + 1，使得比nums[i+1]小的数都在 i + 1 的左边，比nums[i + 1]大的数都在i + 1的右边。        pivot = nums[r]        i = l - 1        for j in range(l, r):            if nums[j] &lt;= pivot:                i += 1                nums[i], nums[j] = nums[j], nums[i]        nums[i + 1], nums[r] = nums[r], nums[i + 1]        return i + 1    def randomized_partition(self, nums, l, r):        p = random.randint(l, r)        nums[r], nums[p] = nums[p], nums[r]        return self.partition(nums, l, r)    def randomized_selected(self, arr, l, r, k):        pos = self.randomized_partition(arr, l, r)        length = pos - l + 1  # pviot 左子序列(包括pivot)长度        if k &lt; length:            # 则说明 k 个最小值在当前基准左侧子序，继续切分左段            self.randomized_selected(arr, l, pos - 1, k)        elif k &gt; length:            # 在右子序找 k - length 最小元素，继续切分右段            self.randomized_selected(arr, pos + 1, r, k - length)        # k = length 则说明已经可以获取 k 个最小值了，找到排序后下标为pos的元素，就返回pos以及pos左边所有的数；    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:  # 特判            return list()        self.randomized_selected(arr, 0, len(arr) - 1, k)        return arr[:k]  # 取前 k 值if __name__ == '__main__':    solution = Solution()    array = [3, 7, 1, 5, 6, 2, 4]    print(solution.getLeastNumbers(array, 2))    # [2, 1]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235array = [3, 7, 1, 5, 6, 2, 4]self.randomized_selected(arr, 0, len(arr) - 1, k)self.randomized_selected(arr, 0, 7 - 1, 2)randomized_selected(self, arr, l, r, k):l = 0r = 6k = 2pos = self.randomized_partition(arr, l, r)p = random.randint(l, r) = 4nums[r] = nums[p] = nums[6] = nums[4] = 6 nums[p] = nums[r] = nums[4] = nums[p] = 4[3, 7, 1, 5, 4, 2, 6]return self.partition(nums, l, r)pivot = nums[r] = nums[6] = 6i = l - 1 = 0 - 1 = -1for j in range(l, r):    j = 0    nums[j] = nums[0] = 3 &lt; pivot = 6:    i = i + 1 = 0    nums[i] = nums[j] = nums[0] = nums[0] = 3    nums[j] = nums[i] = nums[0] = nums[0] = 3    j = 1    nums[j] = nums[1] = 7 &gt; pivot = 6:    j = 2    nums[j] = nums[2] = 1 &lt; pivot = 6:    i = i + 1 = 0 + 1 = 1    nums[i] = nums[j] = nums[1] = nums[2] = 1    nums[j] = nums[i] = nums[0] = nums[1] = 7    [3, 1, 7, 5, 4, 2, 6]    j = 3    nums[j] = nums[3] = 5 &lt; pivot = 6:    i = i + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[3] = 5    nums[j] = nums[i] = nums[3] = nums[2] = 7    [3, 1, 5, 7, 4, 2, 6]    j = 4    nums[j] = nums[4] = 4 &lt; pivot = 6:    i = i + 1 = 2 + 1 = 3    nums[i] = nums[j] = nums[3] = nums[4] = 4    nums[j] = nums[i] = nums[4] = nums[3] = 7    [3, 1, 5, 4, 7, 2, 6]    j = 5    nums[j] = nums[5] = 2 &lt; pivot = 6:    i = i + 1 = 3 + 1 = 4    nums[i] = nums[j] = nums[4] = nums[5] = 2    nums[j] = nums[i] = nums[5] = nums[4] = 7    [3, 1, 5, 4, 2, 7, 6]nums[i + 1] = nums[r] = nums[5] = nums[6] = 6nums[r] = nums[i + 1] = nums[6] = nums[5] = 7[3, 1, 5, 4, 2, 6, 7]切分元素 pivot = nums[p] = 6 交换到它排序以后最终确定的位置上 return i + 1pos = i + 1 = 5  返回原来下标为4的元素6的最终位置在下标5，是第 pos + 1 = 6 大元素，pviot 左子序列(包括pivot)长度length = pos - l + 1 = 5 - 0 + 1 = 6pivot 是数组中第 pos - l + 1 = 6 小的数，k = 2 &lt; length = 6:self.randomized_selected(arr, l, pos - 1, k)self.randomized_selected(arr, 0, 5 - 1, 2)self.randomized_selected(arr, 0, 4, 2)    randomized_selected(self, arr, l, r, k)    l = 0    r = 4    k = 2    [3, 1, 5, 4, 2]    pos = self.randomized_partition(arr, l, r)    p = random.randint(l, r) = 3    nums[r] = nums[p] = nums[4] = nums[3] = 4     nums[p] = nums[r] = nums[3] = nums[4] = 2    [3, 1, 5, 2, 4, 6, 7]  [3, 1, 5, 2, 4]    return self.partition(nums, l, r)    pivot = nums[r] = nums[4] = 4    i = l - 1 = 0 - 1 = -1    for j in range(l, r):        j = 0        nums[j] = nums[0] = 3 &lt; pivot = 4:        i = i + 1 = 0        nums[i] = nums[j] = nums[0] = nums[0] = 3        nums[j] = nums[i] = nums[0] = nums[0] = 3        j = 1        nums[j] = nums[1] = 1 &lt; pivot = 4:        i = i + 1 = 0 + 1 = 1        nums[i] = nums[j] = nums[1] = nums[1] = 1        nums[j] = nums[i] = nums[1] = nums[1] = 1        j = 2        nums[j] = nums[2] = 5 &gt; pivot = 4:        j = 3        nums[j] = nums[3] = 2 &lt; pivot = 4:        i = i + 1 = 1 + 1 = 2        nums[i] = nums[j] = nums[2] = nums[3] = 2        nums[j] = nums[i] = nums[3] = nums[2] = 5        [3, 1, 2, 5, 4, 6, 7]   [3, 1, 2, 5, 4]    nums[i + 1] = nums[r] = nums[3] = nums[4] = 4    nums[r] = nums[i + 1] = nums[4] = nums[3] = 5    [3, 1, 2, 4, 5, 6, 7]    [3, 1, 2, 4, 5]    切分元素 nums[p] = 4 交换到它排序以后最终确定的位置上     return i + 1    pos = i + 1 = 3  返回原来下标为3的元素4的最终位置在下标3    length = pos - l + 1 = 3 - 0 + 1 = 4    k = 2 &lt; length = 4:    self.randomized_selected(arr, l, pos - 1, k)    self.randomized_selected(arr, 0, 3 - 1, 2)    self.randomized_selected(arr, 0, 2, 2)        randomized_selected(self, arr, l, r, k)        l = 0        r = 2        k = 2        [3, 1, 2]        pos = self.randomized_partition(arr, l, r)        p = random.randint(l, r) = 0        nums[r] = nums[p] = nums[2] = nums[0] = 3         nums[p] = nums[r] = nums[0] = nums[2] = 2        [2, 1, 3, 4, 5, 6, 7]  [2, 1, 3]        return self.partition(nums, l, r)        pivot = nums[r] = nums[2] = 3        i = l - 1 = 0 - 1 = -1        for j in range(l, r):            j = 0            nums[j] = nums[0] = 2 &lt; pivot = 3:            i = i + 1 = 0            nums[i] = nums[j] = nums[0] = nums[0] = 2            nums[j] = nums[i] = nums[0] = nums[0] = 2            j = 1            nums[j] = nums[1] = 1 &lt; pivot = 3:            i = i + 1 = 0 + 1 = 1            nums[i] = nums[j] = nums[1] = nums[1] = 1            nums[j] = nums[i] = nums[1] = nums[1] = 1        nums[i + 1] = nums[r] = nums[2] = nums[2] = 3        nums[r] = nums[i + 1] = nums[2] = nums[2] = 3        切分元素 nums[p] = 3 交换到它排序以后最终确定的位置上        return i + 1        pos = i + 1 = 2  返回原来下标为0的元素3的最终位置在下标2        length = pos - l + 1 = 2 - 0 + 1 = 3        k = 2 &lt; length = 3:        self.randomized_selected(arr, l, pos - 1, k)        self.randomized_selected(arr, 0, 2 - 1, 2)        self.randomized_selected(arr, 0, 1, 2)            randomized_selected(self, arr, l, r, k)            l = 0            r = 1            k = 2            [2, 1]            pos = self.randomized_partition(arr, l, r)            p = random.randint(l, r) = 1            nums[r] = nums[p] = nums[1] = nums[1] = 1             nums[p] = nums[r] = nums[1] = nums[1] = 1            [2, 1, 3, 4, 5, 6, 7]  [2, 1]            return self.partition(nums, l, r)            pivot = nums[r] = nums[1] = 1            i = l - 1 = 0 - 1 = -1            for j in range(l, r):                j = 0                nums[j] = nums[0] = 2 &gt; pivot = 1:            nums[i + 1] = nums[r] = nums[0] = nums[1] = 1            nums[r] = nums[i + 1] = nums[1] = nums[0] = 2            [1, 2, 3, 4, 5, 6, 7]  [1, 2]            切分元素 nums[p] = 1 交换到它排序以后最终确定的位置上                return i + 1            pos = i + 1 = 0  返回原来下标为1的元素1的最终位置在下标0            length = pos - l + 1 = 0 - 0 + 1 = 1            k = 2 &gt; length = 1:            self.randomized_selected(arr, pos + 1, r, k - num)            self.randomized_selected(arr, 0 + 1, 1, 2 - 1)            self.randomized_selected(arr, 1, 1, 1)                randomized_selected(self, arr, l, r, k)                l = 1                r = 1                k = 1                [2]                pos = self.randomized_partition(arr, l, r)                p = random.randint(l, r) = 1                nums[r] = nums[p] = nums[1] = nums[1] = 2                 nums[p] = nums[r] = nums[1] = nums[1] = 2                [1, 2, 3, 4, 5, 6, 7]  [2]                return self.partition(nums, l, r)                pivot = nums[r] = nums[1] = 2                i = l - 1 = 1 - 1 = 0                for j in range(l, r):                for j in range(1, 1): j取不到值                nums[i + 1] = nums[r] = nums[1] = nums[1] = 2                nums[r] = nums[i + 1] = nums[1] = nums[1] = 2                [1, 2, 3, 4, 5, 6, 7] [2]                切分元素 nums[p] = 2 交换到它排序以后最终确定的位置上                 return i + 1                pos = i + 1 = 0  返回原来下标为1的元素1的最终位置在下标0                length = pos - l + 1 = 0 - 0 + 1 = 1                k = 1 = length             回到上一层            l = 0            r = 1            k = 2            length = 1        回到上一层        l = 0        r = 2        k = 2        length = 3    回到上一层    l = 0    r = 4    k = 2    length = 4        回到初始值l = 0r = 6k = 2length = 6    return arr[:k] = arr[array = [3, 7, 1, 5, 6, 2, 4]self.randomized_selected(arr, 0, len(arr) - 1, k)self.randomized_selected(arr, 0, 7 - 1, 2)randomized_selected(self, arr, l, r, k):l = 0r = 6k = 2pos = self.randomized_partition(arr, l, r)p = random.randint(l, r) = 4nums[r] = nums[p] = nums[6] = nums[4] = 6 nums[p] = nums[r] = nums[4] = nums[p] = 4[3, 7, 1, 5, 4, 2, 6]return self.partition(nums, l, r)pivot = nums[r] = nums[6] = 6i = l - 1 = 0 - 1 = -1for j in range(l, r):    j = 0    nums[j] = nums[0] = 3 &lt; pivot = 6:    i = i + 1 = 0    nums[i] = nums[j] = nums[0] = nums[0] = 3    nums[j] = nums[i] = nums[0] = nums[0] = 3    j = 1    nums[j] = nums[1] = 7 &gt; pivot = 6:    j = 2    nums[j] = nums[2] = 1 &lt; pivot = 6:    i = i + 1 = 0 + 1 = 1    nums[i] = nums[j] = nums[1] = nums[2] = 1    nums[j] = nums[i] = nums[0] = nums[1] = 7    [3, 1, 7, 5, 4, 2, 6]    j = 3    nums[j] = nums[3] = 5 &lt; pivot = 6:    i = i + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[3] = 5    nums[j] = nums[i] = nums[3] = nums[2] = 7    [3, 1, 5, 7, 4, 2, 6]    j = 4    nums[j] = nums[4] = 4 &lt; pivot = 6:    i = i + 1 = 2 + 1 = 3    nums[i] = nums[j] = nums[3] = nums[4] = 4    nums[j] = nums[i] = nums[4] = nums[3] = 7    [3, 1, 5, 4, 7, 2, 6]    j = 5    nums[j] = nums[5] = 2 &lt; pivot = 6:    i = i + 1 = 3 + 1 = 4    nums[i] = nums[j] = nums[4] = nums[5] = 2    nums[j] = nums[i] = nums[5] = nums[4] = 7    [3, 1, 5, 4, 2, 7, 6]nums[i + 1] = nums[r] = nums[5] = nums[6] = 6nums[r] = nums[i + 1] = nums[6] = nums[5] = 7[3, 1, 5, 4, 2, 6, 7]切分元素 pivot = nums[p] = 6 交换到它排序以后最终确定的位置上 return i + 1pos = i + 1 = 5  返回原来下标为4的元素6的最终位置在下标5，是第 pos + 1 = 6 大元素，pviot 左子序列(包括pivot)长度length = pos - l + 1 = 5 - 0 + 1 = 6pivot 是数组中第 pos - l + 1 = 6 小的数，k = 2 &lt; length = 6:self.randomized_selected(arr, l, pos - 1, k)self.randomized_selected(arr, 0, 5 - 1, 2)self.randomized_selected(arr, 0, 4, 2)    randomized_selected(self, arr, l, r, k)    l = 0    r = 4    k = 2    [3, 1, 5, 4, 2]    pos = self.randomized_partition(arr, l, r)    p = random.randint(l, r) = 3    nums[r] = nums[p] = nums[4] = nums[3] = 4     nums[p] = nums[r] = nums[3] = nums[4] = 2    [3, 1, 5, 2, 4, 6, 7]  [3, 1, 5, 2, 4]    return self.partition(nums, l, r)    pivot = nums[r] = nums[4] = 4    i = l - 1 = 0 - 1 = -1    for j in range(l, r):        j = 0        nums[j] = nums[0] = 3 &lt; pivot = 4:        i = i + 1 = 0        nums[i] = nums[j] = nums[0] = nums[0] = 3        nums[j] = nums[i] = nums[0] = nums[0] = 3        j = 1        nums[j] = nums[1] = 1 &lt; pivot = 4:        i = i + 1 = 0 + 1 = 1        nums[i] = nums[j] = nums[1] = nums[1] = 1        nums[j] = nums[i] = nums[1] = nums[1] = 1        j = 2        nums[j] = nums[2] = 5 &gt; pivot = 4:        j = 3        nums[j] = nums[3] = 2 &lt; pivot = 4:        i = i + 1 = 1 + 1 = 2        nums[i] = nums[j] = nums[2] = nums[3] = 2        nums[j] = nums[i] = nums[3] = nums[2] = 5        [3, 1, 2, 5, 4, 6, 7]   [3, 1, 2, 5, 4]    nums[i + 1] = nums[r] = nums[3] = nums[4] = 4    nums[r] = nums[i + 1] = nums[4] = nums[3] = 5    [3, 1, 2, 4, 5, 6, 7]    [3, 1, 2, 4, 5]    切分元素 nums[p] = 4 交换到它排序以后最终确定的位置上     return i + 1    pos = i + 1 = 3  返回原来下标为3的元素4的最终位置在下标3    length = pos - l + 1 = 3 - 0 + 1 = 4    k = 2 &lt; length = 4:    self.randomized_selected(arr, l, pos - 1, k)    self.randomized_selected(arr, 0, 3 - 1, 2)    self.randomized_selected(arr, 0, 2, 2)        randomized_selected(self, arr, l, r, k)        l = 0        r = 2        k = 2        [3, 1, 2]        pos = self.randomized_partition(arr, l, r)        p = random.randint(l, r) = 0        nums[r] = nums[p] = nums[2] = nums[0] = 3         nums[p] = nums[r] = nums[0] = nums[2] = 2        [2, 1, 3, 4, 5, 6, 7]  [2, 1, 3]        return self.partition(nums, l, r)        pivot = nums[r] = nums[2] = 3        i = l - 1 = 0 - 1 = -1        for j in range(l, r):            j = 0            nums[j] = nums[0] = 2 &lt; pivot = 3:            i = i + 1 = 0            nums[i] = nums[j] = nums[0] = nums[0] = 2            nums[j] = nums[i] = nums[0] = nums[0] = 2            j = 1            nums[j] = nums[1] = 1 &lt; pivot = 3:            i = i + 1 = 0 + 1 = 1            nums[i] = nums[j] = nums[1] = nums[1] = 1            nums[j] = nums[i] = nums[1] = nums[1] = 1        nums[i + 1] = nums[r] = nums[2] = nums[2] = 3        nums[r] = nums[i + 1] = nums[2] = nums[2] = 3        切分元素 nums[p] = 3 交换到它排序以后最终确定的位置上        return i + 1        pos = i + 1 = 2  返回原来下标为0的元素3的最终位置在下标2        length = pos - l + 1 = 2 - 0 + 1 = 3        k = 2 &lt; length = 3:        self.randomized_selected(arr, l, pos - 1, k)        self.randomized_selected(arr, 0, 2 - 1, 2)        self.randomized_selected(arr, 0, 1, 2)            randomized_selected(self, arr, l, r, k)            l = 0            r = 1            k = 2            [2, 1]            pos = self.randomized_partition(arr, l, r)            p = random.randint(l, r) = 1            nums[r] = nums[p] = nums[1] = nums[1] = 1             nums[p] = nums[r] = nums[1] = nums[1] = 1            [2, 1, 3, 4, 5, 6, 7]  [2, 1]            return self.partition(nums, l, r)            pivot = nums[r] = nums[1] = 1            i = l - 1 = 0 - 1 = -1            for j in range(l, r):                j = 0                nums[j] = nums[0] = 2 &gt; pivot = 1:            nums[i + 1] = nums[r] = nums[0] = nums[1] = 1            nums[r] = nums[i + 1] = nums[1] = nums[0] = 2            [1, 2, 3, 4, 5, 6, 7]  [1, 2]            切分元素 nums[p] = 1 交换到它排序以后最终确定的位置上                return i + 1            pos = i + 1 = 0  返回原来下标为1的元素1的最终位置在下标0            length = pos - l + 1 = 0 - 0 + 1 = 1            k = 2 &gt; length = 1:            self.randomized_selected(arr, pos + 1, r, k - num)            self.randomized_selected(arr, 0 + 1, 1, 2 - 1)            self.randomized_selected(arr, 1, 1, 1)                randomized_selected(self, arr, l, r, k)                l = 1                r = 1                k = 1                [2]                pos = self.randomized_partition(arr, l, r)                p = random.randint(l, r) = 1                nums[r] = nums[p] = nums[1] = nums[1] = 2                 nums[p] = nums[r] = nums[1] = nums[1] = 2                [1, 2, 3, 4, 5, 6, 7]  [2]                return self.partition(nums, l, r)                pivot = nums[r] = nums[1] = 2                i = l - 1 = 1 - 1 = 0                for j in range(l, r):                for j in range(1, 1): j取不到值                nums[i + 1] = nums[r] = nums[1] = nums[1] = 2                nums[r] = nums[i + 1] = nums[1] = nums[1] = 2                [1, 2, 3, 4, 5, 6, 7] [2]                切分元素 nums[p] = 2 交换到它排序以后最终确定的位置上                 return i + 1                pos = i + 1 = 0  返回原来下标为1的元素1的最终位置在下标0                length = pos - l + 1 = 0 - 0 + 1 = 1                k = 1 = length             回到上一层            l = 0            r = 1            k = 2            length = 1        回到上一层        l = 0        r = 2        k = 2        length = 3    回到上一层    l = 0    r = 4    k = 2    length = 4        回到初始值l = 0r = 6k = 2length = 6    return arr[:k] = arr[1]  \n\n\n这里的循环 partition 相当于 selection 的复杂度，平均下来是 O(n) 的复杂度。\nT(n) = T(n/2) + O(n)\n与带 selection 的 partition 有一些不同之处。\n突然醒悟其实这就是基于partition 实现的 selection，不同之处只是在于:返回第 k+1 个元素还是前 k 个元素。因为做完 selection 后，这里的 partition 必然也实现了此效果。\n基于 selection 的 partition, 可以用 O(n) 时间把 median 当做 pivot.\n12345678910111213141516171819202122232425262728293031323334353637383940414243from typing import Listclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        def partition(nums, left, right):  # assume  left &lt; right            pivot = nums[right]  # 取最后一个            i = left            for j in range(left, right):  # 不取 right, 只能取到 right - 1                 if nums[j] &lt; pivot:                    nums[i], nums[j] = nums[j], nums[i]                    i += 1            nums[i], nums[right] = nums[right], nums[i]            return i        if k == 0:  # 特殊情况处理            return []        # if k == len(arr): # 可不加此，下面代码也能处理        #     return arr        # 当找到第 k 小的数字，即划分好了前 k 小的数字        left, right = 0, len(arr) - 1        target = k - 1        while left &lt; right:            # left == right 说明最后一次，有 target = left = right            ind = partition(arr, left, right)  # 原地修改了 arr            if ind == target:                # 当前 ind 恰是 target, 恰有 arr[0,target-1] &lt; arr[target] &lt; arr[target+1, n-1]                return arr[:target + 1]  # 可直接返回            elif ind &lt; target:                # arr划分为 arr[0,ind-1] &lt; arr[ind] &lt; arr[ind+1, n-1], target 需在右半段中找                left = ind + 1            else:                # 当前 arr 划分为 arr[0,ind-1] &lt; arr[ind] &lt; arr[ind+1, n-1], 而 target 需要在左半段中找                right = ind - 1        return arr[:left + 1]  if __name__ == '__main__':    solution = Solution()    array = [3, 2, 1]    print(solution.getLeastNumbers(array, 2))    from typing import Listclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        def partition(nums, left, right):  # assume  left &lt; right            pivot = nums[right]  # 取最后一个            i = left            for j in range(left, right):  # 不取 right, 只能取到 right - 1                 if nums[j] &lt; pivot:                    nums[i], nums[j] = nums[j], nums[i]                    i += 1            nums[i], nums[right] = nums[right], nums[i]            return i        if k == 0:  # 特殊情况处理            return []        # if k == len(arr): # 可不加此，下面代码也能处理        #     return arr        # 当找到第 k 小的数字，即划分好了前 k 小的数字        left, right = 0, len(arr) - 1        target = k - 1        while left &lt; right:            # left == right 说明最后一次，有 target = left = right            ind = partition(arr, left, right)  # 原地修改了 arr            if ind == target:                # 当前 ind 恰是 target, 恰有 arr[0,target-1] &lt; arr[target] &lt; arr[target+1, n-1]                return arr[:target + 1]  # 可直接返回            elif ind &lt; target:                # arr划分为 arr[0,ind-1] &lt; arr[ind] &lt; arr[ind+1, n-1], target 需在右半段中找                left = ind + 1            else:                # 当前 arr 划分为 arr[0,ind-1] &lt; arr[ind] &lt; arr[ind+1, n-1], 而 target 需要在左半段中找                right = ind - 1        return arr[:left + 1]  if __name__ == '__main__':    solution = Solution()    array = [3, 2, 1]    print(solution.getLeastNumbers(array, 2))    # [1, 2]\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748arr = [3, 2, 1]k = 2left = 0right = 2target = 1进入循环partition(arr, left, right) pivot = nums[right] = nums[2] = 1i = 0j = 0nums[j] = nums[0] = 3 &gt; pivot = 1j = 1 只能取到 right - 1 = 2 - 1 = 1 nums[j] = nums[1] = 2 &gt; pivot = 1nums[i] = nums[right] = nums[0] = nums[2] = 1 nums[right] = nums[i] = nums[2] = nums[0] = 3nums = [1, 2, 3] return i = 0ind = i = 0 &lt; target = 1left = ind + 1 = 1 &lt; right = 2再循环ind = partition(arr, left, right)pivot = nums[right] = nums[2] = 3i = 1j = 1 只能取到 right - 1 = 2 - 1 = 1 nums[j] = nums[1] = 2 &lt; pivot = 3nums[i] = nums[j] = nums[1] = nums[1] = 2 nums[j] = nums[i] = nums[1] = nums[1] = 2 nums = [1, 2, 3]i = i + 1 = 2nums[i] = nums[right] = nums[1] = nums[2] = 3 nums[right] = nums[i] = nums[2] = nums[1] = 2nums = [1, 3, 2] return i = 2ind = i = 2 &gt; target = 1right = ind - 1 = 2 - 1 = 1 = left 跳出循环return arr[:left + 1] = arr[:1 + 1] = arr[0:2] = [1, arr = [3, 2, 1]k = 2left = 0right = 2target = 1进入循环partition(arr, left, right) pivot = nums[right] = nums[2] = 1i = 0j = 0nums[j] = nums[0] = 3 &gt; pivot = 1j = 1 只能取到 right - 1 = 2 - 1 = 1 nums[j] = nums[1] = 2 &gt; pivot = 1nums[i] = nums[right] = nums[0] = nums[2] = 1 nums[right] = nums[i] = nums[2] = nums[0] = 3nums = [1, 2, 3] return i = 0ind = i = 0 &lt; target = 1left = ind + 1 = 1 &lt; right = 2再循环ind = partition(arr, left, right)pivot = nums[right] = nums[2] = 3i = 1j = 1 只能取到 right - 1 = 2 - 1 = 1 nums[j] = nums[1] = 2 &lt; pivot = 3nums[i] = nums[j] = nums[1] = nums[1] = 2 nums[j] = nums[i] = nums[1] = nums[1] = 2 nums = [1, 2, 3]i = i + 1 = 2nums[i] = nums[right] = nums[1] = nums[2] = 3 nums[right] = nums[i] = nums[2] = nums[1] = 2nums = [1, 3, 2] return i = 2ind = i = 2 &gt; target = 1right = ind - 1 = 2 - 1 = 1 = left 跳出循环return arr[:left + 1] = arr[:1 + 1] = arr[0:2] = [1, 2]\n\n1234567891011121314151617181920212223242526272829303132class Solution:    # 取数组第一个值，该值进行归位，左边都比该值小，右边都比该值大。    def partition(self, nums, left, right):        pivot = nums[left]        # 原地排序        while left &lt; right:            while left &lt; right and pivot &lt;= nums[right]:                right -= 1            # 从right开始，如果比tmp小，则交换。            nums[left] = nums[right]            while left &lt; right and nums[left] &lt;= pivot:                left += 1            # 从left开始，如果比tmp大，则交换。            nums[right] = nums[left]        nums[left] = pivot        return left    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        size = len(arr)        if size == 0 or k &gt; size: return        if size == 1 or size == k:            return arr        left, right = 0, size - 1        while left &lt;= right:  # 这里其实也相当于是二分法            pivot = self.partition(arr, left, right)  # left, right, split_ind 都是原始 index            if pivot == k:  # 在 split_ind 左边有 k 个元素，全部不大于 pivot                break            elif pivot &gt; k:                right = pivot - 1  # 不-1 会陷入死循环            else:                left = pivot + 1  # 不 +1 会陷入死循环        class Solution:    # 取数组第一个值，该值进行归位，左边都比该值小，右边都比该值大。    def partition(self, nums, left, right):        pivot = nums[left]        # 原地排序        while left &lt; right:            while left &lt; right and pivot &lt;= nums[right]:                right -= 1            # 从right开始，如果比tmp小，则交换。            nums[left] = nums[right]            while left &lt; right and nums[left] &lt;= pivot:                left += 1            # 从left开始，如果比tmp大，则交换。            nums[right] = nums[left]        nums[left] = pivot        return left    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        size = len(arr)        if size == 0 or k &gt; size: return        if size == 1 or size == k:            return arr        left, right = 0, size - 1        while left &lt;= right:  # 这里其实也相当于是二分法            pivot = self.partition(arr, left, right)  # left, right, split_ind 都是原始 index            if pivot == k:  # 在 split_ind 左边有 k 个元素，全部不大于 pivot                break            elif pivot &gt; k:                right = pivot - 1  # 不-1 会陷入死循环            else:                left = pivot + 1  # 不 +1 会陷入死循环        return arr[:k]\n\n1234567891011121314151617181920class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        l, r = 0, len(arr) - 1        while l &lt; r:            pivot = self.partition(arr, l, r)            if pivot &gt; k - 1:                r = pivot - 1            else:                l = pivot + 1        return arr[:k]    def partition(self, nums, l, r):        pivot = r        right = l        for i in range(l, r):            if nums[i] &lt; nums[pivot]:                nums[i], nums[right] = nums[right], nums[i]                right += 1        nums[pivot], nums[right] = nums[right], nums[pivot]        class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        l, r = 0, len(arr) - 1        while l &lt; r:            pivot = self.partition(arr, l, r)            if pivot &gt; k - 1:                r = pivot - 1            else:                l = pivot + 1        return arr[:k]    def partition(self, nums, l, r):        pivot = r        right = l        for i in range(l, r):            if nums[i] &lt; nums[pivot]:                nums[i], nums[right] = nums[right], nums[i]                right += 1        nums[pivot], nums[right] = nums[right], nums[pivot]        return right\n\n\n\n法二：\n12345import heapqclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        heapq.heapify(arr)        import heapqclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        heapq.heapify(arr)        return heapq.nsmallest(k, arr)\n\n法三通过构造k个元素的大根堆来存储最小的k个元素，实时维护数组的前 k 小值，步骤如下：\n将数组中的元素依次入堆，如果堆中元素不足K个，那么就是直接添加；当堆中元素大于等于K个时，首先取数组前k个元素初始化堆，从最后一个非叶结点开始到根结点来构建最大堆随后从第 k+1 个数开始遍历，依次将堆顶元素与遍历到的当前元素比较\n\n如果大于大根堆的堆顶元素，则说明这个元素不属于最小的k个数之列，跳过不入堆。\n如果当遍历到的数比大根堆的堆顶的数要小，把堆顶元素弹出，再插入当前遍历到的数。那么将堆顶的数换成这个更小的数，再从堆顶重新堆化（heapify）构建最大堆这样下去之后，由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里，最后将大根堆里的数存入数组返回，取数组的前k个元素即为前k小的数\n\npython3标准库中提供了heapq，使用原地算法得到对小顶堆进行操作实现 大顶堆 方法：要对数组中所有的数取其相反数，小顶堆的插入和弹出操作均将元素 取反\n在写代码的时候，我们使用的也是库函数中的优先队列数据结构，在面试中，我们不需要实现堆的内部结构，把数据结构使用好，会分析其复杂度即可。\n时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。\n空间复杂度：O(k)，因为大根堆里最多 k 个数。\n12345678910111213141516171819202122232425262728from typing import Listimport heapqclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:  # 排除 0 的情况            return list()        # python默认是小根堆，把所有的元素都加负号以满足最大二叉堆性质        # 求最小k个数那就要转化为负值来做        hp = [-x for x in arr[:k]]        # 将列表hp原地改为最大二叉堆列表，具备大顶堆特征        heapq.heapify(hp)        for i in range(k, len(arr)):            if -hp[0] &gt; arr[i]:                # 堆顶元素下标为0，如果这个元素小，就入堆                # 将最小二叉堆hp的堆顶元素弹出                heapq.heappop(hp)                # 将num压入堆ls中，将 item 的值加入 hp 中，保持堆的不变性。                heapq.heappush(hp, -arr[i])        return [-x for x in hp]if __name__ == '__main__':    solution = Solution()    array = [3, 2, 1, 5, 6, 4]    print(solution.getLeastNumbers(array, 2))    from typing import Listimport heapqclass Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:  # 排除 0 的情况            return list()        # python默认是小根堆，把所有的元素都加负号以满足最大二叉堆性质        # 求最小k个数那就要转化为负值来做        hp = [-x for x in arr[:k]]        # 将列表hp原地改为最大二叉堆列表，具备大顶堆特征        heapq.heapify(hp)        for i in range(k, len(arr)):            if -hp[0] &gt; arr[i]:                # 堆顶元素下标为0，如果这个元素小，就入堆                # 将最小二叉堆hp的堆顶元素弹出                heapq.heappop(hp)                # 将num压入堆ls中，将 item 的值加入 hp 中，保持堆的不变性。                heapq.heappush(hp, -arr[i])        return [-x for x in hp]if __name__ == '__main__':    solution = Solution()    array = [3, 2, 1, 5, 6, 4]    print(solution.getLeastNumbers(array, 2))    # [2, 1]\n\n\n12345678910111213141516171819202122232425262728array = [3, 2, 1, 5, 6, 4]k = 2arr[:k] = arr[:2] = [3, 2]hp = [-3, -2]heapq.heapify(hp)  最小堆hp = [-3, -2]for i in range(k, len(arr))for i in range(2, 6)    i = 2    -hp[0] = 3 &gt; arr[i] = arr[2] = 1    heapq.heappop(hp)    hp = [-2]    heapq.heappush(hp, -arr[i])    heapq.heappush(hp, -1)    hp = [-2, -1]    i = 3    -hp[0] = 2 &lt; arr[i] = arr[3] = 5    i = 4    -hp[0] = 2 &lt; arr[i] = arr[4] = 6    i = 5    -hp[0] = 2 &lt; arr[i] = arr[3] = 4    return [-x for x in hp]    return [-x for x in [-2, -1]]    return [2, array = [3, 2, 1, 5, 6, 4]k = 2arr[:k] = arr[:2] = [3, 2]hp = [-3, -2]heapq.heapify(hp)  最小堆hp = [-3, -2]for i in range(k, len(arr))for i in range(2, 6)    i = 2    -hp[0] = 3 &gt; arr[i] = arr[2] = 1    heapq.heappop(hp)    hp = [-2]    heapq.heappush(hp, -arr[i])    heapq.heappush(hp, -1)    hp = [-2, -1]    i = 3    -hp[0] = 2 &lt; arr[i] = arr[3] = 5    i = 4    -hp[0] = 2 &lt; arr[i] = arr[4] = 6    i = 5    -hp[0] = 2 &lt; arr[i] = arr[3] = 4    return [-x for x in hp]    return [-x for x in [-2, -1]]    return [2, 1]]\n\n-3 &lt; -2\n12345678910111213   -3   /  -2   /  -2不符合最小堆，调整   -2   /   -2   /     -3   /  -2   /  -2不符合最小堆，调整   -2   /   -2   /  -1\n\n\n12345678910111213141516class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:            return list()        # python默认是小根堆，求最小k个数那就要转化为负值来做，变成大根堆        hp = [-x for x in arr[:k]]        # 将列表hp原地改为最大二叉堆列表，具备大顶堆特征        heapq.heapify(hp)          for item in arr[k:]:            if -hp[0] &gt; item:                # 堆顶元素下标为0，如果这个元素小，就入堆                # 将最小二叉堆hp的堆顶元素弹出                heapq.heappop(hp)                  # 将num压入堆ls中                heapq.heappush(hp, -item)        return [-x for x class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        if k == 0:            return list()        # python默认是小根堆，求最小k个数那就要转化为负值来做，变成大根堆        hp = [-x for x in arr[:k]]        # 将列表hp原地改为最大二叉堆列表，具备大顶堆特征        heapq.heapify(hp)          for item in arr[k:]:            if -hp[0] &gt; item:                # 堆顶元素下标为0，如果这个元素小，就入堆                # 将最小二叉堆hp的堆顶元素弹出                heapq.heappop(hp)                  # 将num压入堆ls中                heapq.heappush(hp, -item)        return [-x for x in hp]\n\n\n击败97%\n1234567class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        heap = [-a for a in arr[:k]]        heapq.heapify(heap)        for i in range(k, len(arr)):            heapq.heappushpop(heap, -arr[i])        return [-a for a class Solution:    def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:        heap = [-a for a in arr[:k]]        heapq.heapify(heap)        for i in range(k, len(arr)):            heapq.heappushpop(heap, -arr[i])        return [-a for a in heap]\n\n123456789101112131415161718192021222324class Solution:       def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:    if not arr or k == 0: return []    if len(arr) &lt;= k: return arr    heap = arr[:k]  # 初始化    def buildMaxHeap(pos):        while pos*2+1 &lt; k:            max_pos = pos*2+1            if pos*2+2 &lt; k and heap[pos*2+2] &gt; heap[pos*2+1]:  # 存在右节点，且右节点大于左节点                max_pos += 1            if heap[pos] &lt; heap[max_pos]:  # 最大节点大于根节点，上浮/下沉                heap[pos],heap[max_pos] = heap[max_pos],heap[pos]                pos = max_pos            else: break        for i in range(k//2, -1, -1):  # k//2 ~ 0: 2i+1为左节点于数组中index        buildMaxHeap(i)  # 由叶子节点开始上浮    for i in range(k, len(arr)):        if arr[i] &lt; heap[0]:            heap[0] = arr[i]            buildMaxHeap(0)  # 由根节点开始下沉        else: continue    class Solution:       def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]:    if not arr or k == 0: return []    if len(arr) &lt;= k: return arr    heap = arr[:k]  # 初始化    def buildMaxHeap(pos):        while pos*2+1 &lt; k:            max_pos = pos*2+1            if pos*2+2 &lt; k and heap[pos*2+2] &gt; heap[pos*2+1]:  # 存在右节点，且右节点大于左节点                max_pos += 1            if heap[pos] &lt; heap[max_pos]:  # 最大节点大于根节点，上浮/下沉                heap[pos],heap[max_pos] = heap[max_pos],heap[pos]                pos = max_pos            else: break        for i in range(k//2, -1, -1):  # k//2 ~ 0: 2i+1为左节点于数组中index        buildMaxHeap(i)  # 由叶子节点开始上浮    for i in range(k, len(arr)):        if arr[i] &lt; heap[0]:            heap[0] = arr[i]            buildMaxHeap(0)  # 由根节点开始下沉        else: continue    return heap\n\n\n大根堆 – 最小k个元素求前k个最小用最大堆，求前k个最大用最小堆。步骤如下：1: 取数组前k个元素初始化堆，从最后一个非叶子节点开始到根节点来构建大根堆2: 当某个元素大于堆顶元素时，直接抛弃3: 当某个元素小于堆顶元素时，替换栈顶元素，再从堆顶重新构建大根堆\n1234567891011121314151617181920212223242526272829303132333435class Solution:    @staticmethod    def swap(heap, i, j):        heap[i], heap[j] = heap[j], heap[i]    def heapify(self, heap, i):        left, right = 2 * i + 1, 2 * i + 2        largest = i        if left &lt; len(heap) and heap[left] &gt; heap[largest]:            largest = left        if right &lt; len(heap) and heap[right] &gt; heap[largest]:            largest = right        if largest != i:  # 调整当前子树为大顶堆            self.swap(heap, i, largest)            self.heapify(heap, largest)    def build_heap(self, heap: list):        # 从最后一个非叶子节点开始构建大根堆, len(heap)//2 - 1就是最后一个非叶子节点        for i in range(len(heap) // 2 - 1, -1, -1):            self.heapify(heap, i)    def getLeastNumbers(self, arr: list, k: int):        if not arr or k &lt;= 0: return []        if len(arr) &lt;= k: return arr        heap = arr[:k]        self.build_heap(heap)  # 构建大根堆        for i in range(k, len(arr)):            if arr[i] &lt; heap[0]:  # 当前元素比堆根小，则弹出堆根并插入当前元素                heap[0] = arr[i]                self.heapify(heap, 0)  # 重新调整堆根        class Solution:    @staticmethod    def swap(heap, i, j):        heap[i], heap[j] = heap[j], heap[i]    def heapify(self, heap, i):        left, right = 2 * i + 1, 2 * i + 2        largest = i        if left &lt; len(heap) and heap[left] &gt; heap[largest]:            largest = left        if right &lt; len(heap) and heap[right] &gt; heap[largest]:            largest = right        if largest != i:  # 调整当前子树为大顶堆            self.swap(heap, i, largest)            self.heapify(heap, largest)    def build_heap(self, heap: list):        # 从最后一个非叶子节点开始构建大根堆, len(heap)//2 - 1就是最后一个非叶子节点        for i in range(len(heap) // 2 - 1, -1, -1):            self.heapify(heap, i)    def getLeastNumbers(self, arr: list, k: int):        if not arr or k &lt;= 0: return []        if len(arr) &lt;= k: return arr        heap = arr[:k]        self.build_heap(heap)  # 构建大根堆        for i in range(k, len(arr)):            if arr[i] &lt; heap[0]:  # 当前元素比堆根小，则弹出堆根并插入当前元素                heap[0] = arr[i]                self.heapify(heap, 0)  # 重新调整堆根        return heap\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution:    def GetLeastNumbers_Solution(self, tinput, k):        # 第一种        # if len(tinput) &lt; k:        #     return []        # ret = sorted(tinput)        # return ret[:k]        # 第二种,使用最大堆        # 创建或者是插入最大堆        def createMaxHeap(num):            maxHeap.append(num)            currentIndex = len(maxHeap) - 1            while currentIndex != 0:                parentIndex = (currentIndex - 1) &gt;&gt; 1  # 任意节点的父节点                if maxHeap[parentIndex] &lt; maxHeap[currentIndex]:                    maxHeap[parentIndex], maxHeap[currentIndex] = maxHeap[currentIndex], maxHeap[parentIndex]                    currentIndex = parentIndex                else:                    break        # 调整最大堆，头节点发生改变        def adjustMaxHeap(num):            if num &lt; maxHeap[0]:                maxHeap[0] = num            maxHeapLen = len(maxHeap)            index = 0            while index &lt; maxHeapLen:                leftIndex = index * 2 + 1                rightIndex = index * 2 + 2                if rightIndex &lt; maxHeapLen:                    if maxHeap[rightIndex] &lt; maxHeap[leftIndex]:                        largerIndex = leftIndex                    else:                        largerIndex = rightIndex                elif leftIndex &lt; maxHeapLen:                    largerIndex = leftIndex                else:                    break                if maxHeap[index] &lt; maxHeap[largerIndex]:                    maxHeap[index], maxHeap[largerIndex] = maxHeap[largerIndex], maxHeap[index]                index = largerIndex        maxHeap = []        tinputLen = len(tinput)        if tinputLen &lt; k or k &lt;= 0:            return []        for i in range(tinputLen):            if i &lt; k:                createMaxHeap(tinput[i])            else:                adjustMaxHeap(tinput[i])        class Solution:    def GetLeastNumbers_Solution(self, tinput, k):        # 第一种        # if len(tinput) &lt; k:        #     return []        # ret = sorted(tinput)        # return ret[:k]        # 第二种,使用最大堆        # 创建或者是插入最大堆        def createMaxHeap(num):            maxHeap.append(num)            currentIndex = len(maxHeap) - 1            while currentIndex != 0:                parentIndex = (currentIndex - 1) &gt;&gt; 1  # 任意节点的父节点                if maxHeap[parentIndex] &lt; maxHeap[currentIndex]:                    maxHeap[parentIndex], maxHeap[currentIndex] = maxHeap[currentIndex], maxHeap[parentIndex]                    currentIndex = parentIndex                else:                    break        # 调整最大堆，头节点发生改变        def adjustMaxHeap(num):            if num &lt; maxHeap[0]:                maxHeap[0] = num            maxHeapLen = len(maxHeap)            index = 0            while index &lt; maxHeapLen:                leftIndex = index * 2 + 1                rightIndex = index * 2 + 2                if rightIndex &lt; maxHeapLen:                    if maxHeap[rightIndex] &lt; maxHeap[leftIndex]:                        largerIndex = leftIndex                    else:                        largerIndex = rightIndex                elif leftIndex &lt; maxHeapLen:                    largerIndex = leftIndex                else:                    break                if maxHeap[index] &lt; maxHeap[largerIndex]:                    maxHeap[index], maxHeap[largerIndex] = maxHeap[largerIndex], maxHeap[index]                index = largerIndex        maxHeap = []        tinputLen = len(tinput)        if tinputLen &lt; k or k &lt;= 0:            return []        for i in range(tinputLen):            if i &lt; k:                createMaxHeap(tinput[i])            else:                adjustMaxHeap(tinput[i])        return sorted(maxHeap)\n\n\n215. 数组中的第K个最大元素​    在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n示例 1:\n12输入: [3,2,1,5,6,4] 和 k = 2输出: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5\n\n示例 2:\n12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4\n说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n题目要求我们找到“数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素” ，语义是从右边往左边数第 k 个元素（从 1 开始），那么从左向右数是第几个呢，我们列出几个找找规律就好了。一共 6 个元素，找第 2 大，索引是 4；一共 6 个元素，找第 4 大，索引是 2。因此，升序排序以后，目标元素的索引是 len - k。找第 k 大，即找第 len - k 小\n123class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        return heapq.nlargest(k, nums)[class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        return heapq.nlargest(k, nums)[-1]\n\n法二：借助 partition 操作定位到最终排定以后索引为 len - k 的那个元素（特别注意：随机化切分元素）\n时间复杂度：O(N)，这里 N 是数组的长度，理由可以参考主定理进行分析。空间复杂度：O(1)，原地排序，没有借助额外的辅助空间。注意：本题必须随机初始化 pivot 元素，否则通过时间会很慢，因为测试用例中有极端测试用例。\n12345678910111213141516171819202122232425262728293031323334353637from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:  # 死循环            index = self.__partition(nums, left, right)            if index == target:                return nums[index]  # 结束循环            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1    '''parition 的操作         在循环中，保持的循环不变量是：         [left + 1, j] &lt; pivot 与 (j, i) &gt;= pivot         因此，在 partition 的最后，需要将 left 位置与 j 位置交换，交换以后就能得到：         [left, j - 1] &lt; pivot，nums[j] = pivot ，[j + 1, right] &gt;= pivot ，j 位置就是 pivot 在排序以后应该呆的位置。    '''    def __partition(self, nums, left, right):        pivot = nums[left]        j = left        for i in range(left + 1, right + 1):            if nums[i] &lt; pivot:                j += 1   # 小于 pivot 的元素都被交换到前面                nums[i], nums[j] = nums[j], nums[i]        #  partition 的作用：把一个数组的子区间按照 pivot 进行分区，分区完成以后，交换 left 和 分区的分界线，把切分元素 pivot 交换到它排序以后最终确定的位置上。        nums[left], nums[j] = nums[j], nums[left]        from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:  # 死循环            index = self.__partition(nums, left, right)            if index == target:                return nums[index]  # 结束循环            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1    '''parition 的操作         在循环中，保持的循环不变量是：         [left + 1, j] &lt; pivot 与 (j, i) &gt;= pivot         因此，在 partition 的最后，需要将 left 位置与 j 位置交换，交换以后就能得到：         [left, j - 1] &lt; pivot，nums[j] = pivot ，[j + 1, right] &gt;= pivot ，j 位置就是 pivot 在排序以后应该呆的位置。    '''    def __partition(self, nums, left, right):        pivot = nums[left]        j = left        for i in range(left + 1, right + 1):            if nums[i] &lt; pivot:                j += 1   # 小于 pivot 的元素都被交换到前面                nums[i], nums[j] = nums[j], nums[i]        #  partition 的作用：把一个数组的子区间按照 pivot 进行分区，分区完成以后，交换 left 和 分区的分界线，把切分元素 pivot 交换到它排序以后最终确定的位置上。        nums[left], nums[j] = nums[j], nums[left]        return j\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263array = [3, 2, 1]k = 2size = 3target = size - k = 3 - 2 = 1 left = 0right = size - 1 = 3 - 1 = 2index = self.__partition(nums, left, right)    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i 只取到 right + 1 - 1 = 2    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &gt; target = 1right = index - 1 = 2 - 1 = 1self.__partition(nums, left, right)    pivot = nums[left] = 1    j = left = 0    i = 1    nums[1] = 2 &gt; pivot = 1    i = 2    nums[2] = 3 &gt; pivot = 1    nums[left] = nums[j] = nums[0] = nums[0] = 1     nums[j] = nums[left] = nums[0] = nums[0] = 1    nums = [1, 2, 3] 切分元素 pivot = 1 交换到它排序以后最终确定的位置上。         return jindex = j = 0 &lt; target = 1left = index + 1 = 0 + 1 = 1self.__partition(nums, left, right)    pivot = nums[left] = nums[1] = 2    j = left = 1    i = 2    nums[2] = 3 &gt; pivot = 1    nums[left] = nums[j] = nums[1] = nums[1] = 2     nums[j] = nums[left] = nums[1] = nums[1] = 2    nums = [1, 2, 3] 切分元素 pivot = 2 交换到它排序以后最终确定的位置上。    return jindex = j = 1 = target = 1return nums[index] = nums[1] = array = [3, 2, 1]k = 2size = 3target = size - k = 3 - 2 = 1 left = 0right = size - 1 = 3 - 1 = 2index = self.__partition(nums, left, right)    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i 只取到 right + 1 - 1 = 2    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &gt; target = 1right = index - 1 = 2 - 1 = 1self.__partition(nums, left, right)    pivot = nums[left] = 1    j = left = 0    i = 1    nums[1] = 2 &gt; pivot = 1    i = 2    nums[2] = 3 &gt; pivot = 1    nums[left] = nums[j] = nums[0] = nums[0] = 1     nums[j] = nums[left] = nums[0] = nums[0] = 1    nums = [1, 2, 3] 切分元素 pivot = 1 交换到它排序以后最终确定的位置上。         return jindex = j = 0 &lt; target = 1left = index + 1 = 0 + 1 = 1self.__partition(nums, left, right)    pivot = nums[left] = nums[1] = 2    j = left = 1    i = 2    nums[2] = 3 &gt; pivot = 1    nums[left] = nums[j] = nums[1] = nums[1] = 2     nums[j] = nums[left] = nums[1] = nums[1] = 2    nums = [1, 2, 3] 切分元素 pivot = 2 交换到它排序以后最终确定的位置上。    return jindex = j = 1 = target = 1return nums[index] = nums[1] = 2\n\n\n法三：随机\n1234567891011121314151617181920212223242526272829303132333435363738394041from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:            index = self.__partition(nums, left, right)            if index == target:                return nums[index]            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1    ''' parition 的操作        在循环中，保持的循环不变量是：        [left + 1, j] &lt; pivot 与 (j, i) &gt;= pivot        因此，在 partition 的最后，需要将 left 位置与 j 位置交换，交换以后就能得到：        [left, j - 1] &lt; pivot，nums[j] = pivot ，[j + 1, right] &gt;= pivot ，j 位置就是 pivot 在排序以后应该呆的位置。    '''    def __partition(self, nums, left, right):        # 随机化切分元素        # randint 是包括左右区间的        random_index = random.randint(left, right)        nums[random_index], nums[left] = nums[left], nums[random_index]        pivot = nums[left]        j = left        for i in range(left + 1, right + 1):            if nums[i] &lt; pivot:                j += 1                nums[i], nums[j] = nums[j], nums[i]        #  partition 的作用：把一个数组的子区间按照 pivot 进行分区，分区完成以后，交换 left 和 分区的分界线，把切分元素 pivot 交换到它排序以后最终确定的位置上。        nums[left], nums[j] = nums[j], nums[left]        from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:            index = self.__partition(nums, left, right)            if index == target:                return nums[index]            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1    ''' parition 的操作        在循环中，保持的循环不变量是：        [left + 1, j] &lt; pivot 与 (j, i) &gt;= pivot        因此，在 partition 的最后，需要将 left 位置与 j 位置交换，交换以后就能得到：        [left, j - 1] &lt; pivot，nums[j] = pivot ，[j + 1, right] &gt;= pivot ，j 位置就是 pivot 在排序以后应该呆的位置。    '''    def __partition(self, nums, left, right):        # 随机化切分元素        # randint 是包括左右区间的        random_index = random.randint(left, right)        nums[random_index], nums[left] = nums[left], nums[random_index]        pivot = nums[left]        j = left        for i in range(left + 1, right + 1):            if nums[i] &lt; pivot:                j += 1                nums[i], nums[j] = nums[j], nums[i]        #  partition 的作用：把一个数组的子区间按照 pivot 进行分区，分区完成以后，交换 left 和 分区的分界线，把切分元素 pivot 交换到它排序以后最终确定的位置上。        nums[left], nums[j] = nums[j], nums[left]        return j\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667array = [3, 2, 1, 5, 6, 4]k = 2size = 6target = size - k = 6 - 2 = 4left = 0right = size - 1 = 6 - 1 = 5index = self.__partition(nums, left, right)    random_index = left    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i = 3     nums[i] = nums[3] = 5 &gt; pivot = 3    i = 4     nums[i] = nums[4] = 6 &gt; pivot = 3    i = 5     nums[i] = nums[5] = 4 &gt; pivot = 3    i 只取到 right + 1 - 1 = 5    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3, 5, 6, 4] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &lt; target = 4left = index + 1 = 2 + 1 = 3self.__partition(nums, left, right)self.__partition(nums, 3, 5)    random_index = left    pivot = nums[left] = nums[3] = 5    j = left = 3    i = 4    nums[4] = 6 &gt; pivot = 5    i = 5    nums[5] = 4 &lt; pivot = 5    j = j + 1 = 4    nums[i] = nums[j] = nums[5] = nums[4] = 6     nums[j] = nums[i] = nums[4] = nums[5] = 4     [1, 2, 3, 5, 4, 6]    nums[left] = nums[j] = nums[3] = nums[4] = 6     nums[j] = nums[left] = nums[4] = nums[3] = 5    nums = [1, 2, 3, 4, 5, 6] 切分元素 pivot = 5 交换到它排序以后最终确定的位置上。    return jindex = j = 4 = target = 4return nums[index] = nums[4] = array = [3, 2, 1, 5, 6, 4]k = 2size = 6target = size - k = 6 - 2 = 4left = 0right = size - 1 = 6 - 1 = 5index = self.__partition(nums, left, right)    random_index = left    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i = 3     nums[i] = nums[3] = 5 &gt; pivot = 3    i = 4     nums[i] = nums[4] = 6 &gt; pivot = 3    i = 5     nums[i] = nums[5] = 4 &gt; pivot = 3    i 只取到 right + 1 - 1 = 5    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3, 5, 6, 4] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &lt; target = 4left = index + 1 = 2 + 1 = 3self.__partition(nums, left, right)self.__partition(nums, 3, 5)    random_index = left    pivot = nums[left] = nums[3] = 5    j = left = 3    i = 4    nums[4] = 6 &gt; pivot = 5    i = 5    nums[5] = 4 &lt; pivot = 5    j = j + 1 = 4    nums[i] = nums[j] = nums[5] = nums[4] = 6     nums[j] = nums[i] = nums[4] = nums[5] = 4     [1, 2, 3, 5, 4, 6]    nums[left] = nums[j] = nums[3] = nums[4] = 6     nums[j] = nums[left] = nums[4] = nums[3] = 5    nums = [1, 2, 3, 4, 5, 6] 切分元素 pivot = 5 交换到它排序以后最终确定的位置上。    return jindex = j = 4 = target = 4return nums[index] = nums[4] = 5\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667array = [3, 2, 1, 5, 6, 4]k = 2size = 6target = size - k = 6 - 2 = 4left = 0right = size - 1 = 6 - 1 = 5index = self.__partition(nums, left, right)    random_index = right    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i = 3     nums[i] = nums[3] = 5 &gt; pivot = 3    i = 4     nums[i] = nums[4] = 6 &gt; pivot = 3    i = 5     nums[i] = nums[5] = 4 &gt; pivot = 3    i 只取到 right + 1 - 1 = 5    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3, 5, 6, 4] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &lt; target = 4left = index + 1 = 2 + 1 = 3self.__partition(nums, left, right)self.__partition(nums, 3, 5)    random_index = left    pivot = nums[left] = nums[3] = 5    j = left = 3    i = 4    nums[4] = 6 &gt; pivot = 5    i = 5    nums[5] = 4 &lt; pivot = 5    j = j + 1 = 4    nums[i] = nums[j] = nums[5] = nums[4] = 6     nums[j] = nums[i] = nums[4] = nums[5] = 4     [1, 2, 3, 5, 4, 6]    nums[left] = nums[j] = nums[3] = nums[4] = 6     nums[j] = nums[left] = nums[4] = nums[3] = 5    nums = [1, 2, 3, 4, 5, 6] 切分元素 pivot = 5 交换到它排序以后最终确定的位置上。    return jindex = j = 4 = target = 4return nums[index] = nums[4] = array = [3, 2, 1, 5, 6, 4]k = 2size = 6target = size - k = 6 - 2 = 4left = 0right = size - 1 = 6 - 1 = 5index = self.__partition(nums, left, right)    random_index = right    pivot = nums[left] = nums[0] = 3    j = left = 0    i = 1    nums[i] = nums[1] = 2 &lt; pivot = 3    j = j + 1 = 1    nums[i] = nums[j] = nums[1] = nums[1] = 2      nums[j] = nums[i] = nums[1] = nums[1] = 2      i = 2     nums[i] = nums[2] = 1 &lt; pivot = 3    j = j + 1 = 1 + 1 = 2    nums[i] = nums[j] = nums[2] = nums[2] = 1      nums[j] = nums[i] = nums[2] = nums[2] = 1      i = 3     nums[i] = nums[3] = 5 &gt; pivot = 3    i = 4     nums[i] = nums[4] = 6 &gt; pivot = 3    i = 5     nums[i] = nums[5] = 4 &gt; pivot = 3    i 只取到 right + 1 - 1 = 5    跳出循环    nums[left] = nums[j] = nums[0] = nums[2] = 1     nums[j] = nums[left] = nums[2] = nums[0] = 3    nums = [1, 2, 3, 5, 6, 4] 切分元素 pivot = 3 交换到它排序以后最终确定的位置上。    return jindex = j = 2 &lt; target = 4left = index + 1 = 2 + 1 = 3self.__partition(nums, left, right)self.__partition(nums, 3, 5)    random_index = left    pivot = nums[left] = nums[3] = 5    j = left = 3    i = 4    nums[4] = 6 &gt; pivot = 5    i = 5    nums[5] = 4 &lt; pivot = 5    j = j + 1 = 4    nums[i] = nums[j] = nums[5] = nums[4] = 6     nums[j] = nums[i] = nums[4] = nums[5] = 4     [1, 2, 3, 5, 4, 6]    nums[left] = nums[j] = nums[3] = nums[4] = 6     nums[j] = nums[left] = nums[4] = nums[3] = 5    nums = [1, 2, 3, 4, 5, 6] 切分元素 pivot = 5 交换到它排序以后最终确定的位置上。    return jindex = j = 4 = target = 4return nums[index] = nums[4] = 5\n\n使用双指针，将与 pivot 相等的元素等概论地分到 pivot 最终排定位置的两边。使用双指针的办法找到切分元素的位置。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:            index = self.__partition(nums, left, right)            if index == target:                return nums[index]            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1'''parition 的操作 在之前遍历的过程中 将等于 pivot 的元素分散到两边在循环中，保持的循环不变量是：    # [left + 1, lt） &lt;= pivot    # (rt, right] &gt;= pivot因此，在 partition 的最后，需要将 left 位置与 rt 位置交换，交换以后就能得到：[left, rt - 1] &lt; pivot，nums[rt] = pivot ，[rt + 1, right] &gt;= pivot ，rt 位置就是 pivot 在排序以后应该呆的位置。'''    def __partition(self, nums, left, right):        # randint 是包括左右区间的        random_index = random.randint(left, right)        nums[random_index], nums[left] = nums[left], nums[random_index]        pivot = nums[left]        lt = left + 1        rt = right        while True:            while lt &lt;= rt and nums[lt] &lt; pivot:                lt += 1            while lt &lt;= rt and nums[rt] &gt; pivot:                rt -= 1            if lt &gt; rt:                break            nums[lt], nums[rt] = nums[rt], nums[lt]            lt += 1            rt -= 1        nums[left], nums[rt] = nums[rt], nums[left]        return rtif __name__ == '__main__':    solution = Solution()    array = [3, 2, 1]    print(solution.findKthLargest(array, 2))    from typing import Listimport randomclass Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        size = len(nums)        target = size - k        left = 0        right = size - 1        while True:            index = self.__partition(nums, left, right)            if index == target:                return nums[index]            elif index &lt; target:                # 下一轮在 [index + 1, right] 里找                left = index + 1            else:                right = index - 1'''parition 的操作 在之前遍历的过程中 将等于 pivot 的元素分散到两边在循环中，保持的循环不变量是：    # [left + 1, lt） &lt;= pivot    # (rt, right] &gt;= pivot因此，在 partition 的最后，需要将 left 位置与 rt 位置交换，交换以后就能得到：[left, rt - 1] &lt; pivot，nums[rt] = pivot ，[rt + 1, right] &gt;= pivot ，rt 位置就是 pivot 在排序以后应该呆的位置。'''    def __partition(self, nums, left, right):        # randint 是包括左右区间的        random_index = random.randint(left, right)        nums[random_index], nums[left] = nums[left], nums[random_index]        pivot = nums[left]        lt = left + 1        rt = right        while True:            while lt &lt;= rt and nums[lt] &lt; pivot:                lt += 1            while lt &lt;= rt and nums[rt] &gt; pivot:                rt -= 1            if lt &gt; rt:                break            nums[lt], nums[rt] = nums[rt], nums[lt]            lt += 1            rt -= 1        nums[left], nums[rt] = nums[rt], nums[left]        return rtif __name__ == '__main__':    solution = Solution()    array = [3, 2, 1]    print(solution.findKthLargest(array, 2))    # [2]\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667array = [3, 2, 1]k = 2size = 3target = size - k = 3 - 2 = 1 left = 0right = size - 1 = 3 - 1 = 2    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 0    nums[random_index] = nums[left] = nums[0] = nums[0] = 3    nums[left] = nums[random_index] = nums[0] = nums[0] = 3    pivot = nums[left] = 3    lt = left + 1 = 0 + 1 = 1    rt = right = 2    while lt = 1 &lt; rt = 2 and nums[lt] = 2 &lt; pivot = 3:    lt = lt + 1 = 2    while lt = 2 = rt = 2 and nums[lt] = 1 &lt; pivot = 3:    lt = lt + 1 = 3    while lt = 3 &gt; rt = 2 and     退出循环    while lt = 3 &gt; rt = 2 and     不进入循环    if lt &gt; rt:    break    nums[left] = nums[rt] = nums[0] = nums[2] = 3    nums[rt] = nums[left] = nums[2] = nums[0] = 1    [1, 2, 3]    return rt    index = rt = 2 &gt; target    right = index - 1 = 2 - 1 = 1    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 0    nums[random_index] = nums[left] = nums[0] = nums[0] = 3    nums[left] = nums[random_index] = nums[0] = nums[0] = 1    pivot = nums[left] = 1    lt = left + 1 = 0 + 1 = 1    rt = right = 1    lt = rt and nums[rt] = nums[1] = 2 &gt; pivot = 1:    rt = rt - 1 = 0    lt = 1 &gt; rt  = 0 and     break    nums[left] = nums[rt] = nums[0] = nums[0] = 1    nums[rt] = nums[left] = nums[0] = nums[0] = 1    [1, 2, 3]    return rt    index = rt = 0 &lt; target = 1    left = index + 1 = 0 + 1 = 1    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 1    nums[random_index] = nums[left] = nums[1] = nums[1] = 2    nums[left] = nums[random_index] = nums[1] = nums[1] = 2    pivot = nums[left] = 2    lt = left + 1 = 1 + 1 = 2    rt = right = 1    lt &gt; rt and     break    nums[left] = nums[rt] = nums[1] = nums[1] = 2    nums[left] = nums[rt] = nums[1] = nums[1] = 2    [1, 2, 3]    切分元素 pivot = 3 交换到它排序以后最终确定的位置上    return rt    index = rt = 1 = target = 1    return nums[index] = nums[1] = array = [3, 2, 1]k = 2size = 3target = size - k = 3 - 2 = 1 left = 0right = size - 1 = 3 - 1 = 2    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 0    nums[random_index] = nums[left] = nums[0] = nums[0] = 3    nums[left] = nums[random_index] = nums[0] = nums[0] = 3    pivot = nums[left] = 3    lt = left + 1 = 0 + 1 = 1    rt = right = 2    while lt = 1 &lt; rt = 2 and nums[lt] = 2 &lt; pivot = 3:    lt = lt + 1 = 2    while lt = 2 = rt = 2 and nums[lt] = 1 &lt; pivot = 3:    lt = lt + 1 = 3    while lt = 3 &gt; rt = 2 and     退出循环    while lt = 3 &gt; rt = 2 and     不进入循环    if lt &gt; rt:    break    nums[left] = nums[rt] = nums[0] = nums[2] = 3    nums[rt] = nums[left] = nums[2] = nums[0] = 1    [1, 2, 3]    return rt    index = rt = 2 &gt; target    right = index - 1 = 2 - 1 = 1    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 0    nums[random_index] = nums[left] = nums[0] = nums[0] = 3    nums[left] = nums[random_index] = nums[0] = nums[0] = 1    pivot = nums[left] = 1    lt = left + 1 = 0 + 1 = 1    rt = right = 1    lt = rt and nums[rt] = nums[1] = 2 &gt; pivot = 1:    rt = rt - 1 = 0    lt = 1 &gt; rt  = 0 and     break    nums[left] = nums[rt] = nums[0] = nums[0] = 1    nums[rt] = nums[left] = nums[0] = nums[0] = 1    [1, 2, 3]    return rt    index = rt = 0 &lt; target = 1    left = index + 1 = 0 + 1 = 1    self.__partition(nums, left, right)    random_index = random.randint(left, right) = 1    nums[random_index] = nums[left] = nums[1] = nums[1] = 2    nums[left] = nums[random_index] = nums[1] = nums[1] = 2    pivot = nums[left] = 2    lt = left + 1 = 1 + 1 = 2    rt = right = 1    lt &gt; rt and     break    nums[left] = nums[rt] = nums[1] = nums[1] = 2    nums[left] = nums[rt] = nums[1] = nums[1] = 2    [1, 2, 3]    切分元素 pivot = 3 交换到它排序以后最终确定的位置上    return rt    index = rt = 1 = target = 1    return nums[index] = nums[1] = 2\n双指针是同向出发的吧，参考代码 2 和参考代码 3 是一样的，这种写法使得 \n+ 1, j] &lt; nums[left] ```，```[j + 1, right] &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364前后两个指针一边往中间走一边交换的双指针，把等于 nums[left] 的元素平均分到了区间的两边，递归树相对是平衡的。它们就这点区别。我觉得您这种写法会有冗余操作。就拿这 个测试案例[3,2,1,5,6,4] 2来说，您的参考代码2第一次分区需要4次交换操作，而双指针向中间的写法，应该只需要最后一次交换就可以了。参考代码 2 和参考代码 3 是认识 partition 的第 1 步，并且是不怎么好的写法。至于它多做了一些交换，这个正如您所说，跟输入数据具体的样子有关。对于一类数据是不好的，对于另一类数据又是好的，如果后面遍历到的元素都是 pivot 大，那么一次都不需要交换，具体的评估可能还有点复杂然后才是双指针的写法，法三确定数据量的情况下寻找第K大的数，用快速选择的算法，快排中的轴值计算在分解的过程当中，我们会对子数组进行划分，  1. 如果某次划分得到的 index 正好就是倒数第 k 个下标的时候，就直接返回 a[index]；  2. 否则，如果 index 比目标下标小，就递归右子区间，  3. 否则递归左子区间。  这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。至于 a[left⋯j−1] 和 a[j+1⋯right] 是否是有序的，我们不关心。一开始是n个比对，然后你选的数是第 a 个，然后就缩小了范围(left, index), (index, right)，接下来如果k 在(index, right)之间就只要再比对(index, right)次，然后递归下去，可以发现如果是平均分的话差不多就是比对n个然后是n/2 ，n/4，...,n/2^m 加起来不会超过2n，当然了这是要分配比较均匀的情况。上面用了随机分片就一般不会出现全都是n-1这种情况了```pyfrom typing import Listimport randomclass Solution:    def quickSelect(self, a, l, r, target):        index = self.randomPartition(a, l, r)        if index == target:            return a[index]        elif index < target:            return self.quickSelect(a, index + 1, r, target)        else:            return self.quickSelect(a, l, index - 1, target)    def randomPartition(self, a, l, r):        i = random.randint(l, r)        # 将随机数先放在[l,r]最右边a[r]上        a[i], a[r] = a[r], a[i]        return self.partition(a, l, r)    def partition(self, a, l, r):        # 在调用当前方法的randomPartition方法中，已经确定了了随机数是nums[r]        pivot = a[r]        i = l - 1        # nums[j] 小于 随机数 pivot 的数都跟[l,r]左边区间交换        for j in range(l, r):            if a[j] < pivot:                i += 1                a[i], a[j] = a[j], a[i]        # 这个for循环操作就是将小于 pivot 的数都往[i, j]的左边区间设置，        # 从而实现存在[l, i]区间,使得对应数值都 小于 pivot        # 现在将pivot也就是nums[r] 跟nums[i+1]交换，从而分成两个区间[l，i+1]左, [i+2, r]右，左边区间的值都小于pivot        i += 1        a[i], a[r] = a[r], a[i]        return i    def findKthLargest(self, nums, k):        return self.quickSelect(nums, 0, len(nums) - 1, len(nums) - k)\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384array = [3, 2, 1, 5, 6, 4]k = 2self.quickSelect(nums, 0, len(nums) - 1, len(nums) - k)quickSelect(self, a, l, r, target)a = [3, 2, 1, 5, 6, 4]l = 0r = len(nums) - 1 = 6 - 1 = 5 target = len(nums) - k = 6 - 2 = 4self.randomPartition(a, l, r)i = 0a[i] = a[r] = a[0] = a[5] = 4a[r] = a[i] = a[5] = a[0] = 3[4, 2, 1, 5, 6, 3]return self.partition(a, l, r)pivot = a[r] = 3i = l - 1 = -1for j in range(l, r):    j = 0    a[j] = a[0] = 4 &gt; pivot = 3:    j = 1    a[j] = a[1] = 2 &lt; pivot = 3:    i = i + 1 = -1 + 1 = 0    a[i] = a[j] = a[0] = a[1] = 2    a[j] = a[i] = a[1] = a[0] = 4    [2, 4, 1, 5, 6, 3]    j = 2    a[j] = a[2] = 1 &lt; pivot = 3:    i = i + 1 = 0 + 1 = 1    a[i] = a[j] = a[1] = a[2] = 1    a[j] = a[i] = a[2] = a[1] = 4    [2, 1, 4, 5, 6, 3]    j = 3    a[j] = a[3] = 5 &gt; pivot = 3:    j = 4    a[j] = a[4] = 6 &gt; pivot = 3:i = i + 1 = 2a[i] = a[r] = a[2] = a[5] = 3a[r] = a[i] = a[5] = a[2] = 4[2, 1, 3, 5, 6, 4]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return i index = i = 2 &lt; target = 4return self.quickSelect(a, index + 1, r, target)quickSelect(self, a, l, r, target)a = [2, 1, 3, 5, 6, 4]l = 3r = 5target = 4self.randomPartition(a, l, r)i = 3a[i] = a[r] = a[3] = a[5] = 4a[r] = a[i] = a[5] = a[3] = 5[2, 1, 3, 4, 6, 5]return self.partition(a, l, r)pivot = a[5] = 6i = l - 1 = 2for j in range(l, r):    j = 3    a[j] = a[3] = 4 &lt; pivot = 5:    i = i + 1 = 2 + 1 = 3    a[i] = a[j] = a[3] = a[3] = 4    a[j] = a[i] = a[3] = a[3] = 4    [2, 1, 3, 4, 6, 5]    j = 4    a[j] = a[4] = 6 &gt; pivot = 5:i = i + 1 = 3 + 1 = 4a[i] = a[r] = a[4] = a[5] = 5a[r] = a[i] = a[5] = a[4] = 6[2, 1, 3, 4, 5, 6]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return i index = i = 4 = targetreturn a[index] = array = [3, 2, 1, 5, 6, 4]k = 2self.quickSelect(nums, 0, len(nums) - 1, len(nums) - k)quickSelect(self, a, l, r, target)a = [3, 2, 1, 5, 6, 4]l = 0r = len(nums) - 1 = 6 - 1 = 5 target = len(nums) - k = 6 - 2 = 4self.randomPartition(a, l, r)i = 0a[i] = a[r] = a[0] = a[5] = 4a[r] = a[i] = a[5] = a[0] = 3[4, 2, 1, 5, 6, 3]return self.partition(a, l, r)pivot = a[r] = 3i = l - 1 = -1for j in range(l, r):    j = 0    a[j] = a[0] = 4 &gt; pivot = 3:    j = 1    a[j] = a[1] = 2 &lt; pivot = 3:    i = i + 1 = -1 + 1 = 0    a[i] = a[j] = a[0] = a[1] = 2    a[j] = a[i] = a[1] = a[0] = 4    [2, 4, 1, 5, 6, 3]    j = 2    a[j] = a[2] = 1 &lt; pivot = 3:    i = i + 1 = 0 + 1 = 1    a[i] = a[j] = a[1] = a[2] = 1    a[j] = a[i] = a[2] = a[1] = 4    [2, 1, 4, 5, 6, 3]    j = 3    a[j] = a[3] = 5 &gt; pivot = 3:    j = 4    a[j] = a[4] = 6 &gt; pivot = 3:i = i + 1 = 2a[i] = a[r] = a[2] = a[5] = 3a[r] = a[i] = a[5] = a[2] = 4[2, 1, 3, 5, 6, 4]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return i index = i = 2 &lt; target = 4return self.quickSelect(a, index + 1, r, target)quickSelect(self, a, l, r, target)a = [2, 1, 3, 5, 6, 4]l = 3r = 5target = 4self.randomPartition(a, l, r)i = 3a[i] = a[r] = a[3] = a[5] = 4a[r] = a[i] = a[5] = a[3] = 5[2, 1, 3, 4, 6, 5]return self.partition(a, l, r)pivot = a[5] = 6i = l - 1 = 2for j in range(l, r):    j = 3    a[j] = a[3] = 4 &lt; pivot = 5:    i = i + 1 = 2 + 1 = 3    a[i] = a[j] = a[3] = a[3] = 4    a[j] = a[i] = a[3] = a[3] = 4    [2, 1, 3, 4, 6, 5]    j = 4    a[j] = a[4] = 6 &gt; pivot = 5:i = i + 1 = 3 + 1 = 4a[i] = a[r] = a[4] = a[5] = 5a[r] = a[i] = a[5] = a[4] = 6[2, 1, 3, 4, 5, 6]切分元素 pivot = 3 交换到它排序以后最终确定的位置上return i index = i = 4 = targetreturn a[index] = 5\n\n1234567891011121314151617181920212223242526class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        def partition(nums, left, right):            pivot = nums[right]            i = left            for j in range(left, right + 1):                if nums[j] &lt; pivot:                    nums[i], nums[j] = nums[j], nums[i]                    i += 1            nums[i], nums[right] = nums[right], nums[i]            return i        n = len(nums)        t = n - k        #        if not (0&lt;= t &lt;= n-1):        #            return        left, right = 0, n - 1        while left &lt; right:  # 若设置成 left &lt; right 如果下面没有语句的话，可能会漏解， 例如 [3]            ind = partition(nums, left, right)            if ind == t:                return nums[ind]            elif ind &lt; t:                left = ind + 1            else:                right = ind - 1        return nums[left]  class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        def partition(nums, left, right):            pivot = nums[right]            i = left            for j in range(left, right + 1):                if nums[j] &lt; pivot:                    nums[i], nums[j] = nums[j], nums[i]                    i += 1            nums[i], nums[right] = nums[right], nums[i]            return i        n = len(nums)        t = n - k        #        if not (0&lt;= t &lt;= n-1):        #            return        left, right = 0, n - 1        while left &lt; right:  # 若设置成 left &lt; right 如果下面没有语句的话，可能会漏解， 例如 [3]            ind = partition(nums, left, right)            if ind == t:                return nums[ind]            elif ind &lt; t:                left = ind + 1            else:                right = ind - 1        return nums[left]  # 对应前面 left<right, 若前面设置为 left <= right, 则不用此语句\n\n\n方法二：基于堆排序的选择方法思路和算法我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k - 1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。\n时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)，因为 k &lt; n，故渐进时间复杂为 O(n+klogn)=O(nlogn)。空间复杂度：O(logn)，即递归使用栈空间的空间代价。\n123456789101112131415161718192021222324252627282930313233343536373839from typing import Listimport randomclass Solution:    def maxHeapify(self, a, i, heapSize):        l = i * 2 + 1        r = i * 2 + 2        largest = i        if l &lt; heapSize and a[l] &gt; a[largest]:            largest = l        if r &lt; heapSize and a[r] &gt; a[largest]:            largest = r        if largest != i:            a[i], a[largest] = a[largest], a[i]            self.maxHeapify(a, largest, heapSize)    def buildMaxHeap(self, a, heapSize):  # 由列表建立大根堆            \"\"\"\"从后往前遍历所有内部节点，其中最后一个内部节点的公式为len(nums_list)//2 - 1\"\"\"        # 从最后一个非叶子节点开始堆化        # 从最后一个非叶子节点开始构建大根堆, len(heap)//2 - 1就是最后一个非叶子节点        for i in range(heapSize // 2, -1, -1):            self.maxHeapify(a, i, heapSize)    def findKthLargest(self, nums, k):        heapSize = len(nums)        self.buildMaxHeap(nums, heapSize)        for i in range(len(nums) - 1, len(nums) - k, -1):            nums[0], nums[i] = nums[i], nums[0]            heapSize -= 1            self.maxHeapify(nums, 0, heapSize)        return nums[0]if __name__ == '__main__':    solution = Solution()    array = [3, 2, 3, 1, 2, 4, 5, 5, 6]    print(solution.findKthLargest(array, 4))    from typing import Listimport randomclass Solution:    def maxHeapify(self, a, i, heapSize):        l = i * 2 + 1        r = i * 2 + 2        largest = i        if l &lt; heapSize and a[l] &gt; a[largest]:            largest = l        if r &lt; heapSize and a[r] &gt; a[largest]:            largest = r        if largest != i:            a[i], a[largest] = a[largest], a[i]            self.maxHeapify(a, largest, heapSize)    def buildMaxHeap(self, a, heapSize):  # 由列表建立大根堆            \"\"\"\"从后往前遍历所有内部节点，其中最后一个内部节点的公式为len(nums_list)//2 - 1\"\"\"        # 从最后一个非叶子节点开始堆化        # 从最后一个非叶子节点开始构建大根堆, len(heap)//2 - 1就是最后一个非叶子节点        for i in range(heapSize // 2, -1, -1):            self.maxHeapify(a, i, heapSize)    def findKthLargest(self, nums, k):        heapSize = len(nums)        self.buildMaxHeap(nums, heapSize)        for i in range(len(nums) - 1, len(nums) - k, -1):            nums[0], nums[i] = nums[i], nums[0]            heapSize -= 1            self.maxHeapify(nums, 0, heapSize)        return nums[0]if __name__ == '__main__':    solution = Solution()    array = [3, 2, 3, 1, 2, 4, 5, 5, 6]    print(solution.findKthLargest(array, 4))    # 5\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269array = [3, 2, 3, 1, 2, 4, 5, 5, 6]findKthLargest(self, nums, k)findKthLargest(array, 2)nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]k = 4heapSize = 9self.buildMaxHeap(nums, heapSize)buildMaxHeap(self, a, heapSize):for i in range(heapSize // 2, -1, -1):for i in range(4, -1, -1):    i = 4    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 9    r = i * 2 + 2 = 10    largest = i = 4    l = 9 = heapSize     i = 3    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 5 &gt; a[largest] = a[3] = 1     largest = l = 7    a[r] = a[8] = 6 &gt; a[largest] = a[7] = 5     largest = r = 8 != i = 3    a[i] = a[largest] = a[3] = a[8] = 6    a[largest] = a[i] = a[7] = a[3] = 1    a = [3, 2, 3, 6, 2, 4, 5, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize)    i = largest = 8    l = i * 2 + 1 = 17    r = i * 2 + 2 = 18    largest = i = 8    l = 17 &gt; heapSize = 9    largest = 8 = i    i = 2    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 9    a[l] = a[5] = 4 &gt; a[largest] = a[2] = 3     largest = l = 5    a[r] = a[6] = 5 &gt; a[largest] = a[5] = 4     largest = r = 6 != i = 2    a[i] = a[largest] = a[2] = a[6] = 5    a[largest] = a[i] = a[6] = a[2] = 3    a = [3, 2, 5, 6, 2, 4, 3, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 6    l = i * 2 + 1 = 13    r = i * 2 + 2 = 14    largest = i = 6    l = 13 &gt; heapSize = 9    largest = 6 = i    i = 1    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 9    a[l] = a[3] = 6 &gt; a[largest] = a[1] = 2     largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 6     largest = 3 != i = 1    a[i] = a[largest] = a[1] = a[3] = 6    a[largest] = a[i] = a[3] = a[1] = 2    a = [3, 6, 5, 2, 2, 4, 3, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 5 &gt; a[largest] = a[3] = 2     largest = l = 7    a[r] = a[8] = 1 &lt; a[largest] = a[7] = 5     largest = l = 7 != i = 3    a[i] = a[largest] = a[3] = a[7] = 5    a[largest] = a[i] = a[7] = a[3] = 2    [3, 6, 5, 5, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 7    l = i * 2 + 1 = 15    r = i * 2 + 2 = 16    largest = i = 6    l = 15 &gt; heapSize = 9    largest = 7 = i    i = 0    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 9    a[l] = a[1] = 6 &gt; a[largest] = a[0] = 3     largest = l = 1    a[r] = a[2] = 5 &lt; a[largest] = a[1] = 6    largest = l = 1 != i = 0     a[i] = a[largest] = a[0] = a[1] = 6    a[largest] = a[i] = a[1] = a[0] = 3    a = [6, 3, 5, 5, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 1    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 9    a[l] = a[3] = 5 &gt; a[largest] = a[1] = 3     largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 5     largest = 3 != i = 1    a[i] = a[largest] = a[1] = a[3] = 5    a[largest] = a[i] = a[3] = a[1] = 3    a = [6, 5, 5, 3, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 2 &lt; a[largest] = a[3] = 3    a[r] = a[8] = 1 &lt; a[largest] = a[3] = 3     largest = 3 = i for i in range(len(nums) - 1, len(nums) - k, -1):for i in range(9 - 1, 9 - 4, -1):for i in range(8, 5, -1):    i = 8     nums[0] = nums[i] = a[8] = 1     nums[i] = nums[8] = a[0] = 6     [1, 5, 5, 3, 2, 4, 3, 2, 6]    heapSize = heapSize - 1 = 8    [1, 5, 5, 3, 2, 4, 3, 2] 去掉a[8]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 8    a[l] = a[1] = 5 &gt; a[largest] = a[0] = 1    largest = l = 1    a[r] = a[2] = 5 = a[largest] = a[1] = 5     largest = 1 != i = 0    a[i] = a[largest] = a[0] = a[1] = 5    a[largest] = a[i] = a[1] = a[0] = 1    a = [5, 1, 5, 3, 2, 4, 3, 2]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 1    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 8    a[l] = a[3] = 3 &gt; a[largest] = a[1] = 1    largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 3     largest = 3 != i = 1     a[i] = a[largest] = a[1] = a[3] = 3    a[largest] = a[i] = a[3] = a[1] = 1    a = [5, 3, 5, 1, 2, 4, 3, 2]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 8    a[l] = a[7] = 2 &gt; a[largest] = a[3] = 1    largest = l = 7    a[r] = a[8]不存在    largest = 7 != i = 3     a[i] = a[largest] = a[3] = a[7] = 2    a[largest] = a[i] = a[7] = a[3] = 1    a = [5, 3, 5, 2, 2, 4, 3, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 7    l = i * 2 + 1 = 15    r = i * 2 + 2 = 16    largest = i = 7    l = 15 &gt; heapSize = 8     largest = 7 = i     i = 7     nums[0] = nums[i] = a[7] = 1     nums[i] = nums[7] = a[0] = 5     [1, 3, 5, 2, 2, 4, 3, 5]    heapSize = heapSize - 1 = 7    [1, 3, 5, 2, 2, 4, 3] 去掉a[7]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 7    a[l] = a[1] = 3 &gt; a[largest] = a[0] = 1    largest = l = 0    a[r] = a[2] = 5 &gt; a[largest] = a[1] = 3     largest = r = 2 != i = 0    a[i] = a[largest] = a[0] = a[2] = 5    a[largest] = a[i] = a[2] = a[0] = 1    a = [5, 3, 1, 2, 2, 4, 3]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 2    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 7    a[l] = a[5] = 4 &gt; a[largest] = a[2] = 1    largest = l = 5    a[r] = a[6] = 3 &lt; a[largest] = a[5] = 4     largest = 5 != i = 2     a[i] = a[largest] = a[2] = a[5] = 4    a[largest] = a[i] = a[5] = a[2] = 1    a = [5, 3, 4, 2, 2, 1, 3]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 5    l = i * 2 + 1 = 11    r = i * 2 + 2 = 12    largest = i = 5    l = 11 &gt; heapSize = 7    largest = 5 = i    i = 6     nums[0] = nums[i] = a[6] = 3     nums[i] = nums[6] = a[0] = 5     [3, 3, 4, 2, 2, 1, 5]    heapSize = heapSize - 1 = 6    [3, 3, 4, 2, 2, 1] 去掉a[6]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 6    a[l] = a[1] = 3 = a[largest] = a[0] = 3    a[r] = a[2] = 4 &gt; a[largest] = a[0] = 3     largest = r = 2 != i = 0    a[i] = a[largest] = a[0] = a[2] = 4    a[largest] = a[i] = a[2] = a[0] = 3    a = [4, 3, 3, 2, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 2    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 7    a[l] = a[5] = 1 &lt; a[largest] = a[2] = 3    a[r] = a[6]不存在    largest = ireturn nums[0] = array = [3, 2, 3, 1, 2, 4, 5, 5, 6]findKthLargest(self, nums, k)findKthLargest(array, 2)nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]k = 4heapSize = 9self.buildMaxHeap(nums, heapSize)buildMaxHeap(self, a, heapSize):for i in range(heapSize // 2, -1, -1):for i in range(4, -1, -1):    i = 4    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 9    r = i * 2 + 2 = 10    largest = i = 4    l = 9 = heapSize     i = 3    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 5 &gt; a[largest] = a[3] = 1     largest = l = 7    a[r] = a[8] = 6 &gt; a[largest] = a[7] = 5     largest = r = 8 != i = 3    a[i] = a[largest] = a[3] = a[8] = 6    a[largest] = a[i] = a[7] = a[3] = 1    a = [3, 2, 3, 6, 2, 4, 5, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize)    i = largest = 8    l = i * 2 + 1 = 17    r = i * 2 + 2 = 18    largest = i = 8    l = 17 &gt; heapSize = 9    largest = 8 = i    i = 2    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 9    a[l] = a[5] = 4 &gt; a[largest] = a[2] = 3     largest = l = 5    a[r] = a[6] = 5 &gt; a[largest] = a[5] = 4     largest = r = 6 != i = 2    a[i] = a[largest] = a[2] = a[6] = 5    a[largest] = a[i] = a[6] = a[2] = 3    a = [3, 2, 5, 6, 2, 4, 3, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 6    l = i * 2 + 1 = 13    r = i * 2 + 2 = 14    largest = i = 6    l = 13 &gt; heapSize = 9    largest = 6 = i    i = 1    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 9    a[l] = a[3] = 6 &gt; a[largest] = a[1] = 2     largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 6     largest = 3 != i = 1    a[i] = a[largest] = a[1] = a[3] = 6    a[largest] = a[i] = a[3] = a[1] = 2    a = [3, 6, 5, 2, 2, 4, 3, 5, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 5 &gt; a[largest] = a[3] = 2     largest = l = 7    a[r] = a[8] = 1 &lt; a[largest] = a[7] = 5     largest = l = 7 != i = 3    a[i] = a[largest] = a[3] = a[7] = 5    a[largest] = a[i] = a[7] = a[3] = 2    [3, 6, 5, 5, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 7    l = i * 2 + 1 = 15    r = i * 2 + 2 = 16    largest = i = 6    l = 15 &gt; heapSize = 9    largest = 7 = i    i = 0    self.maxHeapify(a, i, heapSize)    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 9    a[l] = a[1] = 6 &gt; a[largest] = a[0] = 3     largest = l = 1    a[r] = a[2] = 5 &lt; a[largest] = a[1] = 6    largest = l = 1 != i = 0     a[i] = a[largest] = a[0] = a[1] = 6    a[largest] = a[i] = a[1] = a[0] = 3    a = [6, 3, 5, 5, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 1    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 9    a[l] = a[3] = 5 &gt; a[largest] = a[1] = 3     largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 5     largest = 3 != i = 1    a[i] = a[largest] = a[1] = a[3] = 5    a[largest] = a[i] = a[3] = a[1] = 3    a = [6, 5, 5, 3, 2, 4, 3, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 9    a[l] = a[7] = 2 &lt; a[largest] = a[3] = 3    a[r] = a[8] = 1 &lt; a[largest] = a[3] = 3     largest = 3 = i for i in range(len(nums) - 1, len(nums) - k, -1):for i in range(9 - 1, 9 - 4, -1):for i in range(8, 5, -1):    i = 8     nums[0] = nums[i] = a[8] = 1     nums[i] = nums[8] = a[0] = 6     [1, 5, 5, 3, 2, 4, 3, 2, 6]    heapSize = heapSize - 1 = 8    [1, 5, 5, 3, 2, 4, 3, 2] 去掉a[8]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 8    a[l] = a[1] = 5 &gt; a[largest] = a[0] = 1    largest = l = 1    a[r] = a[2] = 5 = a[largest] = a[1] = 5     largest = 1 != i = 0    a[i] = a[largest] = a[0] = a[1] = 5    a[largest] = a[i] = a[1] = a[0] = 1    a = [5, 1, 5, 3, 2, 4, 3, 2]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 1    l = i * 2 + 1 = 3    r = i * 2 + 2 = 4    largest = i = 1    l = 3 &lt; heapSize = 8    a[l] = a[3] = 3 &gt; a[largest] = a[1] = 1    largest = l = 3    a[r] = a[4] = 2 &lt; a[largest] = a[3] = 3     largest = 3 != i = 1     a[i] = a[largest] = a[1] = a[3] = 3    a[largest] = a[i] = a[3] = a[1] = 1    a = [5, 3, 5, 1, 2, 4, 3, 2]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 3    l = i * 2 + 1 = 7    r = i * 2 + 2 = 8    largest = i = 3    l = 7 &lt; heapSize = 8    a[l] = a[7] = 2 &gt; a[largest] = a[3] = 1    largest = l = 7    a[r] = a[8]不存在    largest = 7 != i = 3     a[i] = a[largest] = a[3] = a[7] = 2    a[largest] = a[i] = a[7] = a[3] = 1    a = [5, 3, 5, 2, 2, 4, 3, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 7    l = i * 2 + 1 = 15    r = i * 2 + 2 = 16    largest = i = 7    l = 15 &gt; heapSize = 8     largest = 7 = i     i = 7     nums[0] = nums[i] = a[7] = 1     nums[i] = nums[7] = a[0] = 5     [1, 3, 5, 2, 2, 4, 3, 5]    heapSize = heapSize - 1 = 7    [1, 3, 5, 2, 2, 4, 3] 去掉a[7]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 7    a[l] = a[1] = 3 &gt; a[largest] = a[0] = 1    largest = l = 0    a[r] = a[2] = 5 &gt; a[largest] = a[1] = 3     largest = r = 2 != i = 0    a[i] = a[largest] = a[0] = a[2] = 5    a[largest] = a[i] = a[2] = a[0] = 1    a = [5, 3, 1, 2, 2, 4, 3]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 2    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 7    a[l] = a[5] = 4 &gt; a[largest] = a[2] = 1    largest = l = 5    a[r] = a[6] = 3 &lt; a[largest] = a[5] = 4     largest = 5 != i = 2     a[i] = a[largest] = a[2] = a[5] = 4    a[largest] = a[i] = a[5] = a[2] = 1    a = [5, 3, 4, 2, 2, 1, 3]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 5    l = i * 2 + 1 = 11    r = i * 2 + 2 = 12    largest = i = 5    l = 11 &gt; heapSize = 7    largest = 5 = i    i = 6     nums[0] = nums[i] = a[6] = 3     nums[i] = nums[6] = a[0] = 5     [3, 3, 4, 2, 2, 1, 5]    heapSize = heapSize - 1 = 6    [3, 3, 4, 2, 2, 1] 去掉a[6]    self.maxHeapify(nums, 0, heapSize)    maxHeapify(self, a, i, heapSize):    i = 0    l = i * 2 + 1 = 1    r = i * 2 + 2 = 2    largest = i = 0    l = 1 &lt; heapSize = 6    a[l] = a[1] = 3 = a[largest] = a[0] = 3    a[r] = a[2] = 4 &gt; a[largest] = a[0] = 3     largest = r = 2 != i = 0    a[i] = a[largest] = a[0] = a[2] = 4    a[largest] = a[i] = a[2] = a[0] = 3    a = [4, 3, 3, 2, 2, 1]    self.maxHeapify(a, largest, heapSize)    maxHeapify(self, a, i, heapSize):    i = largest = 2    l = i * 2 + 1 = 5    r = i * 2 + 2 = 6    largest = i = 2    l = 5 &lt; heapSize = 7    a[l] = a[5] = 1 &lt; a[largest] = a[2] = 3    a[r] = a[6]不存在    largest = ireturn nums[0] = 4\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158array = [3, 2, 3, 1, 2, 4, 5, 5, 6]构建大根堆：存入完全二叉树先按照顺序将该数组元素构建成一棵完全二叉树            3           /  \\          2    3         / \\  / \\        1  2 4   5       / \\      5   6从第一个非叶子节点为根节点的子树开始，将其调整为大根堆            3           /  \\          2    3         / \\  / \\        6  2 4   5       / \\      5   1调整倒数第二个非叶子节点作为根节点的子树            3           /  \\          2    5         / \\  / \\        6  2 4   3       / \\      5   1调整倒数第三个非叶子节点作为根节点的子树            3           /  \\          6    5         / \\  / \\        2  2 4   3       / \\      5   1                  3           /  \\          6    5         / \\  / \\        5  2 4   3       / \\      2   1调整倒数第四个非叶子节点作为根节点的子树            6           /  \\          3    5         / \\  / \\        5  2 4   3       / \\      2   1            6           /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2   1第一次删除k = 4，删除3次堆顶元素                       /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2   1先将末尾节点1补充到堆顶位置,再进行调整            1           /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2               5           /  \\          1    5         / \\  / \\        3  2 4   3       / \\      2  开始调整，已删除1次            5           /  \\          3    5         / \\  / \\        1  2 4   3       / \\      2              5           /  \\          3    5         / \\  / \\        2  2 4   3       / \\      1  调整完成，已删除1次 第2次删除           /  \\          3    5         / \\  / \\        2  2 4   3       / \\      1将末尾节点1补充到堆顶位置            1           /  \\          3    5         / \\  / \\        2  2 4   3       / \\再进行调整                 5           /  \\          3    1         / \\  / \\        2  2 4   3       / \\            5           /  \\          3    4         / \\  / \\        2  2 1   3       / \\第3次删除                       /  \\          3    4         / \\  / \\        2  2 1   3将末尾节点3补充到堆顶位置,            3           /  \\          3    4         / \\  / \\        2  2 1   再进行调整            4           /  \\          3    3         / \\  / \\        2  2 1   调整完成,已删除3次返回堆顶元素 array = [3, 2, 3, 1, 2, 4, 5, 5, 6]构建大根堆：存入完全二叉树先按照顺序将该数组元素构建成一棵完全二叉树            3           /  \\          2    3         / \\  / \\        1  2 4   5       / \\      5   6从第一个非叶子节点为根节点的子树开始，将其调整为大根堆            3           /  \\          2    3         / \\  / \\        6  2 4   5       / \\      5   1调整倒数第二个非叶子节点作为根节点的子树            3           /  \\          2    5         / \\  / \\        6  2 4   3       / \\      5   1调整倒数第三个非叶子节点作为根节点的子树            3           /  \\          6    5         / \\  / \\        2  2 4   3       / \\      5   1                  3           /  \\          6    5         / \\  / \\        5  2 4   3       / \\      2   1调整倒数第四个非叶子节点作为根节点的子树            6           /  \\          3    5         / \\  / \\        5  2 4   3       / \\      2   1            6           /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2   1第一次删除k = 4，删除3次堆顶元素                       /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2   1先将末尾节点1补充到堆顶位置,再进行调整            1           /  \\          5    5         / \\  / \\        3  2 4   3       / \\      2               5           /  \\          1    5         / \\  / \\        3  2 4   3       / \\      2  开始调整，已删除1次            5           /  \\          3    5         / \\  / \\        1  2 4   3       / \\      2              5           /  \\          3    5         / \\  / \\        2  2 4   3       / \\      1  调整完成，已删除1次 第2次删除           /  \\          3    5         / \\  / \\        2  2 4   3       / \\      1将末尾节点1补充到堆顶位置            1           /  \\          3    5         / \\  / \\        2  2 4   3       / \\再进行调整                 5           /  \\          3    1         / \\  / \\        2  2 4   3       / \\            5           /  \\          3    4         / \\  / \\        2  2 1   3       / \\第3次删除                       /  \\          3    4         / \\  / \\        2  2 1   3将末尾节点3补充到堆顶位置,            3           /  \\          3    4         / \\  / \\        2  2 1   再进行调整            4           /  \\          3    3         / \\  / \\        2  2 1   调整完成,已删除3次返回堆顶元素 4\n\n\n1234567891011121314151617181920212223242526272829303132333435class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        def adju_max_heap(nums_list, in_node):  # 从当前内部节点处修正大根堆            \"\"\"\"in_node是内部节点的索引\"\"\"            l, r, large_idx= 2*in_node+1, 2*in_node+2, in_node  # 最大值的索引默认为该内部节点            if l &lt; len(nums_list) and nums_list[large_idx] &lt; nums[l]:                  # 如果左孩子值大于该内部节点的值，则最大值索引指向左孩子                large_idx = l            if r &lt; len(nums_list) and nums_list[large_idx] &lt; nums[r]:                # 如果执行了上一个if语句，此时最大值索引指向左孩子，否则还是指向该内部节点                # 然后最大值索引指向的值和右孩子的值比较                large_idx = r            # 上述两个if就是得到(内部节点，左孩子，右孩子)中最大值的索引            if large_idx != in_node: # 如果最大值在左孩子和右孩子中，则和内部节点交换                nums_list[large_idx], nums_list[in_node] = nums_list[in_node], nums_list[large_idx]                # 如何内部节点是和左孩子交换，那就递归修正它的左子树，否则递归修正它的右子树                adju_max_heap(nums_list, large_idx)        def build_max_heap(nums_list):  # 由列表建立大根堆            \"\"\"\"从后往前遍历所有内部节点，其中最后一个内部节点的公式为len(nums_list)//2 - 1\"\"\"            # 从最后一个非叶子节点开始堆化            for in_node in range(len(nums_list)//2 - 1, -1, -1):                adju_max_heap(nums_list, in_node)                def find_kth_max(nums_list, k):  # 从列表中找到第k个最大的            build_max_heap(nums_list)  # 先建立大根堆            for _ in range(k-1):                nums_list[0], nums_list[-1] = nums_list[-1], nums_list[0]  # 堆头和堆尾交换                nums_list.pop()  # 删除堆尾                adju_max_heap(nums_list, 0)  # 从堆头处开始修正大根堆            return nums_list[0]        class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        def adju_max_heap(nums_list, in_node):  # 从当前内部节点处修正大根堆            \"\"\"\"in_node是内部节点的索引\"\"\"            l, r, large_idx= 2*in_node+1, 2*in_node+2, in_node  # 最大值的索引默认为该内部节点            if l &lt; len(nums_list) and nums_list[large_idx] &lt; nums[l]:                  # 如果左孩子值大于该内部节点的值，则最大值索引指向左孩子                large_idx = l            if r &lt; len(nums_list) and nums_list[large_idx] &lt; nums[r]:                # 如果执行了上一个if语句，此时最大值索引指向左孩子，否则还是指向该内部节点                # 然后最大值索引指向的值和右孩子的值比较                large_idx = r            # 上述两个if就是得到(内部节点，左孩子，右孩子)中最大值的索引            if large_idx != in_node: # 如果最大值在左孩子和右孩子中，则和内部节点交换                nums_list[large_idx], nums_list[in_node] = nums_list[in_node], nums_list[large_idx]                # 如何内部节点是和左孩子交换，那就递归修正它的左子树，否则递归修正它的右子树                adju_max_heap(nums_list, large_idx)        def build_max_heap(nums_list):  # 由列表建立大根堆            \"\"\"\"从后往前遍历所有内部节点，其中最后一个内部节点的公式为len(nums_list)//2 - 1\"\"\"            # 从最后一个非叶子节点开始堆化            for in_node in range(len(nums_list)//2 - 1, -1, -1):                adju_max_heap(nums_list, in_node)                def find_kth_max(nums_list, k):  # 从列表中找到第k个最大的            build_max_heap(nums_list)  # 先建立大根堆            for _ in range(k-1):                nums_list[0], nums_list[-1] = nums_list[-1], nums_list[0]  # 堆头和堆尾交换                nums_list.pop()  # 删除堆尾                adju_max_heap(nums_list, 0)  # 从堆头处开始修正大根堆            return nums_list[0]        return find_kth_max(nums, k) \n\n小根堆最多只需要k个元素在堆里，时间复杂度 O(nlogk)，在k小于n时不是更优，q 里最多就 k 个元素空间复杂度：O(k)\n123456789class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        \"\"\"使用小顶堆\"\"\"        q = []        for c in nums:            heapq.heappush(q, c)            while len(q) &gt; k:                heapq.heappop(q)        class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        \"\"\"使用小顶堆\"\"\"        q = []        for c in nums:            heapq.heappush(q, c)            while len(q) &gt; k:                heapq.heappop(q)        return heapq.heappop(q)\n\n\n\n33.数据流中的中位数 [^本题考点 树]​    题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n例如，\n[2,3,4]&nbsp;的中位数是 3\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n设计一个支持以下两种操作的数据结构：\n\nvoid addNum(int num) - 从数据流中添加一个整数到数据结构中。\ndouble findMedian() - 返回目前所有元素的中位数。示例 1：1234输入：[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,输入：[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]\n\n\n\n示例 2：\n1234输入：[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"][[],[2],[],[3],[]]输出：[null,null,2.00000,null,输入：[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000]\n\n法一：暴力\n解题思路：给定一长度为 N 的无序数组，其中位数的计算方法：数据流新进来一个数，都把它与已经读出来的数进行一次排序，（使用 O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。\n法二当从数据流中读出的数的个数为奇数的时候，中位数是“前有序数组”中的最小值当从数据流中读出的数的个数为偶数的时候，左中位数是“前有序数组”中的最小值，右中位数是“后有序数组”中的最大值前后后序大小堆谁在前面都是可以的\n我们只关心在中间的那两个数（或者一个数）这两个“有序数组”中的最值，对除了中位数以外的其它位置的元素没有必要进行 “比较” 和 “交换” 的操作。\n“中位数”把它们分为两个部分,一部分是“前有序数组”,另一部分是“后有序数组”\n借助 堆就的性质，通过树的形式减少了元素比较的次数。每次都从堆里得到一个 “最值” 而其它元素无需排序，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。\n建立一个 小顶堆 min_heap (am ..a3 a2 a1)和 大顶堆 B(b1 b2 b3.. bn) ，am &gt; ..a3 &gt; a2 &gt; a1,a1是堆顶b1 &gt; b2 &gt; b3.. &gt; bn,b1是堆顶各保存列表的一半元素，且规定：\n\n小顶堆 min_heap 保存 较大 的一半，长度为 N/2（ N 为偶数）或 (N+1)/2（ N 为奇数）；\n大顶堆 max_heap 保存 较小 的一半，长度为 N/2（ N 为偶数）或 (N-1)/2（ N 为奇数）；\n\n算法流程：设元素总数为 N = m + n ，其中 m 和 n 分别为 min_heap 和 max_heap 中的元素个数。规定添加元素时保证：\n\nm = n + 1 = (N + 1) / 2，N 为 奇数\nm = n = N / 2，N 为 偶数中位数可仅根据 min_heap, max_heap 的堆顶元素计算得到。中位数 = a1 , m != n中位数 = (a1 + b1)/2 , m = n \n\n因为它是一实时插入，也会实时计算所有数的中位数。那么一个大根堆，一个小根堆肯定是一个放一次数字，交替插入。至于先插入哪个队列都是可以的\n为什么比较长度就可以判断怎么插入两个堆咧，平衡这两个堆始终保持\n\n小根堆的长度-大根堆的长度 = 0 或者 1 \n小顶堆 min_heap 保存较大一半、 大顶堆 max_heap 保存较小一半。\n\n也可以用以优化成boolean的True False或者count变量统计当前一共有几个数字，若为奇数则先插入min_heap队列（max_heap队列），为偶数则先插入max_heap队列（min_heap队列）。 \naddNum(num) 函数： 从数据流中添加一个整数到数据结构中。\n\n当 m = n（即总数量 N 为 偶数）：需向 小顶堆 min_heap 添加一个元素。实现方法：将新元素 num 插入至大根堆 max_heap ，再弹出大根堆 max_heap 堆顶元素插入至 min_heap ；因为 num 可能属于 “较小的一半” （即属于 max_heap ），所以不能将 nums 直接插入至 min_heap 。\n\n\n当 m !=n（即 N 为 奇数）说明小根堆长度-大根堆长度=1：需向大根堆 max_heap 添加一个元素。实现方法：将新元素 num 插入至小根堆 min_heap ，再弹出 min_heap 堆顶元素插入至 max_heap ；\n\nfindMedian() 函数：返回目前所有元素的中位数。\n\n当 m = n（ N 为 偶数）：则中位数为 ( min_heap 的堆顶元素 + max_heap 的堆顶元素)/2。\n当 m !=n（ N 为 奇数）：则中位数为 min_heap 的堆顶元素。\n\n时间复杂度：O(5⋅logn)+O(1)≈O(logn).\n\n查找中位数 O(1)： 获取堆顶元素使用 O(1) 时间；\n添加数字 O(logN)： 每个数据的从堆中取出最值插入和弹出操作，优先队列会自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因查找元素插入位置 O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。最坏情况下，从顶部有三个堆插入和两个堆删除。每一个都需要花费 O(logn) 时间。找到平均值需要持续的 O(1) 时间，因为可以直接访问堆的顶部。单独的分析每个操作，addNum 和 findMedian 是只和 N 相关的，题目只是要求我们单独分析每个操作的时间复杂度。addNum 是对数复杂度， findMedian 是 O(1) 。\n\n空间复杂度 O(N)：其中 N 为数据流中的元素数量，在容器中保存输入的线性空间小顶堆 min_heap 和大顶堆 max_heap 最多同时保存 N 个元素。两个堆的空间复杂度是 O(N/2)\nPython 中 heapq 模块是小顶堆。实现 大顶堆 方法：小顶堆的插入和弹出操作均将元素 取反 即可\n123456789101112131415161718192021222324252627282930import heapqclass MedianFinder:    def __init__(self):        \"\"\"        initialize your data structure here.        \"\"\"        # 初始化大顶堆和小顶堆        self.min_heap = [] # 小顶堆，保存较大的一半        self.max_heap = [] # 大顶堆，保存较小的一半    def addNum(self, num: int) -&gt; None:        if len(self.min_heap) != len(self.max_heap):            # 总数为奇数时，先加到小顶堆，再把小堆顶元素加到大顶堆            heapq.heappush(self.min_heap, num)            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))        else:  # 总数为偶数时，先加到大顶堆，再把大堆顶元素加到小顶堆             heapq.heappush(self.max_heap, -num)            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))    def findMedian(self) -&gt; float:        if len(self.min_heap) != len(self.max_heap):             return self.min_heap[0]         else:  # 你存进B的时候，为了实现大顶堆，加了负号            return (self.min_heap[0] -self.max_heap[0]) / 2.0 # Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)import heapqclass MedianFinder:    def __init__(self):        \"\"\"        initialize your data structure here.        \"\"\"        # 初始化大顶堆和小顶堆        self.min_heap = [] # 小顶堆，保存较大的一半        self.max_heap = [] # 大顶堆，保存较小的一半    def addNum(self, num: int) -&gt; None:        if len(self.min_heap) != len(self.max_heap):            # 总数为奇数时，先加到小顶堆，再把小堆顶元素加到大顶堆            heapq.heappush(self.min_heap, num)            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))        else:  # 总数为偶数时，先加到大顶堆，再把大堆顶元素加到小顶堆             heapq.heappush(self.max_heap, -num)            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))    def findMedian(self) -&gt; float:        if len(self.min_heap) != len(self.max_heap):             return self.min_heap[0]         else:  # 你存进B的时候，为了实现大顶堆，加了负号            return (self.min_heap[0] -self.max_heap[0]) / 2.0 # Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()\n\nPush item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().\n根据以上文档说明，可将 Python 代码优化为：\n123456789101112131415161718192021222324import heapqclass MedianFinder:    def __init__(self):        \"\"\"        initialize your data structure here.        \"\"\"        # 初始化大顶堆和小顶堆        self.min_heap = []  # 小顶堆，保存较大的一半        self.max_heap = []  # 大顶堆，保存较小的一半    def addNum(self, num: int) -&gt; None:        if len(self.min_heap) != len(self.max_heap):            # 先加到小顶堆，再把小堆顶元素加到大顶堆            heapq.heappush(self.max_heap, -heapq.heappushpop(self.min_heap, num))        else:  # 先加到大顶堆，再把大堆顶元素加到小顶堆            heapq.heappush(self.min_heap, -heapq.heappushpop(self.max_heap, -num))    def findMedian(self) -&gt; float:        if len(self.min_heap) != len(self.max_heap):            return self.min_heap[0]        else:  # 你存进B的时候，为了实现大顶堆，加了负号            return (self.min_heap[0] - self.max_heap[0]) / import heapqclass MedianFinder:    def __init__(self):        \"\"\"        initialize your data structure here.        \"\"\"        # 初始化大顶堆和小顶堆        self.min_heap = []  # 小顶堆，保存较大的一半        self.max_heap = []  # 大顶堆，保存较小的一半    def addNum(self, num: int) -&gt; None:        if len(self.min_heap) != len(self.max_heap):            # 先加到小顶堆，再把小堆顶元素加到大顶堆            heapq.heappush(self.max_heap, -heapq.heappushpop(self.min_heap, num))        else:  # 先加到大顶堆，再把大堆顶元素加到小顶堆            heapq.heappush(self.min_heap, -heapq.heappushpop(self.max_heap, -num))    def findMedian(self) -&gt; float:        if len(self.min_heap) != len(self.max_heap):            return self.min_heap[0]        else:  # 你存进B的时候，为了实现大顶堆，加了负号            return (self.min_heap[0] - self.max_heap[0]) / 2.0\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[5, 2, 4, 3, 1, 6]length = 6 = N 为偶数len(self.A) = 0 = len(self.B)插入 5，    A 小顶          B 大顶(负数的小顶堆)                             -5      A 小顶          B 大顶(负数的小顶堆)                5 findMedian() = A[0] = 5    len(self.A) = 1 != len(self.B) = 0插入 2，从存储较小 大顶 B    A 小顶          B 大顶(负数的小顶堆)       2                   /  \\                5      A 小顶          B 大顶(负数的小顶堆)       5               -2findMedian() = (5 - (-2)) / 2 = 3.5len(self.A) = 1 = len(self.B)插入 4，从存储较大 小顶 A    A 小顶          B 大顶(负数的小顶堆)      5               -4                    /  \\                   -2    A 小顶          B 大顶(负数的小顶堆)                      4               -2    /  \\                5              findMedian() = A[0] = 4len(self.A) = 2 != len(self.B) = 1插入 3，从存储较小 大顶 B     3               -2    /  \\            /  \\    5   4               4               -3    /  \\            /  \\    5              -2findMedian() (4 - (-3)) / 2 = 3.5len(self.A) = 2 = len(self.B)插入 1 &gt; 3.5，从存储较大 小顶 A      4              -3    /  \\            /  \\    5              -2   -1      3               -2    /  \\            /  \\    5   4          -1findMedian() = A[0] = 3len(self.A) = 3 != len(self.B) = 2插入 6 &gt; 2.5，从存储较小 大顶 B     3               -2    /  \\            /  \\    5   4          -1                        /  \\            /  \\  6                   4               -3    /  \\            /  \\    5   6          -1   -2   findMedian() (4 - (-3)) / 2 = [5, 2, 4, 3, 1, 6]length = 6 = N 为偶数len(self.A) = 0 = len(self.B)插入 5，    A 小顶          B 大顶(负数的小顶堆)                             -5      A 小顶          B 大顶(负数的小顶堆)                5 findMedian() = A[0] = 5    len(self.A) = 1 != len(self.B) = 0插入 2，从存储较小 大顶 B    A 小顶          B 大顶(负数的小顶堆)       2                   /  \\                5      A 小顶          B 大顶(负数的小顶堆)       5               -2findMedian() = (5 - (-2)) / 2 = 3.5len(self.A) = 1 = len(self.B)插入 4，从存储较大 小顶 A    A 小顶          B 大顶(负数的小顶堆)      5               -4                    /  \\                   -2    A 小顶          B 大顶(负数的小顶堆)                      4               -2    /  \\                5              findMedian() = A[0] = 4len(self.A) = 2 != len(self.B) = 1插入 3，从存储较小 大顶 B     3               -2    /  \\            /  \\    5   4               4               -3    /  \\            /  \\    5              -2findMedian() (4 - (-3)) / 2 = 3.5len(self.A) = 2 = len(self.B)插入 1 &gt; 3.5，从存储较大 小顶 A      4              -3    /  \\            /  \\    5              -2   -1      3               -2    /  \\            /  \\    5   4          -1findMedian() = A[0] = 3len(self.A) = 3 != len(self.B) = 2插入 6 &gt; 2.5，从存储较小 大顶 B     3               -2    /  \\            /  \\    5   4          -1                        /  \\            /  \\  6                   4               -3    /  \\            /  \\    5   6          -1   -2   findMedian() (4 - (-3)) / 2 = 3.5 \n\n\n\n使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177# 未封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createMaxHeap(self, num):        self.littleValueMaxHeap.append(num)        tmpIndex = len(self.littleValueMaxHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1  # 任意节点的父节点            if self.littleValueMaxHeap[parentIndex] &lt; self.littleValueMaxHeap[tmpIndex]:                self.littleValueMaxHeap[parentIndex], self.littleValueMaxHeap[tmpIndex] = self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMaxHeap(self, num):        if num &lt; self.littleValueMaxHeap[0]:            self.littleValueMaxHeap[0] = num        maxHeapLen = len(self.littleValueMaxHeap)        tmpIndex = 0        while tmpIndex &lt; maxHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; maxHeapLen:                largerIndex = rightIndex if self.littleValueMaxHeap[leftIndex] &lt; self.littleValueMaxHeap[rightIndex] else leftIndex            elif leftIndex &lt; maxHeapLen:                largerIndex = leftIndex            else:                break            if self.littleValueMaxHeap[tmpIndex] &lt; self.littleValueMaxHeap[largerIndex]:                self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[largerIndex] = self.littleValueMaxHeap[largerIndex], self.littleValueMaxHeap[tmpIndex]                tmpIndex = largerIndex            else:                break    def createMinHeap(self, num):        self.bigValueMinHeap.append(num)        tmpIndex = len(self.bigValueMinHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.bigValueMinHeap[tmpIndex] &lt; self.bigValueMinHeap[parentIndex]:                self.bigValueMinHeap[parentIndex], self.bigValueMinHeap[tmpIndex] = self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMinHeap(self, num):        if num &lt; self.bigValueMinHeap[0]:            self.littleValueMaxHeap[0] = num        minHeapLen = len(self.bigValueMinHeap)        tmpIndex = 0        while tmpIndex &lt; minHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; minHeapLen:                smallerIndex = rightIndex if self.bigValueMinHeap[rightIndex] &lt; self.bigValueMinHeap[leftIndex] else leftIndex            elif leftIndex &lt; minHeapLen:                smallerIndex = leftIndex            else:                break            if self.bigValueMinHeap[smallerIndex] &lt; self.bigValueMinHeap[tmpIndex]:                self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[smallerIndex] = self.bigValueMinHeap[smallerIndex], self.bigValueMinHeap[tmpIndex]                tmpIndex = smallerIndex            else:                break    def Insert(self, num):        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustMaxHeap(num)                self.createMinHeap(tmpNum)            else:                self.createMinHeap(num)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createMaxHeap(num)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustMinHeap(num)                    self.createMaxHeap(tmpNum)                else:                    self.createMaxHeap(num)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2# 封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createHeap(self, num, heap, cmpFunc):        heap.append(num)        tmpIndex = len(heap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if cmpFunc(heap[tmpIndex], heap[parentIndex]):                heap[parentIndex], heap[tmpIndex] = heap[tmpIndex], heap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustHeap(self, num, heap, cmpFunc):        if num &lt; heap[0]:            heap[0] = num        heapLen = len(heap)        tmpIndex = 0        while tmpIndex &lt; heapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; heapLen:                largerIndex = rightIndex if cmpFunc(heap[rightIndex], heap[leftIndex]) else leftIndex            elif leftIndex &lt; heapLen:                largerIndex = leftIndex            else:                break            if cmpFunc(heap[largerIndex], heap[tmpIndex]):                heap[tmpIndex], heap[largerIndex] = heap[largerIndex], heap[tmpIndex]                tmpIndex = largerIndex            else:                break    def Insert(self, num):        def cmpMaxHeap(a, b):            return b &lt; a        def cmpMinHeap(a, b):            return a &lt; b        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustHeap(num, self.littleValueMaxHeap, cmpMaxHeap)                self.createHeap(tmpNum, self.bigValueMinHeap, cmpMinHeap)            else:                self.createHeap(num, self.bigValueMinHeap, cmpMinHeap)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustHeap(num, self.bigValueMinHeap, cmpMinHeap)                    self.createHeap(tmpNum, self.littleValueMaxHeap, cmpMaxHeap)                else:                    self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2                if __name__ == '__main__':    s = Solution()    for i in [5,2,3,4,1,6,7,0,# 未封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createMaxHeap(self, num):        self.littleValueMaxHeap.append(num)        tmpIndex = len(self.littleValueMaxHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1  # 任意节点的父节点            if self.littleValueMaxHeap[parentIndex] &lt; self.littleValueMaxHeap[tmpIndex]:                self.littleValueMaxHeap[parentIndex], self.littleValueMaxHeap[tmpIndex] = self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMaxHeap(self, num):        if num &lt; self.littleValueMaxHeap[0]:            self.littleValueMaxHeap[0] = num        maxHeapLen = len(self.littleValueMaxHeap)        tmpIndex = 0        while tmpIndex &lt; maxHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; maxHeapLen:                largerIndex = rightIndex if self.littleValueMaxHeap[leftIndex] &lt; self.littleValueMaxHeap[rightIndex] else leftIndex            elif leftIndex &lt; maxHeapLen:                largerIndex = leftIndex            else:                break            if self.littleValueMaxHeap[tmpIndex] &lt; self.littleValueMaxHeap[largerIndex]:                self.littleValueMaxHeap[tmpIndex], self.littleValueMaxHeap[largerIndex] = self.littleValueMaxHeap[largerIndex], self.littleValueMaxHeap[tmpIndex]                tmpIndex = largerIndex            else:                break    def createMinHeap(self, num):        self.bigValueMinHeap.append(num)        tmpIndex = len(self.bigValueMinHeap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if self.bigValueMinHeap[tmpIndex] &lt; self.bigValueMinHeap[parentIndex]:                self.bigValueMinHeap[parentIndex], self.bigValueMinHeap[tmpIndex] = self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustMinHeap(self, num):        if num &lt; self.bigValueMinHeap[0]:            self.littleValueMaxHeap[0] = num        minHeapLen = len(self.bigValueMinHeap)        tmpIndex = 0        while tmpIndex &lt; minHeapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; minHeapLen:                smallerIndex = rightIndex if self.bigValueMinHeap[rightIndex] &lt; self.bigValueMinHeap[leftIndex] else leftIndex            elif leftIndex &lt; minHeapLen:                smallerIndex = leftIndex            else:                break            if self.bigValueMinHeap[smallerIndex] &lt; self.bigValueMinHeap[tmpIndex]:                self.bigValueMinHeap[tmpIndex], self.bigValueMinHeap[smallerIndex] = self.bigValueMinHeap[smallerIndex], self.bigValueMinHeap[tmpIndex]                tmpIndex = smallerIndex            else:                break    def Insert(self, num):        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustMaxHeap(num)                self.createMinHeap(tmpNum)            else:                self.createMinHeap(num)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createMaxHeap(num)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustMinHeap(num)                    self.createMaxHeap(tmpNum)                else:                    self.createMaxHeap(num)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2# 封装版本class Solution:    def __init__(self):        self.littleValueMaxHeap = []        self.bigValueMinHeap = []        self.maxHeapCount = 0        self.minHeapCount = 0    def createHeap(self, num, heap, cmpFunc):        heap.append(num)        tmpIndex = len(heap) - 1        while tmpIndex != 0:            parentIndex = (tmpIndex - 1) &gt;&gt; 1            if cmpFunc(heap[tmpIndex], heap[parentIndex]):                heap[parentIndex], heap[tmpIndex] = heap[tmpIndex], heap[parentIndex]                tmpIndex = parentIndex            else:                break    def adjustHeap(self, num, heap, cmpFunc):        if num &lt; heap[0]:            heap[0] = num        heapLen = len(heap)        tmpIndex = 0        while tmpIndex &lt; heapLen:            leftIndex = tmpIndex * 2 + 1            rightIndex = tmpIndex *2 + 2            if rightIndex &lt; heapLen:                largerIndex = rightIndex if cmpFunc(heap[rightIndex], heap[leftIndex]) else leftIndex            elif leftIndex &lt; heapLen:                largerIndex = leftIndex            else:                break            if cmpFunc(heap[largerIndex], heap[tmpIndex]):                heap[tmpIndex], heap[largerIndex] = heap[largerIndex], heap[tmpIndex]                tmpIndex = largerIndex            else:                break    def Insert(self, num):        def cmpMaxHeap(a, b):            return b &lt; a        def cmpMinHeap(a, b):            return a &lt; b        if self.minHeapCount &lt; self.maxHeapCount:            self.minHeapCount += 1            if num &lt; self.littleValueMaxHeap[0]:                tmpNum = self.littleValueMaxHeap[0]                self.adjustHeap(num, self.littleValueMaxHeap, cmpMaxHeap)                self.createHeap(tmpNum, self.bigValueMinHeap, cmpMinHeap)            else:                self.createHeap(num, self.bigValueMinHeap, cmpMinHeap)        else:            self.maxHeapCount += 1            if self.littleValueMaxHeap == []:                self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)            else:                if self.bigValueMinHeap[0] &lt; num:                    tmpNum = self.bigValueMinHeap[0]                    self.adjustHeap(num, self.bigValueMinHeap, cmpMinHeap)                    self.createHeap(tmpNum, self.littleValueMaxHeap, cmpMaxHeap)                else:                    self.createHeap(num, self.littleValueMaxHeap, cmpMaxHeap)    def GetMedian(self):        if self.minHeapCount &lt; self.maxHeapCount:            return self.littleValueMaxHeap[0]        else:            return (self.bigValueMinHeap[0] + self.littleValueMaxHeap[0]) / 2                if __name__ == '__main__':    s = Solution()    for i in [5,2,3,4,1,6,7,0,8]:        s.Insert(i)        print(s.GetMedian())\n\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940def heap_sort(nums):    # 调整堆    # 迭代写法    def adjust_heap(nums, startpos, endpos):        newitem = nums[startpos]        pos = startpos        childpos = pos * 2 + 1        while childpos &lt; endpos:            rightpos = childpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:                childpos = rightpos            if newitem &lt; nums[childpos]:                nums[pos] = nums[childpos]                pos = childpos                childpos = pos * 2 + 1            else:                break        nums[pos] = newitem        # 递归写法    def adjust_heap(nums, startpos, endpos):        pos = startpos        chilidpos = pos * 2 + 1        if chilidpos &lt; endpos:            rightpos = chilidpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]:                chilidpos = rightpos            if nums[chilidpos] &gt; nums[pos]:                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]                adjust_heap(nums, pos, endpos)    n = len(nums)    # 建堆    for i in reversed(range(n // 2)):        adjust_heap(nums, i, n)    # 调整堆    for i in range(n - 1, -1, -1):        nums[0], nums[i] = nums[i], nums[0]        adjust_heap(nums, 0, i)    def heap_sort(nums):    # 调整堆    # 迭代写法    def adjust_heap(nums, startpos, endpos):        newitem = nums[startpos]        pos = startpos        childpos = pos * 2 + 1        while childpos &lt; endpos:            rightpos = childpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]:                childpos = rightpos            if newitem &lt; nums[childpos]:                nums[pos] = nums[childpos]                pos = childpos                childpos = pos * 2 + 1            else:                break        nums[pos] = newitem        # 递归写法    def adjust_heap(nums, startpos, endpos):        pos = startpos        chilidpos = pos * 2 + 1        if chilidpos &lt; endpos:            rightpos = chilidpos + 1            if rightpos &lt; endpos and nums[rightpos] &gt; nums[chilidpos]:                chilidpos = rightpos            if nums[chilidpos] &gt; nums[pos]:                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]                adjust_heap(nums, pos, endpos)    n = len(nums)    # 建堆    for i in reversed(range(n // 2)):        adjust_heap(nums, i, n)    # 调整堆    for i in range(n - 1, -1, -1):        nums[0], nums[i] = nums[i], nums[0]        adjust_heap(nums, 0, i)    return nums\n\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"剑指offer25~30题","url":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/","content":"树的知识点：什么叫做树？树是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，是根朝上，而叶朝下的。它具有以下的特点：\n\n每个结点至多只有两颗子树\n二叉树的子树有左右之分，其次序不能任意颠倒\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n\n树的术语\n\n节点的度：一个节点含有的子树的个数称为该节点的度；\n树的度：一棵树中，最大的节点的度称为树的度；\n叶节点或终端节点：度为零的节点；没有子节点\n父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；\n兄弟节点：具有相同父节点的节点互称为兄弟节点；\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；\n树的高度或深度：树中节点的最大层次；\n堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n节点的祖先：从根到该节点所经分支上的所有节点；\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林；\n\n树的种类\n\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；\n\n有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；\n\n二叉树：每个节点最多含有两个子树的树，子树被称作“左子树”（left subtree）和“右子树”（right subtree）二叉树常被用于实现二叉查找树和二叉堆。  \n\n性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）  \n性质2: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）\n性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;\n性质4: 具有n个结点的完全二叉树的深度必为 log2(n+1)  (log2n)+1。\n性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）\n\n\n完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层（1~d-1）的节点数目均已达最大值，且第d层有叶子结点所有节点从左向右连续地紧密排列，并且最后一层或者是满的，或者是在右边缺少连续若干节点，\n\n满二叉树的定义是所有叶节点都在最底层的完全二叉树;除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。特点是每一层上的节点数都是最大节点数。\n\n\n\n\n深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点    - 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；    - 二叉搜索树：Binary Search Tree    左子树中所有节点的值 =&lt; 根节点的值 =&lt; 右子树中所有节点的值\n\n霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；\nB树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。\n\n树的存储与表示顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。\n二叉树的节点表示以及树的创建通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子\n123456class TreeNode(object):    \"\"\" 定义树的存储结构 Definition of a binary tree node.\"\"\"    def __init__(self, x):        self.val = x        self.left = None        self.right = class TreeNode(object):    \"\"\" 定义树的存储结构 Definition of a binary tree node.\"\"\"    def __init__(self, x):        self.val = x        self.left = None        self.right = None\n\n\n树的创建，创建一个树的类，并给一个root根节点，一开始为空，随后添加节点\n12345678910111213141516171819202122232425262728class Tree(object):    \"\"\"树类\"\"\"    def __init__(self, root=None):        self.root = root    def add(self, elem):        \"\"\"为树添加节点\"\"\"        node = Node(elem)        #如果树是空的，则对根节点赋值        if self.root == None:            self.root = node        else:            queue = []            queue.append(self.root)            #对已有的节点进行层次遍历            while queue:                #弹出队列的第一个元素                cur = queue.pop(0)                if cur.lchild == None:                    cur.lchild = node                    return                elif cur.rchild == None:                    cur.rchild = node                    return                else:                    class Tree(object):    \"\"\"树类\"\"\"    def __init__(self, root=None):        self.root = root    def add(self, elem):        \"\"\"为树添加节点\"\"\"        node = Node(elem)        #如果树是空的，则对根节点赋值        if self.root == None:            self.root = node        else:            queue = []            queue.append(self.root)            #对已有的节点进行层次遍历            while queue:                #弹出队列的第一个元素                cur = queue.pop(0)                if cur.lchild == None:                    cur.lchild = node                    return                elif cur.rchild == None:                    cur.rchild = node                    return                else:                    #如果左右子树都不为空，加入队列继续判断                    queue.append(cur.lchild)                    queue.append(cur.rchild)\n\n\n常见的一些树的应用场景1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树2.路由协议就是使用了树的算法3.mysql数据库索引4.文件系统的目录结构5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构\n)\n二叉树的遍历：遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次且只仅访问一次。由于二叉树是非线性结构，因树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。\n深度优先搜索(Depth First Search DFS)沿着树的深度遍历树的节点，尽可能深的搜索树的分支，从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。这三种方式常被用于访问树的节点，可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）\n当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。\n深度优先遍历、递归、栈，它们三者的关系背后统一的逻辑都是「后进先出」\n解决可达性的问题。两个要点：栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。\n找到开始节点-&gt;访问节点并进行操作-&gt;递归调用dfs遍历下一个节点-&gt;遇到边界或已访问节点就return返回-&gt;全部遍历结束返回到开始节点，结束dfs\n1234567    0   /  \\  1    2 / \\  / \\3  4 5   6 / \\  /7     8     0   /  \\  1    2 / \\  / \\3  4 5   6 / \\  /7     8 9  \n层次遍历： 0 1 2 3 4 5 6 7 8 9先序遍历： 0 1 3 7 8 4 9 2 5 6中序遍历： 7 3 8 1 9 4 0 5 2 6         738认作一个左子树，94认作一个右子树，该子树的根节点 1         738认作一个左子树，94认作一个节点，该子树的根节点 1         134认作一个左子树，256认作一个右子树后序遍历： 7 8 3 9 4 1 5 6 2 0\n1234567  A /  \\B    F \\    \\  C    G    / \\  A /  \\B    F \\    \\  C    G    / \\  /   D   E H\n先序:a b c d e f g h中序:b d c e a f h g后序:d e c b h g f a\n\n先(前)序遍历 我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树根节点-&gt;左子树-&gt;右子树Top-&gt;Bottom 和 Left-&gt;Right\n\n迭代使用栈来完成，先将根节点放入栈中，将根节点出栈，将根节点值放入结果数组中然后遍历左子树、右子树，因为栈是先进后出，先压右节点右子树入栈，再压左节点左子树入栈，出栈的时候才是先左后右的顺序，整体顺序才是中左右每次迭代弹出当前栈顶元素，继续出栈（左子树被出栈）……依次循环出栈遍历入栈，直到栈为空，遍历完成\n12345678910111213141516171819            0           /  \\          1    2         / \\  / \\        3  4 5   6前序                               |3|                     |1|       |4|  |4|            |5|      |0|  | |  |2|  |2|  |2|  |2|  |2|  |2|  | |  |6|  |6|  | |stack ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                              |6|                                                        |5|  |5|                                              |2|  |2|  |2|  |2|                                         |4|  |4|  |4|  |4|  |4|                                    |3|  |3|  |3|  |3|  |3|  |3|                           |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|res   | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|              0           /  \\          1    2         / \\  / \\        3  4 5   6前序                               |3|                     |1|       |4|  |4|            |5|      |0|  | |  |2|  |2|  |2|  |2|  |2|  |2|  | |  |6|  |6|  | |stack ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                              |6|                                                        |5|  |5|                                              |2|  |2|  |2|  |2|                                         |4|  |4|  |4|  |4|  |4|                                    |3|  |3|  |3|  |3|  |3|  |3|                           |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|res   | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|        ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---\n1234567891011121314151617181920212223class Solution(object):    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []                stack, output = [root, ], []        # [root, ]这个‘,’是什么意思呀?这个是方便多行定义的时候复制的,        #否则容易在添加元素的过程中缺少逗号出现语法错误.        #具体可以查python data structure trailing comma这个关键词.         #对于tuple的定义就有差别了,因为(1)这个东西有二意性,        # 所以tuple声明单元素的时候必须加逗号,也就是(1,)        while stack:            # 第一步的，先访问的是根节点，辅助栈的            root = stack.pop()            if root:                output.append(root.val)  # 把根节点加入到结果集                if root.right:                    stack.append(root.right)  # 加入到辅助栈                if root.left:                    stack.append(root.left)  # 加入到辅助栈                class Solution(object):    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if root is None:            return []                stack, output = [root, ], []        # [root, ]这个‘,’是什么意思呀?这个是方便多行定义的时候复制的,        #否则容易在添加元素的过程中缺少逗号出现语法错误.        #具体可以查python data structure trailing comma这个关键词.         #对于tuple的定义就有差别了,因为(1)这个东西有二意性,        # 所以tuple声明单元素的时候必须加逗号,也就是(1,)        while stack:            # 第一步的，先访问的是根节点，辅助栈的            root = stack.pop()            if root:                output.append(root.val)  # 把根节点加入到结果集                if root.right:                    stack.append(root.right)  # 加入到辅助栈                if root.left:                    stack.append(root.left)  # 加入到辅助栈                return output\n时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。\n先将根节点 cur 和遍历所有的左子树入栈并加入结果中，直至 cur 为空，用一个 while 循环实现：然后，每弹出一个栈顶元素 tmp，就到达它的右孩子，再将这个节点当作 cur 重新按上面的步骤来一遍，直至栈为空。这里又需要一个 while 循环。\n12345678910111213141516171819            0           /  \\          1    2         / \\  / \\        3  4 5   6前序                |3|       |4|                            |1|  |1|  |1|  |1|  |1|  | |  | |  | |  |5|  | |  |6|  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |2|  |2|  |2|  |2|  |2|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                              |6|  |6|  |6|                                                   |5|  |5|  |5|  |5|  |5|                                                  |2|  |2|  |2|  |2|  |2|  |2|                          |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|                |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|            |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|res   |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|              0           /  \\          1    2         / \\  / \\        3  4 5   6前序                |3|       |4|                            |1|  |1|  |1|  |1|  |1|  | |  | |  | |  |5|  | |  |6|  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |2|  |2|  |2|  |2|  |2|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                              |6|  |6|  |6|                                                   |5|  |5|  |5|  |5|  |5|                                                  |2|  |2|  |2|  |2|  |2|  |2|                          |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|                |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|            |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|res   |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|        ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---\n\n两个操作，一个是处理：将元素放进res数组中，一个是访问：遍历节点。分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为要访问的元素和要处理的元素（也就是在把节点的数值放进result数组中）顺序是一致的，都是中间节点。遇到节点直接把它的值存到输出数组里面，所以刚刚才能写出相对简洁的代码\n12345678910111213141516171819class Solution(object):    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        stack, res = [], []        cur = root  # 将树压入栈中        while cur or stack :  # 循环栈            # 根节点和左子树入栈            while cur:                res.append(cur.val)                stack.append(cur)                cur = cur.left  # 移至最左            # 每弹出一个元素，就到达右子树            temp  = stack.pop()  # 根节点等于出栈的节点            cur = temp.right            class Solution(object):    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        stack, res = [], []        cur = root  # 将树压入栈中        while cur or stack :  # 循环栈            # 根节点和左子树入栈            while cur:                res.append(cur.val)                stack.append(cur)                cur = cur.left  # 移至最左            # 每弹出一个元素，就到达右子树            temp  = stack.pop()  # 根节点等于出栈的节点            cur = temp.right            return res\n\n\n中序（根）遍历左子树-&gt;根节点-&gt;右子树先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。\n\n就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。创建一个Stack，然后按 左 中 右的顺序输出节点。尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。当处理完最小单位的子树时，返回到上层处理了中间节点。如果有右节点，其也要进行中序遍历。\n和前序遍历的代码完全相同，只是在出栈的时候才将节点 tmp 的值加入到结果中。\n12345678910111213141516171819202122232425262728293031            0           /  \\          1    2中序                                                    |1|  | |  | |  | |stack |0|  |0|  |0|  | |  |2|  | |                                |2|                 | |  |0|  |0|  |0|res   | |  | |  |1|  |1|  |1|  |1|             0           /  \\          1    2         / \\  / \\        3  4 5   6中序                |3|       | |                            |1|  |1|  |1|  | |  |4|  | |  | |  | |  |5|  | |  | |  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |2|  |2|  |2|  | |  |6|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                                   | |  |6|                                                   | |  | |  |2|  |2|  |2|                                                   | |  | |  |5|  |5|  |5|  |5|                            | |  | |  | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|                  | |  | |  | |  | |  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|             | |  | |  | |  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  res   | |  | |  | |  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|               0           /  \\          1    2中序                                                    |1|  | |  | |  | |stack |0|  |0|  |0|  | |  |2|  | |                                |2|                 | |  |0|  |0|  |0|res   | |  | |  |1|  |1|  |1|  |1|             0           /  \\          1    2         / \\  / \\        3  4 5   6中序                |3|       | |                            |1|  |1|  |1|  | |  |4|  | |  | |  | |  |5|  | |  | |  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |2|  |2|  |2|  | |  |6|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                                   | |  |6|                                                   | |  | |  |2|  |2|  |2|                                                   | |  | |  |5|  |5|  |5|  |5|                            | |  | |  | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|                  | |  | |  | |  | |  |4|  |4|  |4|  |4|  |4|  |4|  |4|  |4|             | |  | |  | |  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  |1|  res   | |  | |  | |  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|  |3|         ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- \n\n12345678910111213141516171819202122class Solution(object):    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        stack, res = [], []        cur = root        while cur or stack :            # cur 节点不为空一直压栈，并到达最左端的叶子节点            while cur:                stack.append(cur)                # 考虑左子树                cur = cur.left            # 节点为空就出栈             temp = stack.pop()            # 出栈元素加入结果            res.append(temp.val)              # 考虑右子树            cur = temp.right            class Solution(object):    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        stack, res = [], []        cur = root        while cur or stack :            # cur 节点不为空一直压栈，并到达最左端的叶子节点            while cur:                stack.append(cur)                # 考虑左子树                cur = cur.left            # 节点为空就出栈             temp = stack.pop()            # 出栈元素加入结果            res.append(temp.val)              # 考虑右子树            cur = temp.right            return res\n\n\n后序遍历 左子树-&gt;右子树-&gt;根节点 从下到上、从左至右\n\n1234567891011121314151617181920212223242526272829303132333435363738            1           /  \\          2    3         / \\  / \\        4  5    ```       当遍历完某个根节点的左子树，回到根节点的时候，对于中序遍历和先序遍历可以把当前根节点从栈里弹出，然后转到右子树当遍历完 2,4,5 的时候，回到 1 之后我们就可以把 1 弹出，然后通过 1 到达右子树继续遍历。而对于后序遍历，当我们到达 1 的时候并不能立刻把 1 弹出，因为遍历完右子树，我们还需要将这个根节点加入到 list 中。所以我们就需要判断是从左子树到的根节点，还是右子树到的根节点。如果是从左子树到的根节点，此时应该转到右子树。如果是从右子树到的根节点，那么就可以把当前节点弹出，并且加入到 list 中。当然，如果是从左子树到的根节点，此时如果根节点的右子树为 None， 此时也可以把当前节点弹出，并且加入到             1           /  \\          2    3         / \\  / \\        4  5    ```       当遍历完某个根节点的左子树，回到根节点的时候，对于中序遍历和先序遍历可以把当前根节点从栈里弹出，然后转到右子树当遍历完 2,4,5 的时候，回到 1 之后我们就可以把 1 弹出，然后通过 1 到达右子树继续遍历。而对于后序遍历，当我们到达 1 的时候并不能立刻把 1 弹出，因为遍历完右子树，我们还需要将这个根节点加入到 list 中。所以我们就需要判断是从左子树到的根节点，还是右子树到的根节点。如果是从左子树到的根节点，此时应该转到右子树。如果是从右子树到的根节点，那么就可以把当前节点弹出，并且加入到 list 中。当然，如果是从左子树到的根节点，此时如果根节点的右子树为 None， 此时也可以把当前节点弹出，并且加入到 list 中。基于上边的思想，可以写出一些不同的代码。法一：从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，而这里是先把左节点压入栈，再把右节点压入栈（根 - 右 - 左），按照从上到下、从左至右的顺序依次压入栈中。需要将输出列表逆序输出（左 - 右 -根），即后续遍历。只是能返回遍历的结果，并不是严格意义上树拓扑结构的遍历。虽然结果是正确，但是如果需要按照后续遍历的顺序对树节点进行访问（或操作），此解法就无法满足。时间复杂度为 O(N)：访问每个节点恰好一次，其中 N 是节点的个数，也就是树的大小。空间复杂度为 O(N)：取决于树的结构，最坏情况需要保存整棵树先序遍历：root->left->right 后序遍历：left->right-root，两者反过来当然不相等了，但是如果把先序遍历改成root->right-left，再逆序一下就相等了\n        0\n       /  \\\n      1    2\n\n后序\n       | |  | |  |2|  | |\n\nstack |0|  | |  |1|  |1|  |1|  | | \n                           |1| \n            | |  | |  |2|  |2| 压入根左右\n\nres   | |  |0|  |0|  |0|  |0|  |0| 弹出根右左————逆序：左右根\n        0\n       /  \\\n      1    2\n     / \\  / \\\n    3  4 5   6\n\n后序                          |6|  | |           | |  |2|  | |  |5|  |5|  | |  | |  | |  |4|  | |  | |stack |0|  | |  |1|  |1|  |1|  |1|  |1|  | |  |3|  |3|  |3|  | |      —  —  —  —  —  —  —  —  —  —  —  — \n                                                         |3|\n                                               | |  |4|  |4|    \n                                     |1|  |1|  |1|  |1|  |1|\n                      | |  | |  |5|  |5|  |5|  |5|  |5|  |5|\n            | |  | |  | |  |6|  |6|  |6|  |6|  |6|  |6|  |6| \n       | |  | |  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|\n\nres   | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|      —  —  —  —  —  —  —  —  —  —  —  —\n1234567891011121314151617181920```pythonclass Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        if not root:            return res        stack = [root,]        while stack:            node = stack.pop()            res.append(node.val)            # res.insert(0, node.val)  # 直接插入头部，不用反转            if node.left :                stack.append(node.left)            if node.right:                stack.append(node.right)        return res[::-1]        # return ```pythonclass Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        if not root:            return res        stack = [root,]        while stack:            node = stack.pop()            res.append(node.val)            # res.insert(0, node.val)  # 直接插入头部，不用反转            if node.left :                stack.append(node.left)            if node.right:                stack.append(node.right)        return res[::-1]        # return res  # 直接插入头部，不用反转\n\n法二：从「根-左-右」节点插入结果数组尾部的逻辑，修改为将节点插入结果数组的头部，数组变成—&gt; 「右-左-根」遍历的顺序先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点—&gt; 「左-右-根」这刚好是后序遍历的顺序\n节点 cur 先到达最右端的叶子节点并将路径上的节点入栈；然后每次从栈中弹出一个元素后，cur 到达它的左孩子，并将左孩子看作 cur 继续执行上面的步骤。\n12345678910111213141516171819202122232425262728293031            0           /  \\          1    2后序                                                    |2|  | |  | |  | |stack |0|  |0|  |0|  | |  |1|  | |                           |0|  |0|            |0|  |0|  |0|  |2|  |2| 压入根左右res   |0|  |2|  |2|  |2|  |1|  |1| 弹出根右左————逆序：左右根            0           /  \\          1    2         / \\  / \\        3  4 5   6后序                |6|       | |  | |                            |2|  |2|  |2|  | |  |5|  | |  | |  | |  |4|  | |  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |1|  |1|  |1|  | |  |3|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                                   |0|  |0|                                                   |0|  |0|  |0|  |2|  |2|                                             | |  |0|  |2|  |2|  |2|  |6|  |6|                          | |  |0|  |0|  |0|  |2|  |6|  |6|  |6|  |5|  |5|                |0|  |0|  |0|  |2|  |2|  |2|  |6|  |5|  |5|  |5|  |1|  |1|            |0|  |2|  |2|  |2|  |6|  |6|  |6|  |5|  |1|  |1|  |1|  |4|  |4|res   |0|  |2|  |6|  |6|  |6|  |5|  |5|  |5|  |1|  |4|  |4|  |4|  |3|  |3|              0           /  \\          1    2后序                                                    |2|  | |  | |  | |stack |0|  |0|  |0|  | |  |1|  | |                           |0|  |0|            |0|  |0|  |0|  |2|  |2| 压入根左右res   |0|  |2|  |2|  |2|  |1|  |1| 弹出根右左————逆序：左右根            0           /  \\          1    2         / \\  / \\        3  4 5   6后序                |6|       | |  | |                            |2|  |2|  |2|  | |  |5|  | |  | |  | |  |4|  | |  | |stack |0|  |0|  |0|  |0|  |0|  |0|  |0|  | |  |1|  |1|  |1|  | |  |3|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                                   |0|  |0|                                                   |0|  |0|  |0|  |2|  |2|                                             | |  |0|  |2|  |2|  |2|  |6|  |6|                          | |  |0|  |0|  |0|  |2|  |6|  |6|  |6|  |5|  |5|                |0|  |0|  |0|  |2|  |2|  |2|  |6|  |5|  |5|  |5|  |1|  |1|            |0|  |2|  |2|  |2|  |6|  |6|  |6|  |5|  |1|  |1|  |1|  |4|  |4|res   |0|  |2|  |6|  |6|  |6|  |5|  |5|  |5|  |1|  |4|  |4|  |4|  |3|  |3|        ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---\n\n1234567891011121314151617181920class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        res, stack = [], []        cur = root                while cur or stack:              while cur:                res.insert(0, cur.val)  # 插入头部不用逆序                # res.append(cur.val)  # 插入尾部要逆序                stack.append(cur)                # 每次先遍历右节点                cur = cur.right            # 再遍历左节点            cur = stack.pop().left                return res  # 插入头部不用逆序，更快        class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        res, stack = [], []        cur = root                while cur or stack:              while cur:                res.insert(0, cur.val)  # 插入头部不用逆序                # res.append(cur.val)  # 插入尾部要逆序                stack.append(cur)                # 每次先遍历右节点                cur = cur.right            # 再遍历左节点            cur = stack.pop().left                return res  # 插入头部不用逆序，更快        # return res[::-1]  # 插入尾部要逆序输出，要慢很多 \n\n\n因此掌握标准的栈操作解法是必要的。\n123456789101112131415161718def laterOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack :        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack[-1]        tmpNode = node.right        if node.right == None:            node = stack.pop()            print(node.val)            while stack and node == stack[def laterOrder(root):    if root == None:        return None    stack = []    tmpNode = root    while tmpNode or stack :        while tmpNode:            stack.append(tmpNode)            tmpNode = tmpNode.left        node = stack[-1]        tmpNode = node.right        if node.right == None:            node = stack.pop()            print(node.val)            while stack and node == stack[-1].right:                node =  stack.pop()                print(node.val)\n\n法二递归算法的三个要素1.确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n2.确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n3.确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n它们的模板相对比较固定，一般都会新增一个 dfs 函数：\n1234567def dfs(root):    if not root:        def dfs(root):    if not root:        return        res.append(root.val)        dfs(root.left)        dfs(root.right)\n\n对于前序、中序和后序遍历，只需将递归函数里的 res.append(root.val) 放在不同位置即可，然后调用这个递归函数就可以了，代码完全一样。\n1.前序遍历\n\n确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入root在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是\n确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return\n确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值123456789101112131415class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            res.append(root.val)  # 根节点root 的处理在此处完成            dfs(root.left)            dfs(root.right)        dfs(root)        class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            res.append(root.val)  # 根节点root 的处理在此处完成            dfs(root.left)            dfs(root.right)        dfs(root)        return res\n\n\n\n2.中序遍历\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            dfs(root.left)  # 左            res.append(root.val)  # 根节点root 的处理在此处完成            dfs(root.right)  # 右        dfs(root)        return res```                3.后序遍历```python class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            dfs(root.left)  # 左            dfs(root.right)  # 右            res.append(root.val)  # 根节点root 的处理在此处完成        dfs(root)        return res```                     - 广度优先遍历（Breath First Search）bfs返回其按 层序遍历 得到的节点值。从树的root开始，从上到下从从左到右遍历整个树的节点按照高度顺序逐层遍历的访问整棵树，示例：二叉树：[3,9,20,null,null,15,class Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            dfs(root.left)  # 左            res.append(root.val)  # 根节点root 的处理在此处完成            dfs(root.right)  # 右        dfs(root)        return res```                3.后序遍历```python class Solution:    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:        res = []        def dfs(root):            nonlocal res  # 为了让上一级定义的 res 能在这个函数用            if not root:                return            dfs(root.left)  # 左            dfs(root.right)  # 右            res.append(root.val)  # 根节点root 的处理在此处完成        dfs(root)        return res```                     - 广度优先遍历（Breath First Search）bfs返回其按 层序遍历 得到的节点值。从树的root开始，从上到下从从左到右遍历整个树的节点按照高度顺序逐层遍历的访问整棵树，示例：二叉树：[3,9,20,null,null,15,7],\n3\n\n   /   9  20    /     15   7\n1返回其层次遍历结果：\n[  [3],  [9,20],  [15,7]]\n12345678910111213141516171819202122232425将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。每层遍历都以上一层遍历的结果作为起点，遍历一个长度，遍历一个距离能访问到的所有节点。要求我们区分每一层，同一层的节点应该放在一起，也就是返回一个二维数组，故使用模板二。使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。用到 deque 的结构用来模拟队列（先进先出），当前层的节点肯定会优先访问，先将根节点放到队列中，然后不断遍历队列然后每次处理从队列中出队一个元素要明确要从那些点开始扩张(具体如何扩张需要根据题目要求)对于扩张后满足某条件的点再进行处理，根据需要进入队列，进入队列的点就是扩到下一层的点(不同题目需要处理的方法不同，大家灵活运用)然后接着循环处理 deque 中的元素，直到 deque 为空，则代表所有点都已经完成扩张最后根据题目要求输出结果(当然这已经不属于 BFS 模板的范围了)BFS总共有两个模板：  1. 如果不需要确定当前遍历到了哪一层，BFS模板如下。```pywhile queue 不空：    cur = queue.pop()    for 节点 in cur的所有相邻节点：        将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。每层遍历都以上一层遍历的结果作为起点，遍历一个长度，遍历一个距离能访问到的所有节点。要求我们区分每一层，同一层的节点应该放在一起，也就是返回一个二维数组，故使用模板二。使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。用到 deque 的结构用来模拟队列（先进先出），当前层的节点肯定会优先访问，先将根节点放到队列中，然后不断遍历队列然后每次处理从队列中出队一个元素要明确要从那些点开始扩张(具体如何扩张需要根据题目要求)对于扩张后满足某条件的点再进行处理，根据需要进入队列，进入队列的点就是扩到下一层的点(不同题目需要处理的方法不同，大家灵活运用)然后接着循环处理 deque 中的元素，直到 deque 为空，则代表所有点都已经完成扩张最后根据题目要求输出结果(当然这已经不属于 BFS 模板的范围了)BFS总共有两个模板：  1. 如果不需要确定当前遍历到了哪一层，BFS模板如下。```pywhile queue 不空：    cur = queue.pop()    for 节点 in cur的所有相邻节点：        if 该节点有效且未访问过：            queue.push(该节点)\n\n如果要确定当前遍历到了哪一层，BFS模板如下。这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。12345678910level = 0while queue 不空：    size = queue.size()    while (size --) {        cur = queue.pop()        for 节点 in cur的所有相邻节点：            level = 0while queue 不空：    size = queue.size()    while (size --) {        cur = queue.pop()        for 节点 in cur的所有相邻节点：            if 该节点有效且未被访问过：                queue.push(该节点)    }    level ++;\n\n\n\n123456节点对象list1初始仅包含根节点，后续仅保存一层节点节点值list2初始为空，后续累积保存整棵树的所有节点值节点对象list1初始仅包含根节点，后续仅保存一层节点节点值list2初始为空，后续累积保存整棵树的所有节点值while 节点对象list1不为空:    收集当前层节点对象list1的每一个值，添加保存至节点值list2    收集当前层节点对象list1的每一个子节点，覆盖保存至节点对象list1返回收集完全的节点值list2\n\n实现 BFS 时需要考虑以下问题：队列：用来存储每一轮遍历的节点；标记：对于遍历过的节点，应该将它标记，防止重复遍历。\n适用场景：求解目标：「层序遍历」、「最短路径」。输入数据：没什么特征，不像深搜，需要有“递归”的性质。如果是树或者状态转换图，概率更大。\n算法流程：\n\n特例处理： 当根节点为空，则返回空列表 [] ；\n初始化： 打印最终结果列表 res = [] ，包含根节点的队列 queue = [root] ；\nBFS 循环： 当队列 queue 为空时跳出；\n新建一个临时列表 cur_layer ，用于存储当前层打印结果；\n当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）避免定义了一个新队列存放下一层的节点，\n出队： 队首元素出队，记为 node；\n打印： 将 node.val 添加至 cur_layer 尾部；\n添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；\n\n\n将当前层结果 cur_layer 添加入 res 。\n返回值： 返回打印结果列表 res 即可。\n\n时间复杂度 O(N)：每个点进队出队各一次，BFS 需循环 n 次。n 为二叉树的节点数量空间复杂度 O(N)： 因为是按层打印，最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。假定是满二叉树，也就是叶子节点那一层全满，那么每一层应该是2^(n-1)，然后采用等比数列求和，就是2^n-1，所以 (2^n-1) / (2^n-1) 约等于2，所以可以看到几乎就是N/2这个 N / 2 是一个数量级的表示，代表平衡情况下 最后一层节点数量是 所有节点数量的一半。准确来说，最后一层节点的数量是 (N+1)/2 ~\n1234567891011121314151617181920212223242526class Solution(object):    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:  # 返回含列表的列表        if not root:  # root为空遇到叶子节点返回[]             return []        queue = collections.deque()        queue.append(root)  # 根元素入队列        res = []  # 层序遍历结果列表        while queue:  # 直到队列为空，无法再次向队列中推入节点，循环结束。            # 当队列不为空的时候            cur_layer = []  # 临时变量，记录当前层的节点            # 第i次迭代得到二叉树的第i层的len(queue)个结点进行拓展            # 如果节点的左/右子树不为空，也放入队列中            for _ in range(len(queue)):                # range() 的工作机制是在开启循环时建立一个列表，然后循环按照这个列表进行，因此“只会在进入循环前执行一次 len(queue) ”                 cur = queue.popleft()  # 从弹出队列的头部元素开始将队列中的元素都拿出来(也就是获取这一层的节点)                # 不用判断 if cur: 因为不是序列化，None时不会append                cur_layer.append(cur.val)  # 节点加入到当前层cur_layer                # 如果当前节点有左右子节点，则先左后右压入队列，作为下一层的元素                if cur.left:                    queue.append(cur.left)  # 左子树，移动一层，不是最左                if cur.right:                    queue.append(cur.right)            #  某一层的节点都处理完之后，将临时的当前层的结果压入最终返回结果中            res.append(cur_layer)        class Solution(object):    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:  # 返回含列表的列表        if not root:  # root为空遇到叶子节点返回[]             return []        queue = collections.deque()        queue.append(root)  # 根元素入队列        res = []  # 层序遍历结果列表        while queue:  # 直到队列为空，无法再次向队列中推入节点，循环结束。            # 当队列不为空的时候            cur_layer = []  # 临时变量，记录当前层的节点            # 第i次迭代得到二叉树的第i层的len(queue)个结点进行拓展            # 如果节点的左/右子树不为空，也放入队列中            for _ in range(len(queue)):                # range() 的工作机制是在开启循环时建立一个列表，然后循环按照这个列表进行，因此“只会在进入循环前执行一次 len(queue) ”                 cur = queue.popleft()  # 从弹出队列的头部元素开始将队列中的元素都拿出来(也就是获取这一层的节点)                # 不用判断 if cur: 因为不是序列化，None时不会append                cur_layer.append(cur.val)  # 节点加入到当前层cur_layer                # 如果当前节点有左右子节点，则先左后右压入队列，作为下一层的元素                if cur.left:                    queue.append(cur.left)  # 左子树，移动一层，不是最左                if cur.right:                    queue.append(cur.right)            #  某一层的节点都处理完之后，将临时的当前层的结果压入最终返回结果中            res.append(cur_layer)        return res\n12345678910111213141516171819202122232425262728            0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的                                    |6|                          |4|  | |  |5|  |6|                          | |  |2|  | |  |3|  |4|  |4|  |5|  |6|  | |  | |queue |0|  | |  |1|  |2|  |2|  |3|  |3|  |4|  |5|  |6|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           | |  | |  | |  | |  | |  | |  |6|                 | |  | |  | |  | |  | |  | |  | |  |5|  |5|             | |  | |  | |  | |  |2|  |2|  | |  |4|  |4|  |4| cur_l | |  |0|  | |  |1|  |1|  |1|  |1|  |3|  |3|  |3|  |3|        ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                         |6|                                                        |5|                                                        |4|                                                        |3|                                                             |-|                                     |2|                 |2|                                    |1|                 |1|              | |  | |  | |  | |  | |  |-|  |-|  |-|  |-|  |-| res   | |  | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|             0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的                                    |6|                          |4|  | |  |5|  |6|                          | |  |2|  | |  |3|  |4|  |4|  |5|  |6|  | |  | |queue |0|  | |  |1|  |2|  |2|  |3|  |3|  |4|  |5|  |6|  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           | |  | |  | |  | |  | |  | |  |6|                 | |  | |  | |  | |  | |  | |  | |  |5|  |5|             | |  | |  | |  | |  |2|  |2|  | |  |4|  |4|  |4| cur_l | |  |0|  | |  |1|  |1|  |1|  |1|  |3|  |3|  |3|  |3|        ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                                                         |6|                                                        |5|                                                        |4|                                                        |3|                                                             |-|                                     |2|                 |2|                                    |1|                 |1|              | |  | |  | |  | |  | |  |-|  |-|  |-|  |-|  |-| res   | |  | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|       ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  \n\n当访问根结点 3 的时候需要把它的左右孩子结点 [9, 20]先保存起来，访问[9, 20]把它两个结点的左右孩子结点保存起来[none, none, 15, 7], 访问[15, 7]的时候左右孩子结点为 [ ]。返访问为空结束层遍历。\n12345678910111213141516171819class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:  # root为空时直接返回[]            return []        res = []  # 返回的最终结果        cur_nodes = [root]  # 当前访问层        next_nodes = []  # 下一层需要访问的        res.append([i.val for i in cur_nodes])  # 先把第一层的值放入res中        while cur_nodes or next_nodes:  # 当前结点或下一层结点不为空            for node in cur_nodes:  # 当前结点的所有孩子都加入next_nodes                if node.left:                    next_nodes.append(node.left)                if node.right:                    next_nodes.append(node.right)            if next_nodes:  # 下一层结点不为空时加入res                res.append([i.val for i in next_nodes])            cur_nodes = next_nodes  # 更新当前结点为next_nodes            next_nodes = []  # 下一层结点置空        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:  # root为空时直接返回[]            return []        res = []  # 返回的最终结果        cur_nodes = [root]  # 当前访问层        next_nodes = []  # 下一层需要访问的        res.append([i.val for i in cur_nodes])  # 先把第一层的值放入res中        while cur_nodes or next_nodes:  # 当前结点或下一层结点不为空            for node in cur_nodes:  # 当前结点的所有孩子都加入next_nodes                if node.left:                    next_nodes.append(node.left)                if node.right:                    next_nodes.append(node.right)            if next_nodes:  # 下一层结点不为空时加入res                res.append([i.val for i in next_nodes])            cur_nodes = next_nodes  # 更新当前结点为next_nodes            next_nodes = []  # 下一层结点置空        return res\n12345678910111213141516171819202122232425262728            0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的                               |6|                          |4|  |5|  | |  | |                          | |  |2|  |2|  |3|  |4|  | |  | |  | |  | |  | |cur_n |0|  |0|  |1|  |1|  |2|  |3|  | |  | |  | |  | |  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           |6|  | |  | |  | |  | |  | |  | |                 | |  | |  |5|  | |  | |  | |  | |  | |  | |            |2|  | |  |4|  |4|  | |  | |  | |  | |  | |  | |next_ | |  |1|  | |  |3|  |3|  | |  | |  | |  | |  | |  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           |6|  |6|                           |5|  |5|                          |4|  |4|                          |3|  |3|              |-|  |-|  |-|  |-|  |-|            |2|  |2|  |2|  |2|  |2|            |1|  |1|  |1|  |1|  |1|       |-|  |-|  |-|  |-|  |-|  |-|res   |0|  |0|  |0|  |0|  |0|  |0|             0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的                               |6|                          |4|  |5|  | |  | |                          | |  |2|  |2|  |3|  |4|  | |  | |  | |  | |  | |cur_n |0|  |0|  |1|  |1|  |2|  |3|  | |  | |  | |  | |  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           |6|  | |  | |  | |  | |  | |  | |                 | |  | |  |5|  | |  | |  | |  | |  | |  | |            |2|  | |  |4|  |4|  | |  | |  | |  | |  | |  | |next_ | |  |1|  | |  |3|  |3|  | |  | |  | |  | |  | |  | |      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---                           |6|  |6|                           |5|  |5|                          |4|  |4|                          |3|  |3|              |-|  |-|  |-|  |-|  |-|            |2|  |2|  |2|  |2|  |2|            |1|  |1|  |1|  |1|  |1|       |-|  |-|  |-|  |-|  |-|  |-|res   |0|  |0|  |0|  |0|  |0|  |0|       ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  \n\n\n递归相同层的节点归于同一个数组传入辅助的level参数决定层次\n1234567891011121314151617181920212223class Solution(object):    def levelOrder(self, root):        if not root:            return []        res = []        def dfs(depth, r):            # 在第一次遍历到某一层是是没有\"[]\"的, 需要补一个\"[]\",用来存储该层节点值            # 多维列表的长度            # print(len([[1, 2], [3, 4], [5, 6]]))  # 3            if len(res) &lt; depth:                res.append([])            #  将当前节点的值加入到res中，depth代表当前层，假设depth是3，节点值是99            # res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]            res[depth - 1].append(r.val)            # 递归的处理左子树，右子树，同时将层数depth+1            if r.left:  # 左节点存在，只在本次以左节点为根节点递归函数中深度加一                dfs(depth + 1, r.left)            if r.right:  # 右节点存在，只在本次以右节点为根节点递归函数中深度加一                dfs(depth + 1, r.right)        dfs(1, root)        class Solution(object):    def levelOrder(self, root):        if not root:            return []        res = []        def dfs(depth, r):            # 在第一次遍历到某一层是是没有\"[]\"的, 需要补一个\"[]\",用来存储该层节点值            # 多维列表的长度            # print(len([[1, 2], [3, 4], [5, 6]]))  # 3            if len(res) &lt; depth:                res.append([])            #  将当前节点的值加入到res中，depth代表当前层，假设depth是3，节点值是99            # res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]            res[depth - 1].append(r.val)            # 递归的处理左子树，右子树，同时将层数depth+1            if r.left:  # 左节点存在，只在本次以左节点为根节点递归函数中深度加一                dfs(depth + 1, r.left)            if r.right:  # 右节点存在，只在本次以右节点为根节点递归函数中深度加一                dfs(depth + 1, r.right)        dfs(1, root)        return res\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950            0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的①root = 0len(res) = 0 &lt; depth = 1res = [ [] ]res[depth - 1].append(r.val)=res[0].append(r.val)res = [ [0] ]root.left存在root = root.leftlen(res) = 1 &lt; depth = 2res = [ [0], [] ]res[depth - 1].append(r.val)=res[1].append(r.val)res = [ [0], [1] ]root.right存在root = root.rightlen(res) = 2 = depth = 2res = [ [0], [1] ]res[depth - 1].append(r.val)=res[1].append(r.val)res = [ [0], [1, 2] ]②root = 1root.left存在root = root.leftlen(res) = 2 &lt; depth = 3res = [ [0], [1, 2], [] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3] ]root.right存在root = root.rightlen(res) = 3 = depth = 3res = [ [0], [1, 2], [3] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4] ]②root = 2root.left存在root = root.leftlen(res) = 3 &lt; depth = 3res = [ [0], [1, 2], [3, 4] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4, 5] ]root.right存在root = root.rightlen(res) = 3 = depth = 3res = [ [0], [1, 2], [3, 4, 5] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4, 5,             0           /  \\          1    2         / \\  / \\        3  4 5   6层序 队列 删除第一个 最下面的①root = 0len(res) = 0 &lt; depth = 1res = [ [] ]res[depth - 1].append(r.val)=res[0].append(r.val)res = [ [0] ]root.left存在root = root.leftlen(res) = 1 &lt; depth = 2res = [ [0], [] ]res[depth - 1].append(r.val)=res[1].append(r.val)res = [ [0], [1] ]root.right存在root = root.rightlen(res) = 2 = depth = 2res = [ [0], [1] ]res[depth - 1].append(r.val)=res[1].append(r.val)res = [ [0], [1, 2] ]②root = 1root.left存在root = root.leftlen(res) = 2 &lt; depth = 3res = [ [0], [1, 2], [] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3] ]root.right存在root = root.rightlen(res) = 3 = depth = 3res = [ [0], [1, 2], [3] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4] ]②root = 2root.left存在root = root.leftlen(res) = 3 &lt; depth = 3res = [ [0], [1, 2], [3, 4] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4, 5] ]root.right存在root = root.rightlen(res) = 3 = depth = 3res = [ [0], [1, 2], [3, 4, 5] ]res[depth - 1].append(r.val)=res[2].append(r.val)res = [ [0], [1, 2], [3, 4, 5, 6] ]\n\n1234567891011121314151617181920class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        \"\"\"递归法\"\"\"        if root is None:            return []                result = []                def add_to_result(level, node):            if level &gt; len(result) - 1:                result.append([])                            result[level].append(node.val)            if node.left:                add_to_result(level+1, node.left)            if node.right:                add_to_result(level+1, node.right)                add_to_result(0, root)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        \"\"\"递归法\"\"\"        if root is None:            return []                result = []                def add_to_result(level, node):            if level &gt; len(result) - 1:                result.append([])                            result[level].append(node.val)            if node.left:                add_to_result(level+1, node.left)            if node.right:                add_to_result(level+1, node.right)                add_to_result(0, root)        return result\n\n法四本题使用 DFS 同样能做，DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 level。递归到新节点要把该节点放入 level 对应列表的末尾。\n当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，应该在 res 中新建一个列表用来保存该 level 的所有节点。\n1234567891011121314151617class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return        res = []        def helper(root, depth):            # 相等于给当层返回值提供一个容器先，            # 如果size的数量正好等于level，说明正好需要提供下一层的容器            # 遍历到新的一个 level 时，需要新建一列表保存该层的所有节点            if len(res) == depth:                res.append([])            res[depth].append(root.val)            if root.left: helper(root.left, depth + 1)            if root.right: helper(root.right, depth + 1)        helper(root, 0)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return        res = []        def helper(root, depth):            # 相等于给当层返回值提供一个容器先，            # 如果size的数量正好等于level，说明正好需要提供下一层的容器            # 遍历到新的一个 level 时，需要新建一列表保存该层的所有节点            if len(res) == depth:                res.append([])            res[depth].append(root.val)            if root.left: helper(root.left, depth + 1)            if root.right: helper(root.right, depth + 1)        helper(root, 0)        return res\n\n\n28.从上往下打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如:给定二叉树:&nbsp;[3,9,20,null,null,15,7],\n12345  3 / \\9  20  /  \\ 15     3 / \\9  20  /  \\ 15   7\n返回：\n1[3,9,20,15,[3,9,20,15,7]\n\n解题思路：\n\n二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。\nBFS 通常借助 队列 的先入先出特性来实现。\n\n算法流程：\n\n特例处理：当树的根节点为空，则直接返回空列表 [] ；\n初始化：打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；\nBFS 循环：当队列 queue 为空时跳出；\n出队： 队首元素出队，记为 node；\n打印： 将 node.val 添加至列表 tmp 尾部；\n添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；\n返回值： 返回打印结果列表 res ，一个一维数组，不用区分每一层。\n\n时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。空间复杂度 O(N) ： 最差情况下，满二叉树的最下面那层 该层有N/2个节点，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。\ncollections 中的双端队列 deque() 的 popleft() 方法 O(1) 时间复杂度；列表 list 的 pop(0) 方法时间复杂度为 O(N) 。\n123456789101112class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[int]:  #　返回含数字的列表        if not root: return []  # 如果根结点为空，直接返回空列表        res, queue = [], collections.deque()        queue.append(root)        # 写成queue=[root]， pop(0) 方法时间复杂度为 O(N)         while queue:  # 当队列不为空时一直循环            node = queue.popleft()            res.append(node.val)            if node.left: queue.append(node.left)            if node.right: queue.append(node.right)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[int]:  #　返回含数字的列表        if not root: return []  # 如果根结点为空，直接返回空列表        res, queue = [], collections.deque()        queue.append(root)        # 写成queue=[root]， pop(0) 方法时间复杂度为 O(N)         while queue:  # 当队列不为空时一直循环            node = queue.popleft()            res.append(node.val)            if node.left: queue.append(node.left)            if node.right: queue.append(node.right)        return res\n1234567891011121314151617181920212223242526272829303132333435363738394041  3          queue=[3] / \\         res=[]9   2  /  \\ 1   7  3          queue=[] / \\         res=[3]9   2        queue添加左右子节点  queue=[9, 2]  /  \\ 1   7     3          queue=[2] # 队列默认删除第一个元素 / \\         res=[3, 9]9   2        queue添加左右子节点：节点 9 无左右子节点，直接跳过  /  \\       queue=[2] 1   7      3           / \\         queue=[]9   2        res=[3, 9, 2]  /  \\       queue添加左右子节点 queue=[1, 7]  1    7       3          queue=[7] / \\         res=[3, 9, 2, 1]9   2        queue添加左右子节点：节点 1 无左右子节点，直接跳过  /  \\       queue=[7]  1    7       3          queue=[] / \\         res=[3, 9, 2, 1, 7]9   2        queue添加左右子节点：节点 7 无左右子节点，直接跳过  /  \\       queue=[]  1    7       3          queue=[], queue为空 / \\         跳出循环，返回res9   2          /  \\         1      3          queue=[3] / \\         res=[]9   2  /  \\ 1   7  3          queue=[] / \\         res=[3]9   2        queue添加左右子节点  queue=[9, 2]  /  \\ 1   7     3          queue=[2] # 队列默认删除第一个元素 / \\         res=[3, 9]9   2        queue添加左右子节点：节点 9 无左右子节点，直接跳过  /  \\       queue=[2] 1   7      3           / \\         queue=[]9   2        res=[3, 9, 2]  /  \\       queue添加左右子节点 queue=[1, 7]  1    7       3          queue=[7] / \\         res=[3, 9, 2, 1]9   2        queue添加左右子节点：节点 1 无左右子节点，直接跳过  /  \\       queue=[7]  1    7       3          queue=[] / \\         res=[3, 9, 2, 1, 7]9   2        queue添加左右子节点：节点 7 无左右子节点，直接跳过  /  \\       queue=[]  1    7       3          queue=[], queue为空 / \\         跳出循环，返回res9   2          /  \\         1    7        \n\n请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n例如:给定二叉树:&nbsp;[3,9,2,null,null,1,7],\n12345  3 / \\9   2  /  \\ 1     3 / \\9   2  /  \\ 1   7\n返回其层次遍历结果：\n12345[  [3],  [2,9],  [1,[  [3],  [2,9],  [1,7]]\n\n奇数层正序打印顺序是从左边节点到右边节点，偶数层倒序打印顺序是从右边节点到左边节点双端队列的方法省了倒序的时间，\n方法一：层序遍历 + 双端队列\n\n利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：\n奇数层 则添加至 tmp 尾部 ，\n偶数层 则添加至 tmp 头部 。算法流程：\n\n\n\n\n特例处理： 当树的根节点为空，则直接返回空列表 [] ；\n初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；\nBFS 循环： 当 deque 为空时跳出；\n新建列表 tmp ，用于临时存储当前层打印结果；\n当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；\n出队： 队首元素出队，记为 node；\n打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；\n添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；\n\n\n将当前层结果 tmp 转化为 list 并添加入 res ；\n\n\n返回值： 返回打印结果列表 res 即可；\n\n代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。\n时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。\n123456789101112131415161718192021class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque([root])        while deque:            tmp = collections.deque()            for _ in range(len(deque)):                node = deque.popleft()                # 每打印一层， res 长度就会加 1 ；                # 因此，在遍历第 1 层时， res 长度为 0 ；                # 在遍历第 2 层时， res 长度为 1；以此类推。                 # 因此， res 的长度为 奇数 ，说明当前是偶数层。                if len(res) &amp; 1:  # if len(res) % 2 ，与位运算比除法更快                # len(res)对2求余是1，代表是 1 3 5 7，此时在遍历 2 4 6 8 ……层，因此偶数层 -&gt; 队列头部                    tmp.appendleft(node.val)                else:  # len(res)对2求余是0，即为奇数层 -&gt; 队列尾部                    tmp.append(node.val)                if node.left: deque.append(node.left)                if node.right: deque.append(node.right)            res.append(list(tmp))  # list() 这个函数时间复杂度是O（N）        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque([root])        while deque:            tmp = collections.deque()            for _ in range(len(deque)):                node = deque.popleft()                # 每打印一层， res 长度就会加 1 ；                # 因此，在遍历第 1 层时， res 长度为 0 ；                # 在遍历第 2 层时， res 长度为 1；以此类推。                 # 因此， res 的长度为 奇数 ，说明当前是偶数层。                if len(res) &amp; 1:  # if len(res) % 2 ，与位运算比除法更快                # len(res)对2求余是1，代表是 1 3 5 7，此时在遍历 2 4 6 8 ……层，因此偶数层 -&gt; 队列头部                    tmp.appendleft(node.val)                else:  # len(res)对2求余是0，即为奇数层 -&gt; 队列尾部                    tmp.append(node.val)                if node.left: deque.append(node.left)                if node.right: deque.append(node.right)            res.append(list(tmp))  # list() 这个函数时间复杂度是O（N）        return res\n\n1234567891011121314151617181920212223242526272829303132333435363738394041    3         / \\  9   2    /  \\   1    7res = []  len(res)= 0 0%2=0 下一层插入队列尾部deque = [3]tem = [] len(deque) = 1 deque = []node = 3tem = [3] deque = [9]deque = [9, 2]res = [ [3] ] len(res)= 1 1%2=1!=0 下一层插入队列头部tem = []len(deque) = 2 deque = [2]node = 9tem = [9] deque = []node = 2tem = [2，9] deque = [1, 7]res = [ [3], [2, 9] ]  len(res)= 2 2%2=0 下一层插入队列尾部 tem = []len(deque) = 2 deque = [7]node = 1tem = [1] deque = []node = 7tem = [1，7] deque = []res = [ [3], [2, 9], [1，    3         / \\  9   2    /  \\   1    7res = []  len(res)= 0 0%2=0 下一层插入队列尾部deque = [3]tem = [] len(deque) = 1 deque = []node = 3tem = [3] deque = [9]deque = [9, 2]res = [ [3] ] len(res)= 1 1%2=1!=0 下一层插入队列头部tem = []len(deque) = 2 deque = [2]node = 9tem = [9] deque = []node = 2tem = [2，9] deque = [1, 7]res = [ [3], [2, 9] ]  len(res)= 2 2%2=0 下一层插入队列尾部 tem = []len(deque) = 2 deque = [7]node = 1tem = [1] deque = []node = 7tem = [1，7] deque = []res = [ [3], [2, 9], [1，7] ] deque = []为空跳出循环\n\n法二queue也可以直接用列表来存储，使用列表迭代来取节点，这样可以省略pop操作。但是要注意不能直接给queue列表添加元素，这样会导致跳不出for循环，要使用中间变量temp2来存储下一层节点。\n123456789101112131415161718192021222324class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:            return []        queue = [root]        res = []        while queue:            tmp = collections.deque()            temp2 = []            for node in queue:                if len(res) &amp; 1:  # 偶数层                    tmp.appendleft(node.val)                else:  # 奇数层                    tmp.append(node.val)                if node.left:                    temp2.append(node.left)                if node.right:                    temp2.append(node.right)            res.append(list(tmp))            queue = temp2        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:            return []        queue = [root]        res = []        while queue:            tmp = collections.deque()            temp2 = []            for node in queue:                if len(res) &amp; 1:  # 偶数层                    tmp.appendleft(node.val)                else:  # 奇数层                    tmp.append(node.val)                if node.left:                    temp2.append(node.left)                if node.right:                    temp2.append(node.right)            res.append(list(tmp))            queue = temp2        return res\n\n123456789101112131415161718192021222324252627282930313233343536373839    3         / \\  9   2    /  \\   1    7res = []  len(res)= 0 0%2=0 下一层插入队列尾部queue = [3]temp = [] temp2 = [] node = 3temp = [3] temp2 = [9]temp2 = [9, 2]res = [ [3] ] len(res)= 1 1%2=1!=0 下一层插入队列头部queue = [9, 2]temp = []temp2 = []node = 9temp = [9] temp2 = [] node = 2temp = [2, 9] temp2 = [1, 7] res = [ [3], [2, 9] ] len(res)= 2 2%2=0 下一层插入队列尾部queue = [1, 7]temp = []temp2 = []node = 1temp = [1] temp2 = [] node = 7temp = [1, 7] temp2 = [] res = [ [3], [2, 9], [1，    3         / \\  9   2    /  \\   1    7res = []  len(res)= 0 0%2=0 下一层插入队列尾部queue = [3]temp = [] temp2 = [] node = 3temp = [3] temp2 = [9]temp2 = [9, 2]res = [ [3] ] len(res)= 1 1%2=1!=0 下一层插入队列头部queue = [9, 2]temp = []temp2 = []node = 9temp = [9] temp2 = [] node = 2temp = [2, 9] temp2 = [1, 7] res = [ [3], [2, 9] ] len(res)= 2 2%2=0 下一层插入队列尾部queue = [1, 7]temp = []temp2 = []node = 1temp = [1] temp2 = [] node = 7temp = [1, 7] temp2 = [] res = [ [3], [2, 9], [1，7] ] queue = []为空跳出循环\n\n方法三：层序遍历 + 双端队列（奇偶层逻辑分离）通过将奇偶层逻辑拆分，可以消除冗余的判断。算法流程：与方法一对比，仅 BFS 循环不同。\n\nBFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；\n打印奇数层： 从左向右 打印，先左后右 加入下层节点；\n若 deque 为空，说明向下无偶数层，则跳出；\n打印偶数层： 从右向左 打印，先右后左 加入下层节点；\n\n\n\n123456789101112131415161718192021222324252627282930class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque()        deque.append(root)        while deque:            tmp = []            # 打印奇数层            for _ in range(len(deque)):                # 从左向右打印                node = deque.popleft()                tmp.append(node.val)                # 先左后右加入下层节点                if node.left:                     deque.append(node.left)                if node.right:                     deque.append(node.right)            res.append(tmp)            if not deque: break # 若为空则提前跳出            # 打印偶数层            tmp = []            for _ in range(len(deque)):                # 从右向左打印                node = deque.pop()                tmp.append(node.val)                # 先右后左加入下层节点                if node.right: deque.appendleft(node.right)                if node.left: deque.appendleft(node.left)            res.append(tmp)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque()        deque.append(root)        while deque:            tmp = []            # 打印奇数层            for _ in range(len(deque)):                # 从左向右打印                node = deque.popleft()                tmp.append(node.val)                # 先左后右加入下层节点                if node.left:                     deque.append(node.left)                if node.right:                     deque.append(node.right)            res.append(tmp)            if not deque: break # 若为空则提前跳出            # 打印偶数层            tmp = []            for _ in range(len(deque)):                # 从右向左打印                node = deque.pop()                tmp.append(node.val)                # 先右后左加入下层节点                if node.right: deque.appendleft(node.right)                if node.left: deque.appendleft(node.left)            res.append(tmp)        return res\n\n12345678910111213141516171819202122232425262728293031323334353637383940    3         / \\  9   2    /  \\   1    7res = []deque = [3]tem = [] len(deque) = 1deque = []node = 3tem = [3] deque = [9]deque = [9, 2]res = [ [3] ]tem = []len(deque) = 2 deque = [9]node = 2tem = [2] deque = [7, 9]deque = [1, 7, 9]deque = [1, 7]node = 9 deque = [1, 7]res = [ [3], [2, 9] ]  tem = []len(deque) = 2 deque = [7]node = 1tem = [1] deque = []node = 7tem = [1, 7]res = [ [3], [2, 9], [1,     3         / \\  9   2    /  \\   1    7res = []deque = [3]tem = [] len(deque) = 1deque = []node = 3tem = [3] deque = [9]deque = [9, 2]res = [ [3] ]tem = []len(deque) = 2 deque = [9]node = 2tem = [2] deque = [7, 9]deque = [1, 7, 9]deque = [1, 7]node = 9 deque = [1, 7]res = [ [3], [2, 9] ]  tem = []len(deque) = 2 deque = [7]node = 1tem = [1] deque = []node = 7tem = [1, 7]res = [ [3], [2, 9], [1, 7] ] deque = []为空跳出循环\n\n法四奇偶层的判断可以用标志符做判断，利用乘法“正负得负，负负得正”，每层遍历完后做一次乘法，可以很简单的实现标志符的奇偶层转变。\n12345678910111213141516171819202122232425class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque()        deque.append(root)        flag = False  # True False都可以只要反转就行        while deque:            flag = not flag  # 每次都进行反转            tmp = []            for _ in range(len(deque)):                if flag:  # 从左向右打印                    node = deque.popleft()                    if node.left:                        deque.append(node.left)                    if node.right:                        deque.append(node.right)                else:  # 从右向左，出队顺序为头进尾出，右节点早于左节点                    node = deque.pop()                    if node.right:                        deque.appendleft(node.right)                    if node.left:                        deque.appendleft(node.left)                tmp.append(node.val)            res.append(tmp)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res, deque = [], collections.deque()        deque.append(root)        flag = False  # True False都可以只要反转就行        while deque:            flag = not flag  # 每次都进行反转            tmp = []            for _ in range(len(deque)):                if flag:  # 从左向右打印                    node = deque.popleft()                    if node.left:                        deque.append(node.left)                    if node.right:                        deque.append(node.right)                else:  # 从右向左，出队顺序为头进尾出，右节点早于左节点                    node = deque.pop()                    if node.right:                        deque.appendleft(node.right)                    if node.left:                        deque.appendleft(node.left)                tmp.append(node.val)            res.append(tmp)        return res\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647    3         / \\  9   2    /  \\   1    7res = []deque = [3]flag = Falseflag = Truetem = [] len(deque) = 1deque = []node = 3deque = [9]deque = [9, 2]tem = [3] res = [ [3] ]flag = Falsetem = [] len(deque) = 2deque = [9]node = 2deque = [9]deque = [1, 7, 9]tem = [2] deque = [1, 7]node = 9deque = [1, 7]tem = [2, 9] res = [ [3], [2, 9] ]flag = Truetem = [] len(deque) = 2deque = [7]node = 1deque = [7]deque = [7]tem = [1] deque = []node = 7deque = []tem = [1, 7] res = [ [3], [2, 9], [1,     3         / \\  9   2    /  \\   1    7res = []deque = [3]flag = Falseflag = Truetem = [] len(deque) = 1deque = []node = 3deque = [9]deque = [9, 2]tem = [3] res = [ [3] ]flag = Falsetem = [] len(deque) = 2deque = [9]node = 2deque = [9]deque = [1, 7, 9]tem = [2] deque = [1, 7]node = 9deque = [1, 7]tem = [2, 9] res = [ [3], [2, 9] ]flag = Truetem = [] len(deque) = 2deque = [7]node = 1deque = [7]deque = [7]tem = [1] deque = []node = 7deque = []tem = [1, 7] res = [ [3], [2, 9], [1, 7] ]\n\n\n1234567891011121314151617181920212223242526272829303132from collections import dequeclass Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        queue = deque([root])  #储存每一层节点的队列        level = 0  #表示节点的层级        while queue:            res.append([])            if level % 2 == 0:  #偶数层                for i in range(len(queue)):                    node = queue.popleft()                    res[level].append(node.val)                    if node.left:                        queue.append(node.left)                    if node.right:                        queue.append(node.right)            else:  #奇数层                for j in range(len(queue)):                    node = queue.pop()                    res[level].append(node.val)                    if node.right:                        queue.appendleft(node.right)                    if node.left:                        queue.appendleft(node.left)            level += 1        from collections import dequeclass Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        queue = deque([root])  #储存每一层节点的队列        level = 0  #表示节点的层级        while queue:            res.append([])            if level % 2 == 0:  #偶数层                for i in range(len(queue)):                    node = queue.popleft()                    res[level].append(node.val)                    if node.left:                        queue.append(node.left)                    if node.right:                        queue.append(node.right)            else:  #奇数层                for j in range(len(queue)):                    node = queue.pop()                    res[level].append(node.val)                    if node.right:                        queue.appendleft(node.right)                    if node.left:                        queue.appendleft(node.left)            level += 1        return res\n12345678910111213141516171819    3         / \\  9   2    /  \\   1    7res = []deque = [3]flag = Falseflag = Truetem = [] len(deque) = 1deque = []node = 3deque = [9]deque = [9, 2]tem = [3] res = [ [    3         / \\  9   2    /  \\   1    7res = []deque = [3]flag = Falseflag = Truetem = [] len(deque) = 1deque = []node = 3deque = [9]deque = [9, 2]tem = [3] res = [ [3] ]\n\n法五双栈如果当前层是偶数层(0,2,4),就访问queue1并依次读取左子树和右子树,如果当前层是奇数层,就访问queue2并先读取右子树再读取左子树\n1234567891011121314151617181920212223242526272829303132class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        level = 0  # 表示节点的层级        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            if level % 2 == 0:  # 如果当前是奇数层                # 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2                for i in range(len(stack1)):                    node = stack1.pop()                    temp.append(node.val)                    if node.left:                        stack2.append(node.left)                    if node.right:                        stack2.append(node.right)            else:  # 如果当前是偶数层                for j in range(len(stack2)):                    node = stack2.pop()                    temp.append(node.val)                    if node.right:                        stack1.append(node.right)                    if node.left:                        stack1.append(node.left)            res.append(temp)            level += 1        class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        level = 0  # 表示节点的层级        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            if level % 2 == 0:  # 如果当前是奇数层                # 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2                for i in range(len(stack1)):                    node = stack1.pop()                    temp.append(node.val)                    if node.left:                        stack2.append(node.left)                    if node.right:                        stack2.append(node.right)            else:  # 如果当前是偶数层                for j in range(len(stack2)):                    node = stack2.pop()                    temp.append(node.val)                    if node.right:                        stack1.append(node.right)                    if node.left:                        stack1.append(node.left)            res.append(temp)            level += 1        return res\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344    3         / \\  9   2    /  \\   1    7res = []queue1 = [3]queue2 = []level = 0res=[ [] ]len(queue1) = 1queue1 = []node = 3res = [ [3] ]queu2 = [9]queue2 = [9, 2]level = 1res = [ [3], [] ]len(queue2) = 2queue2 = [9]node = 2res = [ [3], [2] ]queue1 = [7]queue1 = [7, 1]queue2 = []node = 9res = [ [3], [2, 9] ]queue1 = [7, 1]level = 2res = [ [3], [2, 9], [] ]len(queue1) = 2queue1 = [7]node = 1res = [ [3], [2, 9], [1] ]queue1 = []node = 7res = [ [3], [2, 9], [1] ]level =     3         / \\  9   2    /  \\   1    7res = []queue1 = [3]queue2 = []level = 0res=[ [] ]len(queue1) = 1queue1 = []node = 3res = [ [3] ]queu2 = [9]queue2 = [9, 2]level = 1res = [ [3], [] ]len(queue2) = 2queue2 = [9]node = 2res = [ [3], [2] ]queue1 = [7]queue1 = [7, 1]queue2 = []node = 9res = [ [3], [2, 9] ]queue1 = [7, 1]level = 2res = [ [3], [2, 9], [] ]len(queue1) = 2queue1 = [7]node = 1res = [ [3], [2, 9], [1] ]queue1 = []node = 7res = [ [3], [2, 9], [1] ]level = 3queue1 = queue2 = [] 都为空，跳出循环\n\n不需要level\n123456789101112131415161718192021222324252627282930class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            if not stack2:  # 如果当前是奇数层                # 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2                while stack1:                    node = stack1.pop()                    temp.append(node.val)                    if node.left:                        stack2.append(node.left)                    if node.right:                        stack2.append(node.right)            else:  # 如果当前是偶数层                while stack2:                    node = stack2.pop()                    temp.append(node.val)                    if node.right:                        stack1.append(node.right)                    if node.left:                        stack1.append(node.left)            if temp:                res.append(temp)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            if not stack2:  # 如果当前是奇数层                # 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2                while stack1:                    node = stack1.pop()                    temp.append(node.val)                    if node.left:                        stack2.append(node.left)                    if node.right:                        stack2.append(node.right)            else:  # 如果当前是偶数层                while stack2:                    node = stack2.pop()                    temp.append(node.val)                    if node.right:                        stack1.append(node.right)                    if node.left:                        stack1.append(node.left)            if temp:                res.append(temp)        return res\n\n\n123456789101112131415161718192021222324252627282930class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            while stack1:                node = stack1.pop()                temp.append(node.val)                if node.left:                    stack2.append(node.left)                if node.right:                    stack2.append(node.right)            if temp:                res.append(temp)            temp2 = []            while stack2:                node = stack2.pop()                temp2.append(node.val)                if node.right:                    stack1.append(node.right)                if node.left:                    stack1.append(node.left)            if temp2:                res.append(temp2)        class Solution:    def levelOrder(self, root: TreeNode) -&gt; [[int]]:        res = []        if not root:            return res        stack1 = [root]  # 栈1存放奇数层的节点。        stack2 = []  # 栈2存放偶数层的节点。        while stack1 or stack2:  # 直到stack1和stack2都为空。            temp = []            while stack1:                node = stack1.pop()                temp.append(node.val)                if node.left:                    stack2.append(node.left)                if node.right:                    stack2.append(node.right)            if temp:                res.append(temp)            temp2 = []            while stack2:                node = stack2.pop()                temp2.append(node.val)                if node.right:                    stack1.append(node.right)                if node.left:                    stack1.append(node.left)            if temp2:                res.append(temp2)        return res\n\n\n\n层序遍历 + 倒序此方法的优点是只用列表即可，无需其他数据结构。偶数层倒序： 若 res 的长度为 奇数 ，说明当前是偶数层，则对 tmp 执行 倒序 操作。复杂度分析：时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N) 。空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。\n1234567891011121314151617181920class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res = []        q = collections.deque()  # BFS模板，需要用队列实现        q.append(root)        while q:            tmp = []            for _ in range(len(q)): # 模板操作                node = q.popleft()                tmp.append(node.val)                if node.left:                    q.append(node.left)                if node.right:                    q.append(node.right)            if len(res) % 2 == 0:  # 如果当前的res的长度是偶数，说明本次tmp中存储的是偶数层(设根为 0 层)                res.append(tmp)            else:                res.append(tmp[::-1])  # 否则将tmp翻转再加入结果集        class Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root: return []        res = []        q = collections.deque()  # BFS模板，需要用队列实现        q.append(root)        while q:            tmp = []            for _ in range(len(q)): # 模板操作                node = q.popleft()                tmp.append(node.val)                if node.left:                    q.append(node.left)                if node.right:                    q.append(node.right)            if len(res) % 2 == 0:  # 如果当前的res的长度是偶数，说明本次tmp中存储的是偶数层(设根为 0 层)                res.append(tmp)            else:                res.append(tmp[::-1])  # 否则将tmp翻转再加入结果集        return res\n\n\n\n\n25.重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n12345678910111213141516171819202122preorder = [3,9,20,15,7]inorder = [9,3,15,20,7]首先根据 preorder 找到根节点是 3    然后根据根节点将 inorder 分成左子树和右子树左子树inorder [9]右子树inorder [15,20,7]把相应的前序遍历的数组也加进来左子树preorder[9] inorder [9]右子树preorder[20 15 7] inorder [15,20,7]现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 preorder = [3,9,20,15,7]inorder = [9,3,15,20,7]首先根据 preorder 找到根节点是 3    然后根据根节点将 inorder 分成左子树和右子树左子树inorder [9]右子树inorder [15,20,7]把相应的前序遍历的数组也加进来左子树preorder[9] inorder [9]右子树preorder[20 15 7] inorder [15,20,7]现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可\n\n我们不需要真的把 preorder 和 inorder 切分了，只需要用分别用两个指针指向开头和结束位置即可。注意下边的两个指针指向的数组范围是包括左边界，不包括右边界。\n给出\n1234567前序遍历preorder = [E,B,A,D,C,F,H,G,I,K,J]中序遍历 inorder = [A,B,C,D,E,F,G,H,I,J,K]根为第一个为 E，则A,B,C,D为E的左子树，F,G,H,I,J,K为E的右子树A,B,C,D为左子树，B,A,D,C,中的根为第一个为B,那么A 为根B的左子树，C,D 为根B的右子树B,A,D,C,中的右子树的根为第一个D，C为根前序遍历preorder = [E,B,A,D,C,F,H,G,I,K,J]中序遍历 inorder = [A,B,C,D,E,F,G,H,I,J,K]根为第一个为 E，则A,B,C,D为E的左子树，F,G,H,I,J,K为E的右子树A,B,C,D为左子树，B,A,D,C,中的根为第一个为B,那么A 为根B的左子树，C,D 为根B的右子树B,A,D,C,中的右子树的根为第一个D，C为根D的左子树\n1234567891011    E    / \\   B   F / \\   \\A   D   H    /  / \\     C  G   I               E    / \\   B   F / \\   \\A   D   H    /  / \\     C  G   I           \\            K           /          J\n\n\n没有重复的元素：表明树中每个节点值都是唯一的，保证节点的数值和它在中序遍历中的下标可以一一对应，这样还原的二叉树才是可以唯一确定的\n在中序遍历中搜索根节点 root 的索引 ，可将此树的中序遍历划分为 [ 左子树 | 根节点 | 右子树 ] 。\n根据中序遍历中的左（右）子树的节点数量，可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ] 。\n左子树区间 和 右子树区间 有对应的 左/右边界这些边界分别用于递归左子树和右子树；\n子树特点： 子树的前序和中序遍历仍符合以上特点，通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。此递推性质让我们联想到用 递归方法 处理。知道inorder中，当前root的左侧的所有点就是其左子树，root的右侧的所有点就是当前root的右子树，就把这左右两堆数字想成当前root的左右2个节点就好，然后扔到函数里进行下一层的递归。\n分治法的思想：把原问题分解（Divide）成若干个与原问题结构相同但规模更小的子问题，待子问题解决（Conquer）以后，再合并（Combine）它们，原问题就得以解决。\n递归某子树解析：\n\n传入形参： \n\n当前递归到此子树根节点在先序遍历中的索引 pre_root 、\n当前递归到此子树在中序遍历列表中的左 / 右边界的索引 in_left / in_right\n\n\n终止条件： 当 in_left &gt; in_right ，子树为空，已经越过叶子节点，此时返回空节点 。\n\n递推工作：recur(pre_root, in_left, in_right)自定义的递归函数，\n\n创建当前根节点root：当前节点在前序遍历中的索引为pre_root的节点前序遍历的首个元素即为根节点 root 的值\n\n搜索树的根节点root在中序遍历的索引i，从而将数组分为左子树和右子树 就是代码中在HashMap中搜索到的 i ； 每次搜索的时间复杂度为 O(1)。 为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（中序遍历的元素，下标）键值对的哈希表。\n\n实参构建根节点root的左子树和右子树：通过调用 recur() 方法开启下一层递归。\n\n左子树：根节点索引为 preL + 1 ，左子树长度 x -(preL + 1) = i - 1 -inL左子树右边界 x = i - 1 -inL + preL + 1 = i -inL + preL左子树右边界不用传入递归函数，但是能方便算右子树的左边界中序遍历的左右边界分别为 in_left 和 i - 1。\n右子树： 根节点索引在前序遍历中为 i - in_left + preL + 1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和 in_right。\n\n\n\n\n返回值： 返回 root 当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。最后一层的结点p的话，他的左右子结点都返回一个空，下面会接着执行return root，也就是这个结点\n\n\nin_left：对当前节点递归时传入；i - 1：中序遍历列表中当前节点的左边一定全部是左子树。\nroot.right = self.recur(pre_root + i - in_left + 1, i + 1, in_right)：当前节点的序号做为0起点，加上中序遍历中左子树的长度，再右移1位得到右子树的根节点的序号；i + 1：中序遍历列表中当前节点的右边一定全部是右子树；in_right：对当前节点递归时传入。\n123456789list2 = ['Runoob', 'Taobao', 'Google']dic = {}for i in range(len(list2)):    dic[list2[i]] = i    print(dic)# {'Runoob': 0}# {'Runoob': 0, 'Taobao': 1}# {'Runoob': 0, 'Taobao': 1, 'Google': 2}list2 = ['Runoob', 'Taobao', 'Google']dic = {}for i in range(len(list2)):    dic[list2[i]] = i    print(dic)# {'Runoob': 0}# {'Runoob': 0, 'Taobao': 1}# {'Runoob': 0, 'Taobao': 1, 'Google': 2}# {'Runoob': 0, 'Taobao': 1, 'Google': 2}\n\n\n1234567891011121314151617181920212223242526272829303132333435class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        # 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；        # 为什创建 po        # 将self.po 指向 preorder 是为了在 recur() 中访问 preorder 。        # 因为 recur() 中要用到前序遍历，所以要建立一个全局变量 po 。        # 也可以把 preorder 作为参数传给 recur() 方法        # 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例        self.dic, self.po = {}, preorder        for i in range(len(inorder)):            # 将中序遍历中序列的节点值及索引全部记录在哈希表中            self.dic[inorder[i]] = i            # 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，            # 用字典搜索是 O(1)         # 根节点 root 的 pre_root, in_left 都是 0        # 开启递归并返回结果        return self.recur(0, 0, len(inorder) - 1)    def recur(self, pre_root, in_left, in_right):        if in_left &gt; in_right: return        # 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None        # 前序遍历的首个元素即为当前子树的根节点 root 的TreeNode对象        root = TreeNode(self.po[pre_root])        # 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树        idx = self.dic[self.po[pre_root]]            # idx = inorder.index(preorder[pre_root])        # index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1)         # 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。        # 开启左子树的下层递归，找左子树的根：        root.left = self.recur(pre_root + 1, in_left, idx - 1)         # 开启右子树的下层递归，找右子树的根：        root.right = self.recur(idx - in_left + pre_root + 1, idx + 1, in_right)         # 返回根节点，作为上层递归的左（右）子节点        class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        # 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；        # 为什创建 po        # 将self.po 指向 preorder 是为了在 recur() 中访问 preorder 。        # 因为 recur() 中要用到前序遍历，所以要建立一个全局变量 po 。        # 也可以把 preorder 作为参数传给 recur() 方法        # 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例        self.dic, self.po = {}, preorder        for i in range(len(inorder)):            # 将中序遍历中序列的节点值及索引全部记录在哈希表中            self.dic[inorder[i]] = i            # 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，            # 用字典搜索是 O(1)         # 根节点 root 的 pre_root, in_left 都是 0        # 开启递归并返回结果        return self.recur(0, 0, len(inorder) - 1)    def recur(self, pre_root, in_left, in_right):        if in_left &gt; in_right: return        # 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None        # 前序遍历的首个元素即为当前子树的根节点 root 的TreeNode对象        root = TreeNode(self.po[pre_root])        # 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树        idx = self.dic[self.po[pre_root]]            # idx = inorder.index(preorder[pre_root])        # index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1)         # 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。        # 开启左子树的下层递归，找左子树的根：        root.left = self.recur(pre_root + 1, in_left, idx - 1)         # 开启右子树的下层递归，找右子树的根：        root.right = self.recur(idx - in_left + pre_root + 1, idx + 1, in_right)         # 返回根节点，作为上层递归的左（右）子节点        return root  \n\n123456789101112131415class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        def recur(pre_root, in_left, in_right):            if in_left &gt; in_right: return # 终止条件：中序遍历为空            # 直接用 preorder             root = TreeNode(preorder[pre_root])  # 建立当前子树的根节点            i = dic[preorder[pre_root]]  # 搜索根节点在中序遍历中的索引，从而可对根节点、左子树、右子树完成划分。            root.left = recur(pre_root + 1, in_left, i - 1) # 开启左子树的下层递归            root.right = recur(i - in_left + pre_root + 1, i + 1, in_right) # 开启右子树的下层递归            return root # 返回根节点，作为上层递归的左（右）子节点        dic = {}        for i in range(len(inorder)):            dic[inorder[i]] = i        return recur(0, 0, len(inorder) - class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        def recur(pre_root, in_left, in_right):            if in_left &gt; in_right: return # 终止条件：中序遍历为空            # 直接用 preorder             root = TreeNode(preorder[pre_root])  # 建立当前子树的根节点            i = dic[preorder[pre_root]]  # 搜索根节点在中序遍历中的索引，从而可对根节点、左子树、右子树完成划分。            root.left = recur(pre_root + 1, in_left, i - 1) # 开启左子树的下层递归            root.right = recur(i - in_left + pre_root + 1, i + 1, in_right) # 开启右子树的下层递归            return root # 返回根节点，作为上层递归的左（右）子节点        dic = {}        for i in range(len(inorder)):            dic[inorder[i]] = i        return recur(0, 0, len(inorder) - 1)\n\n法二\n1234567891011121314151617181920212223242526272829303132class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        # 递归终止条件        # 如果分割到没有左子树或者右子树的时候，        # 那么就意味着根节点的left或者right要指向None        # 实际上inorder 和 preorder一定是同时为空的，因此你无论判断哪个都行        if not preorder or not inorder:              return        # 递归条件：任一节点了若有左节点，那你必须先遍历它的左节点                  root = TreeNode(preorder[0])  # 取出preorder 的第一个值就是根节点        idx = inorder.index(preorder[0])  # 获取在中序遍历中的根节点的索引值        # idx还能当长度用，相当于 左+根 的长度，因为 左+根 和 根+左 是等长的        # 索引值代表了左子树的长度，idx从0开始，                # 下面递归对root的左右子树求解即可        # 中序遍历的 列表的左右节点 分开 切片 成两个列表        # 左闭右开        # 传入子数组参数比较耗时，相当于每次开启递归都要建立两个新的数组，其实是没有必要的        inLeft = inorder[0:idx]        inRight = inorder[idx + 1:]        # 前序遍历的 列表的左右节点 分开 切片 成两个列表        preLeft = preorder[1:idx + 1]        preRight = preorder[idx + 1:]                # 左子树        root.left = self.buildTree(preLeft, inLeft)        # 右子树        root.right = self.buildTree(preRight, inRight)        return root  class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        # 递归终止条件        # 如果分割到没有左子树或者右子树的时候，        # 那么就意味着根节点的left或者right要指向None        # 实际上inorder 和 preorder一定是同时为空的，因此你无论判断哪个都行        if not preorder or not inorder:              return        # 递归条件：任一节点了若有左节点，那你必须先遍历它的左节点                  root = TreeNode(preorder[0])  # 取出preorder 的第一个值就是根节点        idx = inorder.index(preorder[0])  # 获取在中序遍历中的根节点的索引值        # idx还能当长度用，相当于 左+根 的长度，因为 左+根 和 根+左 是等长的        # 索引值代表了左子树的长度，idx从0开始，                # 下面递归对root的左右子树求解即可        # 中序遍历的 列表的左右节点 分开 切片 成两个列表        # 左闭右开        # 传入子数组参数比较耗时，相当于每次开启递归都要建立两个新的数组，其实是没有必要的        inLeft = inorder[0:idx]        inRight = inorder[idx + 1:]        # 前序遍历的 列表的左右节点 分开 切片 成两个列表        preLeft = preorder[1:idx + 1]        preRight = preorder[idx + 1:]                # 左子树        root.left = self.buildTree(preLeft, inLeft)        # 右子树        root.right = self.buildTree(preRight, inRight)        return root  # 返回构造后树的根节点\n\n时间复杂度在最坏情况下(即左侧链，此时先序遍历与中序遍历相反，每一个根都需要在中序中查找一次)为O(n^2)\n迭代法\n123456789101112131415161718192021222324252627class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        \"\"\"思路为官方题解的迭代法思路，注意每次遍历比较的是什么，        一定要在纸上模拟一遍，不要光想\"\"\"        if not preorder:            return None                    root = TreeNode(preorder[0])        stack = []        L = len(preorder)        stack.append(root)        index = 0        for i in range(1, L):            preorderval = preorder[i]            if inorder[index] != stack[-1].val: # 比较栈顶元素和inorder                node = stack[-1]                node.left = TreeNode(preorderval)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[index]:                    node = stack[-1]                    stack.pop()                    index += 1                node.right = TreeNode(preorderval)                stack.append(node.right)        class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        \"\"\"思路为官方题解的迭代法思路，注意每次遍历比较的是什么，        一定要在纸上模拟一遍，不要光想\"\"\"        if not preorder:            return None                    root = TreeNode(preorder[0])        stack = []        L = len(preorder)        stack.append(root)        index = 0        for i in range(1, L):            preorderval = preorder[i]            if inorder[index] != stack[-1].val: # 比较栈顶元素和inorder                node = stack[-1]                node.left = TreeNode(preorderval)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[index]:                    node = stack[-1]                    stack.pop()                    index += 1                node.right = TreeNode(preorderval)                stack.append(node.right)        return root\n\n123456789101112131415161718192021222324class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None                root = TreeNode(preorder[0])        length = len(preorder)        stack = []        stack.append(root)        index = 0        for i in range(1, length):            preorderval = preorder[i]            node = stack[-1]            if node.val != inorder[index]: # 每次比较栈顶元素和inorder[index]                node.left = TreeNode(preorderval)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[index]:# 栈顶元素等于inorder[index],弹出；并且index += 1                    node = stack[-1]                    stack.pop()                    index += 1                node.right = TreeNode(preorderval)                stack.append(node.right)        class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None                root = TreeNode(preorder[0])        length = len(preorder)        stack = []        stack.append(root)        index = 0        for i in range(1, length):            preorderval = preorder[i]            node = stack[-1]            if node.val != inorder[index]: # 每次比较栈顶元素和inorder[index]                node.left = TreeNode(preorderval)                stack.append(node.left)            else:                while stack and stack[-1].val == inorder[index]:# 栈顶元素等于inorder[index],弹出；并且index += 1                    node = stack[-1]                    stack.pop()                    index += 1                node.right = TreeNode(preorderval)                stack.append(node.right)        return root\n\n根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。例如，给出\n12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]\n1234567返回如下的二叉树：    3   / \\  9  20    /  \\   15   返回如下的二叉树：    3   / \\  9  20    /  \\   15   7\n\n\n根据中序遍历和后续遍历的特性我们进行树的还原过程分析首先在后序遍历序列中找到最后一个元素为根节点根据根节点在中序遍历序列中找到根节点的位置根据根节点的位置将中序遍历序列分为左子树和右子树，和子树节点个数根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置递归构造左子树和右子树返回根节点结束\n\n中序序列 表示中序遍历的输出序列；后序序列 表示后序遍历的输出序列。\n先定义变量：in_left: 在中序序列中的左边界，初始化为 0；in_right: 在中序序列中的右边界，初始化为序列末尾索引位置；in_root: 在中序序列中根节点的位置；post_left：在后序序列中的左边界，初始化为 0；post_right：在后序序列中的右边界，初始化为序列末尾索引位置；post_root：在后序序列中根节点的位置。\n后序左子树右边界x①：都用左边in_root -1 - in_left = x - post_leftx = in_root - 1 - in_left + post_left \n②：都用in_rightpost_right - x = in_right - (in_root - 1)x = post_right - in_right + (in_root - 1)\n右子树左边界y①：都用左边y - post_left = in_root - in_lefty = in_root - in_left + post_left②：都用in_rightin_R - (in_root + 1) = post_right - 1 - yy = post_right -1 - in_R + (in_root + 1)y = post_right - in_R + in_root先用法②\n要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。因为是根据后序建立的索引，是从后往前递减的\n中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3]从后序里先拿了3，然后找到中序里3的位置，就能知道9是左子树，15 20 7是右子树 接下来再从后序里拿20，这时候是应该先算中序里的右子树，等右子树三个点都算完了，index才会到9这个点，也就是开始算左子树返回根节点 root。\n12345678910111213141516171819202122232425262728293031323334353637class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        # 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；        # 为什创建 po        # 将self.po 指向 postorder 是为了在 recur() 中访问 postorder 。        # 因为 recur() 中要用到后序遍历，所以要建立一个全局变量 po 。        # 也可以把 postorder 作为参数传给 recur() 方法        # 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例        self.dic, self.po = {}, postorder        for i in range(len(inorder)):            # 将中序遍历中序列的节点值及索引全部记录在哈希表中            self.dic[inorder[i]] = i            # 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，            # 用字典搜索是 O(1)         # 根节点 root 的 pre_root, in_right 都是 len(inorder) - 1        # 开启递归并返回结果        return self.recur(len(inorder) - 1, 0, len(inorder) - 1)    def recur(self, post_right, in_left, in_right):        if in_left &gt; in_right: return        # 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None        # 后序序列末尾元素就是根节点        post_root = post_right        # 根节点 root 的TreeNode对象        root = TreeNode(self.po[post_root])        # 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树        idx = self.dic[self.po[post_root]]            # idx = inorder.index(preorder[post_root])        # index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1)         # 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。        # 开启右子树的下层递归，找右子树的根：        root.right = self.recur(post_right - 1, idx + 1, in_right)         # 开启左子树的下层递归，找左子树的根：        root.left = self.recur(idx + post_right - in_right - 1, in_left, idx - 1)         # 返回根节点，作为上层递归的左（右）子节点        class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        # 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；        # 为什创建 po        # 将self.po 指向 postorder 是为了在 recur() 中访问 postorder 。        # 因为 recur() 中要用到后序遍历，所以要建立一个全局变量 po 。        # 也可以把 postorder 作为参数传给 recur() 方法        # 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例        self.dic, self.po = {}, postorder        for i in range(len(inorder)):            # 将中序遍历中序列的节点值及索引全部记录在哈希表中            self.dic[inorder[i]] = i            # 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，            # 用字典搜索是 O(1)         # 根节点 root 的 pre_root, in_right 都是 len(inorder) - 1        # 开启递归并返回结果        return self.recur(len(inorder) - 1, 0, len(inorder) - 1)    def recur(self, post_right, in_left, in_right):        if in_left &gt; in_right: return        # 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None        # 后序序列末尾元素就是根节点        post_root = post_right        # 根节点 root 的TreeNode对象        root = TreeNode(self.po[post_root])        # 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树        idx = self.dic[self.po[post_root]]            # idx = inorder.index(preorder[post_root])        # index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1)         # 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。        # 开启右子树的下层递归，找右子树的根：        root.right = self.recur(post_right - 1, idx + 1, in_right)         # 开启左子树的下层递归，找左子树的根：        root.left = self.recur(idx + post_right - in_right - 1, in_left, idx - 1)         # 返回根节点，作为上层递归的左（右）子节点        return root  \n\n定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，递归入口为helper(0, n - 1) ：如果 in_left &gt; in_right，说明子树为空，返回空节点。选择后序遍历的最后一个节点作为根节点。利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。\n1234567891011121314151617181920212223class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        def helper(in_left, in_right):            # 如果这里没有节点构造二叉树了，就结束            if in_left &gt; in_right:                return None                        # 选择 post_idx 位置的元素作为当前子树根节点            val = postorder.pop()            root = TreeNode(val)            # 根据 root 所在位置分成左右两棵子树            index = idx_map[val]             # 构造右子树            root.right = helper(index + 1, in_right)            # 构造左子树            root.left = helper(in_left, index - 1)            return root                # 建立（元素，下标）键值对的哈希表        idx_map = {val:idx for idx, val in enumerate(inorder)}         return helper(0, len(inorder) - class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        def helper(in_left, in_right):            # 如果这里没有节点构造二叉树了，就结束            if in_left &gt; in_right:                return None                        # 选择 post_idx 位置的元素作为当前子树根节点            val = postorder.pop()            root = TreeNode(val)            # 根据 root 所在位置分成左右两棵子树            index = idx_map[val]             # 构造右子树            root.right = helper(index + 1, in_right)            # 构造左子树            root.left = helper(in_left, index - 1)            return root                # 建立（元素，下标）键值对的哈希表        idx_map = {val:idx for idx, val in enumerate(inorder)}         return helper(0, len(inorder) - 1)\n时间复杂度：O(n)，其中 n 是树中的节点个数。空间复杂度：O(n)。我们需要使用 O(n) 的空间存储哈希表，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，\n1234567891011121314151617181920212223242526272829303132333435363738class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        def build_tree(in_left, in_right, post_left, post_right):            if in_left &gt; in_right:                return                        # 后序序列末尾元素就是根节点            post_root = post_right            # 构造节点            root = TreeNode(postorder[post_root])            # 在中序序列定位根节点位置            in_root = inorder_map[root.val]                            # size_of_right = in_right - in_root            # 获取中序序列中左子树的节点数            size_of_left = in_root - in_left                        # root.left = build_tree(in_left, in_root-1, post_left, post_right-size_of_right-1)            # 递归构建左子树            root.left = build_tree(in_left, in_root-1, post_left, post_left+size_of_left-1)            # root.right = build_tree(in_root+1, in_right, post_right-size_of_right, post_right-1)            # 递归构建右子树            root.right = build_tree(in_root+1, in_right, post_left+size_of_left, post_root-1)            return root        size = len(inorder)        # 先用字典存储中序序列，元素及其对应的索引位置        inorder_map = {}        for i in range(size):            inorder_map[inorder[i]] = i        return build_tree(0, size-1, 0, sizeclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        def build_tree(in_left, in_right, post_left, post_right):            if in_left &gt; in_right:                return                        # 后序序列末尾元素就是根节点            post_root = post_right            # 构造节点            root = TreeNode(postorder[post_root])            # 在中序序列定位根节点位置            in_root = inorder_map[root.val]                            # size_of_right = in_right - in_root            # 获取中序序列中左子树的节点数            size_of_left = in_root - in_left                        # root.left = build_tree(in_left, in_root-1, post_left, post_right-size_of_right-1)            # 递归构建左子树            root.left = build_tree(in_left, in_root-1, post_left, post_left+size_of_left-1)            # root.right = build_tree(in_root+1, in_right, post_right-size_of_right, post_right-1)            # 递归构建右子树            root.right = build_tree(in_root+1, in_right, post_left+size_of_left, post_root-1)            return root        size = len(inorder)        # 先用字典存储中序序列，元素及其对应的索引位置        inorder_map = {}        for i in range(size):            inorder_map[inorder[i]] = i        return build_tree(0, size-1, 0, size-1)\n\n\n26.树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n12345678910111213141516171819树A：    3    / \\   4   5  / \\ 1   2树 B：①   3   / 4②   5     \\     ③   4   /  树A：    3    / \\   4   5  / \\ 1   2树 B：①   3   / 4②   5     \\     ③   4   /  1  \n\n名词规定：树 A 的根节点记作 节点 A ，树 B 的根节点称为 节点 B 。\n解题思路：若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：\n\n先序遍历树 A 中的每个节点 n_A；（对应函数 isSubStructure(A, B)）\n判断树 A 中 以 n_A 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）\n\n如果a树和b树的当前节点的值相同，那么比较a的左右节点和b的左右子树是否相同如果a树和b树的当前节点的值不同，那么比较a的左子树和B是否相同，或者比较a的右子树和B是否相同\nrecur判断A,B的根结点是否相同，相同的话继续递归左右子节点判断是否相同，一直相同的话就返回true，若不相同就调用A的左节点或者右几点为根结点与B比较，都要重新匹配整个树 B \n算法流程：isSubStructure(A, B) 函数：\n\n特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；\n返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；\n以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；\n树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；\n树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；以上 2. 3. 实质上是在对树 A 做 先序遍历 。\n\n\n\nrecur(A, B) 函数：在匹配子结构，因此要 左子树相同 “且”右子树相同才是子结构。\n\n终止条件：\n当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；\n当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；\n当节点 A 和 B 的值不同：说明匹配失败，返回 false ；\n\n\n返回值：\n判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；\n判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；\n\n复杂度分析：时间复杂度 O(MN)： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。\n空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。当达到 M 时， 树 B 只遍历一层就会返回 因为 树 A 已经到底了~ \n空间复杂度要看在同一时刻，有多少递归函数未返回，而不是总共执行了多少函数。因为递归过程中是会回溯的，返回了的函数就不计入空间复杂度计算啦\n这类题目与字符串匹配有些神似，求解过程大致分为两步：先将根节点匹配；根节点匹配后，对子树进行匹配。而参与匹配的二叉树可以是一棵，与自身匹配；也可以是两棵，即互相匹配。\n12345678910111213141516171819202122232425262728293031323334class Solution:    def isSubStructure(self, A: TreeNode, B: TreeNode) -&gt; bool:        # 定义一个标志位res用来做判断        res = False  # 如果没这句 local variable 'res' referenced befored assignment        # 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false        if A is not None and B is not None:            if A.val == B.val:                res = self.helper(A, B)            # 如果根结点开始的没有找到，那么就再去TreeA的左子节点当作起点，去判断是否包含TreeB            if not res:                res = self.isSubStructure(A.left, B)            # 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB            if not res:                res = self.isSubStructure(A.right, B)        # 最后返回help()里面的res即得到结果        return res        def helper(self, A, B):        # 用于递归判断树的每个节点是否相同        # 需要注意的地方是: 前两个if语句不可以颠倒顺序        # 如果颠倒顺序，会先判断A是否为None，当A为空B为空时，B的结点已经遍历完成确定相等了，但是返回了False，判断错误先        # 如果TreeB已经遍历完了，还没发现不一样的，        # B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构        if B is None:            return True        # 如果TreeB还没有遍历完，TreeA却遍历完了。返回false        if A is None:            return False        # 如果其中有一个点没有对应上，返回false        if A.val != B.val:            return False        # 如果以上情况都不是，说明A.val == B.val，根节点对应的上，        # 那么继续向下递归判断子节点里是否匹配        return self.helper(A.left, B.left) class Solution:    def isSubStructure(self, A: TreeNode, B: TreeNode) -&gt; bool:        # 定义一个标志位res用来做判断        res = False  # 如果没这句 local variable 'res' referenced befored assignment        # 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false        if A is not None and B is not None:            if A.val == B.val:                res = self.helper(A, B)            # 如果根结点开始的没有找到，那么就再去TreeA的左子节点当作起点，去判断是否包含TreeB            if not res:                res = self.isSubStructure(A.left, B)            # 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB            if not res:                res = self.isSubStructure(A.right, B)        # 最后返回help()里面的res即得到结果        return res        def helper(self, A, B):        # 用于递归判断树的每个节点是否相同        # 需要注意的地方是: 前两个if语句不可以颠倒顺序        # 如果颠倒顺序，会先判断A是否为None，当A为空B为空时，B的结点已经遍历完成确定相等了，但是返回了False，判断错误先        # 如果TreeB已经遍历完了，还没发现不一样的，        # B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构        if B is None:            return True        # 如果TreeB还没有遍历完，TreeA却遍历完了。返回false        if A is None:            return False        # 如果其中有一个点没有对应上，返回false        if A.val != B.val:            return False        # 如果以上情况都不是，说明A.val == B.val，根节点对应的上，        # 那么继续向下递归判断子节点里是否匹配        return self.helper(A.left, B.left) and self.helper(A.right, B.right)\n\n123456789101112131415161718192021222324252627282930class Solution:    def isSubStructure(self, A: TreeNode, B: TreeNode) -&gt; bool:        # 若两个结点有一个为空，不符合要求        if B == None or A == None:            return False        # 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false        if A is not None and B is not None:            # 如果找到了对应TreeB的根节点的点            if A.val == B.val and self.helper(A,B):                return True            return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)            # 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB        def helper(self, A, B):        # 用于递归判断树的每个节点是否相同        # 需要注意的地方是: 前两个if语句不可以颠倒顺序        # 如果颠倒顺序，会先判断A是否为None，其实这个时候B的结点已经遍历完成确定相等了，但是返回了False，判断错误        # 如果TreeB已经遍历完了，还没发现不一样的，        # B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构        if B is None:            return True        # 如果TreeB还没有遍历完，TreeA却遍历完了。返回false        if A is None:            return False        # 如果其中有一个点没有对应上，返回false        if A.val != B.val:            return False        # 如果以上情况都不是，说明A.val == B.val，根节点对应的上，        # 那么继续向下递归判断子节点里是否匹配        return self.helper(A.left, B.left) class Solution:    def isSubStructure(self, A: TreeNode, B: TreeNode) -&gt; bool:        # 若两个结点有一个为空，不符合要求        if B == None or A == None:            return False        # 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false        if A is not None and B is not None:            # 如果找到了对应TreeB的根节点的点            if A.val == B.val and self.helper(A,B):                return True            return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B)            # 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB        def helper(self, A, B):        # 用于递归判断树的每个节点是否相同        # 需要注意的地方是: 前两个if语句不可以颠倒顺序        # 如果颠倒顺序，会先判断A是否为None，其实这个时候B的结点已经遍历完成确定相等了，但是返回了False，判断错误        # 如果TreeB已经遍历完了，还没发现不一样的，        # B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构        if B is None:            return True        # 如果TreeB还没有遍历完，TreeA却遍历完了。返回false        if A is None:            return False        # 如果其中有一个点没有对应上，返回false        if A.val != B.val:            return False        # 如果以上情况都不是，说明A.val == B.val，根节点对应的上，        # 那么继续向下递归判断子节点里是否匹配        return self.helper(A.left, B.left) and self.helper(A.right, B.right)\n\n\n\n27.二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。\n输入描述:123456789101112二叉树的镜像定义：源二叉树             4           /  \\          2     7         / \\   / \\        1   3 6   9        镜像二叉树             4           /  \\          7     2         / \\   / \\        9   6 3   二叉树的镜像定义：源二叉树             4           /  \\          2     7         / \\   / \\        1   3 6   9        镜像二叉树             4           /  \\          7     2         / \\   / \\        9   6 3   1\n\n二叉树镜像定义：对于二叉树中任意节点 root ，设其左 / 右子节点分别为 left, right ；则在二叉树的镜像中的对应 root 节点，其左 / 右子节点分别为 right, left 。\n方法一：递归 （dfs）二叉树\n交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换和现实中的树是一样的，是根 — 枝 — 叶 的结构。当我们剪下两个树枝（上面分别有树枝分叉、直到叶），并将此二树枝交换位置 嫁接回树上。 此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。仔细看下题目的输入和输出，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来完成这道题。\n①前序遍历，是基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。递归解析：\n\n终止条件： 当节点 root 为空时（即越过叶节点），则返回 None ；\n递推工作：\n初始化节点 tmp ，用于暂存 root 的左子节点；\n交换当前节点的左右节点，整个子树交换但它们内部的子树还没翻转，并将返回值作为 root 的节点\n再递归的交换当前节点的左节点，递归的交换当前节点的右节点，并将返回值作为 root 的 子节点 。\n\n\n返回值： 返回当前节点 root ；  \n\n时间复杂度：每个元素都必须访问一次，所以是O(n)空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)\nQ： 为何需要暂存 root 的左子节点？A： 在递归右子节点 “root.left = mirrorTree(root.right);” 执行完毕后，root.left 的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。\n这个节点不存在，比如叶子节点返回左子树，就是返回空相当于 root = None ，交换只是把 None 赋给了一个变量，不会报错，只要不执行 None.left 这种就好\n在交换左右孩子的时候，temp指针在函数体结束返回后，temp 会被销毁，temp所指向的数据不会销毁，销毁指针数据的方法是delete temp;\n1234567891011121314151617181920212223242526272829303132333435             4           /  \\          2     7         / \\   / \\        1   3 6   9root = 4tmp = root.left = 2root.left = root.right = 7root.right = tmp = 2             4           /  \\          7     2         / \\   / \\        6   9 1   3root = root.left = 7tmp = root.left = 6root.left = root.right = 9root.right = tmp = 6             4           /  \\          7     2         / \\   / \\        9   6 1   3第一个递归函数的函数root不断改变不影响第二个递归函数的函数root的初始值root = root.right = 2tmp = root.left = 1root.left = root.right = 3root.right = tmp = 1             4           /  \\          7     2         / \\   / \\        9   6 3                4           /  \\          2     7         / \\   / \\        1   3 6   9root = 4tmp = root.left = 2root.left = root.right = 7root.right = tmp = 2             4           /  \\          7     2         / \\   / \\        6   9 1   3root = root.left = 7tmp = root.left = 6root.left = root.right = 9root.right = tmp = 6             4           /  \\          7     2         / \\   / \\        9   6 1   3第一个递归函数的函数root不断改变不影响第二个递归函数的函数root的初始值root = root.right = 2tmp = root.left = 1root.left = root.right = 3root.right = tmp = 1             4           /  \\          7     2         / \\   / \\        9   6 3   1\n\n12345678910111213class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        # 递归函数的终止条件，节点为空时返回        if not root: return        # 将当前节点的左右子树交换        tmp = root.left        root.left = root.right        root.right = tmp        # 递归交换当前节点的 左子树和右子树        self.mirrorTree(root.left)        self.mirrorTree(root.right)        # 返回时就表示当前这个节点，以及它的左右子树都已经交换完了            class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        # 递归函数的终止条件，节点为空时返回        if not root: return        # 将当前节点的左右子树交换        tmp = root.left        root.left = root.right        root.right = tmp        # 递归交换当前节点的 左子树和右子树        self.mirrorTree(root.left)        self.mirrorTree(root.right)        # 返回时就表示当前这个节点，以及它的左右子树都已经交换完了            return root\n\n②后序遍历，基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。递归解析：\n\n终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；\n递推工作：\n从根节点开始，递归地对树进行遍历，直到遇到 null 节点，结束递归调用。\n并从叶子结点先开始翻转。\n如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。\n\n\n返回值： 返回当前节点 root ；  \n\n时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。\n1234567891011class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        # 递归压栈压到底        self.mirrorTree(root.left)        self.mirrorTree(root.right)        tmp = root.left        # 执行交换        root.left = root.right        root.right = tmp        class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        # 递归压栈压到底        self.mirrorTree(root.left)        self.mirrorTree(root.right)        tmp = root.left        # 执行交换        root.left = root.right        root.right = tmp        return root\n123456789101112131415161718192021222324252627282930313233343536373839             4           /  \\          2     7         / \\   / \\        1   3 6   9             4           /  \\          2     7         / \\   / \\        9   3 6   1             4           /  \\          2     7         / \\   / \\        9   6 3   1             4           /  \\          7     2         / \\   / \\        3   1 9   6            ``` ③1. 终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；2. 递推工作：   1. 初始化节点 tmp ，用于暂存 root 的左子节点；   2. 开启递归 右子节点 mirrorTree(root.right) ，并将返回值作为 root 的 左子节点 。   3. 开启递归 左子节点 mirrorTree(tmp) ，并将返回值作为 root 的 右子节点 。3. 返回值： 返回当前节点 root ；  ```pyclass Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        tmp = root.left        # 开始递归，重头开始执行原来右边的完成，终止时root为最右下角的节点        root.left = self.mirrorTree(root.right)        # 执行原来左边的        root.right = self.mirrorTree(tmp)        return              4           /  \\          2     7         / \\   / \\        1   3 6   9             4           /  \\          2     7         / \\   / \\        9   3 6   1             4           /  \\          2     7         / \\   / \\        9   6 3   1             4           /  \\          7     2         / \\   / \\        3   1 9   6            ``` ③1. 终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；2. 递推工作：   1. 初始化节点 tmp ，用于暂存 root 的左子节点；   2. 开启递归 右子节点 mirrorTree(root.right) ，并将返回值作为 root 的 左子节点 。   3. 开启递归 左子节点 mirrorTree(tmp) ，并将返回值作为 root 的 右子节点 。3. 返回值： 返回当前节点 root ；  ```pyclass Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        tmp = root.left        # 开始递归，重头开始执行原来右边的完成，终止时root为最右下角的节点        root.left = self.mirrorTree(root.right)        # 执行原来左边的        root.right = self.mirrorTree(tmp)        return root\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119             4           /  \\          2     7         / \\   / \\        1   3 6   9root = 4tmp = root.left = 2root.right = 7root = root.right = 7tmp = root.left = 6 暂存 7 的左子节点 6root.right = 9开启递归 7 的右子节点为 9root = root.right = 9tmp = root.left = None  # 暂存 9 的左子节点 Noneroot.right = None  开启递归 9 的右子节点 None ，触发终止条件并返回 root = root.right = None 开启递归 9 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 9 赋值给 7 的左子节点为 9root = 7root.left  = 9             4           /   \\          2     7         / \\   / \\        1   3 9   9tmp = 6开启递归 7 的左子节点为 6root = tmp = 6tmp = root.left = None  # 暂存 6 的左子节点 Noneroot.right = None  开启递归 6 的右子节点 None ，触发终止条件并返回 root = root.right = None return 空开启递归 6 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 6 赋值 7 的右子节点root = 7 root.right = 6             4           /  \\          2     7         / \\   / \\        1   3 9   6 返回节点 7，7的子节点都用过，跳到上一层节点4  root = 4 tmp = root.left = 2root.right = 7 开启递归 4 的右子节点 7root = root.right = 7 tmp = root.left = None  # 已经用过了 暂存 6 的左子节点 Noneroot.right = None  开启递归 7 的右子节点 None ，触发终止条件并返回 root = root.right = None return 空开启递归 7 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 7 赋值 4 的左子节点root.left = 7             4           /  \\  2       7     7 / \\      / \\   / \\1   3    9   6 9   6  tmp = 2 开启递归4的左子节点2root = tmp = 2tmp = root.left = 1root.right = tmp = 3开启递归2的右子节点3root = root.right = 3tmp = root.left = None   # 暂存 3 的左子节点 None开启递归 3 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 3 的左子节点 None，触发终止条件并返回函数返回 3 赋值给 2 的左子节点root.left = 3             4           /  \\  2       7     7 / \\      / \\   / \\3   3    9   6 9   6  开启递归2的左子节点1 tmproot = tmp = 1tmp = root.left = None   # 暂存 3 的左子节点 None开启递归 1 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 1 的左子节点 None，触发终止条件并返回             4           /  \\  2       7     7 / \\      / \\   / \\3   1    9   6 9   6  返回节点1，2的子节点都用过，跳到上一层返回节点4  开启递归节点4 root = 4tmp = root.left = 2开启递归 4 的左子节点 2root = tmp = 2  root.right = Nonetmp = root.left = None   # 暂存 3 的左子节点 None开启递归 1 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 1 的左子节点 None，触发终止条件并返回函数返回 2 赋值给 4 的右子节点root.right = 2其子树一起移动             4           /  \\          7     2         / \\   / \\        9   6 3                4           /  \\          2     7         / \\   / \\        1   3 6   9root = 4tmp = root.left = 2root.right = 7root = root.right = 7tmp = root.left = 6 暂存 7 的左子节点 6root.right = 9开启递归 7 的右子节点为 9root = root.right = 9tmp = root.left = None  # 暂存 9 的左子节点 Noneroot.right = None  开启递归 9 的右子节点 None ，触发终止条件并返回 root = root.right = None 开启递归 9 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 9 赋值给 7 的左子节点为 9root = 7root.left  = 9             4           /   \\          2     7         / \\   / \\        1   3 9   9tmp = 6开启递归 7 的左子节点为 6root = tmp = 6tmp = root.left = None  # 暂存 6 的左子节点 Noneroot.right = None  开启递归 6 的右子节点 None ，触发终止条件并返回 root = root.right = None return 空开启递归 6 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 6 赋值 7 的右子节点root = 7 root.right = 6             4           /  \\          2     7         / \\   / \\        1   3 9   6 返回节点 7，7的子节点都用过，跳到上一层节点4  root = 4 tmp = root.left = 2root.right = 7 开启递归 4 的右子节点 7root = root.right = 7 tmp = root.left = None  # 已经用过了 暂存 6 的左子节点 Noneroot.right = None  开启递归 7 的右子节点 None ，触发终止条件并返回 root = root.right = None return 空开启递归 7 的左子节点 None，触发终止条件并返回root = tmp = None函数返回 7 赋值 4 的左子节点root.left = 7             4           /  \\  2       7     7 / \\      / \\   / \\1   3    9   6 9   6  tmp = 2 开启递归4的左子节点2root = tmp = 2tmp = root.left = 1root.right = tmp = 3开启递归2的右子节点3root = root.right = 3tmp = root.left = None   # 暂存 3 的左子节点 None开启递归 3 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 3 的左子节点 None，触发终止条件并返回函数返回 3 赋值给 2 的左子节点root.left = 3             4           /  \\  2       7     7 / \\      / \\   / \\3   3    9   6 9   6  开启递归2的左子节点1 tmproot = tmp = 1tmp = root.left = None   # 暂存 3 的左子节点 None开启递归 1 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 1 的左子节点 None，触发终止条件并返回             4           /  \\  2       7     7 / \\      / \\   / \\3   1    9   6 9   6  返回节点1，2的子节点都用过，跳到上一层返回节点4  开启递归节点4 root = 4tmp = root.left = 2开启递归 4 的左子节点 2root = tmp = 2  root.right = Nonetmp = root.left = None   # 暂存 3 的左子节点 None开启递归 1 的右子节点 None ，触发终止条件并返回 root.right = tmp = None开启递归 1 的左子节点 None，触发终止条件并返回函数返回 2 赋值给 4 的右子节点root.right = 2其子树一起移动             4           /  \\          7     2         / \\   / \\        9   6 3   1\n\n迭代①辅助栈（或队列）利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。算法流程：特例处理： 当 root 为空时，直接返回 null ；初始化： 栈（或队列），本文用栈，并加入根节点 root 。循环交换： 当栈 stack 为空时跳出；出栈： 记为 node ；添加子节点： 将 node 左和右子节点入栈；交换： 交换 node 的左 / 右子节点。返回值： 返回根节点 root 。\n入栈的时候 顺序是 2 7 ，所以出栈顺序是 7 2 鸭~ 和 节点是否交换没有关系的\n12345678910class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        stack = [root]        while stack:            node = stack.pop()            if node.left: stack.append(node.left)            if node.right: stack.append(node.right)            node.left, node.right = node.right, node.left        class Solution:    def mirrorTree(self, root: TreeNode) -&gt; TreeNode:        if not root: return        stack = [root]        while stack:            node = stack.pop()            if node.left: stack.append(node.left)            if node.right: stack.append(node.right)            node.left, node.right = node.right, node.left        return root\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071    4         stack=[4]   /  \\       node = 4  2    7 / \\  / \\ 1  3 6  9    4         stack=[]   /  \\       stack=[2, 7]  2    7 / \\  / \\1   3 6  9                                                                               4         交换 2, 7   /  \\       所以出栈顺序是 7 2 鸭~ 和 节点是否交换没有关系的  7    2      stack=[2, 7] / \\  / \\6   9 1  3                                                      | |    4         stack=[2]   /  \\       stack=[2, 6, 9]  7    2 / \\  / \\6   9 1  3       4         交换6, 9   /  \\       stack=[2, 6, 9]  7    2 / \\  / \\9   6 1  3       4         弹出 9   /  \\       stack=[2, 6]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 1  3      4         弹出 6   /  \\       stack=[2]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 1  3      4         弹出 2   /  \\       stack=[]  7    2      stack=[1, 3] / \\  / \\     9   6 1  3      4         交换 None 和 None   /  \\       stack=[1, 3]  7    2       / \\  / \\     9   6 3  1      4         弹出 3   /  \\       stack=[1]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 3  1      4         弹出 1   /  \\       stack=[]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 3  1      4         stack 为空   /  \\       跳出循环，返回4  7    2       / \\  / \\     9   6 3      4         stack=[4]   /  \\       node = 4  2    7 / \\  / \\ 1  3 6  9    4         stack=[]   /  \\       stack=[2, 7]  2    7 / \\  / \\1   3 6  9                                                                               4         交换 2, 7   /  \\       所以出栈顺序是 7 2 鸭~ 和 节点是否交换没有关系的  7    2      stack=[2, 7] / \\  / \\6   9 1  3                                                      | |    4         stack=[2]   /  \\       stack=[2, 6, 9]  7    2 / \\  / \\6   9 1  3       4         交换6, 9   /  \\       stack=[2, 6, 9]  7    2 / \\  / \\9   6 1  3       4         弹出 9   /  \\       stack=[2, 6]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 1  3      4         弹出 6   /  \\       stack=[2]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 1  3      4         弹出 2   /  \\       stack=[]  7    2      stack=[1, 3] / \\  / \\     9   6 1  3      4         交换 None 和 None   /  \\       stack=[1, 3]  7    2       / \\  / \\     9   6 3  1      4         弹出 3   /  \\       stack=[1]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 3  1      4         弹出 1   /  \\       stack=[]  7    2      无子节点可加入stack / \\  / \\     交换 None 和 None9   6 3  1      4         stack 为空   /  \\       跳出循环，返回4  7    2       / \\  / \\     9   6 3  1    \n\n②广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。对当前元素调换其左右子树的位置，然后：\n\n判断其左子树是否为空，不为空就放入队列中\n判断其右子树是否为空，不为空就放入队列中\n\n时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是n/2个，所以时间复杂度是0(n)\n123456789101112131415161718class Solution(object):    def mirrorTree(self, root):        if not root:            return None        # 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素        queue = [root]        while queue:            # 每次都从队列中拿一个节点，并交换这个节点的左右子树            tmp = queue.pop(0)            tmp.left, tmp.right = tmp.right, tmp.left            # 如果当前节点的左子树不为空，则放入队列等待后续处理            if tmp.left:                queue.append(tmp.left)            # 如果当前节点的右子树不为空，则放入队列等待后续处理                if tmp.right:                queue.append(tmp.right)        # 返回处理完的根节点        class Solution(object):    def mirrorTree(self, root):        if not root:            return None        # 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素        queue = [root]        while queue:            # 每次都从队列中拿一个节点，并交换这个节点的左右子树            tmp = queue.pop(0)            tmp.left, tmp.right = tmp.right, tmp.left            # 如果当前节点的左子树不为空，则放入队列等待后续处理            if tmp.left:                queue.append(tmp.left)            # 如果当前节点的右子树不为空，则放入队列等待后续处理                if tmp.right:                queue.append(tmp.right)        # 返回处理完的根节点        return root\n\n12345678910111213141516171819             4           /  \\          2     7         / \\   / \\        1   3 6   9                                                                                                                      |1|                                    |6|  | |  |3|  |3|           | |  | |  |2|  | |  |9|  |9|  |6|  |6|  |6|  |9|  | |queue |4|  | |  |7|  |7|  |2|  |2|  |2|  |9|  |9|  |9|  |2|              4           /  \\          2     7         / \\   / \\        1   3 6   9                                         |7|                     | |  | |  |2|  |2|  |2|  |2|  |2|tmp   | |  |4|  |4|  |4|  |7|  |7|  |7|  |6|  |             4           /  \\          2     7         / \\   / \\        1   3 6   9                                                                                                                      |1|                                    |6|  | |  |3|  |3|           | |  | |  |2|  | |  |9|  |9|  |6|  |6|  |6|  |9|  | |queue |4|  | |  |7|  |7|  |2|  |2|  |2|  |9|  |9|  |9|  |2|              4           /  \\          2     7         / \\   / \\        1   3 6   9                                         |7|                     | |  | |  |2|  |2|  |2|  |2|  |2|tmp   | |  |4|  |4|  |4|  |7|  |7|  |7|  |6|  |4|\n\n35.对称的二叉树 [^本题考点 树]​    题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。\n&nbsp; &nbsp; 1&nbsp; &nbsp;/ &nbsp; 2 &nbsp; 2&nbsp;/ \\ / 3 &nbsp;4 4 &nbsp;3但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:\n&nbsp; &nbsp; 1&nbsp; &nbsp;/ &nbsp; 2 &nbsp; 2&nbsp; &nbsp;\\ &nbsp; &nbsp; &nbsp; 3 &nbsp; 3\n示例 1：\n输入：root = [1,2,2,3,4,4,3]输出：true示例 2：\n输入：root = [1,2,2,null,3,null,3]输出：false\n解题思路：\n\n对称二叉树定义：对于树中 任意两个对称节点 L 和 R ，一定有：\nL.val = R.val ：即此两对称节点值相等。\nL.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；\nL.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。\n\n\n根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。\n\n算法流程：isSymmetric(root) ：\n\n特例处理： 若根节点 root 为空，则直接返回 true 。\n返回值： 即 recur(root.left, root.right) ;\n\nrecur(L, R) ：先“递（推）”至底，再“归”。两个参数的递归，通过「同步移动」两个指针的方法来遍历这棵树，L 指针和 R 指针一开始都指向这棵树的根，随后 R 右移时，L 左移，R 左移时，L 右移。每次检查当前 L 和 R 节点的值是否相等，如果相等再判断左右子树是否对称。\n终止条件：\n\n当 L 和 R 同时越过叶节点： 左右都为空，也就是判断到了最后，还没返回false，那么此树从顶至底的节点都对称，因此返回 true ；\n当 L 或 R 中只有一个越过叶节点 但另一个还没有，此树不对称，因此返回 false ；\n当节点 L 值 \\ne= 节点 R 值： 此树不对称，因此返回 false ；\n\n当 L.val = R.val且不为空，递推工作：\n\n判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；\n判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp; 连接。\n\n时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法，事实上这个递归方法就是在做树的遍历，每个结点访问一次；\n空间复杂度 O(N) ： 最差情况下，根节点的左子节点 有 N/2 长度的链表，右子节点有 N/2 长度的链表，那么递归深度会达到 N/2。因为一直先执行 recur(L.left, R.right) 。只需要保证每个左节点的左边和右节点的右边相同(其余的我可以都为空)，就可以一直走走到最底端，如果是这样的话，应该是O(n/2)，约等于O(n)这样就是线性级别了\n递归复杂度要看递归的深度，因为剪枝or回溯后，内存会被释放。\n1234567891011121314151617class Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:    # 如果此二叉树为空，则其也是对称的        if root == None:            return True        def recur(L, R):            # 如果两侧都为空，则是镜像的了            if not L and not R:                 return True            # 若有一侧不为空，则不是镜像的 或者 如果左侧的值不等于右侧额值，就不是镜像的            if not L or not R or L.val != R.val:            # if L.val!=R.val or not L or not R 会报错，当 L == None 时，直接访问 L.val 会报错的                 return False            # if L.val = R.val:             return recur(L.left, R.right) and recur(L.right, R.left)        # 返回判断此二叉树的左侧和右侧        class Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:    # 如果此二叉树为空，则其也是对称的        if root == None:            return True        def recur(L, R):            # 如果两侧都为空，则是镜像的了            if not L and not R:                 return True            # 若有一侧不为空，则不是镜像的 或者 如果左侧的值不等于右侧额值，就不是镜像的            if not L or not R or L.val != R.val:            # if L.val!=R.val or not L or not R 会报错，当 L == None 时，直接访问 L.val 会报错的                 return False            # if L.val = R.val:             return recur(L.left, R.right) and recur(L.right, R.left)        # 返回判断此二叉树的左侧和右侧        return recur(root.left, root.right)\n\n123456789101112131415161718192021222324252627&nbsp; &nbsp; 1&nbsp; &nbsp;/ \\&nbsp; 2 &nbsp; 2&nbsp;/ \\ / \\3 &nbsp;4 4 &nbsp;3root = 1recur(root.left, root.right) recur(1.left, 1.right) recur(2, 2)L.val = R.valrecur(L.left, R.right)recur(2.left, R=2.right)recur(3, 3)recur(L.left, R.right) recur(L.right, R.left)3.left = 3.right = 3.right = 3.left = NoneL和R同时越过叶子节点，访问了叶节点的 left 和 right， 其 left 和 right 都是 None返回truerecur(L.right, R.left)recur(2.right, 2.left)recur(4, 4)recur(L.left, R.right) recur(L.right, R.left)4.left = 4.right = 4.right = 4&nbsp; &nbsp; 1&nbsp; &nbsp;/ \\&nbsp; 2 &nbsp; 2&nbsp;/ \\ / \\3 &nbsp;4 4 &nbsp;3root = 1recur(root.left, root.right) recur(1.left, 1.right) recur(2, 2)L.val = R.valrecur(L.left, R.right)recur(2.left, R=2.right)recur(3, 3)recur(L.left, R.right) recur(L.right, R.left)3.left = 3.right = 3.right = 3.left = NoneL和R同时越过叶子节点，访问了叶节点的 left 和 right， 其 left 和 right 都是 None返回truerecur(L.right, R.left)recur(2.right, 2.left)recur(4, 4)recur(L.left, R.right) recur(L.right, R.left)4.left = 4.right = 4.right = 4.left = NoneL和R同时越过叶子节点返回true\n\n12345678910111213141516171819class Solution(object):    def isSymmetric(self, root: TreeNode) -&gt; bool:        # 现在获取的 mir = node 就是新建的树的根节点了        mir = self.mirror(root)         return self.recur(root,mir)    def recur(self,root,mir):        if not root and not mir:             return True        if not mir or not root:             return False        return (root.val == mir.val) and self.recur(root.left,mir.left) and self.recur(root.right,mir.right)            def mirror(self, root):        if not root: return        node = TreeNode(root.val) # 建立节点 node        node.left, node.right = self.mirror(root.right), self.mirror(root.left)         # 即镜像之 node.left = root.right , node.right = root.left        class Solution(object):    def isSymmetric(self, root: TreeNode) -&gt; bool:        # 现在获取的 mir = node 就是新建的树的根节点了        mir = self.mirror(root)         return self.recur(root,mir)    def recur(self,root,mir):        if not root and not mir:             return True        if not mir or not root:             return False        return (root.val == mir.val) and self.recur(root.left,mir.left) and self.recur(root.right,mir.right)            def mirror(self, root):        if not root: return        node = TreeNode(root.val) # 建立节点 node        node.left, node.right = self.mirror(root.right), self.mirror(root.left)         # 即镜像之 node.left = root.right , node.right = root.left        return node\n\n方法二：非递归写法（层序遍历）这个方法有点像层序遍历，故使用队列，但是根据对称性，队首和队尾其实都需要能够执行入队和出队操作，因此使用双端队列（Deque）；\n时间复杂度：O(N)，这里 N 为树的结点个数，事实上这个递归方法就是在做树的遍历，每个结点访问一次；空间复杂度：O(L)，这里 L 表示树的相邻两层结点个数之和的最大值。\n首先从队列中拿出两个节点(left和right)比较将left的left节点和right的right节点放入队列将left的right节点和right的left节点放入队列\n12345&nbsp; &nbsp; 2&nbsp; &nbsp;/ \\&nbsp; ３ &nbsp; ３&nbsp;/ \\   / &nbsp; &nbsp; 2&nbsp; &nbsp;/ \\&nbsp; ３ &nbsp; ３&nbsp;/ \\   / \\４ &nbsp;５ N   4&nbsp;\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041from collections import dequeclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:        if root is None:            return True        queue = deque()  # 辅助双端队列        queue.appendleft(root.left)  # 初始节点依次入队        queue.append(root.right)        while queue:            # 从队列中取出两个节点，再比较这两个节点            left_node = queue.popleft()            right_node = queue.pop()            if left_node is None and right_node is None:                # 深度优先，如果两个节点都为空就继续循环，只是越过了某一对叶子节点，而不是检查完了所有的叶子节点，所以不能return true。                continue            if left_node is None or right_node is None:                return False            # 代码走到这里一定有 left_node 和 right_node 非空            # 因此可以取出 val 进行判断了            if left_node.val != right_node.val:                return False            # 将左节点的右孩子，右节点的左孩子入队（以便两节点一起出队，进行比较）            queue.appendleft(left_node.right)            queue.appendleft(left_node.left)            # 将左节点的左孩子， 右节点的右孩子入队（以便两节点一起出队，进行比较）            queue.append(right_node.left)            queue.append(right_node.right)        return from collections import dequeclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:        if root is None:            return True        queue = deque()  # 辅助双端队列        queue.appendleft(root.left)  # 初始节点依次入队        queue.append(root.right)        while queue:            # 从队列中取出两个节点，再比较这两个节点            left_node = queue.popleft()            right_node = queue.pop()            if left_node is None and right_node is None:                # 深度优先，如果两个节点都为空就继续循环，只是越过了某一对叶子节点，而不是检查完了所有的叶子节点，所以不能return true。                continue            if left_node is None or right_node is None:                return False            # 代码走到这里一定有 left_node 和 right_node 非空            # 因此可以取出 val 进行判断了            if left_node.val != right_node.val:                return False            # 将左节点的右孩子，右节点的左孩子入队（以便两节点一起出队，进行比较）            queue.appendleft(left_node.right)            queue.appendleft(left_node.left)            # 将左节点的左孩子， 右节点的右孩子入队（以便两节点一起出队，进行比较）            queue.append(right_node.left)            queue.append(right_node.right)        return True\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&nbsp; &nbsp; 1&nbsp; &nbsp;/ \\&nbsp; 2 &nbsp; 2&nbsp;/ \\ / \\3 &nbsp;4 4 &nbsp;3root = 1queue = [2, 2]left_node = 2right_node = 2queue.appendleft(left_node.right)queue.appendleft(2.right)queue = [4]queue.appendleft(2.left)queue = [3, 4]            # 将左节点的左孩子， 右节点的右孩子放入队列queue.append(right_node.left)queue.append(2.left)queue = [3, 4, 4]queue.append(2.right)queue = [3, 4, 4, 3]left_node = queue.popleft() = 3queue = [4, 4, 3]right_node = queue.pop() = 3queue = [4, 4]queue.appendleft(left_node.right)queue.appendleft(3.right)queue = [4, 4]queue.appendleft(left_node.left)queue.appendleft(3.left)queue = [4, 4]queue.append(right_node.left)queue.append(3.left)queue = [4, 4]queue.append(right_node.right)queue.append(4.right)queue = [4, 4]left_node = queue.popleft() = 4queue = [4]right_node = queue.pop() = 4queue = []queue.appendleft(left_node.right)queue.appendleft(4.right)queue = []queue.appendleft(left_node.left)queue.appendleft(3.left)queue = []queue.append(right_node.left)queue.append(4.left)queue = []queue.append(right_node.right)queue.append(4.right)queue = [] 退出循环\n\n54. 二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第k大的节点。示例 1:\n输入: root = [3,1,4,null,2], k = 1\n123456789   3  / \\ 1   4  \\   2输出: 4中序遍历 [1, 2, 3, 4] 递增序列 中序遍历倒序 [4, 3, 2,    3  / \\ 1   4  \\   2输出: 4中序遍历 [1, 2, 3, 4] 递增序列 中序遍历倒序 [4, 3, 2, 1] 递减序列\n示例 2:\n123456789101112输入: root = [5,3,6,2,4,None,None,1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 4中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 输入: root = [5,3,6,2,4,None,None,1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 4中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列\n\n解题思路：1、看到这题首先想到的是递归遍历每一个节点，然后存在一个数组中，遍历结束后把数组 sort 排序一下就可以取得第 K 大的值了。\n1234567891011class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        res = []        def dfs(root, res):            if not root:                return            dfs(root.left, res)            res.append(root.val)            dfs(root.right, res)        dfs(root, res)        class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        res = []        def dfs(root, res):            if not root:                return            dfs(root.left, res)            res.append(root.val)            dfs(root.right, res)        dfs(root, res)        return res[-k]\n\n2、继续看题会发现是二叉搜索树，发现中序遍历的数组结果刚好是排好序的，这样就可以想到反中序遍历,遍历结束后直接获取数组第 K-1 位的数值就是结果了（当然上面说的都可以不用倒序，直接用中序遍历获取 array.lenth-k 大的值也是所需结果）3、在第二种解法上利用反中序遍历，优化就是直接遍历到第 k 大的值就停止遍历，直接返回需要的值，即第三种解法。本文解法基于此性质：二叉搜索树的中序遍历为 递增序列 。\n根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。从右节点遍历可以早点退出\n中序遍历 为 “左、根、右” 顺序，递归法代码模板如下：\n123456# 打印中序遍历def dfs(root):    if not root: return    dfs(root.left)  # 左    print(root.val) # 根    dfs(root.right) # 打印中序遍历def dfs(root):    if not root: return    dfs(root.left)  # 左    print(root.val) # 根    dfs(root.right) # 右\n\n中序遍历的倒序 为 “右、根、左” 顺序，递归法代码如下：\n123456# 打印中序遍历倒序def dfs(root):    if not root: return    dfs(root.right) # 右    print(root.val) # 根    dfs(root.left)  # 打印中序遍历倒序def dfs(root):    if not root: return    dfs(root.right) # 右    print(root.val) # 根    dfs(root.left)  # 左\n\n为求第 k 个节点，需要实现以下 三项工作 ：\n\n递归遍历时计数，统计当前节点的序号；\n递归到第 k 个节点时，应记录结果 res ；\n记录结果后，后续的遍历即失去意义，应提前终止（即返回）。\n\n递归解析：\n\n终止条件： 当节点 root 为空（越过叶节点），则直接返回；\n\n递归右子树： 即 dfs(root.right) ；\n\n三项工作：\n\n提前返回： 若 k = 0 ，代表已找到目标节点，无需继续遍历，提前终止中序遍历，因此直接返回提升效率，在某些特例下尤其明显，例如：树有 10000 个节点，求第 1 大的节点。不加 if(k == 0) return 是做不到提前返回的，会降低效率\n\n统计序号： 执行 k = k - 1 （即从 k 减至 0 ），每遍历一个节点 k 的值就减一；\n\n记录结果： 若 k = 0 ，代表当前节点为第 k 大的节点，因此记录 res = root.val ；\n\n\n\n递归左子树： 即 dfs(root.left) ；\n\n\n时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。\n题目指出：1≤k≤N （二叉搜索树节点个数）；因此无需考虑 k &gt; N 的情况。若考虑，可以在中序遍历完成后判断 k &gt; 0 是否成立，若成立则说明 k &gt; N 。\n如果修改了函数外部变量的引用，比方说 k -= 1，相当于 k = k - 1，就是给k重新赋值了，那它就变成了内部函数的局部变量，局部变量 k 不能在 dfs() 函数内访问，此时可以声明 self.k = k 则建立了类成员变量 self.k或者在函数内部声明 nonlocal k 说明 k 不会因为引用修改而成为局部变量。需要对于函数 $dfs()$ 的全局变量，因此在 dfs() 内就可以正常访问 k\n不能把两个k==0写在一起，因为此方法在访问每个节点时，需要将 “k -= 1” 前 和 “k -= 1” 后的逻辑分开~如果直接在第一次遇到 k = 0 时，就返回 self.res，下面还会遇到 k -= 1， k 会被减到 -1 , -2 , … ，因此 K 就不 == 0 了，因此就会继续中序遍历，而不会终止。\n12345678910111213141516class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root:                 return            dfs(root.right)            if self.k == 0:                  return            self.k -= 1            if self.k == 0:  # 第一次遇到 k == 0 时 ，记录结果                self.res = root.val            dfs(root.left)        self.k = k        dfs(root)        class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root:                 return            dfs(root.right)            if self.k == 0:                  return            self.k -= 1            if self.k == 0:  # 第一次遇到 k == 0 时 ，记录结果                self.res = root.val            dfs(root.left)        self.k = k        dfs(root)        return self.res\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445       5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列root = 5dfs(root.right)    root = root.right = 5.right = 6    dfs(6)    dfs(root.right)        root = root.right = 6.right = None        dfs(None)    返回上一层 root = 6    k = k - 1 = 3 - 1 = 2    dfs(root.left)        root = root.left = 6.left = None        dfs(None)    返回上一层 root = 6返回上一层 root = 5k = k - 1 = 2 - 1 = 1dfs(5.left)    root = root.left = 5.left = 3    dfs(3)    dfs(root.right)        root = root.right = 3.right = 4        dfs(4)        dfs(root.right)            root = root.right = 4.right = None            dfs(None)        返回上一层 root = 4        k = k - 1 = 1 - 1 = 0        res = root.val = 4        dfs(root.leftt)        root = root.right = 4.left = None            dfs(None)    返回上一层 root = 3    k = 0 return 函数结束    return res =        5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列root = 5dfs(root.right)    root = root.right = 5.right = 6    dfs(6)    dfs(root.right)        root = root.right = 6.right = None        dfs(None)    返回上一层 root = 6    k = k - 1 = 3 - 1 = 2    dfs(root.left)        root = root.left = 6.left = None        dfs(None)    返回上一层 root = 6返回上一层 root = 5k = k - 1 = 2 - 1 = 1dfs(5.left)    root = root.left = 5.left = 3    dfs(3)    dfs(root.right)        root = root.right = 3.right = 4        dfs(4)        dfs(root.right)            root = root.right = 4.right = None            dfs(None)        返回上一层 root = 4        k = k - 1 = 1 - 1 = 0        res = root.val = 4        dfs(root.leftt)        root = root.right = 4.left = None            dfs(None)    返回上一层 root = 3    k = 0 return 函数结束    return res = 4\n\n如果不想要上面的 if ，并且想保留提前返回，实际上也执行了dfs(root.left)\n123456789101112131415class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root: return            dfs(root.right)            self.k -= 1            if self.k &lt;= 0:                if self.k == 0:                     self.res = root.val                return            dfs(root.left)        self.k = k        dfs(root)        class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root: return            dfs(root.right)            self.k -= 1            if self.k &lt;= 0:                if self.k == 0:                     self.res = root.val                return            dfs(root.left)        self.k = k        dfs(root)        return self.res\n\n右根左的顺序，非递归遍历\n1234567891011121314class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        # 右根左 非递归遍历        stack,count = [],0        while root or stack:            while root:                stack.append(root)                root = root.right            if stack:                cur = stack.pop()                count += 1                if count == k:                    class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        # 右根左 非递归遍历        stack,count = [],0        while root or stack:            while root:                stack.append(root)                root = root.right            if stack:                cur = stack.pop()                count += 1                if count == k:                    return curr.val                root = cur.left\n1234567891011121314151617181920212223242526272829303132333435363738       5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1]中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列stack = []root = 5stack = [5]root = root.right = 5.right = 6stack = [5, 6]root = root.right = 6.right = Nonecur = stack.pop() = 6stack = [5]count = count + 1 = 1 &lt; k = 3root = cur.left = 6.left = Nonecur = stack.pop() = 5stack = []count = count + 1 = 2 &lt; k = 3root = cur.left = 5.left = 3stack = [3]root = root.right = 3.right = 4stack = [3, 4]root = root.right = 4.right = Nonecur = stack.pop() = 4stack = [3]count = count + 1 = 3 = kreturn cur.val =        5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1]中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列stack = []root = 5stack = [5]root = root.right = 5.right = 6stack = [5, 6]root = root.right = 6.right = Nonecur = stack.pop() = 6stack = [5]count = count + 1 = 1 &lt; k = 3root = cur.left = 6.left = Nonecur = stack.pop() = 5stack = []count = count + 1 = 2 &lt; k = 3root = cur.left = 5.left = 3stack = [3]root = root.right = 3.right = 4stack = [3, 4]root = root.right = 4.right = Nonecur = stack.pop() = 4stack = [3]count = count + 1 = 3 = kreturn cur.val = 4\n\n\n迭代\n123456789101112131415class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        if not root: return         stack = []        res = []        while root or stack:            while root:                stack.append(root)                root = root.right            root = stack.pop()            res.append(root.val)            if len(res)==k:                 return res[-1]            root = root.left        class Solution:    def kthLargest(self, root: TreeNode, k: int) -&gt; int:        if not root: return         stack = []        res = []        while root or stack:            while root:                stack.append(root)                root = root.right            root = stack.pop()            res.append(root.val)            if len(res)==k:                 return res[-1]            root = root.left        return\n\n1234567891011121314151617181920212223242526272829303132333435363738394041       5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列stack = []root = 5stack = [5]root = root.right = 5.right = 6stack = [5, 6]root = root.right = 6.right = Noneroot = stack.pop() = 6stack = [5]res = [6]len(res) = 1root = root.left = 6.left = Noneroot = stack.pop() = 5stack = []res = [6, 5]len(res) = 2root = root.left = 5.left = 3stack = [3]root = root.right = 3.right = 4stack = [3, 4]root = root.right = 4.right = Noneroot = stack.pop() = 4stack = [3]res = [6, 5, 4] len(res) = 3 = kreturn res[-1] =        5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 中序遍历倒序 [6, 5, 4, 3, 2, 1] 递减序列stack = []root = 5stack = [5]root = root.right = 5.right = 6stack = [5, 6]root = root.right = 6.right = Noneroot = stack.pop() = 6stack = [5]res = [6]len(res) = 1root = root.left = 6.left = Noneroot = stack.pop() = 5stack = []res = [6, 5]len(res) = 2root = root.left = 5.left = 3stack = [3]root = root.right = 3.right = 4stack = [3, 4]root = root.right = 4.right = Noneroot = stack.pop() = 4stack = [3]res = [6, 5, 4] len(res) = 3 = kreturn res[-1] = 4\n\n\n38.二叉搜索树的第k个结点 [^本题考点 树]​    题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如,（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。\n示例 1:\n1234567891011输入: root = [3,1,4,null,2]   3  / \\ 1   4  \\&nbsp;  2输入: k = 1 输出: 1输入: k = 0 输出: 输入: root = [3,1,4,null,2]   3  / \\ 1   4  \\&nbsp;  2输入: k = 1 输出: 1输入: k = 0 输出: 1\n\n示例 2:\n123456789输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 3\n进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化&nbsp;kthSmallest&nbsp;函数？\n方法一：算法：通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素。\n123456class Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        def inorder(r):            return inorder(r.left) + [r.val] + inorder(r.right) if r else []            return inorder(root)[k - class Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        def inorder(r):            return inorder(r.left) + [r.val] + inorder(r.right) if r else []            return inorder(root)[k - 1]\n\n时间复杂度：O(N)，遍历了整个树。空间复杂度：O(N)，用了一个数组存储中序序列。\n方法二：迭代算法：在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。\n时间复杂度：O(H+k)，其中 H 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(logN+k)。当树是一个不平衡树时：复杂度为 O(N+k)，此时所有的节点都在左子树。空间复杂度：O(H+k)当树是一个平衡树时：O(logN+k)。当树是一个非平衡树时：O(N+k)。当迭代到最小的那个数时需要O(H)的复杂度，然后O(K)的复杂度就找第k小的元素的迭代\n12345678910111213class Solution:    def kthSmallest(self, root, k):        stack = []                while True:            while root:                stack.append(root)                root = root.left            root = stack.pop()            k -= 1            if not k:                class Solution:    def kthSmallest(self, root, k):        stack = []                while True:            while root:                stack.append(root)                root = root.left            root = stack.pop()            k -= 1            if not k:                return root.val            root = root.right\n\n123456789101112131415161718192021222324252627282930313233343536       5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 stack = []root = 5stack = [5]root = root.left = 5.left = 3stack = [5, 3]root = root.left = 3.left = 2stack = [5, 3, 2]root = root.left = 2.left = 1stack = [5, 3, 2, 1]root = root.left = 1.left = Nonecur = stack.pop() = 1stack = [5, 3, 2]k = k - 1 = 3 - 1 = 2root = cur.right = 1.right = Nonecur = stack.pop() = 2stack = [5, 3]k = k - 1 = 2 - 1 = 1root = cur.right = 2.right = Nonecur = stack.pop() = 3stack = [5]k = k - 1 = 1 - 1 = 1return cur.val =        5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 stack = []root = 5stack = [5]root = root.left = 5.left = 3stack = [5, 3]root = root.left = 3.left = 2stack = [5, 3, 2]root = root.left = 2.left = 1stack = [5, 3, 2, 1]root = root.left = 1.left = Nonecur = stack.pop() = 1stack = [5, 3, 2]k = k - 1 = 3 - 1 = 2root = cur.right = 1.right = Nonecur = stack.pop() = 2stack = [5, 3]k = k - 1 = 2 - 1 = 1root = cur.right = 2.right = Nonecur = stack.pop() = 3stack = [5]k = k - 1 = 1 - 1 = 1return cur.val = 3\n\n\n递归\n1234567891011121314151617class Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root:                 return            dfs(root.left)  # BFS，不断左侧下探到叶子节点            if self.k == 0:                 return            self.k -= 1  # 左侧下探返回后，节点数+1            if self.k == 0:  # 判断当前节点是否是目标节点，即第k小                self.res = root.val            dfs(root.right)  # 右侧递归        self.k = k  # 全局变量，self不能少        self.res = 0        dfs(root)        class Solution:    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:        def dfs(root):            if not root:                 return            dfs(root.left)  # BFS，不断左侧下探到叶子节点            if self.k == 0:                 return            self.k -= 1  # 左侧下探返回后，节点数+1            if self.k == 0:  # 判断当前节点是否是目标节点，即第k小                self.res = root.val            dfs(root.right)  # 右侧递归        self.k = k  # 全局变量，self不能少        self.res = 0        dfs(root)        return self.res\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152       5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 root = 5dfs(root.left)    root = root.left = 5.left = 3    dfs(3)    dfs(root.left)        root = root.left = 3.left = 2        dfs(2)        dfs(root.left)            root = root.left = 2.left = 1            dfs(1)            dfs(root.left)                root = root.left = 1.left = None                dfs(None)            返回上一层 root = 1            k = k - 1 = 3 - 1 = 2            dfs(root.right)                root = root.right = 2.right = None                dfs(None)            返回上一层 root = 1        返回上一层 root = 2        k = k - 1 = 2 - 1 = 1        dfs(root.right)            root = root.right = 2.right = None            dfs(None)        返回上一层 root = 2    返回上一层 root = 3    k = k - 1 = 1 - 1 = 0    res = root.val = 3    dfs(root.right)        root = root.right = 3.right = 4        dfs(4)        dfs(root.left)            root = root.left = 4.left = None        返回上一层 root = 4           k = 0 return 函数结束    返回上一层 root = 3    k = 0 return 函数结束返回上一层 root = 5k = 0 return 函数结束return self.res =        5      / \\     3   6    / \\   2   4  / 1k = 3[5,3,6,2,4,None,None,1],中序遍历 [1, 2, 3, 4, 5, 6] 递增序列 root = 5dfs(root.left)    root = root.left = 5.left = 3    dfs(3)    dfs(root.left)        root = root.left = 3.left = 2        dfs(2)        dfs(root.left)            root = root.left = 2.left = 1            dfs(1)            dfs(root.left)                root = root.left = 1.left = None                dfs(None)            返回上一层 root = 1            k = k - 1 = 3 - 1 = 2            dfs(root.right)                root = root.right = 2.right = None                dfs(None)            返回上一层 root = 1        返回上一层 root = 2        k = k - 1 = 2 - 1 = 1        dfs(root.right)            root = root.right = 2.right = None            dfs(None)        返回上一层 root = 2    返回上一层 root = 3    k = k - 1 = 1 - 1 = 0    res = root.val = 3    dfs(root.right)        root = root.right = 3.right = 4        dfs(4)        dfs(root.left)            root = root.left = 4.left = None        返回上一层 root = 4           k = 0 return 函数结束    返回上一层 root = 3    k = 0 return 函数结束返回上一层 root = 5k = 0 return 函数结束return self.res = 3\n\n\n29.二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n参考以下这颗二叉搜索树：\n12345    5   / \\  2   6 / \\1       5   / \\  2   6 / \\1   3\n示例 1：\n12输入: [1,6,3,2,5]输出: 输入: [1,6,3,2,5]输出: false\n示例 2：\n12输入: [1,3,2,6,5]输出: 输入: [1,3,2,6,5]输出: true\n\n题目只是说能不能是，而不是所有后序是这样的都是。解题思路：\n题目：假设输入的数组的任意两个数字都互不相同左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值其左、右子树也分别为二叉搜索树。\n后序遍历定义： 遍历顺序为 “左、右、根” 。后序遍历 的序列中，最后一个数字是树的根节点\n左右子树分界点 与根节点作比较数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，\n方法一：递归分治\n\n根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性（即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。\n\n递归解析：i, j 是递归过程中 后序遍历的左右边界， i, j 命名规范用left, right吧i, j 之间的节点是当前子树包含的节点。 \n当 i &gt; j 时，没有节点。\n\n终止条件： 当 i \\geq j i≥j ，说明此子树节点数量 \\leq 1 ≤ 1 ，无需判别正确性，直接返回 true ，递归到“空”则说明所有子树满足\n\n当 i = m = j - 1 时，向下递归 recur(i, m - 1) 时 i &gt; j ，本质上就是左子树为空的情况\n1235 \\  5 \\  6\n[6, 5]第一个大于 root = 5 的后面都是5的右子节点[6]。这个数组只有一个根节点，没有子节点m = 0 = i = 0, recur(i, m - 1) = recur(0, 0 - 1), 0 &gt; -1\n123455 \\  6   \\    5 \\  6   \\    7\n[7, 6, 5]第一个大于 root = 5 的后面都是5的右子树[7，6]。然后再递归这个数组，6是根节点，第一个比6大的后面都是6的右子节点[7]，只有一个根节点，没有子节点\n所以我们能确定这棵树是二叉搜索树。本来left= 0,right = 2, 通过第一个while循环m= cur = 7,那么return中的第二个recur(i, m - 1)就是recur(0, 0 - 1)，这是只有右子树的情况，i &gt; j，返回True\n[1, 2, 3] 可能不是二叉搜索树的后序遍历，但也可能是。根据题意，只要能构成二叉搜索树的后序遍历，就应返回 true 。\n12345    3   /    2 /         3   /    2 /     1       \n本来left= 0,right = 2, 通过第一个while循环 m = cur = 2,那么return中的第二个recur(m, j - 1)就是recur(2, 2 - 1)，这是只有左子树的情况，i &gt; j，返回True\n\n递推工作：\n\n划分左右子树： 遍历后序遍历的 [i, j] 区间元素，从头、左往右找出第一个大于或等于根节点的节点，索引记为 m ，数组的任意两个数字都互不相同，如果没有大于第一个大于根节点 的节点，则根节点索引也记为 m，此时，可划分出左子树区间 [i, m-1] 、右子树区间 [m, j - 1] 、根节点索引 j 。\n\n判断是否为二叉搜索树：\n\n\n\n左子树区间 [i, m - 1] 内的所有节点都应 &lt;&lt; postorder[j] 。而第 1. 划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。\n\n右子树区间 [m, j-1] 内的所有节点都应 &gt;&gt; postorder[j] 。实现方式为遍历，当遇到 \\leq ≤postorder[j] 的节点则跳出；则可通过 cur = j 判断是否为二叉搜索树。\n\n\n\n返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符and 连接。\n\ncur = j ： 判断 “当前树”的后序遍历满足二叉搜索树的性质，若未将postoerder[i, j)遍历完，则非后序遍历序列 返回false\nrecur(i, m - 1) ： 判断 此树的左子树 是否正确。\nrecur(m, j - 1) ： 判断 此树的右子树 是否正确。\n\n\n\n时间复杂度 O(N^2) ： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。\n123456789101112131415class Solution:    def verifyPostorder(self, postorder: [int]) -&gt; bool:        def recur(i, j):            # 如果left==right，就一个节点不需要判断了，            # 如果left&gt;right说明只有左子树的情况，如果只有右子树            if i &gt;= j:                return True            cur = i            while postorder[cur] &lt; postorder[j]: cur += 1            # cur继续保留已经循环了的次数的数值            m = cur  # 第一个大于根节点 的节点的索引记为 m            while postorder[cur] &gt; postorder[j]: cur += 1            return cur == j and recur(i, m - 1) and recur(m, j - 1)        return recur(0, len(postorder) - class Solution:    def verifyPostorder(self, postorder: [int]) -&gt; bool:        def recur(i, j):            # 如果left==right，就一个节点不需要判断了，            # 如果left&gt;right说明只有左子树的情况，如果只有右子树            if i &gt;= j:                return True            cur = i            while postorder[cur] &lt; postorder[j]: cur += 1            # cur继续保留已经循环了的次数的数值            m = cur  # 第一个大于根节点 的节点的索引记为 m            while postorder[cur] &gt; postorder[j]: cur += 1            return cur == j and recur(i, m - 1) and recur(m, j - 1)        return recur(0, len(postorder) - 1)\n\n法二步骤：\n\n确定根节点root；\n遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；\n遍历右子树，若发现有小于root的值，则直接返回false；\n分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。时间复杂度(n) 击败90%\n\n1234567891011121314151617181920212223class Solution:    def verifyPostorder(self, postorder: List[int]) -&gt; bool:        if postorder is None or len(postorder) == 0:            return True        length = len(postorder)        root = postorder[-1]        # 在二叉搜索树中左子树节点都小于根节点，找到左子树的区间，        for i in range(length):            if postorder[i] &gt; root:                break        # 二叉搜索树中右子树的节点都大于根节点        for j in range(i, length):            if postorder[j] &lt; root:                return False        left = True        # 判断左子树是否为二叉搜索树        if i &gt; 0:            left = self.verifyPostorder(postorder[0:i])  # 左闭右开        # 判断右子树是否为二叉搜索树        right = True        if i &lt; length - 1:            right = self.verifyPostorder(postorder[i:-1])        return left class Solution:    def verifyPostorder(self, postorder: List[int]) -&gt; bool:        if postorder is None or len(postorder) == 0:            return True        length = len(postorder)        root = postorder[-1]        # 在二叉搜索树中左子树节点都小于根节点，找到左子树的区间，        for i in range(length):            if postorder[i] &gt; root:                break        # 二叉搜索树中右子树的节点都大于根节点        for j in range(i, length):            if postorder[j] &lt; root:                return False        left = True        # 判断左子树是否为二叉搜索树        if i &gt; 0:            left = self.verifyPostorder(postorder[0:i])  # 左闭右开        # 判断右子树是否为二叉搜索树        right = True        if i &lt; length - 1:            right = self.verifyPostorder(postorder[i:-1])        return left and right\n\n1234567891011121314151617181920212223class Solution(object):    def verifyPostorder(self, postorder):        if not postorder:            return True        def isTree(postorder):            root = postorder[-1]            length = len(postorder)            for i in range(length):                 if postorder[i] &gt; root:                    break            for j in range(i, length-1):                if postorder[j] &lt; root:                    return False            left = True            if i &gt; 0:                left = isTree(postorder[:i])            right = True            if i &lt; length -1 :                right = isTree(postorder[i:-1])            return left and right        class Solution(object):    def verifyPostorder(self, postorder):        if not postorder:            return True        def isTree(postorder):            root = postorder[-1]            length = len(postorder)            for i in range(length):                 if postorder[i] &gt; root:                    break            for j in range(i, length-1):                if postorder[j] &lt; root:                    return False            left = True            if i &gt; 0:                left = isTree(postorder[:i])            right = True            if i &lt; length -1 :                right = isTree(postorder[i:-1])            return left and right        return isTree(postorder)\n\n法三出发点不是检索子树的正确性。 而是“所有递减节点的父节点 root 性质” 得到满足即可\n12345    5   / \\  2   6 / \\1       5   / \\  2   6 / \\1   3\n后序遍历    [1, 3, 2, 6, 5]后序遍历倒序 [5, 6, 2, 3, 1]后序遍历倒序： [ 根节点 | 右子树 | 左子树 ] 。类似 先序遍历的镜像，即先序遍历为 “根、左、右” 的顺序，\n\n设后序遍历倒序列表为 [r_{n}, r_{n-1},…,r_1]，遍历此列表，设索引为 i ，若为 二叉搜索树 ，则有规律：\n\n当节点值 r_i &gt; r_{i+1} 时： 节点 r_i 一定是节点 r_{i+1} 的右子节点。例如5和6是挨着的并且5 &lt; 6，所以6是5的右子节点。证明：比arr[i+1]大的肯定都是他的右子节点，如果还是挨着他的，肯定是在后续遍历中所有的右子节点最后一个遍历的，所以他一定是arr[i]的右子节点\n\n当节点值 r_i &lt; r_{i+1} 时： 节点 r_i 一定是某节点 root 的左子节点，且 root 为节点 r_{i+1}, r_{i+2},…, r_{n}r 中值大于且最接近 r_i 的节点（∵ root 直接连接 左子节点 r_i ）。比如6，2是降序的，那么2肯定是他前面某一个节点的左子节点，并且这个值是大于2中最小的，我们看到5和6都是大于2的，但5最小，所以2就是5的左子节点。同理我们可以观察到3和1是降序，1前面大于1中最小的是2，所以1就是12的左子节点。\n\n\n\n当遍历时遇到递减节点 r_i &lt; r_{i+1}，若为二叉搜索树，则对于后序遍历中节点 r_i 右边的任意节点 r_x \\in [r_{i-1}, r_{i-2}, …, r_1]，必有节点值 r_x &lt; root 。序列中节点2右边的所有节点(即节点3，1)都应小于节点5。\n\n\n节点 r_x 只可能为以下两种情况：① r_x 为 r_i 的左、右子树的各节点；② r_x 为 root 的父节点或更高层父节点的左子树的各节点。在二叉搜索树中，以上节点都应小于 root 。\n\n遍历 “后序遍历的倒序” 会多次遇到递减节点 r_i ，若所有的递减节点 r_i 对应的父节点 root 都满足以上条件，则可判定为二叉搜索树。\n根据以上特点，考虑借助 单调栈 实现：\n借助一个单调栈 stack 存储值递增的节点；\n每当遇到值递减的节点 r_i，则通过出栈来更新节点 r_i 的父节点 root ；\n每轮判断 r_i 和 root 的值关系：\n若 r_i &gt; root 则说明不满足二叉搜索树定义，直接返回 false 。\n若 r_i &lt; root 则说明满足二叉搜索树定义，则继续遍历。\n\n\n\n\n\n算法流程：\n\n初始化： 单调栈 stack ，父节点值 root = +\\inf root=+∞（初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；\n倒序遍历 postorder ：记每个节点为 r_i；\n判断： 若 r_i&gt;root ，说明此后序遍历序列不满足二叉搜索树定义，直接返回 false ；\n更新父节点 root ： 当栈不为空 且 r_i &lt; stack[-1] 时，循环执行出栈，并将出栈节点赋给 root 。\n入栈： 将当前节点 r_i入栈；\n若遍历完成，则说明后序遍历满足二叉搜索树定义，返回 true 。\n\n时间复杂度 O(N) ： 遍历 postorder 所有节点，各节点均入栈 / 出栈一次，使用 O(N) 时间。递归判断需要重复遍历节点，而单调栈不用。空间复杂度 O(N) ： 最差情况下，单调栈 stack 存储所有节点，使用 O(N) 额外空间。\n把先序遍历的功能通过单调栈实现了12356 13265 56231 inf根5(右)-inf左 562 231 ，并且通过局部性使得左中右的顺序在每个节点处都进行判断，太妙了\n12345678910111213141516171819class Solution:    def verifyPostorder(self, postorder: [int]) -&gt; bool:        stack, root = [], float(\"+inf\")        for i in range(len(postorder) - 1, -1, -1):            # root是在什么情况下赋的值，root并不一定都是根节点的值，            # 相对于遇到了左子节点的时候他是左子节点的根节点。            # 如果是右子节点，parent就是他的某一个祖先节点，            # 并且这个右子节点是这个祖先节点的一个左子树的一部分，所以不能超过他，            if postorder[i] &gt; root:                 return False            # 当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，            # 说明当前节点是前面某个节点的左子节点，我们要找到他的根节点            while(stack and postorder[i] &lt; stack[-1]):                root = stack.pop()            # 只要遇到了某一个左子节点，才会执行上面的代码，            # 才会更新root的值，否则root就是一个非常大的值，            # 也就是说如果一直没有遇到左子节点，那么右子节点可以非常大            stack.append(postorder[i])        return class Solution:    def verifyPostorder(self, postorder: [int]) -&gt; bool:        stack, root = [], float(\"+inf\")        for i in range(len(postorder) - 1, -1, -1):            # root是在什么情况下赋的值，root并不一定都是根节点的值，            # 相对于遇到了左子节点的时候他是左子节点的根节点。            # 如果是右子节点，parent就是他的某一个祖先节点，            # 并且这个右子节点是这个祖先节点的一个左子树的一部分，所以不能超过他，            if postorder[i] &gt; root:                 return False            # 当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，            # 说明当前节点是前面某个节点的左子节点，我们要找到他的根节点            while(stack and postorder[i] &lt; stack[-1]):                root = stack.pop()            # 只要遇到了某一个左子节点，才会执行上面的代码，            # 才会更新root的值，否则root就是一个非常大的值，            # 也就是说如果一直没有遇到左子节点，那么右子节点可以非常大            stack.append(postorder[i])        return True\n\n12345678910111213141516171819202122class Solution:    def VerifySquenceOfBST(self, sequence):        if sequence == []:            return False        rootNum = sequence[-1]        del sequence[-1]        index = None        for i in range(len(sequence)):            if index == None and sequence[i] &gt; rootNum:                index = i            if index != None and sequence[i] &lt; rootNum:                return False        if sequence[:index] == []:            leftRet = True        else:            leftRet = self.VerifySquenceOfBST(sequence[:index])        if sequence[index:] == []:            rightRet = True        else:            rightRet = self.VerifySquenceOfBST(sequence[index:])        return leftRet class Solution:    def VerifySquenceOfBST(self, sequence):        if sequence == []:            return False        rootNum = sequence[-1]        del sequence[-1]        index = None        for i in range(len(sequence)):            if index == None and sequence[i] &gt; rootNum:                index = i            if index != None and sequence[i] &lt; rootNum:                return False        if sequence[:index] == []:            leftRet = True        else:            leftRet = self.VerifySquenceOfBST(sequence[:index])        if sequence[index:] == []:            rightRet = True        else:            rightRet = self.VerifySquenceOfBST(sequence[index:])        return leftRet and rightRet\n\n\n12345678910111213141516171819# 先找到根节点的右子节点，然后判断右子树的值是否全大于root；# 然后再递归根节点的左右子树即可class Solution:    def verifyPostorder(self, postorder: List[int]) -&gt; bool:        if not postorder: return True        root = postorder[-1]        cur_index = 0        for i in range(len(postorder)):            if postorder[i] &gt;= root:                cur_index = i                break        left = postorder[:cur_index]        right = postorder[cur_index : -1]        # 检查左右子树是否有不符合要求的节点        for val in right:            if val &lt; root:                return False        # 检查左、右子树是否分别是二叉搜索树        return self.verifyPostorder(left) # 先找到根节点的右子节点，然后判断右子树的值是否全大于root；# 然后再递归根节点的左右子树即可class Solution:    def verifyPostorder(self, postorder: List[int]) -&gt; bool:        if not postorder: return True        root = postorder[-1]        cur_index = 0        for i in range(len(postorder)):            if postorder[i] &gt;= root:                cur_index = i                break        left = postorder[:cur_index]        right = postorder[cur_index : -1]        # 检查左右子树是否有不符合要求的节点        for val in right:            if val &lt; root:                return False        # 检查左、右子树是否分别是二叉搜索树        return self.verifyPostorder(left) and self.verifyPostorder(right)\n\n\n30.二叉树中和为某一值的路径输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)\n12345678910111213141516示例:给定如下二叉树，以及目标和&nbsp;sum = 22，              5             / \\            4   8           /   / \\          11  13  4         /  \\    / \\        7    2  5   1返回:[   [5,4,11,2],   [5,8,4,示例:给定如下二叉树，以及目标和&nbsp;sum = 22，              5             / \\            4   8           /   / \\          11  13  4         /  \\    / \\        7    2  5   1返回:[   [5,4,11,2],   [5,8,4,5]]\n\n解题思路：本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。\n\n先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。\n路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。\n\n算法流程：pathSum(root, sum) 函数：\n\n初始化： 结果列表 res ，路径列表 path 。\n返回值： 返回 res 即可。\n\nrecur(root, tar) 函数：\n\n递推参数： 当前节点 root ，当前目标值 tar 。\n终止条件： 若节点 root 为空，则直接返回。\n递推工作：\n路径更新： 将当前节点值 root.val 加入路径 path ；\n目标值更新： tar = tar - root.val（即目标值 tar 从 sum 减至 0 ）；\n路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。\n先序遍历： 递归左 / 右子节点。\n路径恢复： 只有当前函数终止才会向上回溯前，所有变量恢复到原来的状态，需要将当前节点从路径 path 中弹出删除，即执行 path.pop()\n\n\n\n状态是指完成一件事情进行到哪一个阶段，在上面的代码中：path 、tar 都是状态变量\n时间复杂度 O(N) ： N 为二叉树的节点数，先序遍历需要遍历所有节点。空间复杂度 O(N) ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。res 作为返回值，是必须要使用的空间，因此不计入计算范围内~ 这里的空间复杂度只计算“额外空间”\n击败50%\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution:    def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:        #  res 保存最终的所有路径结果， path 保存每条路径。        res, path = [], []        def recur(root, tar):            # 递归终止条件 1：解决子问题，如果输入结点为空结点，返回空列表            if not root:                   # recur() 函数实际上是 void 函数，最后return 的是 res ,写成return [] 都可以                return              # 有节点            path.append(root.val)            tar -= root.val            # 递归终止条件 2：tar == 0，并且节点为叶子节点             if tar == 0 and not root.left and not root.right:                # 对引用类型参数（Reference Data Type Arguments）动态变量，                # 在调用函数时，将实际参数的 内存地址（引用，而不是真正的变量） 复制传递到函数中。                # 可变对象如列表，字典等，原本就可以改变，如果在函数中对参数修改，将会影响到实际参数。                # 记录路径时若执行 res.append(path) ，                # 把 path 列表对象在“方法传参”中传递所在的内存地址（引用）加到 res 中 ；                # 所有递归函数始终对唯一的内存地址的同一个 path 对象做处理，因此回溯时，也应将 path 还原至此递归函数执行前的形式                 # 不断地变长变短、变长变短的 path 变量所指向的列表在深度优先遍历的过程中只有一份，                # 后续 path 对象改变时，后面又进栈 append 又出栈 pop 的，                # res 中的 path 对象 也会随之改变                # 深度优先遍历完成以后，最终回溯回根节点root，path回到空列表。                # 实际上指向的是同一块内存地址，指向的那块内存区域没有变，因此会看到 6 个空的列表对象。                # res 里面是这样的：[path 在内存中的地址, path 在内存中的地址,                # path 在内存中的地址, path 在内存中的地址, path 在内存中的地址]                # 深拷贝 copy.deepcopy，没有拷贝对象的地址(引用)，只是拷贝对象的值，                # 当一条path找到的时候，我想要完整的保存它，                # 每次都要新复制了一个 path 列表，把新复制的列表的地址复制到 res 中，因此不会受到 path 变化的影响。                # 在它遍历到符合条件的状态时候，把其中的在某个特定时期的状态的变量的地址复制下来                # 解决的方法，list(path)或path[:]或path.copy()                # 本文中的 path 列表对象对于 dfs() 函数来说仍是 ”全局的“                 res.append(list(path))            recur(root.left, tar)  # 递归处理左边或函数已返回（左子树已递归完成）            recur(root.right, tar)  # 递归处理右边或函数已返回（右子树已递归完成）            path.pop()  # 递归完成以后，必须重置变量            # 为什么仅path.pop() 而不tar += root.val呢？            # 而且加上了tar += root.val也能通过？            # tar 是数值不可变对象值传递，因此每轮递归函数里的修改的 tar 都是独立的数字，            # 上层递归的 tar 还保存在系统调用dfs的栈中，是没有变的，相当于tar没有减去那个数，因此tar不用回溯 不用重置            # 在记录路径时，一旦涉及本节点的路径都检查并记录完毕，就要去掉本节点，但未完毕前不能去掉，所以放在最后。            # 另外，递归思考过程中需要且仅需要着眼当下，如果实在纠结递归的进行过程，要从函数调用栈的角度思考。            # 函数执行完就会自己结束的～因为本题 recur() 不需要有返回值，因此就不用 return        recur(root, sum)        return res  class Solution:    def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:        #  res 保存最终的所有路径结果， path 保存每条路径。        res, path = [], []        def recur(root, tar):            # 递归终止条件 1：解决子问题，如果输入结点为空结点，返回空列表            if not root:                   # recur() 函数实际上是 void 函数，最后return 的是 res ,写成return [] 都可以                return              # 有节点            path.append(root.val)            tar -= root.val            # 递归终止条件 2：tar == 0，并且节点为叶子节点             if tar == 0 and not root.left and not root.right:                # 对引用类型参数（Reference Data Type Arguments）动态变量，                # 在调用函数时，将实际参数的 内存地址（引用，而不是真正的变量） 复制传递到函数中。                # 可变对象如列表，字典等，原本就可以改变，如果在函数中对参数修改，将会影响到实际参数。                # 记录路径时若执行 res.append(path) ，                # 把 path 列表对象在“方法传参”中传递所在的内存地址（引用）加到 res 中 ；                # 所有递归函数始终对唯一的内存地址的同一个 path 对象做处理，因此回溯时，也应将 path 还原至此递归函数执行前的形式                 # 不断地变长变短、变长变短的 path 变量所指向的列表在深度优先遍历的过程中只有一份，                # 后续 path 对象改变时，后面又进栈 append 又出栈 pop 的，                # res 中的 path 对象 也会随之改变                # 深度优先遍历完成以后，最终回溯回根节点root，path回到空列表。                # 实际上指向的是同一块内存地址，指向的那块内存区域没有变，因此会看到 6 个空的列表对象。                # res 里面是这样的：[path 在内存中的地址, path 在内存中的地址,                # path 在内存中的地址, path 在内存中的地址, path 在内存中的地址]                # 深拷贝 copy.deepcopy，没有拷贝对象的地址(引用)，只是拷贝对象的值，                # 当一条path找到的时候，我想要完整的保存它，                # 每次都要新复制了一个 path 列表，把新复制的列表的地址复制到 res 中，因此不会受到 path 变化的影响。                # 在它遍历到符合条件的状态时候，把其中的在某个特定时期的状态的变量的地址复制下来                # 解决的方法，list(path)或path[:]或path.copy()                # 本文中的 path 列表对象对于 dfs() 函数来说仍是 ”全局的“                 res.append(list(path))            recur(root.left, tar)  # 递归处理左边或函数已返回（左子树已递归完成）            recur(root.right, tar)  # 递归处理右边或函数已返回（右子树已递归完成）            path.pop()  # 递归完成以后，必须重置变量            # 为什么仅path.pop() 而不tar += root.val呢？            # 而且加上了tar += root.val也能通过？            # tar 是数值不可变对象值传递，因此每轮递归函数里的修改的 tar 都是独立的数字，            # 上层递归的 tar 还保存在系统调用dfs的栈中，是没有变的，相当于tar没有减去那个数，因此tar不用回溯 不用重置            # 在记录路径时，一旦涉及本节点的路径都检查并记录完毕，就要去掉本节点，但未完毕前不能去掉，所以放在最后。            # 另外，递归思考过程中需要且仅需要着眼当下，如果实在纠结递归的进行过程，要从函数调用栈的角度思考。            # 函数执行完就会自己结束的～因为本题 recur() 不需要有返回值，因此就不用 return        recur(root, sum)        return res  # 返回二维列表，内部每个列表表示找到的路径\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162tar = 22root = 5path = [5]tar = 17root = root.left = 4path = [5, 4]tar = 13root = root.left = 11path = [5, 4, 11]tar = 2root = root.left = 7path = [5, 4, 11, 7]tar = -5不满足回到上一层root = 11root = root.right = 2path = [5, 4, 11, 2]tar = 0res = [ [5, 4, 11, 2] ]path = [5, 4, 11]回到上一层root = 4path = [5, 4]回到上一层root = 5path = [5]tar = 17root = root.right = 8path = [5, 8]tar = 9root = root.left = 13path = [5, 8, 13]tar = -4回到上一层root = 8path = [5, 8]tar = 9root = root.right = 4path = [5, 8, 4]tar = 5root = root.left = 5path = [5, 8, 4, 5]tar = 0res = [ [5, 4, 11, 2],  ]回到上一层root = 4path = [5, 8, 4]tar = 5root = root.right = 1path = [5, 8, 4, 1]tar = tar = 22root = 5path = [5]tar = 17root = root.left = 4path = [5, 4]tar = 13root = root.left = 11path = [5, 4, 11]tar = 2root = root.left = 7path = [5, 4, 11, 7]tar = -5不满足回到上一层root = 11root = root.right = 2path = [5, 4, 11, 2]tar = 0res = [ [5, 4, 11, 2] ]path = [5, 4, 11]回到上一层root = 4path = [5, 4]回到上一层root = 5path = [5]tar = 17root = root.right = 8path = [5, 8]tar = 9root = root.left = 13path = [5, 8, 13]tar = -4回到上一层root = 8path = [5, 8]tar = 9root = root.right = 4path = [5, 8, 4]tar = 5root = root.left = 5path = [5, 8, 4, 5]tar = 0res = [ [5, 4, 11, 2],  ]回到上一层root = 4path = [5, 8, 4]tar = 5root = root.right = 1path = [5, 8, 4, 1]tar = 4\n\n\n\n递归先序遍历树，把结点加入路径。若该结点是叶子结点则比较当前路径和是否等于期待和。弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点\n方法二，击败95%\n1234567891011121314151617181920212223242526272829303132333435from typing import Listclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:        res, path = [], []        if not root: return []        def dfs(root, tar):            # print(path)            # 递归终止条件 1：如果遍历到的结点为空结点，返回            if not root: return            # 递归终止条件 2：如果遍历到的叶子结点，且 tar 恰好等于叶子结点的值            path.append(root.val)            if root.val == tar and not root.left and not root.right:                res.append(path[:])                path.pop()                # 在叶子结点处，并且找到了一个解以后，就可以返回，所以要加上 return                return            # 缩进错了，下面 3 行都是 dfs 函数里的内容            dfs(root.left, tar - root.val)            dfs(root.right, tar - root.val)            path.pop()        # 在这里要调用一下 dfs 方法        dfs(root, sum)        from typing import Listclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:        res, path = [], []        if not root: return []        def dfs(root, tar):            # print(path)            # 递归终止条件 1：如果遍历到的结点为空结点，返回            if not root: return            # 递归终止条件 2：如果遍历到的叶子结点，且 tar 恰好等于叶子结点的值            path.append(root.val)            if root.val == tar and not root.left and not root.right:                res.append(path[:])                path.pop()                # 在叶子结点处，并且找到了一个解以后，就可以返回，所以要加上 return                return            # 缩进错了，下面 3 行都是 dfs 函数里的内容            dfs(root.left, tar - root.val)            dfs(root.right, tar - root.val)            path.pop()        # 在这里要调用一下 dfs 方法        dfs(root, sum)        return res\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667path = []root = 5tar = 22path = [5]root = root.left = 4tar = 17path = [5, 4]tar = 13root = root.left = 11path = [5, 4, 11]tar = 2root = root.left = 7path = [5, 4, 11, 7]tar = -5不满足回到上一层root = 11root = root.right = 2path = [5, 4, 11, 2]tar = 0res = [ [5, 4, 11, 2] ]path = [5, 4, 11]回到上一层root = 4path = [5, 4]回到上一层root = 5tar = 22path = [5]root = root.right = 8tar = 17path = [5, 8]root = root.left = 13tar = 9path = [5, 8, 13]回到上一层root = 8tar = 17path = [5, 8]root = root.right = 4tar = 9path = [5, 8, 4]root = root.left = 5tar = 5path = [5, 8, 4, 5]res = [ [5, 4, 11, 2], [5, 8, 4, 5] ]回到上一层root = 4tar = 9path = [5, 8, 4]root = root.right = 1tar = 5path = [5, 8, 4, 1]tar = path = []root = 5tar = 22path = [5]root = root.left = 4tar = 17path = [5, 4]tar = 13root = root.left = 11path = [5, 4, 11]tar = 2root = root.left = 7path = [5, 4, 11, 7]tar = -5不满足回到上一层root = 11root = root.right = 2path = [5, 4, 11, 2]tar = 0res = [ [5, 4, 11, 2] ]path = [5, 4, 11]回到上一层root = 4path = [5, 4]回到上一层root = 5tar = 22path = [5]root = root.right = 8tar = 17path = [5, 8]root = root.left = 13tar = 9path = [5, 8, 13]回到上一层root = 8tar = 17path = [5, 8]root = root.right = 4tar = 9path = [5, 8, 4]root = root.left = 5tar = 5path = [5, 8, 4, 5]res = [ [5, 4, 11, 2], [5, 8, 4, 5] ]回到上一层root = 4tar = 9path = [5, 8, 4]root = root.right = 1tar = 5path = [5, 8, 4, 1]tar = 4\n\n12345678910111213141516171819class Solution:    def pathSum(self, root: TreeNode, sum_: int) -&gt; List[List[int]]:        res = []        def helper(root, path, sum_):            if not root:                return             if not root.left and not root.right and sum_ - root.val == 0:                path += [root.val]                res.append(path)            # path + [root.left.val] 返回一个新的列表，所有递归函数里的 path 操作不会互相干扰。             # path.append(root.left.val)是对path进行修改，无返回值            # 记录到达每个节点时的sum - 「路径和」            # 如果遍历到叶子节点的时候，sum - 「路径和」恰好等于叶子节点的值，            # 那么这条从根节点到叶子节点的路径即为一条满足题目的路径。            helper(root.left, path + [root.val], sum_ - root.val)            helper(root.right, path + [root.val], sum_ - root.val)        helper(root, [], sum_)        class Solution:    def pathSum(self, root: TreeNode, sum_: int) -&gt; List[List[int]]:        res = []        def helper(root, path, sum_):            if not root:                return             if not root.left and not root.right and sum_ - root.val == 0:                path += [root.val]                res.append(path)            # path + [root.left.val] 返回一个新的列表，所有递归函数里的 path 操作不会互相干扰。             # path.append(root.left.val)是对path进行修改，无返回值            # 记录到达每个节点时的sum - 「路径和」            # 如果遍历到叶子节点的时候，sum - 「路径和」恰好等于叶子节点的值，            # 那么这条从根节点到叶子节点的路径即为一条满足题目的路径。            helper(root.left, path + [root.val], sum_ - root.val)            helper(root.right, path + [root.val], sum_ - root.val)        helper(root, [], sum_)        return res\n\n\n31.二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n12345    4   / \\   2   5 / \\1       4   / \\   2   5 / \\1   3\n\n希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n解题思路：本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。因此把标准中序遍历中 改变每个父节点的左右指向即可将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：\n\n排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点；\n双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right = cur ，也应 cur.left = pre 。\n循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right = head 。\n\n123456# 打印中序遍历def dfs(root):    if not root: return    dfs(root.left)  # 左    print(root.val) # 根    dfs(root.right) # 打印中序遍历def dfs(root):    if not root: return    dfs(root.left)  # 左    print(root.val) # 根    dfs(root.right) # 右\n根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。\n算法流程：dfs(cur): 递归法中序遍历；\n\n终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；\n递归左子树，即 dfs(cur.left) ；\n构建链表：\n当 pre 为空时：代表正在访问链表头节点，记为 head 。\n当 pre 不为空时：修改双向节点引用，即 pre.right = cur ， cur.left = pre ；\n保存 cur ：更新 pre = cur ，即节点 cur 是后继节点的 pre ；\n\n\n递归右子树，即 dfs(cur.right) ；并没有创建新节点，pre 、 head 只是两个引用，指向现有节点的地址。\n\ntreeToDoublyList(root)：\n\n特例处理： 若节点 root 为空，则直接返回；\n初始化： 空节点 pre ；\n转化为双向链表： 调用 dfs(root) ；\n构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可。\n返回值： 返回链表的头节点 head 即可。\n\n时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。\npre = ListNode() ，如果不加self的话，pre和head是dfs函数内部的变量，那么就是类中方法的私有变量，是无法被类所访问的，外函数和内函数不能共享由于中序遍历完还需要用到 pre 去实现循环链表，此时可以声明 self.pre = pre 则建立了类成员变量 self.pre或者在函数内部声明 nonlocal pre 说明 pre 不会因为引用修改而成为局部变量。这样此变量就能在所属类的任何方法中访问。类里面的全局变量使其在两个函数 dfs()中都可以正常访问 head 和 pre，\nlist 类型是外部变量全局变量，函数中的函数也可以访问。内部调用 list.append() 等方法，不会改变引用，也就不需要做 self 和 nonlocal 等操作。\nhead是个指针变量，（这里你就当成个普通int型变量来理解就行了），指针变量作为函数参数传入时和普通变量一样，也就是，如你在dfs函数中怎么修改它，当函数结束返回的时候，指针变量或者普通变量还是传入之前的值。但是加上引用就不一样了，此时你在dfs中修改head指针，函数返回时，head指针是被修改过的。\n值传递与引用传递的区别，因为函数是void的，想要把函数内部对指针的修改传出来就得用引用（或者指针的指针也可以），别去管head和pre是不是指针（指针本质上也是一个对象），最后修改一下函数的返回值也是可以的。因为你修改的对象是Node本身，而不是指向的那个东西，所以要对Node再加个引用。（指针参数本质上也是一种值传递，传递的就是地址）\n1234567891011121314151617181920212223242526class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        def dfs(cur):            # 递归出口            if not cur: return            dfs(cur.left)  # # 中序遍历，先递归左子树            # pre 用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur            # pre!=None时，cur左侧存在节点pre，需要进行 pre.right=cur 的操作            # pre 相对于递归函数是全局变量，因此需要加 self            # 中序遍历，然后父节点            if self.pre:  # 修改节点引用                self.pre.right, cur.left = cur, self.pre            # 当pre==None时，cur左侧没有节点，即此时cur为双向链表中的头节点            else:                  self.head = cur  # 记录初始头节点            self.pre = cur  # 保存 cur, pre指向当前的cur            dfs(cur.right)  # 中序遍历，最后 递归右子树         if not root: return        self.pre = None        dfs(root)        # 中序遍历全部迭代完后，head 指向头节点，pre 指向尾节点，        # 构建循环链表：因此修改 head 和 pre 的双向节点引用即可。        # 进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的        self.head.left, self.pre.right = self.pre, self.head        class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        def dfs(cur):            # 递归出口            if not cur: return            dfs(cur.left)  # # 中序遍历，先递归左子树            # pre 用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur            # pre!=None时，cur左侧存在节点pre，需要进行 pre.right=cur 的操作            # pre 相对于递归函数是全局变量，因此需要加 self            # 中序遍历，然后父节点            if self.pre:  # 修改节点引用                self.pre.right, cur.left = cur, self.pre            # 当pre==None时，cur左侧没有节点，即此时cur为双向链表中的头节点            else:                  self.head = cur  # 记录初始头节点            self.pre = cur  # 保存 cur, pre指向当前的cur            dfs(cur.right)  # 中序遍历，最后 递归右子树         if not root: return        self.pre = None        dfs(root)        # 中序遍历全部迭代完后，head 指向头节点，pre 指向尾节点，        # 构建循环链表：因此修改 head 和 pre 的双向节点引用即可。        # 进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的        self.head.left, self.pre.right = self.pre, self.head        return self.head\n\n不是把二叉树的根节点当作链表的头，应该是将最左下的叶节点作为链表的头结点。排序：树的中序遍历 1 2 3 4 5双向：2.right = 3 ,  3.left = 2循环：5.right = 1， 1.left = 5\n12345678910111213141516171819202122232425262728293031323334353637pre = Noneroot = 4cur = rootcur = cur.left = 2cur = cur.left = 1cur = cur.left = None回到上一层cur = 1head = cur = 1pre = cur = 1回到上一层cur = 2pre.right = cur = 2cur.left = self.pre = 1pre = cur = 2cur = cur.right = 3pre.right = cur = 3cur.left = self.pre = 2pre = cur = 3回到上一层cur = 2 回到上一层cur = 4pre.right = cur = 4cur.left = self.pre = 3pre = cur = 4cur = cur.right = 5pre.right = cur = 5cur.left = self.pre = 4pre = cur = 5self.head.left = self.pre = 5self.pre.right = self.head = pre = Noneroot = 4cur = rootcur = cur.left = 2cur = cur.left = 1cur = cur.left = None回到上一层cur = 1head = cur = 1pre = cur = 1回到上一层cur = 2pre.right = cur = 2cur.left = self.pre = 1pre = cur = 2cur = cur.right = 3pre.right = cur = 3cur.left = self.pre = 2pre = cur = 3回到上一层cur = 2 回到上一层cur = 4pre.right = cur = 4cur.left = self.pre = 3pre = cur = 4cur = cur.right = 5pre.right = cur = 5cur.left = self.pre = 4pre = cur = 5self.head.left = self.pre = 5self.pre.right = self.head = 1\n\n\n法二：不用递归，利用栈中序遍历，顺便更改节点左右指向，头结点和尾结点的指针。\n1234567891011121314151617181920212223242526class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        if not root:            return        stack = []        node = root        while node:            stack.append(node)            node = node.left        head = node = stack.pop()        pre = node        node = node.right        while node or stack:            while node:                stack.append(node)                node = node.left            node = stack.pop()            pre.right = node            node.left = pre            pre = node            node = node.right        pre.right = head        head.left = pre        class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        if not root:            return        stack = []        node = root        while node:            stack.append(node)            node = node.left        head = node = stack.pop()        pre = node        node = node.right        while node or stack:            while node:                stack.append(node)                node = node.left            node = stack.pop()            pre.right = node            node.left = pre            pre = node            node = node.right        pre.right = head        head.left = pre        return head\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051stack = []node = root = 4stack = [4]node = node.left = 2stack = [4, 2]node = node.left = 1stack = [4, 2, 1]node = node.left = Nonestack = [4, 2]head = node = 1pre = 1node = node.right = Nonestack = [4]node = 2pre.right = node = 2node.left = pre = 1pre = node = 2node = node.right = 3stack = [4, 3]node = node.left = Nonestack = [4]node = 3pre.right = node = 3node.left = pre = 2pre = node = 3node = node.right = Nonestack = []node = 4pre.right = node = 4node.left = pre = 3pre = node = 4node = node.right = 5stack = [5]node = node.left = Nonestack = []node = 5pre.right = node = 5node.left = pre = 4pre = node = 5node = node.right = Nonestack 和 node 同时为空pre.right = head = 1head.left = pre = stack = []node = root = 4stack = [4]node = node.left = 2stack = [4, 2]node = node.left = 1stack = [4, 2, 1]node = node.left = Nonestack = [4, 2]head = node = 1pre = 1node = node.right = Nonestack = [4]node = 2pre.right = node = 2node.left = pre = 1pre = node = 2node = node.right = 3stack = [4, 3]node = node.left = Nonestack = [4]node = 3pre.right = node = 3node.left = pre = 2pre = node = 3node = node.right = Nonestack = []node = 4pre.right = node = 4node.left = pre = 3pre = node = 4node = node.right = 5stack = [5]node = node.left = Nonestack = []node = 5pre.right = node = 5node.left = pre = 4pre = node = 5node = node.right = Nonestack 和 node 同时为空pre.right = head = 1head.left = pre = 5\n\n法三：分治 递归遍历第一步：需要把 left 指针指向上一个比该元素小的值，right 指针指向下一个比当前元素大的值。但是这个值不一定是该节点的父亲或者儿子。所以递归的时候需要传递当前元素已知的界限给儿子。\n而且传给左孩子的右界限是自己，左界限是当前元素的父亲传下来的界限。给右孩子的则正好相反。\n递归的起始根节点的左右界限都设为 None\n第二步：把最小值和最大值连接起来\n如何找到最小值和最大值，最小值和最大值不一定是叶子节点。我刚开始犯了这个错误。\n最小值一定是某个节点的左儿子，而且他没有左儿子。是整个树最左边的左儿子。\n所以我定义的找最小节点的条件是：没有左儿子 + 父亲传来的左界限为 None最大节点：没有右儿子 + 父亲传来的右界限为 None\n这个方法将dfs()的输出改为头和尾，然后左节点尾连根节点再连右节点头，接着递归即可时间复杂度：O(N)，所有节点遍历一次。空间复杂度：O(N)，当二叉搜索树退化为链表时，树的深度为 N.\n1234567891011121314151617181920212223class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        def dfs(root: 'Node') -&gt; ('Node', 'Node'):            # 根为空，那么 对应的双向链表的 头节点 和 尾节点 也为空            if not root: return None, None            # 左子树 对应的 双向链表的头节点和尾节点            left_head, left_tail = dfs(root.left)            # 右子树 对应的 双向链表的头节点和尾节点            right_head, right_tail = dfs(root.right)            # 根的 左节点 与 左子树的尾节点 互相连接            # 根的 右节点 与 右子树的头节点 互相连接            root.left, root.right = left_tail, right_head            if left_tail:                 left_tail.right = root            if right_head:                 right_head.left = root            # 左子树的头节点 如果存在则作为当前 双向链表的头节点，否则使用 根节点。尾节点同理。            return left_head if left_head else root, right_tail if right_tail else root        head, tail = dfs(root)        # 改造成循环双向链表        if head and tail:            head.left, tail.right = tail, head        class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        def dfs(root: 'Node') -&gt; ('Node', 'Node'):            # 根为空，那么 对应的双向链表的 头节点 和 尾节点 也为空            if not root: return None, None            # 左子树 对应的 双向链表的头节点和尾节点            left_head, left_tail = dfs(root.left)            # 右子树 对应的 双向链表的头节点和尾节点            right_head, right_tail = dfs(root.right)            # 根的 左节点 与 左子树的尾节点 互相连接            # 根的 右节点 与 右子树的头节点 互相连接            root.left, root.right = left_tail, right_head            if left_tail:                 left_tail.right = root            if right_head:                 right_head.left = root            # 左子树的头节点 如果存在则作为当前 双向链表的头节点，否则使用 根节点。尾节点同理。            return left_head if left_head else root, right_tail if right_tail else root        head, tail = dfs(root)        # 改造成循环双向链表        if head and tail:            head.left, tail.right = tail, head        return head\n\n123456789101112131415161718192021222324class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        if not root:            return None        def merge(root):            if not root:                return None, None            lh, lt = merge(root.left)            rh, rt = merge(root.right)            res = [lh, rt]            if not lh:                res[0] = root                            root.left = lt            if lt:                lt.right = root            if not rt:                res[1] = root            root.right = rh            if rh:                rh.left = root            return res        head, tail = merge(root)        head.left, tail.right = tail, head        class Solution:    def treeToDoublyList(self, root: 'Node') -&gt; 'Node':        if not root:            return None        def merge(root):            if not root:                return None, None            lh, lt = merge(root.left)            rh, rt = merge(root.right)            res = [lh, rt]            if not lh:                res[0] = root                            root.left = lt            if lt:                lt.right = root            if not rt:                res[1] = root            root.right = rh            if rh:                rh.left = root            return res        head, tail = merge(root)        head.left, tail.right = tail, head        return head\n\n\n回溯法一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。\n采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n找到一个可能存在的正确的答案；\n在尝试了所有可能的分步方法后宣告该问题没有答案。\n\n「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。\n搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。\n与动态规划的区别共同点用于求解多阶段决策问题。多阶段决策问题即：\n\n求解一个问题分为很多步骤（阶段）；\n每一个步骤（阶段）可以有多种选择。不同点\n动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；\n回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。\n\n怎么前进（进入下一个状态）；怎么回退（回到上一个状态）；什么时候停止。 其中比较重要的是：采取何种方式处理好状态的前进和回退。\n回溯问题本身是在树形问题上的遍历，且是深度优先遍历。所以有回退的过程，需要撤销选择。单从代码上看可能看不出来，一定要先理解「深度优先遍历」这个思想，然后再去理解为什么可以用「一个变量」去在「所有可能的状态集合」里搜索要求的状态。\n我在标题和题解的一开始都在强调这件事情。怎样构建一个「树」的模型，去执行深度优先遍历，是解决这一类问题的关键思想\n全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n示例:\n输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]\n从全排列问题开始理解回溯算法我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。\n按顺序枚举每一个位置可能出现的数字，之前已经出现的数字在接下来要选择的数字中不能出现\n先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。\n说明：\n\n每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；\n使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。例如：从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；\n\n正是因为修改的都是同一个对象，在回到来过的地方的时候，这个对象的值要和之前来到的时候是一样的。\n\n深度优先遍历，借助系统栈空间，已经选了哪些树的 path，保存每一个结点的所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；\n深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。\n\n使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。\n设计状态变量：表示了在求解一个问题的时候所处的阶段。\n\n首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；\n递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；\n布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应下标设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。\n\n需要根据问题的场景设计合适的状态变量。\n剪枝回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。\n由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。总结做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。\n在画图的过程中思考清楚：分支如何产生；递归到叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？\n在前进时，需要查看当前数字是否已经在组合的路径中，也就是要回避非法状态；在回退时，要将当前数字从组合的路径中删除，以达到回溯、不影响进入到下一个状态的目的。 \n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from typing import Listclass Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        def dfs(nums, length, depth, path, used, res):            if depth == length:  # 递归结束条件：当前递归的层数=输入数组的长度                res.append(list(path))                return  # 在满足条件return之后，depth-1=2，i =2顺次执行状态重置的代码。path = [1, 2], used = [True, True, False]                # 至于它为什么可以继续执行上一步的状态重置，而不需要再次进入if语句是因为！！！在我们把第三个True置为False，并把3 pop之后，本层调用已经结束了,因为所有的可能已经都调用完了，该函数的子孙们都被解决掉了，[1, 2]后面不会在加上除了3以外的数字                # 回到上一层，depth = 1, i = 1                 # dfs(nums, length, depth + 1, path, used, res)就是个单纯的语句了，就继续往下执行代码啦，                # 然后又来到了状态重置这里，改变第二个位置的状态[True, False, False]，pop(), path = [1],                # 进入for                # depth = 1, i = 2, used = [True, False, True], path = [1, 3]                # dfs(nums, length, depth + 1, path, used, res)进入下一层                # depth = 2, i = 0, used[0] = True, path = [1, 3],                 # depth = 2, i = 1, used[1] = False, used = [True, True, True], path = [1, 3, 2],                 # return i =1,            # 在非叶子结点处，产生不同的分支，            for i in range(length):                if not used[i]:  # 当前未选择的数中依次选择一个元素作为下一个位置的元素，flase才能                    used[i] = True  # 标记为已经选择的元素                    path.append(nums[i])  # 把选择的元素添加到栈的末尾                    print('递归前 used =', used, ', path =', path)                    dfs(nums, length, depth + 1, path, used, res)                    # 下一层结点的递归执行结束以后，                    # 它后面的语句是表示程序要回退到上一个结点进行相关操作                    # （这里要结合图形来理解）。                    # 不是因为写了 used[i] = False 和 path.pop() 才有回退                    print('递归后 used =', used, ', path =', path)                    # 下面这两行代码发生 「回溯」，为了保证在回退的时候，相关数据也正确，最终结果才会正确。                    # 回溯发生在从 深层结点 回到 浅层结点 的过程，                    # 代码在形式上和递归之前是对称的                    used[i] = False                    path.pop()        length = len(nums)  # 输入数组的长度        if len(nums) == 0:  # 如果输入数组是一个空数组            return []  # 返回一个空列表        # 初始化每个元素都为 false，表示这些数还没有被选择，空间换时间        used = [False for _ in range(length)]        # print([False for _ in range(3)])  # [False, False, False]        res = []        dfs(nums, length, 0, [], used, res)        return resif __name__ == '__main__':    nums = [1, 2, from typing import Listclass Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        def dfs(nums, length, depth, path, used, res):            if depth == length:  # 递归结束条件：当前递归的层数=输入数组的长度                res.append(list(path))                return  # 在满足条件return之后，depth-1=2，i =2顺次执行状态重置的代码。path = [1, 2], used = [True, True, False]                # 至于它为什么可以继续执行上一步的状态重置，而不需要再次进入if语句是因为！！！在我们把第三个True置为False，并把3 pop之后，本层调用已经结束了,因为所有的可能已经都调用完了，该函数的子孙们都被解决掉了，[1, 2]后面不会在加上除了3以外的数字                # 回到上一层，depth = 1, i = 1                 # dfs(nums, length, depth + 1, path, used, res)就是个单纯的语句了，就继续往下执行代码啦，                # 然后又来到了状态重置这里，改变第二个位置的状态[True, False, False]，pop(), path = [1],                # 进入for                # depth = 1, i = 2, used = [True, False, True], path = [1, 3]                # dfs(nums, length, depth + 1, path, used, res)进入下一层                # depth = 2, i = 0, used[0] = True, path = [1, 3],                 # depth = 2, i = 1, used[1] = False, used = [True, True, True], path = [1, 3, 2],                 # return i =1,            # 在非叶子结点处，产生不同的分支，            for i in range(length):                if not used[i]:  # 当前未选择的数中依次选择一个元素作为下一个位置的元素，flase才能                    used[i] = True  # 标记为已经选择的元素                    path.append(nums[i])  # 把选择的元素添加到栈的末尾                    print('递归前 used =', used, ', path =', path)                    dfs(nums, length, depth + 1, path, used, res)                    # 下一层结点的递归执行结束以后，                    # 它后面的语句是表示程序要回退到上一个结点进行相关操作                    # （这里要结合图形来理解）。                    # 不是因为写了 used[i] = False 和 path.pop() 才有回退                    print('递归后 used =', used, ', path =', path)                    # 下面这两行代码发生 「回溯」，为了保证在回退的时候，相关数据也正确，最终结果才会正确。                    # 回溯发生在从 深层结点 回到 浅层结点 的过程，                    # 代码在形式上和递归之前是对称的                    used[i] = False                    path.pop()        length = len(nums)  # 输入数组的长度        if len(nums) == 0:  # 如果输入数组是一个空数组            return []  # 返回一个空列表        # 初始化每个元素都为 false，表示这些数还没有被选择，空间换时间        used = [False for _ in range(length)]        # print([False for _ in range(3)])  # [False, False, False]        res = []        dfs(nums, length, 0, [], used, res)        return resif __name__ == '__main__':    nums = [1, 2, 3]    solution = Solution()    res = solution.permute(nums)    print(res)\n\n因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。\n它们的区别仅在于\n1、二进制右边是低位，数组左边是索引为 0 的位置；\n2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。\n因此，完全可以用一个整数表示一个布尔型数组。\n我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。\n异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。\n具体说来：\n把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。\n因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。\n它们的区别仅在于\n1、二进制右边是低位，数组左边是索引为 0 的位置；\n2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。\n因此，完全可以用一个整数表示一个布尔型数组。\n我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。\n异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。\n具体说来：\n把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。\n123456789101112131415161718192021class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        res = []        n = k = len(nums)        def back_func(first=0):            # first等于k时返回，代表着是计算A(n,k)的全排列问题，应题目要求此时k==n            if first == k:                res.append(nums[:])                return            for i in range(first, n):                # 用first选定nums中每个位置，取值是[0, n-1]                # 用交换来选定first位置上所有可能的元素                # 当first=0时有n个元素可以放到first位置                nums[first], nums[i] = nums[i], nums[first]                # first位置放好元素之后，用递归去放first+1位置的元素，它有n-1种取值                back_func(first+1)                # 当将k个位置都放好元素之后函数会return，但别忘了撤销交换操作，                # 因为此时的first位置还要继续for循环和其它的i位置交换元素                nums[first], nums[i] = nums[i], nums[first]        back_func()        class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        res = []        n = k = len(nums)        def back_func(first=0):            # first等于k时返回，代表着是计算A(n,k)的全排列问题，应题目要求此时k==n            if first == k:                res.append(nums[:])                return            for i in range(first, n):                # 用first选定nums中每个位置，取值是[0, n-1]                # 用交换来选定first位置上所有可能的元素                # 当first=0时有n个元素可以放到first位置                nums[first], nums[i] = nums[i], nums[first]                # first位置放好元素之后，用递归去放first+1位置的元素，它有n-1种取值                back_func(first+1)                # 当将k个位置都放好元素之后函数会return，但别忘了撤销交换操作，                # 因为此时的first位置还要继续for循环和其它的i位置交换元素                nums[first], nums[i] = nums[i], nums[first]        back_func()        return res\n\n123456789101112131415161718class Solution:    def permute(self, nums):        def backtrack(first = 0):            # 所有数都填完了            if first == n:                  res.append(nums[:])            for i in range(first, n):                # 动态维护数组                nums[first], nums[i] = nums[i], nums[first]                # 继续递归填下一个数                backtrack(first + 1)                # 撤销操作                nums[first], nums[i] = nums[i], nums[first]                n = len(nums)        res = []        backtrack()        class Solution:    def permute(self, nums):        def backtrack(first = 0):            # 所有数都填完了            if first == n:                  res.append(nums[:])            for i in range(first, n):                # 动态维护数组                nums[first], nums[i] = nums[i], nums[first]                # 继续递归填下一个数                backtrack(first + 1)                # 撤销操作                nums[first], nums[i] = nums[i], nums[first]                n = len(nums)        res = []        backtrack()        return res\n\n12345678910111213class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        res = []        def backtrack(nums, tmp):  # temp为临时列表            if not nums:  # 已经选完所有的元素了，可以结束                res.append(tmp)                return             for i in range(len(nums)):                # backtrack函数，确定好递归的终点和当前一步转移到下一步的递归的写法，然后从起点开始调用这个递归函数就行了。                # nums[:i] + nums[i+1:] 对nums当中除了第i个数之外的数进行遍历                backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]])        backtrack(nums, [])        class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        res = []        def backtrack(nums, tmp):  # temp为临时列表            if not nums:  # 已经选完所有的元素了，可以结束                res.append(tmp)                return             for i in range(len(nums)):                # backtrack函数，确定好递归的终点和当前一步转移到下一步的递归的写法，然后从起点开始调用这个递归函数就行了。                # nums[:i] + nums[i+1:] 对nums当中除了第i个数之外的数进行遍历                backtrack(nums[:i] + nums[i+1:], tmp + [nums[i]])        backtrack(nums, [])        return res\n\n\n12345678910111213141516171819202122class Solution(object):    def permute(self, nums):        if len(nums) &lt;= 1:            return [nums]        visited = [False for _ in range(len(nums))]  # 记录那些元素已经访问        res = []        def dfs(numbers, result, cur, visit):            if len(cur) == len(numbers):                result.append(cur[:])  # 这里记得用cur[:]或拷贝                return            for i in range(len(numbers)):                if visit[i]:  # 如果已经访问过某元素，直接跳过进下一个元素                    continue                cur.append(numbers[i])                visit[i] = True  # 将访问过的元素标记                dfs(numbers, result, cur, visit)                cur.pop()  # 恢复到之前状态                visit[i] = False  # 恢复到之前状态        dfs(nums, res, [], visited)        class Solution(object):    def permute(self, nums):        if len(nums) &lt;= 1:            return [nums]        visited = [False for _ in range(len(nums))]  # 记录那些元素已经访问        res = []        def dfs(numbers, result, cur, visit):            if len(cur) == len(numbers):                result.append(cur[:])  # 这里记得用cur[:]或拷贝                return            for i in range(len(numbers)):                if visit[i]:  # 如果已经访问过某元素，直接跳过进下一个元素                    continue                cur.append(numbers[i])                visit[i] = True  # 将访问过的元素标记                dfs(numbers, result, cur, visit)                cur.pop()  # 恢复到之前状态                visit[i] = False  # 恢复到之前状态        dfs(nums, res, [], visited)        return res\n\n\n递归\n12345678910class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) &lt;= 1:  # 递归终止条件            return [nums]        res = []        for idx, num in enumerate(nums):            res_nums = nums[:idx] + nums[idx + 1:]  # 确定剩余元素            for j in self.permute(res_nums):                  res.append([num] + j)        class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) &lt;= 1:  # 递归终止条件            return [nums]        res = []        for idx, num in enumerate(nums):            res_nums = nums[:idx] + nums[idx + 1:]  # 确定剩余元素            for j in self.permute(res_nums):                  res.append([num] + j)        return res\n\n\n组数总和给定一个无重复元素的数组&nbsp;candidates&nbsp;和一个目标数&nbsp;target&nbsp;，找出&nbsp;candidates&nbsp;中所有可以使数字和为&nbsp;target&nbsp;的组合。candidates&nbsp;中的数字可以无限制重复被选取。\n说明：\n\n所有数字（包括&nbsp;target）都是正整数。\n解集不能包含重复的组合。&nbsp;示例&nbsp;1：123456输入：candidates = [2,3,6,7], target = 7,所求解集为：[  [7],  [2,2,输入：candidates = [2,3,6,7], target = 7,所求解集为：[  [7],  [2,2,3]]\n示例&nbsp;2：1234567输入：candidates = [2,3,5], target = 8,所求解集为：[&nbsp; [2,2,2,2],&nbsp; [2,3,3],&nbsp; [3,输入：candidates = [2,3,5], target = 8,所求解集为：[&nbsp; [2,2,2,2],&nbsp; [2,3,3],&nbsp; [3,5]]\n\n\n\n思路分析：根据示例 1：输入: candidates = [2, 3, 6, 7]，target = 7。\n候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。\n先画出树形图，然后编码实现。\n二叉树的序列化与反序列化**序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。**\n说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。不能有任何辅助信息帮助完成序列化和反序列化。LeetCode的测试方式是事先提供一个二叉树，然后跑一下你的序列化代码，然后将你序列化的返回的字符串作为反序列化的输入，比较还原的二叉树和原始二叉树的序列化结果是否一致，说明你的方法就对了。你事先把结果保存了，比如你在序列化的时候如果保存了 root 为类的成员，然后在反序列化中直接返回存储的 root，这样题目就没有意义了，防止你使用作弊方式来通过测试，\nDFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：先序遍历、中序遍历、后序遍历\n示例: \n12345678910111213141516171819202122你可以将以下二叉树：    1   / \\  2   3     / \\    4   5        1      /   \\     2      3    / \\   /  \\   X   X  4   5        / \\  / \\       X   X X  X       序列化为 \"[1,2,None,None,3,4,None,None,5,None,None]\"None,None, 是用来标记缺少左、右子节点遇到 None 节点也要翻译成一个符号，反序列化时才知道这里对应 None。为使反序列化可行，考虑将越过叶节点后的 null 也看作是节点。在此基础上，对于列表中任意某节点 node ，其左子节点 node.left 和右子节点 node.right 在序列中的位置都是 唯一确定 你可以将以下二叉树：    1   / \\  2   3     / \\    4   5        1      /   \\     2      3    / \\   /  \\   X   X  4   5        / \\  / \\       X   X X  X       序列化为 \"[1,2,None,None,3,4,None,None,5,None,None]\"None,None, 是用来标记缺少左、右子节点遇到 None 节点也要翻译成一个符号，反序列化时才知道这里对应 None。为使反序列化可行，考虑将越过叶节点后的 null 也看作是节点。在此基础上，对于列表中任意某节点 node ，其左子节点 node.left 和右子节点 node.right 在序列中的位置都是 唯一确定 的。\n\n\n递归遍历一棵树，只需关注当前的根节点就好，它的子树的遍历交给递归完成：\n\n“serialize函数，请帮我序列化我的左右子树，我等你的返回结果，再追加到我身上。”\n\n\n选择前序遍历是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。\n\n\n何反序列化呢？前序遍历的序列化后的字符串呈现这样的排列：“根|(根|(根|左|右)|(根|左|右))|(根|(根|左|右)|(根|左|右))”序列化得到的字符串序列，通过指定分隔符逗号，对字符串进行切片，返回分割后的字符串列表，转化为数组，先序遍历的元素列表然后从左向右遍历dataList列表，依次弹出 dataList 数组的首项，用它构建当前子树的根节点，\n\n如果当前的元素(字符)为 ‘X’ ，返回 None，\n如果它不为 ‘X’，则为它创建节点，并递归调用 buildTree 构建左右子树，当前子树构建完毕，返回当前子树 \n\n时间复杂度O(n)：在序列化和反序列化函数中，我们只访问每个节点一次，其中 n 是节点数，即树的大小。空间复杂度O(n)：在序列化和反序列化函数中，我们递归会使用栈空间\n123456789101112131415161718192021222324252627282930313233class Codec:    def serialize(self, root): # 要求转化成字符串格式        def dfs(root):            if not root:                # 遇到None节点，“翻译”成X                                return 'null,'  # 字符串类型            # if root:            # 左子树的序列化的字符串            left = dfs(root.left)            # 右子树的序列化的字符串            right = dfs(root.right)            # 按 根|左|右 顺序拼接            return str(root.val) + ',' + left + right        return dfs(root)            def deserialize(self, data):        # 由前序遍历的list，由序列化字符串转成，返回这棵树        def dfs(data):            # 输入为序列化字符串转成的 list 数组            val = data.pop(0)            if val == 'null':                # 是X，就返回None节点                return None            # 不是X，则创建节点            node = TreeNode(val)  # 实例化一个节点            node.left = dfs(data)  # 构建左子树            node.right = dfs(data)  # 构建右子树            return node  # 返回当前构建好的子树        dataList = data.split(',')        return dfs(dataList)  class Codec:    def serialize(self, root): # 要求转化成字符串格式        def dfs(root):            if not root:                # 遇到None节点，“翻译”成X                                return 'null,'  # 字符串类型            # if root:            # 左子树的序列化的字符串            left = dfs(root.left)            # 右子树的序列化的字符串            right = dfs(root.right)            # 按 根|左|右 顺序拼接            return str(root.val) + ',' + left + right        return dfs(root)            def deserialize(self, data):        # 由前序遍历的list，由序列化字符串转成，返回这棵树        def dfs(data):            # 输入为序列化字符串转成的 list 数组            val = data.pop(0)            if val == 'null':                # 是X，就返回None节点                return None            # 不是X，则创建节点            node = TreeNode(val)  # 实例化一个节点            node.left = dfs(data)  # 构建左子树            node.right = dfs(data)  # 构建右子树            return node  # 返回当前构建好的子树        dataList = data.split(',')        return dfs(dataList)  # 构建的入口\n虽然序列化的时候结尾会多出一个逗号，然后反序列化split列表会处理这个逗号，然后正确地建树。最后会多出一个空字符串，但是并没有影响，反序列化的时候就是序列化方式并不唯一，是自己制定的，只要你能按照你序列化的规则再反序列化把树正确地建出来就行。\n序列化\n123456789101112131415161718192021222324252627282930313233343536root = 1root = root.left = 2left = dfs(2)root = root.left = Nonereturn 'X'root = root.right = Nonereturn 'X'回到上一层root = 1root = root.right = 3right = dfs(3)root = root.left = 4left = dfs(4)root = root.left = Nonereturn 'X'root = root.right = Nonereturn 'X'回到上一层root = 3root = root.right = 5right = dfs(5)root = root.left = Nonereturn 'X'root = root.right = Nonereturn root = 1root = root.left = 2left = dfs(2)root = root.left = Nonereturn 'X'root = root.right = Nonereturn 'X'回到上一层root = 1root = root.right = 3right = dfs(3)root = root.left = 4left = dfs(4)root = root.left = Nonereturn 'X'root = root.right = Nonereturn 'X'回到上一层root = 3root = root.right = 5right = dfs(5)root = root.left = Nonereturn 'X'root = root.right = Nonereturn 'X'\n\n\n12345678910111213141516171819202122from collections import dequeclass Codec:    def serialize(self, root):        if root == None:             return 'X,'        leftserilized = self.serialize(root.left)        rightserilized = self.serialize(root.right)        return str(root.val) + ',' + leftserilized + rightserilized    def deserialize(self, data):        dataList = data.split(',')        root = self.buildTree(dataList)        return root     def buildTree(self,data):        val = data.pop(0)        if val == 'X':             return None        node = TreeNode(val)        node.left = self.buildTree(data)        node.right = self.buildTree(data)        from collections import dequeclass Codec:    def serialize(self, root):        if root == None:             return 'X,'        leftserilized = self.serialize(root.left)        rightserilized = self.serialize(root.right)        return str(root.val) + ',' + leftserilized + rightserilized    def deserialize(self, data):        dataList = data.split(',')        root = self.buildTree(dataList)        return root     def buildTree(self,data):        val = data.pop(0)        if val == 'X':             return None        node = TreeNode(val)        node.left = self.buildTree(data)        node.right = self.buildTree(data)        return node\n\n法三，最快，击败99%\n1234567891011121314151617181920212223242526from collections import dequeclass Codec:    def serialize(self, root):        def dfs(node):            if node:                vals.append(str(node.val))                dfs(node.left)                dfs(node.right)            else:                vals.append(\"#\")        vals = []        dfs(root)        return \",\".join(vals)    def deserialize(self, data):        def dfs():            v = next(vals)            if v == \"#\":                return None            node = TreeNode(int(v))            node.left = dfs()            node.right = dfs()            return node        vals = iter(data.split(\",\"))        from collections import dequeclass Codec:    def serialize(self, root):        def dfs(node):            if node:                vals.append(str(node.val))                dfs(node.left)                dfs(node.right)            else:                vals.append(\"#\")        vals = []        dfs(root)        return \",\".join(vals)    def deserialize(self, data):        def dfs():            v = next(vals)            if v == \"#\":                return None            node = TreeNode(int(v))            node.left = dfs()            node.right = dfs()            return node        vals = iter(data.split(\",\"))        return dfs()\n\nBFS 可以按照层次的顺序从上到下遍历所有的节点 利用队列示例: \n1234567891011121314151617你可以将以下二叉树：    1   / \\  2   3     / \\    4   5        1      /   \\     2      3    / \\   /  \\   X   X  4   5        / \\  / \\       X   X X  X       序列化为字符串 你可以将以下二叉树：    1   / \\  2   3     / \\    4   5        1      /   \\     2      3    / \\   /  \\   X   X  4   5        / \\  / \\       X   X X  X       序列化为字符串 \"[1,2,3,X,X,4,5,X,X,X,X]\"X,X, 是用来标记缺少左、右子节点遇到越过叶节点的 None 节点也要翻译成一个符号，反序列化时才知道这里对应 None。\n\n序列化算法流程：\n\n特例处理： 若 root 为空，则直接返回空列表 “[]” ；\n初始化： 队列 queue （包含根节点 root ）；序列化列表 res ；\n层序遍历： 当 queue 为空时跳出；\n节点出队，记为 node ；\n若 node 不为空：\n将它的值推入一个数组 res ，打印字符串 node.val 让子节点 None 也入列，，\n将左、右子节点入列 queue ；\n\n\n否则（若 node 为空）：将 ‘null’ 推入 res 数组，打印字符串 “null” ；\n\n\n返回值： 拼接列表（用 ‘,’ 隔开，首尾添加中括号）。将它转成字符串，就是序列化字符串。\n\n时间复杂度 O(N) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N + 1 个 null ，总体复杂度为 O(2N + 1) = O(N) 。空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储 (N + 1)/2 个节点（或 N+1 个 null），使用 O(N) ；列表 res 使用 O(N) 。\n反序列化除了第一个是根节点的值，其他节点值都是成对的，对应左右子节点。我们用一个指针从第二项开始扫描，每次考察两个节点值。\n起初用根节点值构建根节点，并让它入列。让节点出列，考察出列的节点，指针指向的字符是它的左子节点，指针右边的字符是它的右子节点。如果子节点值不为 ‘X’，则为它创建节点，并认父亲，并作为未来的父亲入列。如果子节点值为 ‘X’，什么都不用做。所有的父节点（真实节点）都会在队列里走一遍。\n基于本文一开始分析的 “ node, node.left, node.right ” 在序列化列表中的位置关系，可实现反序列化。\n利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。\n算法流程：\n\n特例处理： 若 data 为空，直接返回 null ；\n初始化： 序列化列表 vals （先去掉首尾中括号，再用逗号隔开），指针 i = 1 ，根节点 root （值为 vals[0] ），队列 queue（包含 root ）；\n按层构建： 当 queue 为空时跳出；\n节点出队，记为 node ；\n构建 node 的左子节点：node.left 的值为 vals[i] ，并将 node.left 入队；\n执行 i+=1 ；\n构建 node 的右子节点：node.right 的值为 vals[i] ，并将 node.right 入队；\n执行 i+=1 ；\n\n\n返回值： 返回根节点 root 即可。\n\n时间复杂度 O(N) ： N 为二叉树的节点数，按层构建二叉树需要遍历整个 vals ，其长度最大为 2N+1 。空间复杂度 O(N) ： 最差情况下，假如是一颗满二叉树，最后一排空节点个数为2N+1/2，队列 queue 同时存储 (N + 1)/2 个节点，因此使用 O(N) 额外空间。\n如果想在去掉多余的null上实现可逆，可以尝试在序列化的最后加一个while loop去掉 null，然后反序列化的时候把输入的‘data’作为queue 来做后续操作（可以节省因为子节点过多而多花费的判断null的时间）\n序列化\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051queue = [1]res = []queue = []node = 1res = [1]queue = [2, 3]queue = [3]node = 2 res = [1, 2]queue = [3, None, None]queue = [None, None]node = 3 res = [1, 2, 3]queue = [None, None, 4, 5]queue = [None, 4, 5]node = Noneres = [1, 2, 3, None] queue = [4, 5]node = Noneres = [1, 2, 3, None, None] queue = [5]node = 4res = [1, 2, 3, null, null, 4] queue = [5, None, None]queue = [None, None]node = 5res = [1, 2, 3, null, null, 4, 5] queue = [None, None, None, None]queue = [None, None, None]node = Noneres = [1, 2, 3, null, null, 4, 5, null] queue = [None, None]node = Noneres = [1, 2, 3, null, null, 4, 5, null, null] queue = [None]node = Noneres = [1, 2, 3, null, null, 4, 5, null, null, null] queue = []node = Noneres = [1, 2, 3, null, null, 4, 5, null, null, null, queue = [1]res = []queue = []node = 1res = [1]queue = [2, 3]queue = [3]node = 2 res = [1, 2]queue = [3, None, None]queue = [None, None]node = 3 res = [1, 2, 3]queue = [None, None, 4, 5]queue = [None, 4, 5]node = Noneres = [1, 2, 3, None] queue = [4, 5]node = Noneres = [1, 2, 3, None, None] queue = [5]node = 4res = [1, 2, 3, null, null, 4] queue = [5, None, None]queue = [None, None]node = 5res = [1, 2, 3, null, null, 4, 5] queue = [None, None, None, None]queue = [None, None, None]node = Noneres = [1, 2, 3, null, null, 4, 5, null] queue = [None, None]node = Noneres = [1, 2, 3, null, null, 4, 5, null, null] queue = [None]node = Noneres = [1, 2, 3, null, null, 4, 5, null, null, null] queue = []node = Noneres = [1, 2, 3, null, null, 4, 5, null, null, null, null] \n\n12345678910111213141516171819202122232425262728293031323334353637383940414243class Codec:    def serialize(self, root):        if not root: return \"[]\"        queue = collections.deque()        queue.append(root)        res = []        while queue:            node = queue.popleft()            if node:                res.append(str(node.val))                queue.append(node.left)                queue.append(node.right)            else:                 res.append(\"null\")        return '[' + ','.join(res) + ']'        # res.append(node.val + \",\");         # 可以优化成 res.append(node.val).append(\",\")。因为拼接字符串可能增大消耗。        # +号就是把字符串拼接起来的意思，因为中括号是字符串类型，所以要加一个' ',         # 就和你输出'hello world'一样，输出结果其实并没有' '，你跑一下结果就知道了，就是[1,2,3,null,null,4,5]，那个题目里的引号只是告诉你结果是引号里的东西(是字符串类型，而不是数组类型)，结果就是那串字符 [1,2,3,null,null,4,5] 并不是结果要带引号    def deserialize(self, data):        if data=='[]':            return None        # 去除第一个和最后一个字符串，也就是去掉两个单括号        vals, i = data[1:-1].split(','), 1        # TreeNode 的 val 变量是 int 类型        root = TreeNode(int(vals[0]))  # 实例化一个节点        queue = collections.deque()        queue.append(root)        while queue:            node = queue.popleft()            if vals[i] != \"null\":                # 构建左子树                node.left = TreeNode(int(vals[i]))                queue.append(node.left)            i += 1            if vals[i] != \"null\":                # 构建右子树                node.right = TreeNode(int(vals[i]))                queue.append(node.right)            i += 1        class Codec:    def serialize(self, root):        if not root: return \"[]\"        queue = collections.deque()        queue.append(root)        res = []        while queue:            node = queue.popleft()            if node:                res.append(str(node.val))                queue.append(node.left)                queue.append(node.right)            else:                 res.append(\"null\")        return '[' + ','.join(res) + ']'        # res.append(node.val + \",\");         # 可以优化成 res.append(node.val).append(\",\")。因为拼接字符串可能增大消耗。        # +号就是把字符串拼接起来的意思，因为中括号是字符串类型，所以要加一个' ',         # 就和你输出'hello world'一样，输出结果其实并没有' '，你跑一下结果就知道了，就是[1,2,3,null,null,4,5]，那个题目里的引号只是告诉你结果是引号里的东西(是字符串类型，而不是数组类型)，结果就是那串字符 [1,2,3,null,null,4,5] 并不是结果要带引号    def deserialize(self, data):        if data=='[]':            return None        # 去除第一个和最后一个字符串，也就是去掉两个单括号        vals, i = data[1:-1].split(','), 1        # TreeNode 的 val 变量是 int 类型        root = TreeNode(int(vals[0]))  # 实例化一个节点        queue = collections.deque()        queue.append(root)        while queue:            node = queue.popleft()            if vals[i] != \"null\":                # 构建左子树                node.left = TreeNode(int(vals[i]))                queue.append(node.left)            i += 1            if vals[i] != \"null\":                # 构建右子树                node.right = TreeNode(int(vals[i]))                queue.append(node.right)            i += 1        return root\n\n反序列化\n123456789101112131415161718192021222324data = '[1, 2, 3, null, null, 4, 5, null, null, null, null]' print(data, type(data))# [1, 2, 3, null, null, 4, 5, null, null, null, null] &lt;class 'str'&gt;print(data[1:-1], type(data[1:-1]))# 1, 2, 3, null, null, 4, 5, null, null, null, null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))# ['1', ' 2', ' 3', ' null', ' null', ' 4', ' 5', ' null', ' null', ' null', ' null'] &lt;class 'list'&gt;data = '[1,2,3,null,null,4,5,null,null,null,null]' print(data, type(data))# [1,2,3,null,null,4,5,null,null,null,null] &lt;class 'str'&gt; print(data[1:-1], type(data[1:-1]))# 1,2,3,null,null,4,5,null,null,null,null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))# ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null'] &lt;class 'list'&gt;a = ['1', ' 2', ' 3']b = ['1', '2', '3']print(type(a[2]), type(b[2]))# &lt;class 'str'&gt; &lt;class 'str'&gt;print(a[2], b[2], a[2] == b[2])# 3 3 Falseprint(a[0], b[0], a[0] == b[0])data = '[1, 2, 3, null, null, 4, 5, null, null, null, null]' print(data, type(data))# [1, 2, 3, null, null, 4, 5, null, null, null, null] &lt;class 'str'&gt;print(data[1:-1], type(data[1:-1]))# 1, 2, 3, null, null, 4, 5, null, null, null, null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))# ['1', ' 2', ' 3', ' null', ' null', ' 4', ' 5', ' null', ' null', ' null', ' null'] &lt;class 'list'&gt;data = '[1,2,3,null,null,4,5,null,null,null,null]' print(data, type(data))# [1,2,3,null,null,4,5,null,null,null,null] &lt;class 'str'&gt; print(data[1:-1], type(data[1:-1]))# 1,2,3,null,null,4,5,null,null,null,null &lt;class 'str'&gt;print(data[1:-1].split(','), type(data[1:-1].split(',')))# ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null'] &lt;class 'list'&gt;a = ['1', ' 2', ' 3']b = ['1', '2', '3']print(type(a[2]), type(b[2]))# &lt;class 'str'&gt; &lt;class 'str'&gt;print(a[2], b[2], a[2] == b[2])# 3 3 Falseprint(a[0], b[0], a[0] == b[0])# 1 1 True\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vals = ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null']type(vals) = &lt;class 'list'&gt;root = = TreeNode(int(vals[0])) = 1queue = [1]queue = []node = 1vals[i] 都是 str 类型 i初始值为1vals[i] = vals[1] = '2'node.left = 2 queue = [2]i = 2vals[i] = vals[2] = '3'node.right = 3queue = [2, 3]i = 3queue = [3]node = 2vals[i] = vals[3] = 'null'i = 4vals[i] = vals[4] = 'null'i = 5queue = []node = 3vals[i] = vals[5] = '4'node.left = 4queue = [4]i = 6vals[i] = vals[6] = '5'node.right = 5queue = [4，5]i = 7queue = [5]node = 4vals[i] = vals[7] = 'null'i = 8vals[i] = vals[4] = 'null'i = 9queue = []node = 5vals[i] = vals[9] = 'null'i = 10vals[i] = vals[4] = vals = ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null']type(vals) = &lt;class 'list'&gt;root = = TreeNode(int(vals[0])) = 1queue = [1]queue = []node = 1vals[i] 都是 str 类型 i初始值为1vals[i] = vals[1] = '2'node.left = 2 queue = [2]i = 2vals[i] = vals[2] = '3'node.right = 3queue = [2, 3]i = 3queue = [3]node = 2vals[i] = vals[3] = 'null'i = 4vals[i] = vals[4] = 'null'i = 5queue = []node = 3vals[i] = vals[5] = '4'node.left = 4queue = [4]i = 6vals[i] = vals[6] = '5'node.right = 5queue = [4，5]i = 7queue = [5]node = 4vals[i] = vals[7] = 'null'i = 8vals[i] = vals[4] = 'null'i = 9queue = []node = 5vals[i] = vals[9] = 'null'i = 10vals[i] = vals[4] = 'null'i = 11queue = [] queue为空，结束循环空子树不用赋值\n\n\n法二\n1234567891011121314151617181920212223242526272829303132333435class Codec:    def serialize(self, root):        if not root: return []        queue = collections.deque()        queue.append(root)        res = ''        while queue:            node = queue.popleft()            if node:                res += str(node.val) + ','                queue.append(node.left)  # 不管是不是None节点都入列                queue.append(node.right)            else:  # 是None节点                res += 'X,'        return res    def deserialize(self, data):        if not data: return None        data = data.split(',')        root = TreeNode(data.pop(0))        queue = collections.deque()        queue.append(root)        while queue:            node = queue.popleft()            if data:                val = data.pop(0)                if val != 'X':                    node.left = TreeNode(val)                    queue.append(node.left)            if data:                val = data.pop(0)                if val != 'X':                    node.right = TreeNode(val)                    queue.append(node.right)        class Codec:    def serialize(self, root):        if not root: return []        queue = collections.deque()        queue.append(root)        res = ''        while queue:            node = queue.popleft()            if node:                res += str(node.val) + ','                queue.append(node.left)  # 不管是不是None节点都入列                queue.append(node.right)            else:  # 是None节点                res += 'X,'        return res    def deserialize(self, data):        if not data: return None        data = data.split(',')        root = TreeNode(data.pop(0))        queue = collections.deque()        queue.append(root)        while queue:            node = queue.popleft()            if data:                val = data.pop(0)                if val != 'X':                    node.left = TreeNode(val)                    queue.append(node.left)            if data:                val = data.pop(0)                if val != 'X':                    node.right = TreeNode(val)                    queue.append(node.right)        return root\n\n\n反序列化\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455data = [1,2,3,None,None,4,5,None,None,None,None]data = [2,3,None,None,4,5,None,None,None,None]root = 1queue = [1]queue = []node = 1data = [3,None,None,4,5,None,None,None,None]val = 2queue = [2]data = [None,None,4,5,None,None,None,None]val = 3queue = [2, 3]queue = [3]node = 2data = [None,4,5,None,None,None,None]val = Nonequeue = [3]data = [4,5,None,None,None,None]val = Nonequeue = [3]queue = []node = 3data = [5,None,None,None,None]val = 4queue = [4]data = [None,None,None,None]val = 5queue = [4, 5]queue = [5]node = 4data = [None,None,None]val = Nonequeue = [5]data = [None,None]val = Nonequeue = [5]queue = []node = 5data = [None]val = Nonequeue = []data = []val = Nonequeue = [] queue为空，结束循环\n\n\n344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1：\n12输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]输出：[\"o\",\"l\",\"l\",\"e\",输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n示例 2：\n12输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]输出：[\"h\",\"a\",\"n\",\"n\",\"a\",输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n（1）使用 list 本身的reverse() 方法\n1234567891011&gt;&gt;&gt; s = [\"h\",\"e\",\"l\",\"l\",\"o\"]&gt;&gt;&gt; reversed(s)        # Python内置reverse()函数可以反转一个可迭代序列&lt;list_reverseiterator object at 0x0000014C63AF5CF8&gt;&gt;&gt;&gt; list(reversed(s))  # 强转成list['o', 'l', 'l', 'e', 'h']&gt;&gt;&gt; s                  # s本身并没有修改['h', 'e', 'l', 'l', 'o'] &gt;&gt;&gt; s.reverse()        # 使用list本身的reverse方法&gt;&gt;&gt; s                  # s被改为倒序[\"o\",\"l\",\"l\",\"e\",&gt;&gt;&gt; s = [\"h\",\"e\",\"l\",\"l\",\"o\"]&gt;&gt;&gt; reversed(s)        # Python内置reverse()函数可以反转一个可迭代序列&lt;list_reverseiterator object at 0x0000014C63AF5CF8&gt;&gt;&gt;&gt; list(reversed(s))  # 强转成list['o', 'l', 'l', 'e', 'h']&gt;&gt;&gt; s                  # s本身并没有修改['h', 'e', 'l', 'l', 'o'] &gt;&gt;&gt; s.reverse()        # 使用list本身的reverse方法&gt;&gt;&gt; s                  # s被改为倒序[\"o\",\"l\",\"l\",\"e\",\"h\"]    \n\n（2）\n12345678910```s[:]```浅拷贝 表示数组中所有子模块，```s[:]=s[::-1]```表示将原数组反转后赋值给s中每一个对应的位置```s=s[::-1]```表示将s反转后赋值给新的对象s（可以通过id函数查看内存地址），与题意原地修改不符。```pyclass Solution:    def reverseString(self, s: List[str]) -> None:        \"\"\"        Do not return anything, modify s in-place instead.        \"\"\"        s[:]=s[::-1]\n\n（3）双指针思路与算法对于长度为 N 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 s[0] s[1] s[2] … s[N - 1]，那么反转后字符数组为 s[N - 1] s[N - 2] … s[0]。比较反转前后下标变化很容易得出 s[i] 的字符与 s[N - 1 - i] 的字符发生了交换的规律\n\n初始化：left 指向数组第一个元素，right 指向数组最后一个元素，\n步骤：\n当 left &lt; right：\n把 left 和 right 指向的元素交换一下，交换s[left]和s[right]对应元素，\nleft 指针后移，right 指针前移，left+=1,right-=1，\n再把它两个交换，以此类推，\n\n\n当 left &gt;= right直到 left 和 right 相遇指向同一个元素，这样就得到了一个倒序的序列。\n\n\n时间复杂度：O(N)，其中 N 为字符数组的长度。一共执行了 N/2 次的交换。\n空间复杂度：O(1)。只使用了常数空间来存放若干变量。\n\n1234567891011class Solution:    def reverseString(self, s: List[str]) -&gt; None:        \"\"\"        Do not return anything, modify s in-place instead.        \"\"\"        i = 0        right = len(s) - 1        while left &lt; right:               s[left], s[right] = s[right], s[left]            left += 1            right -= class Solution:    def reverseString(self, s: List[str]) -&gt; None:        \"\"\"        Do not return anything, modify s in-place instead.        \"\"\"        i = 0        right = len(s) - 1        while left &lt; right:               s[left], s[right] = s[right], s[left]            left += 1            right -= 1\n\n\n9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n12输入: 121输出: 输入: 121输出: true\n\n示例 2:\n123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3:\n123输入: 10输出: false解释: 从右向左读, 为 01 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。\n法一：将整数转为字符串，需要额外的非常量空间来创建问题描述中所不允许的字符串。思路：首先，我们应该处理一些临界情况。负数都不可能是回文，直接返回False，如：’-1 ‘ 的回文是 ‘1-‘只需要，因为 - 不等于 1。所以我们可以对所有负数返回 false。\n考虑大于等于 0 的时候，首先把数字转换成一个字符串，这样就非常方便判断。\n定义两个指针一个指向第一个元素的首指针和一个指向末尾的尾指针，然后首指针后移，尾指针前移作对比，如果中间有不相等的就返回False，如果没有直到首尾指针相遇说明是一个回文数。\n123456789101112131415161718192021222324252627class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt;0:            return False  # 负数肯定不是回文数        s = str(x)        # 把x转换成str        beg, end = 0, len(s)-1        while beg &lt; end:          # s是个位数的时候,end = 0不会执行到 while里            if s[beg] == s[end]:                beg += 1                end -= 1            else:                return False        return True def test():    s = Solution()    print(s.isPalindrome(121) is True)    print(s.isPalindrome(-1) is True)    print(s.isPalindrome(1) is True) test()``` ```pyclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        return (str(x) == str(x)[::class Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt;0:            return False  # 负数肯定不是回文数        s = str(x)        # 把x转换成str        beg, end = 0, len(s)-1        while beg &lt; end:          # s是个位数的时候,end = 0不会执行到 while里            if s[beg] == s[end]:                beg += 1                end -= 1            else:                return False        return True def test():    s = Solution()    print(s.isPalindrome(121) is True)    print(s.isPalindrome(-1) is True)    print(s.isPalindrome(1) is True) test()``` ```pyclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        return (str(x) == str(x)[::-1])\n123class Solution:    def isPalindrome(self, x: int) -&gt; bool:        return (x &gt;= 0) and (x == int(str(x)[::class Solution:    def isPalindrome(self, x: int) -&gt; bool:        return (x &gt;= 0) and (x == int(str(x)[::-1]))\n\n\n考虑只反转 int 数字的一半\n1234567891011class Solution:    def isPalindrome(self, x: int) -&gt; bool:        s = str(x)        l = len(s)        h = l//2        return s[:h] == str(x)[-1:-h-1:-1]# s = '12321'# l = 5# h = 2# s[:h] = s[:2] = '12'class Solution:    def isPalindrome(self, x: int) -&gt; bool:        s = str(x)        l = len(s)        h = l//2        return s[:h] == str(x)[-1:-h-1:-1]# s = '12321'# l = 5# h = 2# s[:h] = s[:2] = '12'# str(x)[-1:-h-1:-1] = str(x)[-1:-3:-1] = '12' \n\n法二：不将整数转为字符串，将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。如果真是回文，是不可能溢出的；若非回文，溢出就会成为负数，自然也就跟原数不相等了\n按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的后一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。\n回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。\n例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。\n除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。\n步骤\n\n每次进行取余操作 （ %10），取出最低的数字：y = x % 10\n将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y\n每取一个最低位数字，x 都要自除以 10\n判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了\n最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将revertNum除以 10 以后应该和 x 相等。\n\n对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。\n现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？\n由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。\n时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 特殊情况：        # 如上所述，当 x &lt; 0 时，x 不是回文数。        # 同样地，如果数字的最后一位是 0，为了使该数字为回文，        # 则其第一位数字也应该是 0        # 只有 0 满足这一属性        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False        revertedNumber = 0        while x &gt; revertedNumber:            revertedNumber = revertedNumber * 10 + x % 10            x //= 10        # 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。        # 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber or x == revertedNumber // 10if __name__ == '__main__':    obj = Solution()    # print(obj.isPalindrome(12321))  # True    # print(obj.isPalindrome(123321))  # True    # print(obj.isPalindrome(-1))  # False    # print(obj.isPalindrome(0))  # True    # print(obj.isPalindrome(6))  # True    print(obj.isPalindrome(10))  # False# x = 12321 &gt; 0 数字长度为奇数# revertedNumber = 0 &lt; x # revertedNumber = revertedNumber * 10 + x % 10# revertedNumber = 0 * 10 + 12321 % 10 = 1 # x = x // 10 = 1232 &gt; revertedNumber# revertedNumber = 1 * 10 + 1232 % 10 = 12# x = x // 10 = 123 &gt; revertedNumber# revertedNumber = 12 * 10 + 123 % 10 = 123# x = x // 10 = 12 &lt; revertedNumber# x = 12 = revertedNumber // 10 = 123 // 10# return True# x = 123321 &gt; 0 数字长度为偶数# revertedNumber = 0 &lt; x # revertedNumber = revertedNumber * 10 + x % 10# revertedNumber = 0 * 10 + 123321 % 10 = 1 # x = x // 10 = 12332 &gt; revertedNumber# revertedNumber = 1 * 10 + 12332 % 10 = 12# x = x // 10 = 1233 &gt; revertedNumber# revertedNumber = 12 * 10 + 1233 % 10 = 123# x = x // 10 = 123 = revertedNumberclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 特殊情况：        # 如上所述，当 x &lt; 0 时，x 不是回文数。        # 同样地，如果数字的最后一位是 0，为了使该数字为回文，        # 则其第一位数字也应该是 0        # 只有 0 满足这一属性        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False        revertedNumber = 0        while x &gt; revertedNumber:            revertedNumber = revertedNumber * 10 + x % 10            x //= 10        # 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。        # 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，        # 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber or x == revertedNumber // 10if __name__ == '__main__':    obj = Solution()    # print(obj.isPalindrome(12321))  # True    # print(obj.isPalindrome(123321))  # True    # print(obj.isPalindrome(-1))  # False    # print(obj.isPalindrome(0))  # True    # print(obj.isPalindrome(6))  # True    print(obj.isPalindrome(10))  # False# x = 12321 &gt; 0 数字长度为奇数# revertedNumber = 0 &lt; x # revertedNumber = revertedNumber * 10 + x % 10# revertedNumber = 0 * 10 + 12321 % 10 = 1 # x = x // 10 = 1232 &gt; revertedNumber# revertedNumber = 1 * 10 + 1232 % 10 = 12# x = x // 10 = 123 &gt; revertedNumber# revertedNumber = 12 * 10 + 123 % 10 = 123# x = x // 10 = 12 &lt; revertedNumber# x = 12 = revertedNumber // 10 = 123 // 10# return True# x = 123321 &gt; 0 数字长度为偶数# revertedNumber = 0 &lt; x # revertedNumber = revertedNumber * 10 + x % 10# revertedNumber = 0 * 10 + 123321 % 10 = 1 # x = x // 10 = 12332 &gt; revertedNumber# revertedNumber = 1 * 10 + 12332 % 10 = 12# x = x // 10 = 1233 &gt; revertedNumber# revertedNumber = 12 * 10 + 1233 % 10 = 123# x = x // 10 = 123 = revertedNumber# return True\n\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]},{"title":"剑指offer1~24题","url":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/","content":"提供熟练度，一个题目默写5遍\n任何逻辑都先写特殊情况，然后再一般程序=算法+数据结构。系统=服务+存储。\n单独的return要怎么理解呢，无返回值 void 类型函数， 需要 return 提前终止~ 由于是无返回值函数，因此无需返回任何变量~\n12print(not [])  # 返回一个布尔值print([] == None)  print(not [])  # 返回一个布尔值print([] == None)  # False\n力扣后台已经帮你定义好 TreeNode 这个类啦，就是默认代码那个被注释掉的部分，在本地你需要把那个树节点的类写上每个节点是 O(1)，总节点数是 O(n) \nListNode这个是类，ListNode(i)实际上是类的实例化，它创建了一个对象，调用了initialization这个初始化函数int(i)倒是直接将i的类型进行改变。\nroot 是 节点，是一个类的实例；root.val 是此节点的值；[root] 是向当前列表添加一个子列表，子列表包含 root 节点\n动态规划与分治的区别：前者自底向上，后者自顶向下\nlog n 一般和二叉树的高度相关，例如：二叉搜索树的平均查找时间复杂度为 O(log n) 。而树的遍历，一般都是 O(N) 复杂度，例如先序遍历，每开启一个递归函数 遍历到一个节点，而树节点为 N ， 因此复杂度为 O(N)\n123# ListNode(0) 建立一个值为 0 ListNode 类型的变量的节点实例，开辟结点的内存空间，# 变量 node 引用指向 “节点实例”地址 node = ListNode(# ListNode(0) 建立一个值为 0 ListNode 类型的变量的节点实例，开辟结点的内存空间，# 变量 node 引用指向 “节点实例”地址 node = ListNode(0)\n\n判断时间复杂度判断占用时间\n确定问题规模n\n循环减半过程 –&gt; logn\nK层关于n的循环 —&gt;nk复杂情况：根据算法执行过程判断\n\n判断空间复杂度评估算法内存占用大小的式子，表达方式与时间复杂度完全一样\n\n使用了几个变量：O(1)\n使用了长度为n的一维列表：O(n)\n使用了m行n列的二维列表：O(mn)\n\n算法（Algorithm）：是指解题方案的准确而完整的描述，是一系列解决问题的清明确指令步骤，算法代表着用系统的方法描述解决问题的策略机制。能够对一定规范的输入，在有限时间内获得所要求的输出。算法的实现是指将指令步骤序列转化成计算机能够执行的计算机程序。而这个转化过程就叫计算机编程。\n数据结构（Data Structures）：是计算机存储和组织数据的一种方式，可以用来高效地处理数据。举个例子：二分查找就是一个非常经典的算法，而二分查找经常需要作用在一个有序数组上。这里二分就是一种折半的算法思想，很多算法需要特定的数据结构来实现，所以经常把它们放到一块讲。\n抽象数据类型(Abstract Data Type)ADT指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。我们自定义的 ADT 必须要有一个实现，而实现 ADT 时我们所做出的选择会影响实现的功能和效率。数据结构可以通过以下两方面来描述：它们如何存储和组织单个数据元素提供哪些操作来存取和处理其上的数据\n有很多常用的数据结构，如链表、堆、栈，队列，树等。所有的数据结构都会存储一组数据值，但对于如何组织单个数据项和提供哪些操作来处理数据集上有区别。实现 ADT 时，需要根据具体问题来选择具体的数据结构。例如，实现打印队列最好选择 queue 数据结构，而 B-Tree 适合数据库索引。\n实际上，在真正的项目开发中，大部分时间都是从数据库取数据 -&gt; 数据操作和结构化 -&gt; 返回给前端，在数据操作过程中需要合理地抽象， 组织、处理数据，如果选用了错误的数据结构，就会造成代码运行低效。这也是我们需要学习算法和数据结构的原因。\n实现新的数据类型时，我们将使用 python 的 class 实现，它包含属性和方法。属性一般是使用某种特定的数据类型，而方法一般是对属性的操作。 \nADT: Abstract Data Type，抽象数据类型，我们在组合已有的数据结构来实现一种新的数据类型，定义的数据类型，它指定了一组数据值的集合及可作用在这些数据值上的一组操作。ADT 的定义与它的具体实现无关，因此我们可以只关注如何使用它，而无需关注它的具体实现。\nADT 可被看作为一个黑盒子。用户程序与 ADT 实例的交互是通过调用定义在 ADT 接口上的操作进行的。这些操作集可分为 4 类：\nConstructors: 创建和初始化 ADT 的实例Accessors: 返回实例中的数据，而不进行修改Mutators: 修改 ADT 实例的内容Iterators: 逐个处理单个数据组件\n我们以抽象一个背包(Bag) 数据类型来说明，背包是一种容器类型，我们可以给它添加东西，也可以移除东西，并且我们想知道背包里 有多少东西。于是我们可以定义一个新的数据类型叫做 Bag.\n队列 是有序数据集合**队列和栈一样，队列是一种操作受限制的线性表。进行删除操作的端称为队头，称为前端(front)，进行插入操作的端称为队尾，称为后端(rear)。\n数据项总是开始排在队伍的后端，慢慢向前走，直到排到最前面，轮到它的时候离开队列。刚进来的数据排在后端，待在队伍里时间最长的在前端，这种排列规则叫做FIFO(first-in first-out)，“先进先出”\n在实际编码中不会自己来实现一个队列，而是使用标准库中的queue，通过from queue import Queue来导入Queue类。\n**\n对列的添加       insert              append \n队列的取值      列表[-1]            列表[0]\n队列的删除       pop()                    pop(0)\npush(1);push(2);pop(3);push(4); # 尾部插入1234pop(1),pop(2), 头部删除34\n一个Node对象如下示意图：![]C:\\python代码\\牛客网剑指offer66题思路分析\\图解说明\\node对象.jpg\nQueue() 创建一个空队列，无参数，返回值是空队列如果是一个空的队列，那head和tail都指向None。\n当队列里有一个元素时，head和tail两个指针都指向这个元素，next指向None示意图是这样的：\nenqueue(item) 在队列尾部加入一个数据项，参数是数据项，无返回值当队列再增加一个元素时，而head指针不会发生改变，tail指针会移动到新增加的这个元素，前一个元素的next指针也会指向新元素，如下图：\n\nisEmpty() 检测队列是否为空。无参数，返回布尔值。size() 返回队列数据项的数量。无参数，返回一个整数。\n同栈一样，队列也可以用顺序表或者链表实现。我们假设队列里的元素有一个指针，最先加进元素的指针指向它下一个元素，依次类推，最后一个元素的指针是指向None。所以队列里的元素可以抽象出一个Queue类，会创建两个指针，一个head，指向队头的元素，一个tail，指向队尾的元素。同样像链表时的Node类一样有自己的数据和一个指向None的指针。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Node:    def __init__(self, value):        self.value = value        self.next = Noneclass Queue:    def __init__(self):        self.head = None        self.tail = None    def enqueue(self, value):        node = Node(value)  # 实列化节点        if self.head is None:            self.head = node            self.tail = node        else:            self.tail.next = node            self.tail = node    def dequeue(self):        if self.head is None:            raise Exception('This is a empty queue')        cur = self.head        self.head = cur.next        return cur.value    def is_empty(self):        return self.head is None    def size(self):        cur = self.head        count = 0        if cur is None:            return count        while cur.next is not None:            count += 1            cur = cur.next        return count + 1if __name__ == '__main__':    q = Queue()  # 实列化队列    for i in range(5):        q.enqueue(i)    for _ in range(5):        print(q.dequeue())    print(q.is_empty())    print(q.dequeue())        # 0        # 1        # 2        # 3        # 4    print(q.is_empty())  # True    print(q.size())  class Node:    def __init__(self, value):        self.value = value        self.next = Noneclass Queue:    def __init__(self):        self.head = None        self.tail = None    def enqueue(self, value):        node = Node(value)  # 实列化节点        if self.head is None:            self.head = node            self.tail = node        else:            self.tail.next = node            self.tail = node    def dequeue(self):        if self.head is None:            raise Exception('This is a empty queue')        cur = self.head        self.head = cur.next        return cur.value    def is_empty(self):        return self.head is None    def size(self):        cur = self.head        count = 0        if cur is None:            return count        while cur.next is not None:            count += 1            cur = cur.next        return count + 1if __name__ == '__main__':    q = Queue()  # 实列化队列    for i in range(5):        q.enqueue(i)    for _ in range(5):        print(q.dequeue())    print(q.is_empty())    print(q.dequeue())        # 0        # 1        # 2        # 3        # 4    print(q.is_empty())  # True    print(q.size())  # 0\n\n\n12345678910111213141516171819202122232425262728293031class Queue(object):# 使用列表[]实现队列。    def __init__(self):        self.items = []  # 初始化一个[]对象    def is_empty(self):        return self.items == []    def enqueue(self, item):        \"\"\"进队列\"\"\"        self.items.insert(0, item)    def dequeue(self):        \"\"\"出队列\"\"\"        return self.items.pop()    def size(self):        \"\"\"返回大小\"\"\"        return len(self.items)if __name__ == \"__main__\":    q = Queue()    q.enqueue(\"hello\")    q.enqueue(\"world\")    q.enqueue(\"itcast\")    print(q.size())    print(q.dequeue())  # hello    print(q.dequeue())  # world    print(q.dequeue())  class Queue(object):# 使用列表[]实现队列。    def __init__(self):        self.items = []  # 初始化一个[]对象    def is_empty(self):        return self.items == []    def enqueue(self, item):        \"\"\"进队列\"\"\"        self.items.insert(0, item)    def dequeue(self):        \"\"\"出队列\"\"\"        return self.items.pop()    def size(self):        \"\"\"返回大小\"\"\"        return len(self.items)if __name__ == \"__main__\":    q = Queue()    q.enqueue(\"hello\")    q.enqueue(\"world\")    q.enqueue(\"itcast\")    print(q.size())    print(q.dequeue())  # hello    print(q.dequeue())  # world    print(q.dequeue())  # itcast\n\n\nPython 中使用 collections 中的函数 deque() double-ended queue底层是链表，因此头部和尾部是等价的，其限定插入和删除操作在表的两端进行，都是 O(1) 时间复杂度；删除队列头部的数据项，不需要参数，返回值是被删除的数据，队列本身有变化，直接把head指针移动到下一个元素，再把值弹出即可。\n是一种具有队列和栈的性质的数据结构。\n1234567891011121314151617181920212223242526272829303132333435363738394041class Deque(object):    \"\"\"双端队列\"\"\"    def __init__(self):        self.items = []    def is_empty(self):        \"\"\"判断队列是否为空\"\"\"        return self.items == []    def add_front(self, item):        \"\"\"在队头添加元素\"\"\"        self.items.insert(0,item)    def add_rear(self, item):        \"\"\"在队尾添加元素\"\"\"        self.items.append(item)    def remove_front(self):        \"\"\"从队头删除元素\"\"\"        return self.items.pop(0)    def remove_rear(self):        \"\"\"从队尾删除元素\"\"\"        return self.items.pop()    def size(self):        \"\"\"返回队列大小\"\"\"        return len(self.items)if __name__ == \"__main__\":    deque = Deque()    deque.add_front(1)    deque.add_front(2)    deque.add_rear(3)    deque.add_rear(class Deque(object):    \"\"\"双端队列\"\"\"    def __init__(self):        self.items = []    def is_empty(self):        \"\"\"判断队列是否为空\"\"\"        return self.items == []    def add_front(self, item):        \"\"\"在队头添加元素\"\"\"        self.items.insert(0,item)    def add_rear(self, item):        \"\"\"在队尾添加元素\"\"\"        self.items.append(item)    def remove_front(self):        \"\"\"从队头删除元素\"\"\"        return self.items.pop(0)    def remove_rear(self):        \"\"\"从队尾删除元素\"\"\"        return self.items.pop()    def size(self):        \"\"\"返回队列大小\"\"\"        return len(self.items)if __name__ == \"__main__\":    deque = Deque()    deque.add_front(1)    deque.add_front(2)    deque.add_rear(3)    deque.add_rear(4)    print(deque.size())    print(deque.remove_front())    print(deque.remove_front())    print(deque.remove_rear())    print(deque.remove_rear())\n\n123456789101112131415161718192021222324252627282930# 使用collections模块deque()函数实现队列。from collections import deque class Queue:    def __init__(self):        self.items = deque()  # 初始化一个deque对象            def append(self, val):         return self.items.append(val)  # 向队列右边添加元素        def pop(self):          return self.items.popleft()    # 从队列左边取元素        def empty(self):                return len(self.items) == 0    # 判断是不是空队列 def test_queue():    q = Queue()    q.append(0)    q.append(1)    q.append(2)    print(q.pop())    print(q.pop())    print(q.pop()) test_queue()# 输出结果：#     0#     1# 使用collections模块deque()函数实现队列。from collections import deque class Queue:    def __init__(self):        self.items = deque()  # 初始化一个deque对象            def append(self, val):         return self.items.append(val)  # 向队列右边添加元素        def pop(self):          return self.items.popleft()    # 从队列左边取元素        def empty(self):                return len(self.items) == 0    # 判断是不是空队列 def test_queue():    q = Queue()    q.append(0)    q.append(1)    q.append(2)    print(q.pop())    print(q.pop())    print(q.pop()) test_queue()# 输出结果：#     0#     1#     2\n\n使用Python的 list实现队列的优缺点?           collections.deque() 双端队列可以很高效的向两边追加和删除元素，但是对于列表可以很方便向后面去追加元素，但如果想在第一个位置插入元素就需要移动后面所有的元素，因此在这里效率不如 collections.deque() 。deque对于list的性能优势，主要是在两端反复添加大量元素时差异才会比较明显，而对于构建一个全新的集合，list反而比deque还要快一些。\n用python的list数据类型能比较容易的实现队列数据模型，列表 就是 java c++ 中的数组，数组移除头部元素的方式 是把后面的元素全部往前移动一位，所以复杂度是 O(N) ；\n栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在栈的栈顶进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。用 append() 方法把新元素放到栈顶元素的上面，使之成为新的栈顶元素，称作是进栈，入栈或者压栈  \n从一个栈删除元素又称作出栈或退栈，用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放删除，使其相邻的元素成为新的栈顶元素。\n栈可以用顺序表实现，也可以用链表实现。列表方法使得列表可以很方便的作为一个堆栈来使用\n最先进入的元素最后一个被释放先进后出 后进先出\n栈的本质是递归。所以可以借助栈理解递归；栈顶是递归终止条件，栈的每一层是递归的方法体\n取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1.\n123456789stack1 = [3, 4, 5]stack1.append(6)stack1.append(7)print(stack1)  # [3, 4, 5, 6, 7]print(stack1.pop())  # 7print(stack1)  # [3, 4, 5, 6]print(stack1.pop())  # 6print(stack1.pop())  # 5print(stack1)  stack1 = [3, 4, 5]stack1.append(6)stack1.append(7)print(stack1)  # [3, 4, 5, 6, 7]print(stack1.pop())  # 7print(stack1)  # [3, 4, 5, 6]print(stack1.pop())  # 6print(stack1.pop())  # 5print(stack1)  # [3, 4]\n\n123456789101112131415161718192021222324252627282930313233# 使用列表[]实现栈class Stack:    def __init__(self):        self.stack = []    def is_empty(self):        \"\"\"判断是否为空\"\"\"        return self.stack == []    def push(self, element):        \"\"\"添加一个新的元素item到栈顶\"\"\"        self.stack.append(element)    def pop(self):        \"\"\"弹出栈顶元素\"\"\"        return self.stack.pop()    def peek(self):        return self.stack[-1] if self.stack else None    def size(self):        \"\"\"返回栈的元素个数\"\"\"        return len(self.stack)stack = Stack()stack.push(1)stack.push(2)stack.push(3)print(stack.pop())  # 3print(stack)  # &lt;__main__.Stack object at 0x0000024BAF626D60&gt;print(stack.peek())  # 2print(stack.size())  # 使用列表[]实现栈class Stack:    def __init__(self):        self.stack = []    def is_empty(self):        \"\"\"判断是否为空\"\"\"        return self.stack == []    def push(self, element):        \"\"\"添加一个新的元素item到栈顶\"\"\"        self.stack.append(element)    def pop(self):        \"\"\"弹出栈顶元素\"\"\"        return self.stack.pop()    def peek(self):        return self.stack[-1] if self.stack else None    def size(self):        \"\"\"返回栈的元素个数\"\"\"        return len(self.stack)stack = Stack()stack.push(1)stack.push(2)stack.push(3)print(stack.pop())  # 3print(stack)  # &lt;__main__.Stack object at 0x0000024BAF626D60&gt;print(stack.peek())  # 2print(stack.size())  # 2\n1234567891011121314151617181920212223242526# 使用collections模块deque()函数实现栈from collections import deque class Stack(object):    def __init__(self):        self.deque = deque()        def push(self, value):        self.deque.append(value)         def pop(self):        return self.deque.pop()  # 默认从右边取        def test_stack():    s = Stack()    s.push(0)    s.push(1)    s.push(2)    print(s.pop())    print(s.pop())    print(s.pop()) test_stack()#       2#       1# 使用collections模块deque()函数实现栈from collections import deque class Stack(object):    def __init__(self):        self.deque = deque()        def push(self, value):        self.deque.append(value)         def pop(self):        return self.deque.pop()  # 默认从右边取        def test_stack():    s = Stack()    s.push(0)    s.push(1)    s.push(2)    print(s.pop())    print(s.pop())    print(s.pop()) test_stack()#       2#       1#       0\n\n1. 两个栈实现一个队列：[^本题考点 队列 栈]用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )。队列中的元素为int类型。\n解题思路：\n栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。\n双栈可实现列表倒序： 设有含三个元素的栈 A = [1,2,3] 和空栈 B = []。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A = [] , B = [3,2,1] ，即 栈 B 元素实现栈 A 元素倒序 。\n利用栈 B 删除队首元素： 倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。\n\n函数设计：题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。\n\n加入队尾 appendTail()函数： 将数字 val 只需要向栈a加入。\n\n删除队首deleteHead()函数： B里面的肯定是先进到A的，所以即便添加删除轮着来，也是先删完B，才会把A的放入B。如果队列（即双栈）中有元素，那么一定是在 栈 B 中。因此要先判断栈 B 是否为空~有以下三种情况。\n\n当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。\n否则，当 A 也为空： 即两个栈都为空，无元素，因此返回 −1 。\n否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。\n\n\n\n复杂度分析：由于问题特殊，以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况。\n\n时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。 ；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 B 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。\n\n空间复杂度 O(N) ： 最差情况下，栈 A 和 B 共存储已有的 N 个元素。\n\n\n一个 [] 既可以当栈、也可以当队列，当然自己写一个栈类也是可以的~题目的本意应该是让我们使用 先进后出 实现 先进先出 ，而不是考察对某一集合框架的具体使用。无论用什么集合框架，都只能当作“栈”来看待，把 [] 看作栈来使用~\n12345678910111213141516171819202122232425262728class CQueue:    def __init__(self):        self.A, self.B = [], []    def appendTail(self, value: int) -&gt; None:        self.A.append(value)    def deleteHead(self) -&gt; int:        if self.B:            return self.B.pop()        if not self.A:            return -1        while self.A:            self.B.append(self.A.pop())        return self.B.pop()def test():  # 本地测试代码    q = CQueue()    q.appendTail(1)    q.appendTail(2)    q.appendTail(3)    print(q.deleteHead())  # 1    print(q.deleteHead())  # 2    print(q.deleteHead())  class CQueue:    def __init__(self):        self.A, self.B = [], []    def appendTail(self, value: int) -&gt; None:        self.A.append(value)    def deleteHead(self) -&gt; int:        if self.B:            return self.B.pop()        if not self.A:            return -1        while self.A:            self.B.append(self.A.pop())        return self.B.pop()def test():  # 本地测试代码    q = CQueue()    q.appendTail(1)    q.appendTail(2)    q.appendTail(3)    print(q.deleteHead())  # 1    print(q.deleteHead())  # 2    print(q.deleteHead())  # 3test()\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from collections import dequeclass Stack:    '''自己实现栈结构，先进后出'''    def __init__(self):        self.items = deque()    def push(self, val):        return self.items.append(val)    def pop(self):        return self.items.pop()    def top(self):  # 返回栈顶值，双端队列右边作为栈顶        return self.items[-1]    def empty(self):        return len(self.items) == 0class MyQueue:    '''使用栈实现队列操作'''    def __init__(self):        \"\"\"        Initialize your data structure here.        \"\"\"        self.s1 = Stack()        self.s2 = Stack()    def push(self, x: int) -&gt; None:        \"\"\"        Push element x to the back of queue.        \"\"\"        self.s1.push(x)    def pop(self) -&gt; int:        \"\"\"        Removes the element from in front of queue and returns that element.        \"\"\"        if not self.s2.empty():  # 只要栈s2不为空直接返回栈s2中元素            return self.s2.pop()        while not self.s1.empty():  # 只要栈s1不为空，将栈s1的元素转到s2中            val = self.s1.pop()            self.s2.push(val)        return self.s2.pop()    def peek(self) -&gt; int:        \"\"\"        Get the front element.        \"\"\"        if not self.s2.empty():  # 只要栈s2不为空直接返回栈s2中栈顶元素            return self.s2.top()        while not self.s1.empty():            val = self.s1.pop()            self.s2.push(val)        return self.s2.top()    def empty(self) -&gt; bool:        \"\"\"        Returns whether the queue is empty.        \"\"\"        return self.s1.empty() and self.s2.empty()def test():  # 我自己写的本地测试代码，可以不要    q = MyQueue()    q.push(1)    q.push(2)    q.push(3)    print(q.pop())  # 1    print(q.pop())  # 2    print(q.pop())  from collections import dequeclass Stack:    '''自己实现栈结构，先进后出'''    def __init__(self):        self.items = deque()    def push(self, val):        return self.items.append(val)    def pop(self):        return self.items.pop()    def top(self):  # 返回栈顶值，双端队列右边作为栈顶        return self.items[-1]    def empty(self):        return len(self.items) == 0class MyQueue:    '''使用栈实现队列操作'''    def __init__(self):        \"\"\"        Initialize your data structure here.        \"\"\"        self.s1 = Stack()        self.s2 = Stack()    def push(self, x: int) -&gt; None:        \"\"\"        Push element x to the back of queue.        \"\"\"        self.s1.push(x)    def pop(self) -&gt; int:        \"\"\"        Removes the element from in front of queue and returns that element.        \"\"\"        if not self.s2.empty():  # 只要栈s2不为空直接返回栈s2中元素            return self.s2.pop()        while not self.s1.empty():  # 只要栈s1不为空，将栈s1的元素转到s2中            val = self.s1.pop()            self.s2.push(val)        return self.s2.pop()    def peek(self) -&gt; int:        \"\"\"        Get the front element.        \"\"\"        if not self.s2.empty():  # 只要栈s2不为空直接返回栈s2中栈顶元素            return self.s2.top()        while not self.s1.empty():            val = self.s1.pop()            self.s2.push(val)        return self.s2.top()    def empty(self) -&gt; bool:        \"\"\"        Returns whether the queue is empty.        \"\"\"        return self.s1.empty() and self.s2.empty()def test():  # 我自己写的本地测试代码，可以不要    q = MyQueue()    q.push(1)    q.push(2)    q.push(3)    print(q.pop())  # 1    print(q.pop())  # 2    print(q.pop())  # 3 test()\n\n\n剑指 Offer 18. 删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。注意：此题对比原题有改动\n示例 1:\n123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n示例 2:\n12输入: head = [4,5,1,9], val = 1输出: [4,5,输入: head = [4,5,1,9], val = 1输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.\n说明：\n题目保证链表中节点的值互不相同若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点\n面试题13：在O（1）时间删除链表结点题目：给定单向链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该结点。链表结点与函数的定义如下：\n1234567891011121314151617181920212223242526272829303132333435class Node:    def __init__(self, val, next=None):        self.val, self.next = val, nextclass Solution:    def solve(self, headnode, target_node):        \"\"\"        传统方法是从头遍历到要删除的节点，然后让前一个节点指向下一个节点。        思路：把下一个节点节点复制到当前节点就好了。但是要注意只有一个节点的情况        - 链表只有一个节点        - 链表有多个节点并且不是尾节点        - 链表有多个节点并且是尾节点（此时不存在下一个节点了，需要从头遍历）        \"\"\"        if not headnode or not target_node:            return        if target_node.next:            next_node = target_node.next            target_node.next = next_node.next            target_node.val = next_node.val            del next_node        elif target_node == headnode:            headnode.next = None            del target_node        else:  # O(n) 删除            cur_node = headnode            while cur_node:                if cur_node.next == target_node:                    cur_node.next = target_node.next                    del target_node                    class Node:    def __init__(self, val, next=None):        self.val, self.next = val, nextclass Solution:    def solve(self, headnode, target_node):        \"\"\"        传统方法是从头遍历到要删除的节点，然后让前一个节点指向下一个节点。        思路：把下一个节点节点复制到当前节点就好了。但是要注意只有一个节点的情况        - 链表只有一个节点        - 链表有多个节点并且不是尾节点        - 链表有多个节点并且是尾节点（此时不存在下一个节点了，需要从头遍历）        \"\"\"        if not headnode or not target_node:            return        if target_node.next:            next_node = target_node.next            target_node.next = next_node.next            target_node.val = next_node.val            del next_node        elif target_node == headnode:            headnode.next = None            del target_node        else:  # O(n) 删除            cur_node = headnode            while cur_node:                if cur_node.next == target_node:                    cur_node.next = target_node.next                    del target_node                    break                cur_node = cur_node.next\n\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。\n现有一个链表 – head = [4,5,1,9]，它可表示为：4 -&gt; 5 -&gt;1 -&gt;9\n输入: head = [4,5,1,9], node = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n说明:链表至少包含两个节点。\n链表中所有节点的值都是唯一的。\n给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n不要从你的函数中返回任何结果。\n思路：输入只有一个要删除的节点，无法知道前一个节点。\n4 -&gt; 5 -&gt;1 -&gt;9，当我们知道 5 这个节点时，下一个节点 5.next 就知道是 1，下下个节点 9 就是 5.next.next。既然不能直接删除5这个节点，可以让 5 这个值替换成 下一个节点1值，然后可以让 5.next直接指向 9。这样就实现类似删除功能。\n由此的可知 5（node），1（node.next），9（node.next.next）\n1234567891011121314151617# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = None class Solution:    def deleteNode(self, node):        \"\"\"        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        也可以类似这样理解node.next在等号右边就是个节点，左边就是个指针。        \"\"\"        nextnode = node.next            # 获取下一个结点        after_nextnode = node.next.next  # 获取下下个结点        node.val = nextnode.val       # 当前结点值覆盖为下一个结点的值        node.next = after_nextnode    # Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = None class Solution:    def deleteNode(self, node):        \"\"\"        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        也可以类似这样理解node.next在等号右边就是个节点，左边就是个指针。        \"\"\"        nextnode = node.next            # 获取下一个结点        after_nextnode = node.next.next  # 获取下下个结点        node.val = nextnode.val       # 当前结点值覆盖为下一个结点的值        node.next = after_nextnode    # 当前的节点next指向下下个结点\n\n二分查找法 分为整数和浮点数适用于1.数据量较大时，但是数据需要先排好顺序2.顺序存储。原因：1.通过下标即可得到关键字2.任取一个关键字的值即可确定所寻找关键字是在它前面还是后面主要思想是：（设查找的数组区间为array[low, high]）（1）确定该区间的中间位置mid（2）将查找的值T与array[mid]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：\n\na.array[mid]&gt;T 由数组的有序性可知array[mid,mid+1,……,right]&gt;T，故新的区间为array[left,……，mid-1]\nb.array[mid]&lt;T 类似上面查找区间为array[mid+1,……，right]。每一次查找与中间值比较，可以确定是否查找成功，不成功当前收缩左边界或右边界，查找区间将缩小一半，递归查找即可。\n\n一般二分查找：left=mid+1 right=mid-1原因：确定mid所指元素并非査找元素\n把数组内的数据一分为二，然后计算出中间数据的 索引值。\n先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于  target 这个数;那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid]  大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。\n二分查找中的小技巧mid = (left + right) &gt;&gt; 1mid = left + (right - left) // 2 而不是 (high + low) // 2如果left和right很大的话可能会造成溢出越界，使用减法避免了溢出发生除法没有移位的快向右 移一位， 它就相当于 除以2101 = 5 =&gt; 10 = 21100 = 12 =&gt; 110 = 6\n时间复杂度为:O(logn)1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)所以T(n)=O(log2n) =O(logn)2.最好情况查找中间元素O(1)查找的元素即为中间元素（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）空间复杂度\n123456789101112131415161718192021222324252627282930def binary_search(array, target):    left = 0    right = len(array) - 1    while left &lt;= right:        mid = (left + right) &gt;&gt; 1        # 如果中间的数等于我们要找的数，那么就返回。        if array[mid] == target:            return mid        # 如果说中间的数 &lt; 目标的数        elif array[mid] &lt; target:            # 目标的数在右侧，所以左侧取值的索引需要改变为中间的索引+1            left = mid + 1        # 如果说中间的数 &gt; 目标的数        else:            # 目标的数在左侧，所以左侧取值的索引需要改变为中间的索引-1            right = mid - 1    return None  # 没查找到if __name__ == '__main__':    # 元素索引值    # 正常值，包含有和无两种结果    print(binary_search([1, 3, 5, 7, 8, 9], 5))  # 2    print(binary_search([0, 1, 2, 3, 4, 5], 6))  # None    # 边界值    print(binary_search([0, 1, 2, 3, 4, 5], 0))  # 0    print(binary_search([0], 0))  # 0    # 异常值    print(binary_search([], 1))  def binary_search(array, target):    left = 0    right = len(array) - 1    while left &lt;= right:        mid = (left + right) &gt;&gt; 1        # 如果中间的数等于我们要找的数，那么就返回。        if array[mid] == target:            return mid        # 如果说中间的数 &lt; 目标的数        elif array[mid] &lt; target:            # 目标的数在右侧，所以左侧取值的索引需要改变为中间的索引+1            left = mid + 1        # 如果说中间的数 &gt; 目标的数        else:            # 目标的数在左侧，所以左侧取值的索引需要改变为中间的索引-1            right = mid - 1    return None  # 没查找到if __name__ == '__main__':    # 元素索引值    # 正常值，包含有和无两种结果    print(binary_search([1, 3, 5, 7, 8, 9], 5))  # 2    print(binary_search([0, 1, 2, 3, 4, 5], 6))  # None    # 边界值    print(binary_search([0, 1, 2, 3, 4, 5], 0))  # 0    print(binary_search([0], 0))  # 0    # 异常值    print(binary_search([], 1))  # None\n\n2. 旋转数组的最小数字 [^本题考点 查找]把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n输入一个递增排序的数组的一个旋转 ，即输入的是旋转，不是递增数组。旋转后的数组局部有序的，实际上可以划分为两个排序的子数组，{3,4,5,1,2}其中前半部分{3,4,5}和后半部分{1,2}都为非减数组，\n前面子数组的任一元素都大于或者等于后面子数组的任一元素。\n最小的元素是既小于左边的数又小于右边的数，右排序数组 的首个元素 \n由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。在这个问题中，我们使用一种改进的二分搜索，判断条件与标准的二分搜索有些不同。我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？如果数组没有被旋转，是升序排列，就满足 last element &gt; first element\n思考： 是否可以用 numbers[m] 和 numbers[left] 比较做代替？解析： 不可以。因为做比较的目的是判断 mid 在哪个排序数组中。但在 numbers[mid] &gt; numbers[left]情况下，无法判断 m 在哪个排序数组中。本质是因为 right 初始值肯定在右排序数组中；left 初始值无法确定在哪个排序数组中，也就不能确定最小值的位置范围。示例： 当 left = 0, right = 4, mid = 2时，有 numbers[mid] &gt; numbers[left] ，以下两示例得出不同结果。numbers = [1, 2, 3, 4 ,5]   3 4 5 1 2旋转点 min = 0，则 mid 在右排序数组（此示例只有右排序数组）；numbers = [3, 4, 5, 1 ,2]   1 2 3 4 5旋转点 min = 3，则 mid 在左排序数组。\nmid = left + (right - left) / 2整数除法是向下取整的```除，mid更靠近left，再结合while循环的条件left &lt; right，索引号mid= (left+right)/2 &gt; (left+left)/2= left，mid= (left+right)/2 &lt; (right+right)/2 = right，索引从0开始，即在while循环内，mid始终小于right。因此在while循环内，nums[mid]要么大于要么小于nums[right]，不会等于。这样else {right = mid;}这句判断可以改为更精确的else if (nums[mid] &lt; nums[right]) {right = mid;}。\n[0][1][2][3]1234 说的不是具体的值2&lt;2.5，而是索引号1小于3mid &lt; right\n\n循环二分\n\n1.若中间索引对应的值大于右侧索引的值，最小值在中间值右侧，34512左半部分一定是有序的，中间数mid在前半个非递减数组，mid肯定不是最小值 left = mid + 1假如最小值在左边，那么在非递减数组中间值就不会大于右边2.若中间索引对应的值小于右侧索引的值，最小值在中间值左侧 45123右半部分一定是有序的，中间数位于后半个非递减数组中，mid有可能是最小值 right = mid假如最小值在右边， 53214，那么不能构成非递减 \n在rotateArray[mid]==rotateArray[right]时,1.无法判定 m 在左（右）排序数组，即无法判断旋转点 x 在 [left, m] 还是 [m + 1, right] 区间中。：设以下两个旋转点值为 0 的示例数组，则当 left = 0, right = 4 时 m = 2，两示例结果不同。例 [1, 0, 1, 1, 1] ：旋转点 x = 1 ，因此 m = 2 在 右排序数组 中。例 [1, 1, 1, 0, 1] ：旋转点 x = 3 ，因此 m = 2 在 左排序数组 中。\n2.right = right - 1 一个个往前去遍历，复杂度跟直接遍历没差别分析:只需证明每次执行此操作后，旋转点 x 仍在 [left, right] 区间内即可。删除的最后这个元素（下标j），在删除后的区间仍存在，所以不会删除掉旋转点x。简单的说，因为相等，所以删掉一个留下一个，我们在剩下区间搜索，仍可以搜索到删除的那个元素值。\n有重复，暴力地从右到左进行遍历，right mid往左移动一位为什么rght-不会对结果产生影响?-产生影响条件：删除的元素为唯一最小元素-执行条件: numbers[right]= numbers[mid]矛盾\n返回值如果输入数组多于一个数，循环到最后，会只剩两个数，nums[left] == nums[mid]，以及nums[right]，这里的位置left == mid == right - 1。如果nums[left] == nums[mid] &gt; nums[right]，则左边大、右边小，需要执行left = mid + 1，使得left == right，左右边界位置重合，二分循环结束，nums[left]与nums[right]都保存了最小值。\n如果nums[left] == nums[mid] &lt; nums[right]，则左边小、右边大，会执行right = mid，使得left == right，左右边界位置重合，二分循环结束，nums[left]、nums[mid]、nums[right]都保存了最小值。\n如果数组只有一个数，左右边界位置重合，left == right，不会进入while跳出二分循环，最小值输出nums[left]或nums[right]均可返回值 numbers[left] 等于旋转点值 numbers[min] ；但在少数特例下 left 不是旋转点 min 。本题目只要求返回 “旋转点的值” ，因此本方法可行。\n时间复杂度 O(log_2 N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。空间复杂度 O(1) ： left , right , mid 指针使用常数大小的额外空间。\n123456789101112131415161718192021222324252627282930313233343536class Solution:    def minNumberInRotateArray(self, rotateArray):        # 时间复杂度O(n)        # minNum = 0        # for i in range(0, len(rotateArray)):        #     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]        #        # return minNum        # 时间复杂度O(logn) 对数级别         # 若数组大小为0        if not rotateArray:            # 返回0            return 0        # 左侧索引        left = 0        # 右侧索引        right = len(rotateArray) - 1        # 当左侧索引小于右侧索引时循环        while left &lt;= right:  # 直至left&gt;right结束。            # 中间值为左侧索引和右侧索引求和再除以2，向下取整            mid = (left + right) &gt;&gt; 1  # low + (high - low) // 2 而不是 (high + low) // 2            # 若中间索引对应的值小于它左侧一个的值，即为要取得值            if rotateArray[mid] &lt; rotateArray[mid - 1]:                # 返最小标值                return rotateArray[mid]            elif rotateArray[mid] &lt; rotateArray[right]:                # 将右侧索引置为中间索引-1                right = mid - 1                        # if(rotateArray[mid] &gt; rotateArray[left])            else:                # 将左侧索引置为中间索引+1                left = mid + class Solution:    def minNumberInRotateArray(self, rotateArray):        # 时间复杂度O(n)        # minNum = 0        # for i in range(0, len(rotateArray)):        #     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]        #        # return minNum        # 时间复杂度O(logn) 对数级别         # 若数组大小为0        if not rotateArray:            # 返回0            return 0        # 左侧索引        left = 0        # 右侧索引        right = len(rotateArray) - 1        # 当左侧索引小于右侧索引时循环        while left &lt;= right:  # 直至left&gt;right结束。            # 中间值为左侧索引和右侧索引求和再除以2，向下取整            mid = (left + right) &gt;&gt; 1  # low + (high - low) // 2 而不是 (high + low) // 2            # 若中间索引对应的值小于它左侧一个的值，即为要取得值            if rotateArray[mid] &lt; rotateArray[mid - 1]:                # 返最小标值                return rotateArray[mid]            elif rotateArray[mid] &lt; rotateArray[right]:                # 将右侧索引置为中间索引-1                right = mid - 1                        # if(rotateArray[mid] &gt; rotateArray[left])            else:                # 将左侧索引置为中间索引+1                left = mid + 1\n输入一个非减排序的数组的一个旋转，输入为非减排序的数组，即非严格递增的序列，存在重复值，如{1,2,3,3,4,5},旋转后可以是{3,4,5,1,2,3}。输出最小元素。对于未旋转的非减排序array应该有array[start]&lt;array[end]的情况，因此，亦满足array[mid]&lt;array[end];在经过旋转后的rotateArray，满足局部非严格递增，则可以根据rotateArray[mid]&lt;rotateArray[end]初步判断最小值在start-mid之间；否则最小值在mid-end之间。因为存在重复元素，\n其他情况对根据需要更新start、mid和end即可，直至start&gt;end结束。可以想到使用二分查找来解决会优化线性查找的性能。没有具体的值用来比较。设置三个指针，left,right,mid。中间值和高低位进行比较，目的：当进行一次比较时，一定能够确定目标值在mid的某一侧。看处于递增还是递减序列，不管是移动第一个还是第二个指针，查找范围都会缩小到原来的一般，接下来再用更新之后的两个指针重复做新一轮的查找。\n第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最终第一个指针将指向前面子数组的最后一个元素，而第二个指针则会指向后面子数组的第一个元素。也就是她们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。    \n12345678910111213class Solution:    # def minArray(self, numbers: List[int]) -&gt; int:    def minNumberInRotateArray(self, numbers):        low, high = 0, len(numbers) - 1        while low &lt; high:            pivot = low + (high - low) // 2            if numbers[pivot] &lt; numbers[high]:                high = pivot            elif numbers[pivot] &gt; numbers[high]:                low = pivot + 1            else:                high -= 1        class Solution:    # def minArray(self, numbers: List[int]) -&gt; int:    def minNumberInRotateArray(self, numbers):        low, high = 0, len(numbers) - 1        while low &lt; high:            pivot = low + (high - low) // 2            if numbers[pivot] &lt; numbers[high]:                high = pivot            elif numbers[pivot] &gt; numbers[high]:                low = pivot + 1            else:                high -= 1        return numbers[low]\n\n转换思路，比较mid与left是先找最大值，最大值偏右，\n1234567891011class Solution:    # def findMin(self, nums: List[int]) -&gt; int:    def findMin(self, nums):        left, right = 0, len(nums) - 1           while left &lt; right:                      mid = (left + right + 1) &gt;&gt; 1           # 先加一再除，mid更靠近右边的right                 if nums[left] &lt; nums[mid]:                         left = mid                          # 向右移动左边界            elif nums[left] &gt; nums[mid]:                       right = mid - 1                     # 向左移动右边界        return nums[(right + 1) % len(nums)]        class Solution:    # def findMin(self, nums: List[int]) -&gt; int:    def findMin(self, nums):        left, right = 0, len(nums) - 1           while left &lt; right:                      mid = (left + right + 1) &gt;&gt; 1           # 先加一再除，mid更靠近右边的right                 if nums[left] &lt; nums[mid]:                         left = mid                          # 向右移动左边界            elif nums[left] &gt; nums[mid]:                       right = mid - 1                     # 向左移动右边界        return nums[(right + 1) % len(nums)]        # 最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）\n\n数组：是有序的元素序列。[1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。 [1]这些无序排列的同类数据元素的集合称为数组。*\n例如：\nint (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。a(0)             a(1)          a(2)\n数组与python中的 列表比较相似， 用索引去查找。数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。数组还和元组比较像，元组是初始化后，长度指定了就不可以变。但是元组在初始化时给的值，确定了以后就不可以变了。所以可以理解为数组与list 列表很相似。\n123456A = ((1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4))print(len(A))  # 4，二维元组的行数print(A[0])  # (1, 1, 1)print(A[1])  # (2, 2, 2)print(A[2])  # (3, 3, 3)print(len(A[0]))  A = ((1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4))print(len(A))  # 4，二维元组的行数print(A[0])  # (1, 1, 1)print(A[1])  # (2, 2, 2)print(A[2])  # (3, 3, 3)print(len(A[0]))  # 3 二维元组的列数\n\n多维，每一维长度应该是len(A[i])\n\n3.在二维数组中的查找[^本题考点 查找]在一个二维有序数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution:    # array 二维列表    def Find(self, target, array):        # write code here        # 1 2 3 4        # 3 4 5 6        # 4 6 8 10        # 9 11 13 15        # 方法1: 暴力算法        # 直接遍历一遍数组，即可判断目标target是否存在        # 时间复杂度 o(n**n)，因为最坏情况下，数组中的元素都需要遍历一次        # for i in range(len(array)):  # 横        #     for j in range(len(array[i])):  # 竖        #         if target == array[i][j]:        #             return True        # return False        # 选择右上角的数字        # 为什么不从左上角开始搜寻，左上角向右和向下都是递增，        # 那么对于一个点，对于向右和向下会产生一个岔路        # 无法确定下一次二分应该往哪边分，由此无法进行二分下去。        # 如果我们找个位置，每次都能确定的往哪个部分二分，即可达到我们想要的结果。        # 如果我们选择从右上脚开始搜寻的话，                 # 右上角的值是这一行的最大数，是这一列的最小数。             # 向下数字递增，向左数字递减，        # 当要查找数字比右上角数字小时，左移，剔除这个数字所在的列        # 要查找数字比右上角数字大时，下移，剔除这个数字所在的行。        # 这样每次能比较一行或者一列，每一步都可以剔除一行或一列，查找的速度比较快。        # 当然也可以选择左下角的数字，思路同上。        # 时间复杂度        # 时间复杂度：O(m+n) ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。        # 这个二维数组的长度是多少，也就是说这个数组有几行；        row_count = len(array)        i = 0  # 初始行号        # 这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列        column_count = len(array[0])        # 给j 一个值，序号从0开始，就是数组列数的值-1，即为j 的最大值。        j = len(array[0]) - 1  # 初始列号        # 循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。                while i &lt; row_count and j &gt;= 0:            # 根据两个索引下标可以取到 对应的在数组中的值            value = array[i][j]            # 如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回True。            if value == target:                return True            # 如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，            # 因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，            # 给它减-1，找前一列的数做比较            elif target &lt; value:                j -= 1            # 如果说取到的值 &lt; 我们的目标值。            # 那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，            # 这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较            else:                i += 1        return class Solution:    # array 二维列表    def Find(self, target, array):        # write code here        # 1 2 3 4        # 3 4 5 6        # 4 6 8 10        # 9 11 13 15        # 方法1: 暴力算法        # 直接遍历一遍数组，即可判断目标target是否存在        # 时间复杂度 o(n**n)，因为最坏情况下，数组中的元素都需要遍历一次        # for i in range(len(array)):  # 横        #     for j in range(len(array[i])):  # 竖        #         if target == array[i][j]:        #             return True        # return False        # 选择右上角的数字        # 为什么不从左上角开始搜寻，左上角向右和向下都是递增，        # 那么对于一个点，对于向右和向下会产生一个岔路        # 无法确定下一次二分应该往哪边分，由此无法进行二分下去。        # 如果我们找个位置，每次都能确定的往哪个部分二分，即可达到我们想要的结果。        # 如果我们选择从右上脚开始搜寻的话，                 # 右上角的值是这一行的最大数，是这一列的最小数。             # 向下数字递增，向左数字递减，        # 当要查找数字比右上角数字小时，左移，剔除这个数字所在的列        # 要查找数字比右上角数字大时，下移，剔除这个数字所在的行。        # 这样每次能比较一行或者一列，每一步都可以剔除一行或一列，查找的速度比较快。        # 当然也可以选择左下角的数字，思路同上。        # 时间复杂度        # 时间复杂度：O(m+n) ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。        # 这个二维数组的长度是多少，也就是说这个数组有几行；        row_count = len(array)        i = 0  # 初始行号        # 这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列        column_count = len(array[0])        # 给j 一个值，序号从0开始，就是数组列数的值-1，即为j 的最大值。        j = len(array[0]) - 1  # 初始列号        # 循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。                while i &lt; row_count and j &gt;= 0:            # 根据两个索引下标可以取到 对应的在数组中的值            value = array[i][j]            # 如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回True。            if value == target:                return True            # 如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，            # 因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，            # 给它减-1，找前一列的数做比较            elif target &lt; value:                j -= 1            # 如果说取到的值 &lt; 我们的目标值。            # 那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，            # 这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较            else:                i += 1        return False\n\n4.包含min 函数的栈[^本题考点 栈]定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n普通栈的 push() 和 pop() 函数的复杂度为 O(1)；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)。原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗\n第一种方法：辅助栈和数据栈不同步，不考虑两个栈的长度必须要保持一致将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现；\n\n数据栈 A ： 栈 A ,用于栈的正常操作 存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。\n辅助栈 B ： 非严格的单调栈则栈 A 中的最小元素始终对应栈 B 的栈顶元素，只记录从大到小的顺序元素，B等价于遍历stack所有元素，把升序的数字都删除掉，储栈 A 中所有 非严格降序 的元素，每当pop()这些降序元素，B会将相应的栈顶元素pop()出去，保证其栈顶元素始终是stack中的最小元素。min() 函数只需返回栈 B 的栈顶元素获取最小值，即可实现 O(1) 复杂度。\n\n函数设计：\n\npush(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。将 x 压入栈 A （即 A.add(x) ）；若 ① 栈 B 为空或② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B （即 B.add(x) ），即更新了栈顶最小值；\n\n假设先后 push 两个相等的最小数字 x ，此时栈 A 最小数字为 x （且有两个 x ）。若使用“小于”作为判断条件，那么此时栈 B 中只有一个最小数字 x 。此时，执行 pop() ，栈 A 会弹出一个最小数字 x ，还留有一个最小数字 x ；栈 B 也弹出了 x ，但栈 B 栈顶元素不是 x 了，此时执行 min() 函数就会判断出错。\n\npop() 函数： 重点为保持栈 A,B 的 元素一致性 。执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。\n\ntop() 函数： 直接返回栈 A 的栈顶元素\n\nmin() 函数： 直接返回栈 B 的栈顶元素\n\n\n时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。不论数据规模多大，都只有有限个步骤，空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class MinStack:    # 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈    def __init__(self):        self.A, self.B = [], []    # def push(self, node: int) -&gt; None:    def push(self, node):        self.A.append(node)        # B非空，True, not True =False,        # B空，False, not False =True,直接加元素        # B最后一个元素小于node，        if not self.B or self.B[-1] &gt;= node:            self.B.append(node)        # if self.B:            # if node &lt;= self.B[-1]:                # self.B.append(node)        # else:            # self.B.append(node)        # ##############错误代码##################        # if not self.B:        #     self.B.append(node)        # if self.B[-1] &gt;= node:  # 如果node是最小的        #     self.B.append(node)        # B为空的时候一下push了两个相同的数，两个条件都符合        ##########################################    # def pop(self) -&gt; None:    def pop(self):        if not self.A:            return None        if self.A.pop() == self.B[-1]:            # pop() 本身就是“出栈”函数， 1、删除栈顶元素，2、返回栈顶元素。            # 无论if判断是与否，原栈的栈顶是被pop了            self.B.pop()    # def top(self) -&gt; int:    def top(self):        # 如果栈里没有数值的话，就返回一个空        if not self.A:            return None        # 否则栈里有数，那么就返回栈顶的那个数        return self.A[-1]    # def min(self) -&gt; int:    def min(self):        # 如果为空的话，就说明没有值，返回none        if not self.B:            return None        return self.B[-1]if __name__ == '__main__':    obj = MinStack()    obj.push(9)    obj.push(10)    obj.push(7)    obj.push(3)    obj.push(5)    obj.push(3)    print(obj.A)  # [9, 10, 7, 3, 5, 3]    print(obj.B)  # [9, 7, 3, 3]    obj.pop()    print(obj.A)  # [9, 10, 7, 3, 5]    print(obj.B)  # [9, 7, 5, 3]    obj.pop()    print(obj.A)  # [9, 10, 7, 3]    print(obj.B)  # [9, 7, 3]    print(obj.min())  class MinStack:    # 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈    def __init__(self):        self.A, self.B = [], []    # def push(self, node: int) -&gt; None:    def push(self, node):        self.A.append(node)        # B非空，True, not True =False,        # B空，False, not False =True,直接加元素        # B最后一个元素小于node，        if not self.B or self.B[-1] &gt;= node:            self.B.append(node)        # if self.B:            # if node &lt;= self.B[-1]:                # self.B.append(node)        # else:            # self.B.append(node)        # ##############错误代码##################        # if not self.B:        #     self.B.append(node)        # if self.B[-1] &gt;= node:  # 如果node是最小的        #     self.B.append(node)        # B为空的时候一下push了两个相同的数，两个条件都符合        ##########################################    # def pop(self) -&gt; None:    def pop(self):        if not self.A:            return None        if self.A.pop() == self.B[-1]:            # pop() 本身就是“出栈”函数， 1、删除栈顶元素，2、返回栈顶元素。            # 无论if判断是与否，原栈的栈顶是被pop了            self.B.pop()    # def top(self) -&gt; int:    def top(self):        # 如果栈里没有数值的话，就返回一个空        if not self.A:            return None        # 否则栈里有数，那么就返回栈顶的那个数        return self.A[-1]    # def min(self) -&gt; int:    def min(self):        # 如果为空的话，就说明没有值，返回none        if not self.B:            return None        return self.B[-1]if __name__ == '__main__':    obj = MinStack()    obj.push(9)    obj.push(10)    obj.push(7)    obj.push(3)    obj.push(5)    obj.push(3)    print(obj.A)  # [9, 10, 7, 3, 5, 3]    print(obj.B)  # [9, 7, 3, 3]    obj.pop()    print(obj.A)  # [9, 10, 7, 3, 5]    print(obj.B)  # [9, 7, 5, 3]    obj.pop()    print(obj.A)  # [9, 10, 7, 3]    print(obj.B)  # [9, 7, 3]    print(obj.min())  # 3\n\n#第二种方法：辅助栈和数据栈同步，考虑两个栈的长度相同，添加一个，另一个栈也会删除一个\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution:    # 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈    def __init__(self):        self.stack = []        self.minValue = []  # 空间换时间    # 给栈中推进去数值，推进去元素node，添加函数    def push(self, node):        self.stack.append(node)        # 如果最小值列表里有值为True        if self.minValue:            # 如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，            # 那么就放进最小值列表中；            if self.minValue[-1] &gt; node:                self.minValue.append(node)            # 如果列表里面的最后一个值，小于node值，那么就说明node这个值大；            #   那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；            else:                self.minValue.append(self.minValue[-1])        # 如果最小值列表里面没有值，就在最小值列表里添加node        else:            self.minValue.append(node)        # if not self.minValue or self.minValue[-1] &gt;= node:        #     self.minValue.append(node)    # 给栈中做删除操作    def pop(self):        # 如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值        if not self.stack:            return None        # 栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个        self.minValue.pop()        # 有值的话，就需要删除一个，删除做pop 操作；返回我们删除的那个数        return self.stack.pop()    # 栈顶    def top(self):        # 如果栈里没有数值的话，就返回一个空        if not self.stack:            return None        # 否则栈里有数，那么就返回栈顶的那个数        return self.stack[-1]    # 取出最小值，那么就是我们minvalue 中的最后一个值为最小值    def min(self):        # 如果为空的话，就说明没有值，返回none        if not self.minValue:            return None        return self.minValue[-1]if __name__ == '__main__':    obj = Solution()    obj.push(9)    obj.push(10)    obj.push(7)    obj.push(3)    obj.push(5)    obj.push(3)    print(obj.stack)  # [9, 10, 7, 3, 5, 3]    print(obj.minValue)  # [9, 9, 7, 3, 3, 3]    obj.pop()    print(obj.stack)  # [9, 10, 7, 3, 5]    print(obj.minValue)  # [9, 9, 7, 3, 3]    obj.pop()    print(obj.stack)  # [9, 10, 7, 3]    print(obj.minValue)  # [9, 9, 7, 3]    print(obj.min())  class Solution:    # 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈    def __init__(self):        self.stack = []        self.minValue = []  # 空间换时间    # 给栈中推进去数值，推进去元素node，添加函数    def push(self, node):        self.stack.append(node)        # 如果最小值列表里有值为True        if self.minValue:            # 如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，            # 那么就放进最小值列表中；            if self.minValue[-1] &gt; node:                self.minValue.append(node)            # 如果列表里面的最后一个值，小于node值，那么就说明node这个值大；            #   那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；            else:                self.minValue.append(self.minValue[-1])        # 如果最小值列表里面没有值，就在最小值列表里添加node        else:            self.minValue.append(node)        # if not self.minValue or self.minValue[-1] &gt;= node:        #     self.minValue.append(node)    # 给栈中做删除操作    def pop(self):        # 如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值        if not self.stack:            return None        # 栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个        self.minValue.pop()        # 有值的话，就需要删除一个，删除做pop 操作；返回我们删除的那个数        return self.stack.pop()    # 栈顶    def top(self):        # 如果栈里没有数值的话，就返回一个空        if not self.stack:            return None        # 否则栈里有数，那么就返回栈顶的那个数        return self.stack[-1]    # 取出最小值，那么就是我们minvalue 中的最后一个值为最小值    def min(self):        # 如果为空的话，就说明没有值，返回none        if not self.minValue:            return None        return self.minValue[-1]if __name__ == '__main__':    obj = Solution()    obj.push(9)    obj.push(10)    obj.push(7)    obj.push(3)    obj.push(5)    obj.push(3)    print(obj.stack)  # [9, 10, 7, 3, 5, 3]    print(obj.minValue)  # [9, 9, 7, 3, 3, 3]    obj.pop()    print(obj.stack)  # [9, 10, 7, 3, 5]    print(obj.minValue)  # [9, 9, 7, 3, 3]    obj.pop()    print(obj.stack)  # [9, 10, 7, 3]    print(obj.minValue)  # [9, 9, 7, 3]    print(obj.min())  # 3\n时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只是有限个步骤，因此时间复杂度是：O(1)。空间复杂度：O(N)，这里 N 是读出的数据的个数。\n5.替换空格[^本题考点 字符串]请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        # 第一种：python中自带的一个替换的函数        # return s.replace(' ','%20')        # 第二种遍历来替换字符串中的空格        strlen = len(s)        # 借助第三方的列表来实现时间的节省。        aaa = []        for i in range(strlen):            # 如果是空格的话那就替换为%20.            if s[i] == \" \":                # if s[i] isspace:                aaa.append(\"%\")                aaa.append(\"2\")                aaa.append(\"0\")            else:                aaa.append(s[i])        return \"\".join(aaa)# 从后往前，先计算需要多少空间，然后从后往前移动，每个空格后面的字符只需要移动一次。# 从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；# 当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。# -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        # 第一种：python中自带的一个替换的函数        # return s.replace(' ','%20')        # 第二种遍历来替换字符串中的空格        strlen = len(s)        # 借助第三方的列表来实现时间的节省。        aaa = []        for i in range(strlen):            # 如果是空格的话那就替换为%20.            if s[i] == \" \":                # if s[i] isspace:                aaa.append(\"%\")                aaa.append(\"2\")                aaa.append(\"0\")            else:                aaa.append(s[i])        return \"\".join(aaa)# 从后往前，先计算需要多少空间，然后从后往前移动，每个空格后面的字符只需要移动一次。# 从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；# 当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。# 从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下\n12345678910111213141516class Solution:    # s 源字符串    def replaceSpace(self, s):        strLen = len(s)        # 定义空字符串准备接收        rep_str = ''        # 遍历，检测到空格就加上\"%20\"        for i in range(strLen):            if s[i].isspace():                rep_str += '%'                rep_str += '2'                rep_str += '0'            else:                rep_str += s[i]        # 返回辅助字符串        class Solution:    # s 源字符串    def replaceSpace(self, s):        strLen = len(s)        # 定义空字符串准备接收        rep_str = ''        # 遍历，检测到空格就加上\"%20\"        for i in range(strLen):            if s[i].isspace():                rep_str += '%'                rep_str += '2'                rep_str += '0'            else:                rep_str += s[i]        # 返回辅助字符串        return rep_str\n\n\n6.斐波那契数列现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39动态规划：原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n\n状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i 个数字 。\n转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1) ；\n初始状态： dp[0] = 0, dp[1] = 1 ，即初始化前两个数字；\n返回值： dp[n] ，即斐波那契数列的第 nn 个数字。\n\n1234567891011121314151617#第一种方法：下面是使用了for循环，class Solution:    def Fibonacci(self, n):        \"\"\"        a，b代表相邻两个斐波那契数；        a是前一个，b是后一个。        经过一次迭代后a代表fib(1)的值，        两次迭代后a代表fib(2)的值，        因此经过n次迭代a代表的是fib(n)的值，        \"\"\"        b = 1        for i in range(0, n - 1):  # 从0取到n-2            a, b = b, a + b  # 返回大的        return b        # for _ in range(n):  # 取到n-1        # a, b = b, a + b        #第一种方法：下面是使用了for循环，class Solution:    def Fibonacci(self, n):        \"\"\"        a，b代表相邻两个斐波那契数；        a是前一个，b是后一个。        经过一次迭代后a代表fib(1)的值，        两次迭代后a代表fib(2)的值，        因此经过n次迭代a代表的是fib(n)的值，        \"\"\"        b = 1        for i in range(0, n - 1):  # 从0取到n-2            a, b = b, a + b  # 返回大的        return b        # for _ in range(n):  # 取到n-1        # a, b = b, a + b        # return a % 1000000007  # 返回小的\n\n第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n123456789class Solution:    def Fibonacci(self, n):       #初始列表值 为 0 1 第三项为 0+1 = 1；        res = [0, 1, 1]        #临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。        while len(res) &lt;= n:               #取出列表的最后两项，然后求和，并添加到列表中。            res.append(res[-1] + res[-2])        class Solution:    def Fibonacci(self, n):       #初始列表值 为 0 1 第三项为 0+1 = 1；        res = [0, 1, 1]        #临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。        while len(res) &lt;= n:               #取出列表的最后两项，然后求和，并添加到列表中。            res.append(res[-1] + res[-2])        return res[n]\n\n42.连续子数组的最大和输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n示例1:\n123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] \n示例2:\n1234​输入：{6, -3,-2, 7, -15, 1, 2, 2}，输入：返回值：8解释: 连从第0个开始，到第3个为止 [6, -3,-2, ​输入：{6, -3,-2, 7, -15, 1, 2, 2}，输入：返回值：8解释: 连从第0个开始，到第3个为止 [6, -3,-2, 7]\n示例3:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889输入: nums = [1,-2,3,10,-4,7,2,-5]输出: 18解释: 连续子数组 [3,10,-4,7,2] ``` 解题思路：常见解法    时间复杂度    空间复杂度暴力搜索    O(N^2)      O(1)分治思想    O(NlogN)    O(logN)动态规划    O(N)        O(1)动态规划是本题的最优解法，以下按照标准流程解题。两种标志DP适用于数组：  * 1. 常数空间，沿数组移动并子啊原数组修改；  * 2. 线性空间，首先沿left-&gt;right方向移动，然后沿right-&gt;left方向移动，最后合并结果。动态规划实质上就是空间换时间（画表格方法），分为一维列表、二维矩阵。自底向上（动态规划）和自底向下（记忆化递归）在一些书里都称为「动态规划」，可以先弄懂它们的区别；1. 最优子结构 大问题的最优解通常由小问题的最优解得到，那么我们就需要通过分类讨论，得到大问题的小问题究竟是哪些。 2. 边界 3. 状态定义 一般数组、字符串相关的状态定义都是 “以 dp[i] 为结尾的 xxx ” 这样，xxx 一般就是求最长、最短、最大、最小这种，dp[i]就是到当前i这个情况下的最优解，以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。都存在选与不选两种选择，选了就与前面i-1的结果联系起来，不选就独立出来，「无后效性」是可以应用动态规划的一个特点：   1. 后面的决策不会影响到前面的决策   2. 之前的状态怎么来的并不重要。4. 转移方程以阶为例，最优子结构为f(10)=f(9) + f(8)，边界是f(1)=1, f(2)=2，状态转移公式f(n)=f(n-1) + f(n-2)跳台动态规划解析：- 数组的子结构通常就是子数组，而本题的最优子结构容易想到是 子数组的连续最大和 把数组分解成把数组长度个子问题- 状态定义（抽象出了子问题）： 设动态规划列表 dp ， 定义数组元素dp[i] 代表当前位置 i 的以元素 nums[i] 为结尾的连续子数组最大和。动态规划的问题的分类讨论的标准不是 nums[i] 的正负，而是上一个状态值 dp[i - 1] 的正负。  - 为何定义最大和 dp[i] 中必须包含元素 nums[i] ：  保证 dp[i] 递推到 dp[i+1] 的正确性、转移方程的有效性，  如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。  - 转移策略，自带剪枝：     1. 若 dp[i−1] ≤ 0 ，说明 dp[i - 1] 没法给 dp[i] 带来正增益，那么加上前面的数反而越来越小了，即 dp[i-1] + nums[i] 还不如 nums[i] 本身大，抛弃掉前面的子组合，自己单独的一个 nums[i]就是最大的了。    2. 若前一个元素dp[i−1] &gt; 0，则将其加到当前元素上  - 状态转移方程    - 记为「状态转移方程 1」    当 dp[i - 1] &gt; 0 时：执行 dp[i] = dp[i-1] + nums[i] ；      当 dp[i - 1] ≤ 0 时：执行 dp[i] = nums[i] ；    - 反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，    因此还可以写出「状态转移方程 2」。如下：      dp[i] = max(dp[i-1], 0) + nums[i]    - dp 初始状态得根据题意和你的状态定义而来：dp[0] = nums[0] 表示以 nums[0] 结尾的连续子数组最大和为 nums[0] 而非 0。如果数组元素只有一个元素，它就是最大和      - 返回值：这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。返回 dp 列表中的最大值应该是把每个位置的 dp[i] 即dp[0]、dp[1]、……、dp[n-1] 都比较得到全局最大值。4.设计dp数组，保存子问题的解，避免重复计算，因此将原数组 nums 用作 dp 列表，即直接在原数组 nums 上修改，由于省去 dp 列表使用的额外空间：nums[i] += max(nums[i-1],0);时间复杂度 O(N) ： 线性遍历一次数组 nums ，使用 O(N) 时间。空间复杂度 O(1) ： 使用常数大小的额外空间。优化空间，由于每次循环中当前状态只依赖于前一个状态，就是说 dp[i] 的更新只取决于 dp[i-1] , 只用一个存储变量 maxnum 各阶段全局最大和从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。```pythonclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        # 动态规划，原地修改数组        max_sum = nums[0]        for i in range(1, len(nums)):            # 写法一            # if nums[i - 1] &gt; 0:                # nums[i] += nums[i - 1]            # 写法二            nums[i] += max(nums[i - 1], 0)                max_sum = max(max_sum, nums输入: nums = [1,-2,3,10,-4,7,2,-5]输出: 18解释: 连续子数组 [3,10,-4,7,2] ``` 解题思路：常见解法    时间复杂度    空间复杂度暴力搜索    O(N^2)      O(1)分治思想    O(NlogN)    O(logN)动态规划    O(N)        O(1)动态规划是本题的最优解法，以下按照标准流程解题。两种标志DP适用于数组：  * 1. 常数空间，沿数组移动并子啊原数组修改；  * 2. 线性空间，首先沿left-&gt;right方向移动，然后沿right-&gt;left方向移动，最后合并结果。动态规划实质上就是空间换时间（画表格方法），分为一维列表、二维矩阵。自底向上（动态规划）和自底向下（记忆化递归）在一些书里都称为「动态规划」，可以先弄懂它们的区别；1. 最优子结构 大问题的最优解通常由小问题的最优解得到，那么我们就需要通过分类讨论，得到大问题的小问题究竟是哪些。 2. 边界 3. 状态定义 一般数组、字符串相关的状态定义都是 “以 dp[i] 为结尾的 xxx ” 这样，xxx 一般就是求最长、最短、最大、最小这种，dp[i]就是到当前i这个情况下的最优解，以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。都存在选与不选两种选择，选了就与前面i-1的结果联系起来，不选就独立出来，「无后效性」是可以应用动态规划的一个特点：   1. 后面的决策不会影响到前面的决策   2. 之前的状态怎么来的并不重要。4. 转移方程以阶为例，最优子结构为f(10)=f(9) + f(8)，边界是f(1)=1, f(2)=2，状态转移公式f(n)=f(n-1) + f(n-2)跳台动态规划解析：- 数组的子结构通常就是子数组，而本题的最优子结构容易想到是 子数组的连续最大和 把数组分解成把数组长度个子问题- 状态定义（抽象出了子问题）： 设动态规划列表 dp ， 定义数组元素dp[i] 代表当前位置 i 的以元素 nums[i] 为结尾的连续子数组最大和。动态规划的问题的分类讨论的标准不是 nums[i] 的正负，而是上一个状态值 dp[i - 1] 的正负。  - 为何定义最大和 dp[i] 中必须包含元素 nums[i] ：  保证 dp[i] 递推到 dp[i+1] 的正确性、转移方程的有效性，  如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。  - 转移策略，自带剪枝：     1. 若 dp[i−1] ≤ 0 ，说明 dp[i - 1] 没法给 dp[i] 带来正增益，那么加上前面的数反而越来越小了，即 dp[i-1] + nums[i] 还不如 nums[i] 本身大，抛弃掉前面的子组合，自己单独的一个 nums[i]就是最大的了。    2. 若前一个元素dp[i−1] &gt; 0，则将其加到当前元素上  - 状态转移方程    - 记为「状态转移方程 1」    当 dp[i - 1] &gt; 0 时：执行 dp[i] = dp[i-1] + nums[i] ；      当 dp[i - 1] ≤ 0 时：执行 dp[i] = nums[i] ；    - 反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，    因此还可以写出「状态转移方程 2」。如下：      dp[i] = max(dp[i-1], 0) + nums[i]    - dp 初始状态得根据题意和你的状态定义而来：dp[0] = nums[0] 表示以 nums[0] 结尾的连续子数组最大和为 nums[0] 而非 0。如果数组元素只有一个元素，它就是最大和      - 返回值：这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。返回 dp 列表中的最大值应该是把每个位置的 dp[i] 即dp[0]、dp[1]、……、dp[n-1] 都比较得到全局最大值。4.设计dp数组，保存子问题的解，避免重复计算，因此将原数组 nums 用作 dp 列表，即直接在原数组 nums 上修改，由于省去 dp 列表使用的额外空间：nums[i] += max(nums[i-1],0);时间复杂度 O(N) ： 线性遍历一次数组 nums ，使用 O(N) 时间。空间复杂度 O(1) ： 使用常数大小的额外空间。优化空间，由于每次循环中当前状态只依赖于前一个状态，就是说 dp[i] 的更新只取决于 dp[i-1] , 只用一个存储变量 maxnum 各阶段全局最大和从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。```pythonclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        # 动态规划，原地修改数组        max_sum = nums[0]        for i in range(1, len(nums)):            # 写法一            # if nums[i - 1] &gt; 0:                # nums[i] += nums[i - 1]            # 写法二            nums[i] += max(nums[i - 1], 0)                max_sum = max(max_sum, nums[i])        return max_sum\n全是正的\n1234567891011121314151617nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1nums[i - 1] = nums[0] = 1 &gt; 0nums[i] = nums[i] + nums[i - 1] nums[1] = nums[1] + nums[0] = 2 + 1 = 3nums = [1, 3, 3]max_sum = max(max_sum,nums[i]) = max(1, 3) = 3i = 2nums[i - 1] = nums[1] = 3 &gt; 0nums[i] = nums[i] + nums[i - 1] nums[2] = nums[2] + nums[1] = 3 + 3 = 6nums = [1, 3, 6]max_sum = max(max_sum,nums[i]) = max(3, nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1nums[i - 1] = nums[0] = 1 &gt; 0nums[i] = nums[i] + nums[i - 1] nums[1] = nums[1] + nums[0] = 2 + 1 = 3nums = [1, 3, 3]max_sum = max(max_sum,nums[i]) = max(1, 3) = 3i = 2nums[i - 1] = nums[1] = 3 &gt; 0nums[i] = nums[i] + nums[i - 1] nums[2] = nums[2] + nums[1] = 3 + 3 = 6nums = [1, 3, 6]max_sum = max(max_sum,nums[i]) = max(3, 6)\n\n全是负的\n12345678910111213nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1nums[i - 1] = nums[0] = -2 &lt; 0max_sum = max(max_sum,nums[i]) = max(-2, -1) = -1nums = [-2,-1,-3]i = 2nums[i - 1] = nums[1] = -1 &lt; 0max_sum = max(max_sum,nums[i]) = max(-2, -1) = -1nums = [-2,-1,nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1nums[i - 1] = nums[0] = -2 &lt; 0max_sum = max(max_sum,nums[i]) = max(-2, -1) = -1nums = [-2,-1,-3]i = 2nums[i - 1] = nums[1] = -1 &lt; 0max_sum = max(max_sum,nums[i]) = max(-2, -1) = -1nums = [-2,-1,-3]\n\n有负有正\n123456789101112131415161718192021222324252627282930313233343536373839404142434445nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1nums[1] += max(nums[1 - 1], 0) = nums[1] + max(-2, 0) = 1  max_sum = max(mmax_sumaxnum,nums[i]) = max(-2, 1) = 1nums = [-2,1,-3,4,-1,2,1,-5,4]i = 2nums[2] += max(nums[2 - 1], 0) = nums[2] + max(1, 0) = -3 + 1 = -2  max_sum = max(max_sum,nums[i]) = max(1, -2) = 1nums = [-2,1,-2,4,-1,2,1,-5,4]i = 3nums[3] += max(nums[3 - 1], 0) = nums[3] + max(-2, 0) = 4 + 0 = 4  max_sum = max(max_sum,nums[i]) = max(1, 4) = 4nums = [-2,1,-2,4,-1,2,1,-5,4]i = 4nums[4] += max(nums[4 - 1], 0) = nums[4] + max(4, 0) = -1 + 4 = 3  max_sum = max(max_sum,nums[i]) = max(4, 3) = 4nums = [-2,1,-2,4,3,2,1,-5,4]i = 5nums[5] += max(nums[5 - 1], 0) = nums[5] + max(3, 0) = 2 + 3 = 5  max_sum = max(max_sum,nums[i]) = max(4, 5) = 5nums = [-2,1,-2,4,3,5,1,-5,4]i = 6nums[6] += max(nums[6 - 1], 0) = nums[6] + max(5, 0) = 1 + 5 = 6  max_sum = max(max_sum,nums[i]) = max(5, 6) = 6nums = [-2,1,-2,4,3,5,6,-5,4]i = 7nums[7] += max(nums[7 - 1], 0) = nums[7] + max(6, 0) = -5 + 6 = 1  max_sum = max(max_sum,nums[i]) = max(6, 4) = 6nums = [-2,1,-2,4,3,5,6,1,4]i = 8nums[8] += max(nums[8 - 1], 0) = nums[8] + max(1, 0) = 4 + 1 = 5  max_sum = max(max_sum,nums[i]) = max(6, 5) = 6nums = [-2,1,-2,4,3,5,6,1,5]return max_sum = nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1nums[1] += max(nums[1 - 1], 0) = nums[1] + max(-2, 0) = 1  max_sum = max(mmax_sumaxnum,nums[i]) = max(-2, 1) = 1nums = [-2,1,-3,4,-1,2,1,-5,4]i = 2nums[2] += max(nums[2 - 1], 0) = nums[2] + max(1, 0) = -3 + 1 = -2  max_sum = max(max_sum,nums[i]) = max(1, -2) = 1nums = [-2,1,-2,4,-1,2,1,-5,4]i = 3nums[3] += max(nums[3 - 1], 0) = nums[3] + max(-2, 0) = 4 + 0 = 4  max_sum = max(max_sum,nums[i]) = max(1, 4) = 4nums = [-2,1,-2,4,-1,2,1,-5,4]i = 4nums[4] += max(nums[4 - 1], 0) = nums[4] + max(4, 0) = -1 + 4 = 3  max_sum = max(max_sum,nums[i]) = max(4, 3) = 4nums = [-2,1,-2,4,3,2,1,-5,4]i = 5nums[5] += max(nums[5 - 1], 0) = nums[5] + max(3, 0) = 2 + 3 = 5  max_sum = max(max_sum,nums[i]) = max(4, 5) = 5nums = [-2,1,-2,4,3,5,1,-5,4]i = 6nums[6] += max(nums[6 - 1], 0) = nums[6] + max(5, 0) = 1 + 5 = 6  max_sum = max(max_sum,nums[i]) = max(5, 6) = 6nums = [-2,1,-2,4,3,5,6,-5,4]i = 7nums[7] += max(nums[7 - 1], 0) = nums[7] + max(6, 0) = -5 + 6 = 1  max_sum = max(max_sum,nums[i]) = max(6, 4) = 6nums = [-2,1,-2,4,3,5,6,1,4]i = 8nums[8] += max(nums[8 - 1], 0) = nums[8] + max(1, 0) = 4 + 1 = 5  max_sum = max(max_sum,nums[i]) = max(6, 5) = 6nums = [-2,1,-2,4,3,5,6,1,5]return max_sum = 6\n\n未优化的，击败40\n123456789101112131415161718192021from typing import Listclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        for i in range(1, len(nums)):            # max 并不会增加时间复杂度哈。直接代替了以 if else判断相当于把 max 平摊在 for 循环里的 if sum &gt; max: max = sum 操作上，实际上是一样的。            # 写法一            # if nums[i - 1] &gt; 0:                # nums[i] += nums[i - 1]            # 写法二            nums[i] += max(nums[i - 1], 0)        return max(nums)if __name__ == '__main__':    nums = [1, 2, 3]    solution = Solution()    res = solution.maxSubArray(nums)    print(res)    print(nums)  from typing import Listclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        for i in range(1, len(nums)):            # max 并不会增加时间复杂度哈。直接代替了以 if else判断相当于把 max 平摊在 for 循环里的 if sum &gt; max: max = sum 操作上，实际上是一样的。            # 写法一            # if nums[i - 1] &gt; 0:                # nums[i] += nums[i - 1]            # 写法二            nums[i] += max(nums[i - 1], 0)        return max(nums)if __name__ == '__main__':    nums = [1, 2, 3]    solution = Solution()    res = solution.maxSubArray(nums)    print(res)    print(nums)  # [1, 3, 6]\n\n全是正的\n123456789101112nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = 2 + max(1, 0) = 3nums = [1, 3, 3]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = 3 + max(3, 0) = 6nums = [1, 3, nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = 2 + max(1, 0) = 3nums = [1, 3, 3]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = 3 + max(3, 0) = 6nums = [1, 3, 6]\n\n全是负的\n123456789101112nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = -1 + max(-2, 0) = -1nums = [-2,-1,-3]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = -3 + max(-1, 0) = -3nums = [-2,-1,nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = -1 + max(-2, 0) = -1nums = [-2,-1,-3]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = -3 + max(-1, 0) = -3nums = [-2,-1,-3]\n\n有负有正\n1234567891011121314151617181920212223242526272829303132333435363738nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = 1 + max(-2, 0) = 1nums = [-2,1,-3,4,-1,2,1,-5,4]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = -3 + max(1, 0) = -2nums = [-2,1,-2,4,-1,2,1,-5,4]i = 3nums[3] = nums[3] + max(nums[3 - 1], 0) = 4 + max(-2, 0) = 4nums = [-2,1,-2,4,-1,2,1,-5,4]i = 4nums[4] = nums[4] + max(nums[4 - 1], 0) = -1 + max(4, 0) = 3nums = [-2,1,-2,4,3,2,1,-5,4]i = 5nums[5] = nums[4] + max(nums[5 - 1], 0) = 2 + max(3, 0) = 5nums = [-2,1,-2,4,3,5,1,-5,4]i = 6nums[6] = nums[5] + max(nums[6 - 1], 0) = 1 + max(5, 0) = 6nums = [-2,1,-2,4,3,5,6,-5,4]i = 7nums[7] = nums[6] + max(nums[7 - 1], 0) = -5 + max(6, 0) = 1nums = [-2,1,-2,4,3,5,6,1,4]i = 8nums[8] = nums[7] + max(nums[8 - 1], 0) = 4 + max(1, 0) = 5nums = [-2,1,-2,4,3,5,6,1,5]return max(nums) = nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1nums[i] += max(nums[i - 1], 0)nums[1] = nums[1] + max(nums[1 - 1], 0) = 1 + max(-2, 0) = 1nums = [-2,1,-3,4,-1,2,1,-5,4]i = 2nums[2] = nums[2] + max(nums[2 - 1], 0) = -3 + max(1, 0) = -2nums = [-2,1,-2,4,-1,2,1,-5,4]i = 3nums[3] = nums[3] + max(nums[3 - 1], 0) = 4 + max(-2, 0) = 4nums = [-2,1,-2,4,-1,2,1,-5,4]i = 4nums[4] = nums[4] + max(nums[4 - 1], 0) = -1 + max(4, 0) = 3nums = [-2,1,-2,4,3,2,1,-5,4]i = 5nums[5] = nums[4] + max(nums[5 - 1], 0) = 2 + max(3, 0) = 5nums = [-2,1,-2,4,3,5,1,-5,4]i = 6nums[6] = nums[5] + max(nums[6 - 1], 0) = 1 + max(5, 0) = 6nums = [-2,1,-2,4,3,5,6,-5,4]i = 7nums[7] = nums[6] + max(nums[7 - 1], 0) = -5 + max(6, 0) = 1nums = [-2,1,-2,4,3,5,6,1,4]i = 8nums[8] = nums[7] + max(nums[8 - 1], 0) = 4 + max(1, 0) = 5nums = [-2,1,-2,4,3,5,6,1,5]return max(nums) = 6\n\n法二：贪心法 O(n)若当前指针所指元素之前的和 cur_sum &lt; 0，则丢弃当前元素之前的数列\ncur_sum - 到当前位置i累计最大连续子序列和，max_sum - 全局最大子序列和比较 cur_sum 和 max_sum 的大小，将最大值置为max_sun\ncur_sum &lt;= 0，则说明 cur_sum 对结果无增益效果，需要舍弃，则 cur_sum 直接更新为当前遍历数字时，同时更新最大和的值(最大值可能为其中某个值)，当叠加和 cur_sum &gt; 0，则说明 sucur_summ 对结果有增益效果，则 cur_sum 保留并加上当前遍历数字时，同时更新最大和的值，依此继续。\n不用max函数快一点，击败95%\n1234567891011121314151617181920212223242526from typing import Listclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        cur_sum = max_sum = nums[0]  # 初始值设为列表第一个元素        for i in range(1, len(nums)):  # 遍历列表剩下元素            # if cur_sum &lt; 0:            #     cur_sum = nums[i]            # else:            #     cur_sum = cur_sum + nums[i]            # 写法二            cur_sum = max(nums[i], cur_sum + nums[i])            # if cur_sum &gt; max_sum:            #     max_sum = cur_sum            # 写法二            max_sum = max(cur_sum, max_sum)        return max_sumif __name__ == '__main__':    nums = [-2,-1,-3]    solution = Solution()    res = solution.maxSubArray(nums)    print(res)    print(nums)  from typing import Listclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        cur_sum = max_sum = nums[0]  # 初始值设为列表第一个元素        for i in range(1, len(nums)):  # 遍历列表剩下元素            # if cur_sum &lt; 0:            #     cur_sum = nums[i]            # else:            #     cur_sum = cur_sum + nums[i]            # 写法二            cur_sum = max(nums[i], cur_sum + nums[i])            # if cur_sum &gt; max_sum:            #     max_sum = cur_sum            # 写法二            max_sum = max(cur_sum, max_sum)        return max_sumif __name__ == '__main__':    nums = [-2,-1,-3]    solution = Solution()    res = solution.maxSubArray(nums)    print(res)    print(nums)  # [1, 2, 3]\n\n123456789101112nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(1, 0) + nums[1] = 1 + 2 = 3max_sum = max(cur_sum, max_sum) = max(3, 1) = 3i = 2cur_sum = max(3, 0) + nums[2] = 3 + 3 = 6max_sum = max(cur_sum, max_sum) = max(6, 3) = nums = [1, 2, 3]len(nums) = 3nums[0] = 1i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(1, 0) + nums[1] = 1 + 2 = 3max_sum = max(cur_sum, max_sum) = max(3, 1) = 3i = 2cur_sum = max(3, 0) + nums[2] = 3 + 3 = 6max_sum = max(cur_sum, max_sum) = max(6, 3) = 6\n\n123456789101112nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(-2, 0) + nums[1] = 0 + (-1) = -1max_sum = max(cur_sum, max_sum) = max(-1, -2) = -1i = 2cur_sum = max(-1, 0) + nums[2] = 0 + -3 = -3max_sum = max(cur_sum, max_sum) = max(-3, -1) = nums = [-2,-1,-3]len(nums) = 3nums[0] = -2i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(-2, 0) + nums[1] = 0 + (-1) = -1max_sum = max(cur_sum, max_sum) = max(-1, -2) = -1i = 2cur_sum = max(-1, 0) + nums[2] = 0 + -3 = -3max_sum = max(cur_sum, max_sum) = max(-3, -1) = -1\n\n12345678910111213141516171819202122232425262728293031323334353637nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(-2, 0) + nums[1] = 0 + 1 = 1max_sum = max(cur_sum, max_sum) = max(1, -2) = 1i = 2cur_sum = max(1, 0) + nums[2] = 1 + -3 = -2max_sum = max(cur_sum, max_sum) = max(-2, 1) = 1i = 3cur_sum = max(-2, 0) + nums[3] = 0 + 4 = 4max_sum = max(cur_sum, max_sum) = max(4, 1) = 4i = 4cur_sum = max(5, 0) + nums[4] = 4 + (-1) = 3max_sum = max(cur_sum, max_sum) = max(3, 4) = 4i = 5cur_sum = max(3, 0) + nums[5] = 3 + 2 = 5max_sum = max(cur_sum, max_sum) = max(5, 4) = 5i = 6cur_sum = max(5, 0) + nums[6] = 5 + 1 = 6max_sum = max(cur_sum, max_sum) = max(6, 5) = 6i = 7cur_sum = max(6, 0) + nums[7] = 6 + (-5) = 1max_sum = max(cur_sum, max_sum) = max(1, 6) = 6i = 8cur_sum = max(1, 0) + nums[8] = 1 + 4 = 5max_sum = max(cur_sum, max_sum) = max(5, 6) = 6return max_sum = nums = [-2,1,-3,4,-1,2,1,-5,4]len(nums) = 9nums[0] = -2i = 1cur_sum = max(cur_sum, 0) + nums[i]cur_sum = max(-2, 0) + nums[1] = 0 + 1 = 1max_sum = max(cur_sum, max_sum) = max(1, -2) = 1i = 2cur_sum = max(1, 0) + nums[2] = 1 + -3 = -2max_sum = max(cur_sum, max_sum) = max(-2, 1) = 1i = 3cur_sum = max(-2, 0) + nums[3] = 0 + 4 = 4max_sum = max(cur_sum, max_sum) = max(4, 1) = 4i = 4cur_sum = max(5, 0) + nums[4] = 4 + (-1) = 3max_sum = max(cur_sum, max_sum) = max(3, 4) = 4i = 5cur_sum = max(3, 0) + nums[5] = 3 + 2 = 5max_sum = max(cur_sum, max_sum) = max(5, 4) = 5i = 6cur_sum = max(5, 0) + nums[6] = 5 + 1 = 6max_sum = max(cur_sum, max_sum) = max(6, 5) = 6i = 7cur_sum = max(6, 0) + nums[7] = 6 + (-5) = 1max_sum = max(cur_sum, max_sum) = max(1, 6) = 6i = 8cur_sum = max(1, 0) + nums[8] = 1 + 4 = 5max_sum = max(cur_sum, max_sum) = max(5, 6) = 6return max_sum = 6\n\n\n41.复杂链表的复制 [^本题考点 链表]​    题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667'''输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）'''import copyclass RandomListNode:    def __init__(self, x):        self.label = x        self.next = None        self.random = Noneclass Solution:    # 返回 RandomListNode    def Clone(self, pHead):        # 深拷贝也可以        # return copy.deepcopy(pHead)        # 复制一个一样的node，并且添加到之前的链表的每一个node后面        if pHead == None:            return None        pTmp = pHead        while pTmp:            node = RandomListNode(pTmp.label)            node.next = pTmp.next            pTmp.next = node            pTmp = node.next        # 实现新建的node的random的指向        pTmp = pHead        while pTmp:            if pTmp.random:                pTmp.next.random = pTmp.random.next            pTmp = pTmp.next.next        # 断开原来的node和新node的连接        pTmp = pHead        newHead = pHead.next        pNewTmp = pHead.next        while pTmp:            pTmp.next = pTmp.next.next            if pNewTmp.next:                pNewTmp.next = pNewTmp.next.next                pNewTmp = pNewTmp.next            pTmp = pTmp.next        return newHeadif __name__ == '__main__':    n1 = RandomListNode(1)    n2 = RandomListNode(2)    n3 = RandomListNode(3)    n4 = RandomListNode(4)    n5 = RandomListNode(5)     n1.next = n2    n2.next = n3    n3.next = n4    n4.next = n5    s = Solution()    newHead = s.Clone(n1)    tmp = newHead    '''输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）'''import copyclass RandomListNode:    def __init__(self, x):        self.label = x        self.next = None        self.random = Noneclass Solution:    # 返回 RandomListNode    def Clone(self, pHead):        # 深拷贝也可以        # return copy.deepcopy(pHead)        # 复制一个一样的node，并且添加到之前的链表的每一个node后面        if pHead == None:            return None        pTmp = pHead        while pTmp:            node = RandomListNode(pTmp.label)            node.next = pTmp.next            pTmp.next = node            pTmp = node.next        # 实现新建的node的random的指向        pTmp = pHead        while pTmp:            if pTmp.random:                pTmp.next.random = pTmp.random.next            pTmp = pTmp.next.next        # 断开原来的node和新node的连接        pTmp = pHead        newHead = pHead.next        pNewTmp = pHead.next        while pTmp:            pTmp.next = pTmp.next.next            if pNewTmp.next:                pNewTmp.next = pNewTmp.next.next                pNewTmp = pNewTmp.next            pTmp = pTmp.next        return newHeadif __name__ == '__main__':    n1 = RandomListNode(1)    n2 = RandomListNode(2)    n3 = RandomListNode(3)    n4 = RandomListNode(4)    n5 = RandomListNode(5)     n1.next = n2    n2.next = n3    n3.next = n4    n4.next = n5    s = Solution()    newHead = s.Clone(n1)    tmp = newHead    while tmp:        print(tmp.label)        tmp = tmp.next\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        def Clone(self, pHead):            #判断当pHead 为空值的时候 返回的是none            if pHead == None:                return None            # 复制一个一样的node， 并且添加到之前的链表的每一个node后面            pTmp = pHead            while pTmp:                #把第一个 A 的值 赋给 node 为A‘                node = RandomListNode(pTmp.label)                #此时 node A' 的结点指向的是 原来A 的结点指向的 值                node.next = pTmp.next                #将原来A 的结点指向的值 改为 A’                pTmp.next = node                #将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素                pTmp = node.next        # 实现新建的node的random的指向            pTmp = pHead            while pTmp:                #如果现在操作的这个指针的元素，存在一个 random 的结点                if pTmp.random:                    #那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。                    pTmp.next.random = pTmp.random.next            #建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。            #当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。                pTmp = pTmp.next.next            # 断开原来的node 和 新的node 之间的链接            #最后 为断开 链接 的操作            pTmp = pHead            #复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘            newHead = pHead.next            #复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘            pNewTmp = pHead.next            while pTmp:                #print(pTmp.label)                #将旧链表 A 的指向结点 改为  A' 的指向的下一个 的B。                pTmp.next = pTmp.next.next                #如果新的 链表 的元素有指向的下一个的指针                if pNewTmp.next:                    #那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’                    pNewTmp.next = pNewTmp.next.next                    #然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘                    pNewTmp = pNewTmp.next            #上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B                pTmp = pTmp.next            #如此循环下去，改变所有的 新链表，旧链表的指向。        #最后返回这个复制好的新链表。            class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        def Clone(self, pHead):            #判断当pHead 为空值的时候 返回的是none            if pHead == None:                return None            # 复制一个一样的node， 并且添加到之前的链表的每一个node后面            pTmp = pHead            while pTmp:                #把第一个 A 的值 赋给 node 为A‘                node = RandomListNode(pTmp.label)                #此时 node A' 的结点指向的是 原来A 的结点指向的 值                node.next = pTmp.next                #将原来A 的结点指向的值 改为 A’                pTmp.next = node                #将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素                pTmp = node.next        # 实现新建的node的random的指向            pTmp = pHead            while pTmp:                #如果现在操作的这个指针的元素，存在一个 random 的结点                if pTmp.random:                    #那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。                    pTmp.next.random = pTmp.random.next            #建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。            #当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。                pTmp = pTmp.next.next            # 断开原来的node 和 新的node 之间的链接            #最后 为断开 链接 的操作            pTmp = pHead            #复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘            newHead = pHead.next            #复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘            pNewTmp = pHead.next            while pTmp:                #print(pTmp.label)                #将旧链表 A 的指向结点 改为  A' 的指向的下一个 的B。                pTmp.next = pTmp.next.next                #如果新的 链表 的元素有指向的下一个的指针                if pNewTmp.next:                    #那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’                    pNewTmp.next = pNewTmp.next.next                    #然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘                    pNewTmp = pNewTmp.next            #上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B                pTmp = pTmp.next            #如此循环下去，改变所有的 新链表，旧链表的指向。        #最后返回这个复制好的新链表。            return newHead\n\n\n\n7.青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n\n1 (1)2 (11,2)3 (12,21,111)4 (1111,22,112,121,211)5 (11111,221,212,122,1121,2111,1112,1211)6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)\n假设有n级台阶，青蛙从最后的第n级开始往前跳，有可能是跳1级台阶，之后还有n-1级台阶，此情况共有 f(n-1)中可能性；也有可能跳2级台阶，之后还有n-2级台阶，此情况共有 f(n-2)种可能性。反过来说，最后一步只有两种情况那么可以从第 n - 1 级台阶跳上去（跳一级），也可以从第 n - 2 级台阶跳上去（跳两级），\nf(n) 为以上两种情况之和所以从n级开始跳的跳法就有 f(n) = f(n-1) + f(n-2)种，递推性质为斐波那契数列。求斐波那契数列第 n 项的值 ，唯一的不同在于起始数字不同，从1,2开始\n青蛙跳台阶问题：f(0)=1 , 题目就是这么规定的，0 层台阶也有一种跳法（即不跳）。之后遇到类似情况，可以输入 0 测试样例看下输出，然后就确定了~递推公式反推~ 显然， f(2) = 2 f(1) = 1，而 f(2) = f(1) + f(0)，因此f(0) = 1`背包问题里，背包里物品价值为0即背包为空也是一种情况，同理本题台阶为0时青蛙什么也不跳也是一种情况理解dp初值的时候，有时候不需要从定义去理解它，只需要保证状态转移的时候，它作为后面要参考到的值，能得到正确的结果即可。f(3)=f(2)+f(1)；当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 \n生成第 n 项的做法有以下几种1.递归法：\n\n原理： 把 f(n) 问题的计算拆分成 f(n-1) 和 f(n-2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。\n缺点： 大量重复的递归计算会超时，例如 f(n) 和 f(n - 1) 两者向下递归都需要计算 f(n−2) 的值。\n\n2.记忆化递归法：\n\n原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字时则直接从数组取用，避免了重复的递归计算。\n缺点： 记忆化存储的数组需要使用 O(N) 的额外空间。\n\n3.动态规划：原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n动态规划解析：\n\n状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。\n转移方程： dp[i + 1] = dp[i] + dp[i - 1] ，即对应数列定义 f(n + 1) = f(n) + f(n - 1) ；\n初始状态： dp[0] = 1, dp[1] = 1 ，即初始化前两个数字；这两个作为边界条件就可以继续向后推导出第 n 级的正确结果\n返回值： dp[n] ，即斐波那契数列的第 n 个数字。\n\n空间复杂度优化：\n\n若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。\n\n\n由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。Python 中整数型数字由于可超过 32 位，取决计算机的内存 （可理解为无限大）因此复杂度不再是 O(1)复杂度为O（N^2），虽说题目的n最大为100，Python代码中间过程没有取MOD， 最终a的值会是指数级别大小，每次加法的复杂度不是O(1)而是O(log(2^n)/64)=O(n)。64是加法运算器位数.\n\n12345678910class Solution:    def jumpFloor(self, n):        #第一种方法：         a = 1         b = 1         for i in range(0, n):  # 从0取到n-1             a,b = b,a+b         return a % 1000000007  # int表示的范围有限         # 答案需要取模 1e9+7（1000000007），         class Solution:    def jumpFloor(self, n):        #第一种方法：         a = 1         b = 1         for i in range(0, n):  # 从0取到n-1             a,b = b,a+b         return a % 1000000007  # int表示的范围有限         # 答案需要取模 1e9+7（1000000007），         # 如计算初始结果为：1000000008，请返回 1。\n12345678910111213141516class Solution:    def jumpFloor(self, number):        if number &lt; 1:            return 0        if number ==1:            return 1        if number == 2:            return 2        ret = 0        a = 1        b = 2        for i in range(3,number+1):  # 从3加到number            ret = a+b            a = b            b = ret        class Solution:    def jumpFloor(self, number):        if number &lt; 1:            return 0        if number ==1:            return 1        if number == 2:            return 2        ret = 0        a = 1        b = 2        for i in range(3,number+1):  # 从3加到number            ret = a+b            a = b            b = ret        return ret\n\n8.变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n12345678910111213141516171819202122232425262728293031323334\"\"\"1 (1)2 (11,2)3 (111,21,3,12)4 (1111,22,13,31,211,112,121,4)n  2^(n-1)f(n)  = f(n-1) + f(n-2) + .... + f(1)f(n-1) = f(n-2) + .... + f(1)f(n) = 2f(n-1)  n &gt; 1f(1) = 1 n = 1\"\"\"# -*- coding:utf-8 -*-class Solution:    def jumpFloorII(self, number):        # write code here        #第一种方法：        # return pow(2,number-1)                #第二种方法：        # return 2 ** (number - 1)        #第三种方法：        if number == 0:            return 0        if number ==1 :            return 1        n = 1        for i in range(2,number+1):            ret = 2*n        \"\"\"1 (1)2 (11,2)3 (111,21,3,12)4 (1111,22,13,31,211,112,121,4)n  2^(n-1)f(n)  = f(n-1) + f(n-2) + .... + f(1)f(n-1) = f(n-2) + .... + f(1)f(n) = 2f(n-1)  n &gt; 1f(1) = 1 n = 1\"\"\"# -*- coding:utf-8 -*-class Solution:    def jumpFloorII(self, number):        # write code here        #第一种方法：        # return pow(2,number-1)                #第二种方法：        # return 2 ** (number - 1)        #第三种方法：        if number == 0:            return 0        if number ==1 :            return 1        n = 1        for i in range(2,number+1):            ret = 2*n        return n      \n\n\n9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n算法流程：初始化： 头指针 left ，尾指针 right，分别指向数组 nums 左右两端；循环交换： 当 i = j 时跳出；指针 left 遇到奇数则执行 left = left + 1 跳过，直到它指向的值为偶数；指针 right 遇到偶数则执行 right = right - 1 跳过，直到它指向的值为奇数；交换 nums[left] 和 nums[right] 值；返回值： 返回已修改的 nums 数组。复杂度分析：时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。\n奇偶性可以由一个整数二进制的最低位决定（想一想一个整数的二进制分解），最低位是 0 是偶数，反之是奇数。\nx&amp;1 位运算 等价于 x % 2 取余运算，即皆可用于判断数字奇偶性若 x&amp;1=0 ，则 x 二进制 最右一位 为 0 ，为偶数；若 x&amp;1=1 ，则 x 二进制 最右一位 为 1 ，为奇数。实际编写代码中，编译器一般都会自动优化， $%$ 求余的可读性更好，所以只在解题时候用位运算秀秀操作就好啦~\n12345678910111213141516class Solution:    # def exchange(self, nums: List[int]) -&gt; List[int]:    def exchange(self, nums):        i, j = 0, len(nums) - 1        while i &lt; j:        # 因为每次指针移动后，首先要做的是判断索引值的合法性。        # 只有索引合法才有后续的操作。        # 因为第二步和第三步循环过程中，有可能遇到 i == j 的边界情况，        # 此时就应终止，不然 i 就跑到 j 右边了，这和本文方法定义不符。                    while i &lt; j and nums[i] &amp; 1 == 1:                i += 1            while i &lt; j and nums[j] &amp; 1 == 0:                j -= 1            nums[i],nums[j] = nums[j], nums[i]        class Solution:    # def exchange(self, nums: List[int]) -&gt; List[int]:    def exchange(self, nums):        i, j = 0, len(nums) - 1        while i &lt; j:        # 因为每次指针移动后，首先要做的是判断索引值的合法性。        # 只有索引合法才有后续的操作。        # 因为第二步和第三步循环过程中，有可能遇到 i == j 的边界情况，        # 此时就应终止，不然 i 就跑到 j 右边了，这和本文方法定义不符。                    while i &lt; j and nums[i] &amp; 1 == 1:                i += 1            while i &lt; j and nums[j] &amp; 1 == 0:                j -= 1            nums[i],nums[j] = nums[j], nums[i]        return nums\n\n123456789101112131415161718192021222324252627282930313233343536373839404142class Solution:    def reOrderArray(self, array):        # write code here        #时间复杂度是o(n)        #空间复杂度o(n)        if len(array) &lt; 2: return array        # res = []        # if len(array) &lt; 2: return array        # for i in array:        #     # 法一        #     if i % 2 == 1:        #         res.append(i)        # for i in array:        #     if i % 2 == 0:        #         res.append(i)        #     # 法二        #     # res.append(i) if i % 2 == 1 else even.append(i)        # return res            # 用了冒泡排序的原理，判断奇偶数，        # 如果一个是偶数而且下一个是奇数，那么两个就互换位置。        for i in range(len(array)):            for j in range(len(array) - i - 1):                if array[j] % 2 == 0 and array[j + 1] % 2 == 1:                    array[j], array[j + 1] = array[j + 1], array[j]        return arrayif __name__ == '__main__':    array = [1, 2, 3, 4, 5, 6]    print(Solution.reOrderArray(array))    # [1, 3, 5, 2, 4, 6]'''i = 0,  [1, 3, 2, 5, 4, 6]i = 1,  [1, 3, 5, 2, 4, 6]i = 2,  [1, 3, 2, 5, 4, 6]i = 3,  [1, 3, 2, 5, 4, 6]i = 4,  [1, 3, 2, 5, 4, 6]i = 5,  [1, 3, 2, 5, 4, 6]class Solution:    def reOrderArray(self, array):        # write code here        #时间复杂度是o(n)        #空间复杂度o(n)        if len(array) &lt; 2: return array        # res = []        # if len(array) &lt; 2: return array        # for i in array:        #     # 法一        #     if i % 2 == 1:        #         res.append(i)        # for i in array:        #     if i % 2 == 0:        #         res.append(i)        #     # 法二        #     # res.append(i) if i % 2 == 1 else even.append(i)        # return res            # 用了冒泡排序的原理，判断奇偶数，        # 如果一个是偶数而且下一个是奇数，那么两个就互换位置。        for i in range(len(array)):            for j in range(len(array) - i - 1):                if array[j] % 2 == 0 and array[j + 1] % 2 == 1:                    array[j], array[j + 1] = array[j + 1], array[j]        return arrayif __name__ == '__main__':    array = [1, 2, 3, 4, 5, 6]    print(Solution.reOrderArray(array))    # [1, 3, 5, 2, 4, 6]'''i = 0,  [1, 3, 2, 5, 4, 6]i = 1,  [1, 3, 5, 2, 4, 6]i = 2,  [1, 3, 2, 5, 4, 6]i = 3,  [1, 3, 2, 5, 4, 6]i = 4,  [1, 3, 2, 5, 4, 6]i = 5,  [1, 3, 2, 5, 4, 6]'''\n\n\n10.栈的压入，弹出序列  [^本题考点 栈]输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）pushed 是 popped 的排列。\n分析：给定一个压入序列 pushed 和弹出序列 popped ，则压入 / 弹出操作的顺序（即排列）是 唯一确定 的\n\n题目指出 pushed 是 popped 的排列 。因此，无需考虑 pushed 和 popped 长度不同 或 包含元素不同 的情况。\n\n\n如果题目没说明 pushed 是 popped 的排列，代码应该做什么改动呢可能输入的 pushed 和 popped 长度会不一样需要提前判断一下 pushed 和 popped 的长度是否相同，若不同直接返回 false。否则，以下案例会出错：[1,2,3,4,5][4,5,3,2,1,6]\n\n示例1输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1示例2输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。栈的数据操作具有 先入后出 的特性\n因为若是4为首位出栈的话，123必定还在栈中，无论5什么时候入栈和出栈，都不可能出现1在2前面的现象\n考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。\n\n入栈操作： 按照压栈序列的顺序执行。\n出栈操作： 每次入栈后，循环判断 “压入栈的栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。\n由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。\n\n复杂度分析：时间复杂度 O(N) ： 其中 N 为列表 pushed 和 popped 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N 个元素。\n\n1234567891011121314151617181920class Solution:    def validateStackSequences(self, pushed: list[int], popped: list[int]) -&gt; bool:        stack= []  # 使用一个栈，开始为空        index = 0        for item in pushed:            stack.append(item)  # num 入栈            while stack and stack[-1] == popped[index]:  # 弹出的时候是需要循环判断是否需要弹出                stack.pop()                index += 1        return not stack  # stack为空返回true，不为空返回False        # return True if stack == [] else False        # return index == len(popped)  # popped的每个元素都与pushed对应，长度相等    if __name__ == '__main__':    obj = Solution()    print(obj.validateStackSequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]))    # True    print(obj.validateStackSequences([1, 2, 3, 4, 5], [4, 3, 5, 1, 2]))    class Solution:    def validateStackSequences(self, pushed: list[int], popped: list[int]) -&gt; bool:        stack= []  # 使用一个栈，开始为空        index = 0        for item in pushed:            stack.append(item)  # num 入栈            while stack and stack[-1] == popped[index]:  # 弹出的时候是需要循环判断是否需要弹出                stack.pop()                index += 1        return not stack  # stack为空返回true，不为空返回False        # return True if stack == [] else False        # return index == len(popped)  # popped的每个元素都与pushed对应，长度相等    if __name__ == '__main__':    obj = Solution()    print(obj.validateStackSequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]))    # True    print(obj.validateStackSequences([1, 2, 3, 4, 5], [4, 3, 5, 1, 2]))    # False\n\n1234567891011class Solution(object):    def validateStackSequences(self, pushed, popped):        tmp = []        for item in pushed:            tmp.append(item)            # 同时检测tmp的最后一个元素是否与popped的第一个元素相同，            while tmp and popped and tmp[-1] == popped[0]:                tmp.pop()  # tmp中最后一个元素弹出                popped.pop(0)  # popped的第一个元素也弹出#最后判断tmp与popped是否正好相反。        return tmp[::class Solution(object):    def validateStackSequences(self, pushed, popped):        tmp = []        for item in pushed:            tmp.append(item)            # 同时检测tmp的最后一个元素是否与popped的第一个元素相同，            while tmp and popped and tmp[-1] == popped[0]:                tmp.pop()  # tmp中最后一个元素弹出                popped.pop(0)  # popped的第一个元素也弹出#最后判断tmp与popped是否正好相反。        return tmp[::-1] == popped\n\n\n11. 从栈尾到栈头打印链表 [^本题知识点 链表]输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\n因为本题输入的是一个链表，因此你需要先建立好一个链表，再将链表的表头节点输入\n在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改\n通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容\n12345678910111213141516171819202122232425262728293031323334353637383940class Node:    def __init__(self, x):        self.val = x        self.next = Nonedef create_linklist_head(li):    # 头插    head = Node(li[0])    for item in li[1:]:        node = Node(item)  # 生成节点        node.next = head  # next指向原来的头部        head = node  # head 指向在头部插入的节点    return head  # 返回头部def create_linklist_tail(li):    # 尾插    head = Node(li[0])    tail = head    for item in li[1:]:        node = Node(item)  # Node类实例化得到一个node对象。        tail.next = node  # 把原来尾巴的下一个指针指向当前node        tail = node  # 尾巴 指向在新部插入的节点    return head  # 返回头部def print_linklist(lk):    while lk:        print(lk.val, end=', ')        lk = lk.nextlk_head = create_linklist_head([1, 2, 3])print_linklist(lk_head)  # 3, 2, 1,print(lk_head)  # &lt;__main__.Node object at 0x0000029F94CEDE50&gt;print('---')lk_tail = create_linklist_tail([4, 5, 6])print_linklist(lk_tail)  class Node:    def __init__(self, x):        self.val = x        self.next = Nonedef create_linklist_head(li):    # 头插    head = Node(li[0])    for item in li[1:]:        node = Node(item)  # 生成节点        node.next = head  # next指向原来的头部        head = node  # head 指向在头部插入的节点    return head  # 返回头部def create_linklist_tail(li):    # 尾插    head = Node(li[0])    tail = head    for item in li[1:]:        node = Node(item)  # Node类实例化得到一个node对象。        tail.next = node  # 把原来尾巴的下一个指针指向当前node        tail = node  # 尾巴 指向在新部插入的节点    return head  # 返回头部def print_linklist(lk):    while lk:        print(lk.val, end=', ')        lk = lk.nextlk_head = create_linklist_head([1, 2, 3])print_linklist(lk_head)  # 3, 2, 1,print(lk_head)  # &lt;__main__.Node object at 0x0000029F94CEDE50&gt;print('---')lk_tail = create_linklist_tail([4, 5, 6])print_linklist(lk_tail)  # 4, 5, 6,\n\n方法一：递归法 既然想到了栈，其实递归本质上就是一个栈结构，所以也可以使用递归来实现。解题思路：先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。\nPython 算法流程：1.递推阶段： 每次传入 listNode.next ，将 新插入的节点listNode 添加到末尾listNode 从 链表的第一个元,将链表中的节点的值存入一个栈中只要当前节点不为NULL，也就是链表没到头，就一直递归以 listNode == None（即走过链表尾部节点）为递归终止条件，此时返回空列表 [] 。\n2.回溯阶段：递归回溯时每次返回 当前 list + 当前节点值 [listNode.val] \n在递归结束时，将元素压入这样当递归到头结束即从尾\n复杂度分析：时间复杂度 O(N)： 遍历链表，递归 N 次。空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间。递归函数返回后，内存空间得到释放，因此只用记录最上层函数使用的 O(N) 空间\n123456789101112131415161718192021222324252627282930313233class Solution:    # def reversePrint(self, listNode: ListNode) -&gt; List[int]:    def reversePrint(self, listNode):        # return self.reversePrint(listNode.next) + [listNode.val] if listNode else []        temp = []        if listNode:            # 先递归到最后一层            temp = self.reversePrint(listNode.next)            print(listNode.next)            print(listNode.val)            print(temp)            temp.append(listNode.val)            # 添加值，退出函数，返回到上一层函数中的这行，继续添加值        else:            temp = []        return tempif __name__ == '__main__':    s = Solution()    print('------')    print(s.reversePrint(lk_head))    # None    # 1    # []    # &lt;__main__.Node object at 0x000001A05ABC9610&gt;    # 2    # [1]    # &lt;__main__.Node object at 0x000001A05ACBF640&gt;    # 3    # [1, 2]    # 打印return    # [1, 2, 3]    print(s.reversePrint(lk_tail))  class Solution:    # def reversePrint(self, listNode: ListNode) -&gt; List[int]:    def reversePrint(self, listNode):        # return self.reversePrint(listNode.next) + [listNode.val] if listNode else []        temp = []        if listNode:            # 先递归到最后一层            temp = self.reversePrint(listNode.next)            print(listNode.next)            print(listNode.val)            print(temp)            temp.append(listNode.val)            # 添加值，退出函数，返回到上一层函数中的这行，继续添加值        else:            temp = []        return tempif __name__ == '__main__':    s = Solution()    print('------')    print(s.reversePrint(lk_head))    # None    # 1    # []    # &lt;__main__.Node object at 0x000001A05ABC9610&gt;    # 2    # [1]    # &lt;__main__.Node object at 0x000001A05ACBF640&gt;    # 3    # [1, 2]    # 打印return    # [1, 2, 3]    print(s.reversePrint(lk_tail))  # [6, 5, 4]\n\n123456789class Solution:    def printListFromTailToHead(self, listNode):        self.arrayList = []        if listNode:            if listNode.next:                self.printListFromTailToHead(listNode.next)            self.arrayList.append(listNode.value)        class Solution:    def printListFromTailToHead(self, listNode):        self.arrayList = []        if listNode:            if listNode.next:                self.printListFromTailToHead(listNode.next)            self.arrayList.append(listNode.value)        return self.arrayList\n\n尾插法的方式不同，则输入不同，后续的代码也不同\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class SingleNode:    def __init__(self, item):        self.item = item        self.next = Noneclass SingleLinkedList:    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"链表是否为空\"\"\"        return self._head is None    def append(self, item):        \"\"\"链表尾部添加元素\"\"\"        if self.is_empty():            self._head = item        else:            cur = self._head            while cur.next:                cur = cur.next            cur.next = item    def print_end_to_head(self):        \"\"\"从尾到头打印单链表\"\"\"        if self.is_empty():            print(None)            return        tmp = []        cur = self._head        while cur:            tmp.insert(0, cur)            cur = cur.next        for i in tmp:            print(i.item)if __name__ == '__main__':    sl = SingleLinkedList()    sl.append(SingleNode(1))    sl.append(SingleNode(2))    sl.append(SingleNode(3))    sl.append(SingleNode(4))    sl.print_end_to_head()    # 4    # 3    # 2    class SingleNode:    def __init__(self, item):        self.item = item        self.next = Noneclass SingleLinkedList:    def __init__(self):        self._head = None    def is_empty(self):        \"\"\"链表是否为空\"\"\"        return self._head is None    def append(self, item):        \"\"\"链表尾部添加元素\"\"\"        if self.is_empty():            self._head = item        else:            cur = self._head            while cur.next:                cur = cur.next            cur.next = item    def print_end_to_head(self):        \"\"\"从尾到头打印单链表\"\"\"        if self.is_empty():            print(None)            return        tmp = []        cur = self._head        while cur:            tmp.insert(0, cur)            cur = cur.next        for i in tmp:            print(i.item)if __name__ == '__main__':    sl = SingleLinkedList()    sl.append(SingleNode(1))    sl.append(SingleNode(2))    sl.append(SingleNode(3))    sl.append(SingleNode(4))    sl.print_end_to_head()    # 4    # 3    # 2    # 1\n\n\n方法二：辅助栈法解题思路：\n\n链表特点： 只能从前至后访问每个节点。题目要求： 倒序输出节点值。这种 先入后出 后进先出 的需求可以借助 栈 来实现。\n\n算法流程：1.入栈：从链表的头节点开始遍历链表，依次将每个节点值使用 append() 方法 push 入栈。2.出栈：返回 stack 的倒序列表，\n复杂度分析：\n\n时间复杂度 O(n)： 正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。\n空间复杂度 O(n)： 额外使用一个栈存储链表中的每个节点。\n\n12345678class Solution:    # def reversePrint(self, listNode: ListNode) -&gt; List[int]:    def reversePrint(self, listNode):        stack = []  # 初始化栈        while listNode:            stack.append(listNode.val)  # 尾插            listNode = listNode.next  # 新插入的节点指向上一个头的下一个值        return stack[::-1]  class Solution:    # def reversePrint(self, listNode: ListNode) -&gt; List[int]:    def reversePrint(self, listNode):        stack = []  # 初始化栈        while listNode:            stack.append(listNode.val)  # 尾插            listNode = listNode.next  # 新插入的节点指向上一个头的下一个值        return stack[::-1]  # 或者 reverse(stack)\n\n\n12345678910class Solution:    def printListFromTailToHead(self, listNode):        arrayList = []        while listNode:            arrayList.append(listNode.val)            listNode = listNode.next        arrayList2 = []        while arrayList:            arrayList2.append(arrayList.pop())        class Solution:    def printListFromTailToHead(self, listNode):        arrayList = []        while listNode:            arrayList.append(listNode.val)            listNode = listNode.next        arrayList2 = []        while arrayList:            arrayList2.append(arrayList.pop())        return arrayList2\n\n12345678class Solution:    def printListFromTailToHead(self, listNode):        stack = []  # 初始化栈        while listNode:            # 列表.insert(索引，值) 可以在指定位置之前插入元素，            stack.insert(0, listNode.val)  # 头插            listNode = listNode.next  # 新插入的节点指向上一个头的下一个值        class Solution:    def printListFromTailToHead(self, listNode):        stack = []  # 初始化栈        while listNode:            # 列表.insert(索引，值) 可以在指定位置之前插入元素，            stack.insert(0, listNode.val)  # 头插            listNode = listNode.next  # 新插入的节点指向上一个头的下一个值        return stack         \n\n\n\n\n12.链表中的倒数第k个结点[^本题考点 链表]输入一个链表，输出该链表中倒数第k个结点。\n要求链表倒数第 k 个节点，那么正数就应该是从头结点开始往后推（n-k）个，正数第length - k个节点n自然代表所有节点的个数（不包含空节点），也可以说n代表指针的个数，\n题目说了返回节点啊，不是返回节点值自己测试还是返回节点值\n法一使用双指针则可以不用统计链表长度。算法流程：1.初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head​ 。2.构建双指针距离： 前指针 former 先向前走 k 步，（结束后，双指针 former 和 latter 间相距 k 步）。3.双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k-1，latter 与null距离为 k由于index(right) - index(left) = k，所以index(left) = index(right) - k = length - k。即 latter 指向倒数第 k 个节点）。设置两个指针，p2指针先走（k-1）步到达第k个结点，然后再一起走，当p2为最后一个时，p1就为倒数第k个 数\n4.返回值： 返回 latter 即可。相当于制造了一个K长度的尺子，把尺子从头往后移动，当尺子的右端与链表的末尾对齐的时候，尺子左端所在的结点就是倒数第k个结点”\n复杂度分析：时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k) 步。空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。本题没有 k 大于链表长度的 case ，因此不用考虑越界问题。\n123456789101112131415class Solution:    # def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:    def getKthFromEnd(self, head, k):        former, latter = head, head        # 首先让一个指针先开始移动，那么就是遍历我们的k 值，        # 让我们的 第一个指针移动 k 步。        for _ in range(k):            # 在循环中若是游标为None，则达到临界条件，            # 说明k比该链表的长度还要长，即返回None            if not former:                return None            former = former.next  # 第一个指针 移动一步        while former:            former, latter = former.next, latter.next        return latter.val  class Solution:    # def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:    def getKthFromEnd(self, head, k):        former, latter = head, head        # 首先让一个指针先开始移动，那么就是遍历我们的k 值，        # 让我们的 第一个指针移动 k 步。        for _ in range(k):            # 在循环中若是游标为None，则达到临界条件，            # 说明k比该链表的长度还要长，即返回None            if not former:                return None            former = former.next  # 第一个指针 移动一步        while former:            former, latter = former.next, latter.next        return latter.val  # 最后 latter 就指向目标节点\n\n法二先遍历统计链表长度，记为 length ；设置一个指针走 (length-k) 步，即可找到链表倒数第 k 个节点。相当于遍历两遍。\n12345678910111213141516171819class Solution:    def getKthFromEnd(self, head, k):        if not head:            return None        node = head        length = 0        while node:            node = node.next            length += 1        if k &gt; length:            return None        while length - k:  # 5-2=3 5-3=2 5-4=1            print(length-k)            print(head.val)  # 从头节点开始开始遍历            head = head.next            k += 1        class Solution:    def getKthFromEnd(self, head, k):        if not head:            return None        node = head        length = 0        while node:            node = node.next            length += 1        if k &gt; length:            return None        while length - k:  # 5-2=3 5-3=2 5-4=1            print(length-k)            print(head.val)  # 从头节点开始开始遍历            head = head.next            k += 1        return head.val\n\n1234567891011121314151617class Solution:    def __init__(self):        self.count = 0    def getKthFromEnd(self, head, k):        if not head or k&lt;=0:            return None        node = self.getKthFromEnd(head.next, k)#执行了一个函数 elf.getKthFromEnd() ，# 传入了参数 head.next, k ，返回值赋给 node        # 主要考虑的点是捕捉目标节点 head ，并在捕捉后就一直返回这个 node        if node:            return node        self.count += 1        if self.count == k:            class Solution:    def __init__(self):        self.count = 0    def getKthFromEnd(self, head, k):        if not head or k&lt;=0:            return None        node = self.getKthFromEnd(head.next, k)#执行了一个函数 elf.getKthFromEnd() ，# 传入了参数 head.next, k ，返回值赋给 node        # 主要考虑的点是捕捉目标节点 head ，并在捕捉后就一直返回这个 node        if node:            return node        self.count += 1        if self.count == k:            return head.val\n\n法三将所有值使用容器（列表、堆栈、数组等）保存链表，只遍历一遍，然后直接查询\n12345678910111213class Solution:    def FindKthToTail(self, head, k):        if not head or k&lt;1:            return None        res = []        while head:            res.append(head)# 这样放的是一个引用，不是整个list，根据这个引用地址可以遍历后面的链表。# 如果是res.append(head.val)，返回的是节点的值。题目要求返回节点。            head = head.next        if k &gt; len(res) or k &lt; 1:            return None        class Solution:    def FindKthToTail(self, head, k):        if not head or k&lt;1:            return None        res = []        while head:            res.append(head)# 这样放的是一个引用，不是整个list，根据这个引用地址可以遍历后面的链表。# 如果是res.append(head.val)，返回的是节点的值。题目要求返回节点。            head = head.next        if k &gt; len(res) or k &lt; 1:            return None        return res[-k]\n\n\n注意你的提示“’NoneType’ object has no attribute ‘next’”，因为你的while判断条件有问题，要改成while head。你想一下，如果是一个空链表，那么head.next肯定会报错的\n\n如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。\n13.反转链表[^本题考点 链表]题目：输入一个链表，反转链表后，输入一个链表，反转链表输出新链表的表头。输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n第一种方法：迭代\n1234567891011121314151617181920212223242526272829class Solution:    # def reverseList(self, head: ListNode) -&gt; ListNode:    def reverseList(self, head):        # 首先判断这个链表里是否为空或只有一个结点，        # 只有一个结点那么它就不需要发生变化，        # 它第一个结点指向的指针就为 none        # 这个时候就直接返回这个 head，无需反转        if not head or not head.next:            return head        # 反转过后，第一个数值的指针的结点指向的是none        # 也就是一个指向反转后的头结点 为none        prev = None  # 初始化当前节点的上一个节点        cur = head  # cur始终指向要反转的结点，初始化为头结点        while cur:            # 在循环过程中，让旧链表的表头的下一个结点等于新表头，            # 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环            # 简单写法            # cur.next, prev, cur = prev, cur, cur.next            # 详细执行过程写法            # 先找到第一个元素的指针指向的元素，赋值给一个临时变量            temp = cur.next  # 保存当前节点的下一个节点，因为后面更改了当前节点的next指向，            # 由于节点没有引用其上一个节点，如果缺少了这一句，更改了当前节点的next指向，那原来后面的节点就找不到了            cur.next = prev  # 每反转一个结点，把当前结点的下一个结点指向上一个节点prev            prev = cur  # 将上一个节点前移到当前节点，prev成为反转后首结点             cur = temp  # 再把cur向前移动一个结点直至None结束        # 最终就达到了翻转链表的效果，        return prev  class Solution:    # def reverseList(self, head: ListNode) -&gt; ListNode:    def reverseList(self, head):        # 首先判断这个链表里是否为空或只有一个结点，        # 只有一个结点那么它就不需要发生变化，        # 它第一个结点指向的指针就为 none        # 这个时候就直接返回这个 head，无需反转        if not head or not head.next:            return head        # 反转过后，第一个数值的指针的结点指向的是none        # 也就是一个指向反转后的头结点 为none        prev = None  # 初始化当前节点的上一个节点        cur = head  # cur始终指向要反转的结点，初始化为头结点        while cur:            # 在循环过程中，让旧链表的表头的下一个结点等于新表头，            # 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环            # 简单写法            # cur.next, prev, cur = prev, cur, cur.next            # 详细执行过程写法            # 先找到第一个元素的指针指向的元素，赋值给一个临时变量            temp = cur.next  # 保存当前节点的下一个节点，因为后面更改了当前节点的next指向，            # 由于节点没有引用其上一个节点，如果缺少了这一句，更改了当前节点的next指向，那原来后面的节点就找不到了            cur.next = prev  # 每反转一个结点，把当前结点的下一个结点指向上一个节点prev            prev = cur  # 将上一个节点前移到当前节点，prev成为反转后首结点             cur = temp  # 再把cur向前移动一个结点直至None结束        # 最终就达到了翻转链表的效果，        return prev  # 题目要求返回表头，cur == None结束，肯定不会返回None\n时间复杂度：O(n)，n 是列表的长度空间复杂度：O(1) 。\n\n第二种方法：递归：我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，所以反转一下我和我的子节点。\n\n\n使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转当递归函数全部出栈后，链表反转完成。\n原来的尾节点变为头节点，next原来指向None，尾部的next为空，将从第二个node开始，循环将next指向前一个节点原来的头节点变为尾节点，next原来指向下一个节点，改为指向None\n不妨假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，5-&gt;next = 4, 4-&gt;next = null。这时候返回了p这个节点，也就是链表5-&gt;4-&gt;null，接下来执行reverseList（3），代码解析为4-&gt;next = 3,3-&gt;next = null，这个时候p就变成了，5-&gt;4-&gt;3-&gt;null, reverseList(2), reverseList(1)依次类推，p就是:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null\n3 需要一直有一个指针指向还没有反转的链表的头部\n使用递归函数需要注意防止递归深度溢出，在Python中，通常情况下，这个深度是1000层，超过将抛出异常。在计算机中，函数递归调用是通过栈（stack）这种数据结构实现的，每当进入一个递归时，栈就会加一层，每当函数返回一次，栈就会减一层。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n123456789101112131415161718192021class Solution:    # def reverseList(self, head: ListNode) -&gt; ListNode:    def reverseList(self, head):        # 递归终止条件是链表里是否为空或只有一个结点，        # 只有一个结点那么它就不需要发生变化，        # 它第一个结点指向的指针就为 none        # 这个时候就直接返回这个 head，无需反转        if not head or not head.next:            return head        cur = self.reverseList(head.next)        # 执行了一个函数 elf.reverseList() ，传入了参数 head.next，        # 直到head.next为空触发终止条件， head.next为最后一个节点作为返回值赋给 cur        # 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，        # head.next.next=null,        # cur = head.next =5        # head=4        head.next.next = head  # head的下一个节点head.next不再指向下一个反转指向前一个        # 4.next.next=4 即5.next=4        # 不能让cur.next = head，每次拿到的cur都是指向5，如果此时执行到节点2，那么相当于5.next=2，这样就不对了        head.next = None  # head的下一个指向设置为空，防止循环指向，要断开        class Solution:    # def reverseList(self, head: ListNode) -&gt; ListNode:    def reverseList(self, head):        # 递归终止条件是链表里是否为空或只有一个结点，        # 只有一个结点那么它就不需要发生变化，        # 它第一个结点指向的指针就为 none        # 这个时候就直接返回这个 head，无需反转        if not head or not head.next:            return head        cur = self.reverseList(head.next)        # 执行了一个函数 elf.reverseList() ，传入了参数 head.next，        # 直到head.next为空触发终止条件， head.next为最后一个节点作为返回值赋给 cur        # 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，        # head.next.next=null,        # cur = head.next =5        # head=4        head.next.next = head  # head的下一个节点head.next不再指向下一个反转指向前一个        # 4.next.next=4 即5.next=4        # 不能让cur.next = head，每次拿到的cur都是指向5，如果此时执行到节点2，那么相当于5.next=2，这样就不对了        head.next = None  # head的下一个指向设置为空，防止循环指向，要断开        return cur\n\n\n1234567891011121314151617181920212223242526272829303132class Solution2:    # 返回ListNode    def ReverseList(self, pHead):        # 判断是否为空值，没有元素        if pHead == None:            return None        # 判断是否只有一个元素        if pHead.next == None:            return pHead        # 左边指针为 头 第一个 指针        leftPointer = pHead        # 中间 的指针 为 第二个指针        midPointer = pHead.next        # 右边的指针  为 指向 中间 指针后的 所有的元素         rightPointer = midPointer.next        # 左边的指针为 起始 的 元素， 反转后 它的next 为 None；        leftPointer.next = None        # 循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。        while rightPointer:            # 中间指针指向的为上一个 元素 即 leftPointer            midPointer.next = leftPointer            # 三个指针开始往右移。每次移一个。            # 左边指针 往右移一个 就是中间指针的位置            leftPointer = midPointer            # 中间指针 往 右 移 一个，就时 右边指针的位置            midPointer = rightPointer            # 右边指针往右移 一个 ，就时 右边指针的下一个。            rightPointer = rightPointer.next        # 当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。        midPointer.next = leftPointer        # 最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。        class Solution2:    # 返回ListNode    def ReverseList(self, pHead):        # 判断是否为空值，没有元素        if pHead == None:            return None        # 判断是否只有一个元素        if pHead.next == None:            return pHead        # 左边指针为 头 第一个 指针        leftPointer = pHead        # 中间 的指针 为 第二个指针        midPointer = pHead.next        # 右边的指针  为 指向 中间 指针后的 所有的元素         rightPointer = midPointer.next        # 左边的指针为 起始 的 元素， 反转后 它的next 为 None；        leftPointer.next = None        # 循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。        while rightPointer:            # 中间指针指向的为上一个 元素 即 leftPointer            midPointer.next = leftPointer            # 三个指针开始往右移。每次移一个。            # 左边指针 往右移一个 就是中间指针的位置            leftPointer = midPointer            # 中间指针 往 右 移 一个，就时 右边指针的位置            midPointer = rightPointer            # 右边指针往右移 一个 ，就时 右边指针的下一个。            rightPointer = rightPointer.next        # 当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。        midPointer.next = leftPointer        # 最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。        return midPointer\n时间复杂度：O(n) 。假设 n 是列表的长度，那么时间复杂度为 O(n) 。空间复杂度：O(n) 。由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。\n如图所示：\n\n\n14.复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）\n\n\n####第一种方法：算法：深度优先搜索1.从头结点 head 开始拷贝；2.由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；3.如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；4.使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。\n时间复杂度：O(N)。空间复杂度：O(N)。\n首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点我们将原节点作为key，新节点作为value放入哈希表中\n原节点和新节点是一一对应的关系，所以\nmap.get(原节点)，得到的就是对应的新节点map.get(原节点.next)，得到的就是对应的新节点.nextmap.get(原节点.random)，得到的就是对应的新节点.random只需要再次遍历原链表，然后设置：新节点.next -&gt; map.get(原节点.next)新节点.random -&gt; map.get(原节点.random)这样新链表的next和random都被串联起来了最后，我们然后map.get(head)，也就是对应的新链表的头节点，就可以解决此问题了\n12345678910111213141516171819202122232425262728class Solution(object):    def copyRandomList(self, head):        if not head:            return None        # 创建一个哈希表，key是原节点，value是新节点        d = dict()        p = head        # 将原节点和新节点放入哈希表中        while p:            new_node = Node(p.val, None, None)            d[p] = new_node            p = p.next        p = head        # 遍历原链表，设置新节点的next和random        while p:            # p是原节点，d[p]是对应的新节点，p.next是原节点的下一个            # d[p.next]是原节点下一个对应的新节点            if p.next:                d[p].next = d[p.next]            # p.random是原节点随机指向            # d[p.random]是原节点随机指向  对应的新节点            if p.random:                d[p].random = d[p.random]            p = p.next        # 主要是第二种是明白在放入hashmap里时候就已经最后指向了null，        # 返回头结点，即原节点对应的value(新节点)        class Solution(object):    def copyRandomList(self, head):        if not head:            return None        # 创建一个哈希表，key是原节点，value是新节点        d = dict()        p = head        # 将原节点和新节点放入哈希表中        while p:            new_node = Node(p.val, None, None)            d[p] = new_node            p = p.next        p = head        # 遍历原链表，设置新节点的next和random        while p:            # p是原节点，d[p]是对应的新节点，p.next是原节点的下一个            # d[p.next]是原节点下一个对应的新节点            if p.next:                d[p].next = d[p.next]            # p.random是原节点随机指向            # d[p.random]是原节点随机指向  对应的新节点            if p.random:                d[p].random = d[p.random]            p = p.next        # 主要是第二种是明白在放入hashmap里时候就已经最后指向了null，        # 返回头结点，即原节点对应的value(新节点)        return d[head]\n\n\n123456789101112131415161718192021222324252627282930313233343536class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        def dfs(head):            if not head:                return None            if head in visited:                return visited[head]            # 创建新结点            copy = Node(head.val, None, None)            visited[head] = copy            #  visited是一个哈希表，即visited = {键：值}，visited[键]=值            copy.next = dfs(head.next)            # 反复运行，会递归得越来越深，            # 当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；            copy.random = dfs(head.random)            # 回溯时，先从尾结点开始回溯：调用dfs(head.random)时，            # 由于结点都保存在了哈希表中，因此 return visited[head]，            # 这时完成random指针，完成了最后一个结点，故return copy。            # 再进行倒数第二个结点的回溯：            # 调用dfs(head.random)，return visited[head]，return copy.......            # 第一部分的 return 是 dfs(head.next) 和 dfs(head.random) 的终止条件，            # 您提到了访问过了就直接返回了，            # 这里的返回可以理解为找到了递归部分 head.next 或 head.random 的终止条件。            # 这时 copy 的值，next，random 都找到了，            # 我们可以最终执行第二部分的 return copy 了。            # copy 是原链表 head 的复制结点，刚开始 next 和 random 都是 null，            # 然后只是对 next 和 random 进行了递归，copy 应该一直就在那里没动等于 head，            # 所以很原链表一样返回 copy就行了。            # 我想问下你说的【return copy之后继续执行copy.random = dfs(head.random)】            # 意思是第二部分 return copy 之后又执行dfs了嘛；            return copy        visited = {}        class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        def dfs(head):            if not head:                return None            if head in visited:                return visited[head]            # 创建新结点            copy = Node(head.val, None, None)            visited[head] = copy            #  visited是一个哈希表，即visited = {键：值}，visited[键]=值            copy.next = dfs(head.next)            # 反复运行，会递归得越来越深，            # 当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；            copy.random = dfs(head.random)            # 回溯时，先从尾结点开始回溯：调用dfs(head.random)时，            # 由于结点都保存在了哈希表中，因此 return visited[head]，            # 这时完成random指针，完成了最后一个结点，故return copy。            # 再进行倒数第二个结点的回溯：            # 调用dfs(head.random)，return visited[head]，return copy.......            # 第一部分的 return 是 dfs(head.next) 和 dfs(head.random) 的终止条件，            # 您提到了访问过了就直接返回了，            # 这里的返回可以理解为找到了递归部分 head.next 或 head.random 的终止条件。            # 这时 copy 的值，next，random 都找到了，            # 我们可以最终执行第二部分的 return copy 了。            # copy 是原链表 head 的复制结点，刚开始 next 和 random 都是 null，            # 然后只是对 next 和 random 进行了递归，copy 应该一直就在那里没动等于 head，            # 所以很原链表一样返回 copy就行了。            # 我想问下你说的【return copy之后继续执行copy.random = dfs(head.random)】            # 意思是第二部分 return copy 之后又执行dfs了嘛；            return copy        visited = {}        return dfs(head)\n\n####方法二：我们也可以不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个链表结点的旁边拷贝，比如 A-&gt;B-&gt;C 变成 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’，最后返回 A’-&gt;B’-&gt;C’。原链表上进行操作的，最后分开时也是在原链表上进行的操作，所以可以认为没有占用额外空间。比如假如输入为数组，我们进行原地修改，最后返回数组的切片数组切片是shallow copy, 空间复杂度依靠slice长度决定函数要完成的目标所需的空间一般不算在空间复杂度内，时间复杂度：O(N)空间复杂度：O(1) 没有使用辅助空间或者使用了常数个辅助空间的情况下原链表最后一个节点肯定指向null，所以可以不用处理新旧链表断开后，新链表最后一个节点不需要再处理了\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        if not head: return head        # 复制一个一样的node， 并且添加到之前的链表的每一个node后面        cur = head        # 根据遍历到的链表每个原节点创建对应的新节点，每个新创建的节点是在原节点后面加入链表        while cur:            # 克隆新结点，把第一个 A 的值 赋给 node 为A‘，            new_node = Node(cur.val, None, None)            # 此时 node A' 的结点指向的是 原来A 的结点指向的下一个值            new_node.next = cur.next            # 克隆新结点在cur 后面，将原来A 的结点指向的值 改为 A’            cur.next = new_node            # 将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，            # 即为 A’ 结点 指向的下一个元素            cur = new_node.next        # 实现新建的node的随机指针random指向的节点        # 原节点1的随机指针指向原节点3，新节点1的随机指针指向的是原节点3的next        # 原节点3的随机指针指向原节点2，新节点3的随机指针指向的是原节点2的next        # 原节点i的随机指针(如果有的话)，指向的是原节点j        # 那么新节点i的随机指针，指向的是原节点j的next        cur = head  # 用头节点的随机指针        while cur:  # 迭代新创建的列表            # 如果现在操作的这个指针的元素，存在一个 random 的结点            # B 的 random 指针指向 A ，意味着 B 的下一个复制节点 B' 的 random 指针指向 A的random 的下一个节点A' 。            cur.next.random = cur.random.next if cur.random else None            # 建好 这个元素的 random 的值，然后移动 指针 到下一个元素，            # 来 建立 下一个 复制的元素的random 结点的指向。            # 当前元素 下一个的下一个 是复制的元素， 也是需要添加random 指向的元素。            cur = cur.next.next        # 断开原来的node 和 新的node 之间的链接分离成原链表和复制的链表        # =====法一========        p = head        dummy = Node(-1, None, None)        cur = dummy        while p:            cur.next = p.next            cur = cur.next            p.next = cur.next            p = p.next        return dummy.next        # =====法二========        # cur_old_list = head        # # 复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘        # cur_new_list = head.next        # # 复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘        # new_head = head.next        #         # while cur_old_list:        #     # 将旧链表 A 的指向结点改为 A’ 的指向的下一个 的B。        #     cur_old_list.next = cur_old_list.next.next        #     # 如果新的 链表 的元素有指向的下一个的指针        #     # 那么就把 这个元素的A’ 的结点指向 改为 A’ 下一个 B 的下一个 的B’        #     if cur_new_list.next:        #         cur_new_list.next = cur_new_list.next.next        #     else:        #         cur_new_list.next = None        #     # 上面新链表的元素指针改好了，再更改 下一个旧链表的 元素        #     # 改好的 A 的结点指向的B        #     cur_old_list = cur_old_list.next        #     # 将新链表的指针移位，来断开下一个链接，也就是 指针改为了 B’        #     cur_new_list = cur_new_list.next        #     # 如此循环下去，改变所有的 新链表，旧链表的指向。        # return new_head  # 最后返回这个复制好的新链表。 ```       第三种方法：对于 python 可直接调用相关函数：```pythonimport copyclass Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        class Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        if not head: return head        # 复制一个一样的node， 并且添加到之前的链表的每一个node后面        cur = head        # 根据遍历到的链表每个原节点创建对应的新节点，每个新创建的节点是在原节点后面加入链表        while cur:            # 克隆新结点，把第一个 A 的值 赋给 node 为A‘，            new_node = Node(cur.val, None, None)            # 此时 node A' 的结点指向的是 原来A 的结点指向的下一个值            new_node.next = cur.next            # 克隆新结点在cur 后面，将原来A 的结点指向的值 改为 A’            cur.next = new_node            # 将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，            # 即为 A’ 结点 指向的下一个元素            cur = new_node.next        # 实现新建的node的随机指针random指向的节点        # 原节点1的随机指针指向原节点3，新节点1的随机指针指向的是原节点3的next        # 原节点3的随机指针指向原节点2，新节点3的随机指针指向的是原节点2的next        # 原节点i的随机指针(如果有的话)，指向的是原节点j        # 那么新节点i的随机指针，指向的是原节点j的next        cur = head  # 用头节点的随机指针        while cur:  # 迭代新创建的列表            # 如果现在操作的这个指针的元素，存在一个 random 的结点            # B 的 random 指针指向 A ，意味着 B 的下一个复制节点 B' 的 random 指针指向 A的random 的下一个节点A' 。            cur.next.random = cur.random.next if cur.random else None            # 建好 这个元素的 random 的值，然后移动 指针 到下一个元素，            # 来 建立 下一个 复制的元素的random 结点的指向。            # 当前元素 下一个的下一个 是复制的元素， 也是需要添加random 指向的元素。            cur = cur.next.next        # 断开原来的node 和 新的node 之间的链接分离成原链表和复制的链表        # =====法一========        p = head        dummy = Node(-1, None, None)        cur = dummy        while p:            cur.next = p.next            cur = cur.next            p.next = cur.next            p = p.next        return dummy.next        # =====法二========        # cur_old_list = head        # # 复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘        # cur_new_list = head.next        # # 复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘        # new_head = head.next        #         # while cur_old_list:        #     # 将旧链表 A 的指向结点改为 A’ 的指向的下一个 的B。        #     cur_old_list.next = cur_old_list.next.next        #     # 如果新的 链表 的元素有指向的下一个的指针        #     # 那么就把 这个元素的A’ 的结点指向 改为 A’ 下一个 B 的下一个 的B’        #     if cur_new_list.next:        #         cur_new_list.next = cur_new_list.next.next        #     else:        #         cur_new_list.next = None        #     # 上面新链表的元素指针改好了，再更改 下一个旧链表的 元素        #     # 改好的 A 的结点指向的B        #     cur_old_list = cur_old_list.next        #     # 将新链表的指针移位，来断开下一个链接，也就是 指针改为了 B’        #     cur_new_list = cur_new_list.next        #     # 如此循环下去，改变所有的 新链表，旧链表的指向。        # return new_head  # 最后返回这个复制好的新链表。 ```       第三种方法：对于 python 可直接调用相关函数：```pythonimport copyclass Solution:    def copyRandomList(self, head: 'Node') -&gt; 'Node':        return copy.deepcopy(head)\n\n迭代对于一个结点，分别拷贝此结点、next 指针指向的结点、random 指针指向的结点，然后进行下一个结点…如果遇到已经出现的结点，那么我们不用拷贝该结点，只需将 next 或 random 指针指向该结点即可。\n\n15.两个链表之间的第一个公共结点输入两个链表，找出它们的第一个公共结点如图：\n\n题目要求输入输入的skipA /skipB 表示之前的节点即使值一样，但是 是new 在堆上的 地址会不一样，而后续节点是通过引用进行连接的链表；=》所以题目可以表述为在两个链表中找到共有的 引用链表的头结点示例1里面输入把相交节点前的节点数分别给定死为2和3了，我试了下改为1和2，相交节点就是1了\nA=[4,1,8,4,5]B=[5,0,1,8,4,5]1是值相同的两个不同节点，8是存在于两个链表中的唯一节点，相交于结点 8。链表是用类实现的，每个节点都是一个类的实例，公共交点，节点共用，节点的地址（引用）相同，他的特征是数值和指针都相等，仅值相同不一定是同一节点，判断node1 != node2 不是node1.val==node2.val，\n法一：两个链表长度分别为L1+C、L2+C，C为公共部分的长度，L1,L2分别为两个链表在交点之前的开头不重复的部分\n使用两个指针 node1，node2 分别指向两个链表 headA, headB 的头结点，\n因为只有当node1==node2的时候，才会跳出 while (node1 != node2) 循环，此时，返回node1和node2是一样的，因为相等。而且node1此时只有两种情况：1.node1为相交点\n\n如果两个链表的长度不一样,同时分别逐结点遍历，两次遍历，当 node1 走了L1+C步后到达链表 headA 的末尾时，重新定位到链表 headB 的头结点，走L2步当 node2 走了L2+C步后到达链表 headB 的末尾时，重新定位到链表 headA 的头结点，走L1步。\n\nL1+C+L2+C == L2+C+L1+CL1+C+L2 == L2+C+L1当两个人走的步数都为L1+L2+C时，一定是同时结束。如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 \n\n如果两个链表的长度一样，L1=L2，遍历一次就可以找到相交的起始节点\n\n2.不相交 C=0a+None + b+None = b+None+ a+None ，a+none+b长度与b+none+a长度相等循环次数最多为a、b长度之和，如果不相交，会在ha==hb=None条件下（最后一个节点），退出循环。\n  1.如果长度不相等，两个指针节点都需要遍历完链表L1+L2(L1+L2）长度，同时移动到尾节点指向None然后node1==node2==None，while条件不成立，跳出循环，返回也是None，表示没有相交结点\n\n如果两个链表的长度一样，遍历一次L1=L2，尾节点同时指向None，跳出循环了\n\n在每一个链表中使用了迭代，最多循环两次，因为每个指针最多遍历两个链表\n法二两个指针分别指向两个链表头部，一起向前走直到其中一个到达末端，另一个与末端距离则是两链表的 长度差。再通过长链表指针先走的方式消除长度差，最终两链表即可同时走到相交点。\n换个方式消除长度差： 拼接两链表。设长-短链表为 C，短-长链表为 D （分别代表长链表在前和短链表在前的拼接链表），则当 C 走到长短链表交接处时，D 走在长链表中，且与长链表头距离为 长度差;\n[5,0,1,8,4,5][4,1,8,4,5][4,1,8,4,5][5,0,1,8,4,5]  \n短链表走到尽头后继续走长链表，就相当于短链表+长链表。长链表走到尽头后又走短链表，相当于长链表+短链表。所以重新走两次其实本质上还是相当于走两次新的拼接的互补链表，这样，当它们相遇时，所指向的结点就是第一个公共结点。当 ha == hb 时跳出，返回即可\n我觉得时会有None出现的，因为headA+headB和headB+ headA长度一定是相等的，假设没有相交，最后一位一定是ha.next == None, hb.next == None，退出循环，然后假设有相交，那就是在某一非链尾位置，ha = =hb 就毋庸置疑了，假设headA长度等于headB，那么第一个None一定会退出，不论是否相交，但是如果相交，既然headA和headB相等，那一定在转换前就能完成==退出循环，如果不相交，这时候ha == None，返回值就是None。\n如果两个链表的长度不一样，需要两次遍历，第一次遍历是为了消除长度差，找到长链表到尾结点的长度和短链表到尾结点的长度一样的节点处，第二次遍历找到相交的起始节点。\n指向长链表的指针先走 “两个链表长度的差值” 步，再两个指针一起走。因为当短的链表指针走到末尾时，长的链表指针刚好距离末尾 “两个链表长度的差值” 步。然后短链表的指针此时指向长链表的开头，两个指针一起走，靠近链表末尾的指针指向空时，靠近开头的指针便走了 长度差值 步。然后此时指向空的指针再指向短链表的开头。这时开始，两个指针距离相交节点的长度就是相同的，两个指针一起走，就能走到相交节点。\n空间复杂度 O(1) 时间复杂度为 O(n)其实也并不是常数系数省略，而是这里的两条链表同时在遍历，总路径是2(m+n)但是迭代次数是m+n所以时间复杂度为O(m+n)。\n12345678910111213141516class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        node1, node2 = headA, headB        while node1 != node2:            node1 = node1.next if node1 else headB            # 不是node1 = node1.next if node1.next else headB            # 理解为两条链表最后都指向了同一个 null （None）节点，代替了不相交的特殊情况            # 如果加next的话，那指针到最后一个结点就直接转链表了，            # 因为你提前判断了它的next是否为空，就不会有null的情况了            # 会一直死循环（如果不相交）。            # 没有交点的情况可以约化为 交点为 None 的情况。（即将两链表末端的 None 看作交点）            # 不用next，最后不相交的话会都等于None而结束循环            node2 = node2.next if node2 else headA        class Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        node1, node2 = headA, headB        while node1 != node2:            node1 = node1.next if node1 else headB            # 不是node1 = node1.next if node1.next else headB            # 理解为两条链表最后都指向了同一个 null （None）节点，代替了不相交的特殊情况            # 如果加next的话，那指针到最后一个结点就直接转链表了，            # 因为你提前判断了它的next是否为空，就不会有null的情况了            # 会一直死循环（如果不相交）。            # 没有交点的情况可以约化为 交点为 None 的情况。（即将两链表末端的 None 看作交点）            # 不用next，最后不相交的话会都等于None而结束循环            node2 = node2.next if node2 else headA        return node1\n\n\n16.合并两个排序的链表 [^本题考点  链表]输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。示例：\n12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n构造链表的这种题一般都是需要两个量，一个存储链表头，一个不断移动进行构造。\n\n引入伪头节点：由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点， dum 的 val 属性不保存任何值将各节点添加至 dum 之后，在整个链表合并完之后，返回它的下一位置即可指向结果链表的头部 ，哑结点可以不需要重复判空; \n\ncur记录下一个插入位置的前一个位置，相当于一个游标，不断移动构造链表。遍历链表的指针，每一次会指向新加入节点，将已合并链表添加至此节点后面。如果不赋值给cur，用dum代替cur去做迭代的话，那dum最终指向的是l1或l2的尾节点，相当于没保存合并后链表的头结点，在构建完成后就没法找到链表头了。先调整 cur 的 next 属性，再后移 cur\n12cur.next = dumcur.next = dumcur = cur.next\n\n第一种方法：  \n\n\n解题思路：\n\n根据题目描述， 链表 l1 , l2是 递增 的，因此容易想到使用双指针 l1 和 l2 遍历两链表，根据 l1.val 和 l2.val 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。\n\n当 l1 和 l2 都不是空链表时，比较两个链表的首结点，将较小值的节点则添加到第三个链表尾结点，将对应链表中的节点向后移一位，并向前移动一个结点。结果会有一个链表先遍历结束，或者没有第三个链表尾结点指向剩余未遍历结束的链表返回第三个链表首结点\n\n\n算法流程：  \n\n初始化： 伪头节点 dum ，节点 cur 指向 dum 。  \n\n循环合并： 当 l1 或 l2    为空时跳出；\n\n当 l1.val &lt; l2.val 时：cur 的后继节点指定为 l1 ，并 l1 向前走一步；把 l1 当前的节点接在 cur 节点的后面同时将 l1 指针往后移一位\n\n当 l1.val  ≥ l2 .val 时：cur 的后继节点指定为 l2 ，并 l2向前走一步 ；\n\n不管我们将哪一个元素接在了后面，我们都需要把 cur 向后移一位，即 cur = cur.next 。  \n\n合并剩余尾部： 跳出时有两种情况，即 l1 为空 或 l2 为空。  \n\n若 l1 != null ： 将 l1添加至节点 cur 之后；\n\n否则： 将 l2 添加至节点 cur 之后。在循环终止的时候， l1 和 l2 至多有一个是非空的（还未被合并完），由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面\n\n返回值： 返回 dum.next 就是合并链表的头节点\n\n\n原地调整链表元素的 next 指针完成合并\n时间复杂度 O(N) ：链表 l1, l2 的长度和，l1 和 l2 只有一个元素会被放进合并链表中，因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，\n空间复杂度 O(1) ：节点引用 dum , cur 使用常数大小的额外空间存放若干变量。\n123456789101112131415class Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        # ListNode(0) 建立一个值为 0 的节点实例，不可变对象0也可以用None，开辟结点的内存空间，dum 引用 指向这个节点对象ListNode(0)        dum = ListNode(0)        cur = dum  # 然后 cur 引用再指向 dum 对象，        # cur 实际上就是保存 ListNode(0) 的地址，你可以随意声明变量去指向此节点~        # 但 cur 和 dum 是两个独立变量，改变 cur，dum 仍然指向这个节点，所以没有变化~        while l1 and l2:            if l1.val &lt; l2.val:                cur.next, l1 = l1, l1.next            else:                cur.next, l2 = l2, l2.next            cur = cur.next        cur.next = l1 or l2  # 等价于 x if x else y        return dum.next  class Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        # ListNode(0) 建立一个值为 0 的节点实例，不可变对象0也可以用None，开辟结点的内存空间，dum 引用 指向这个节点对象ListNode(0)        dum = ListNode(0)        cur = dum  # 然后 cur 引用再指向 dum 对象，        # cur 实际上就是保存 ListNode(0) 的地址，你可以随意声明变量去指向此节点~        # 但 cur 和 dum 是两个独立变量，改变 cur，dum 仍然指向这个节点，所以没有变化~        while l1 and l2:            if l1.val &lt; l2.val:                cur.next, l1 = l1, l1.next            else:                cur.next, l2 = l2, l2.next            cur = cur.next        cur.next = l1 or l2  # 等价于 x if x else y        return dum.next  # 返回第一个值  \n\n####第二种方法：递归如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。\n我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。\n12345678910class Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        if not l1: return l2  # 终止条件，直到两个链表都空        if not l2: return l1        if l1.val &lt;= l2.val:  # 递归调用            l1.next = self.mergeTwoLists(l1.next,l2)            return l1        else:            l2.next = self.mergeTwoLists(l1,l2.next)            class Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        if not l1: return l2  # 终止条件，直到两个链表都空        if not l2: return l1        if l1.val &lt;= l2.val:  # 递归调用            l1.next = self.mergeTwoLists(l1.next,l2)            return l1        else:            l2.next = self.mergeTwoLists(l1,l2.next)            return l2\n其中时间复杂度可以这样计算：给出一个递归算法，其时间复杂度 O(T) 通常是递归调用的数量（记作 {R}R） 和计算的时间复杂度的乘积（表示为 O(s)）的乘积：(T) = R ∗ O(s)\n时间复杂度：O(m+n)。m，n 为 l1} 和 l2 的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 R=O(m+n) 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 O(1)，故递归的总时间复杂度为 O(T)=R∗O(1)=O(m+n) 。\n空间复杂度：O(m+n)。\n对于递归调用 self.mergeTwoLists()，当它遇到终止条件准备回溯时，已经递归调用了 m+nm+n 次，使用了 m+nm+n 个栈帧，故最后的空间复杂度为 O(m+n)。\n\n输入的是两个链表的头结点，最后返回的是合并链表的头结点。但是输出结果却是一个完整的链表\n因此我认为应该就是修改两个链表的引用指向实现合并~ 应该不用新建节点~\n1234567891011121314151617181920212223242526272829303132333435363738class Solution:    # 返回合并后列表    def Merge(self, pHead1, pHead2):        #首先判断两个链表是不是为空。        if pHead1 == None:            return pHead2        if pHead2 == None:            return pHead1        #比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。        newHead = pHead1 if pHead1.val &lt; pHead2.val else pHead2                pTmp1 = pHead1        pTmp2 = pHead2        #判断 如果新表头 是 表1 的头的话 那么 新表头        if newHead == pTmp1:            pTmp1 = pTmp1.next        else:            pTmp2 = pTmp2.next        #        previousPointer = newHead                while pTmp1 and pTmp2:            if pTmp1.val &lt; pTmp2.val:                previousPointer.next = pTmp1                previousPointer = pTmp1                pTmp1 = pTmp1.next            else:                previousPointer.next = pTmp2                previousPointer = pTmp2                pTmp2 = pTmp2.next        if pTmp1 == None:                    previousPointer.next = pTmp2        else:            previousPointer.next = pTmp1                    class Solution:    # 返回合并后列表    def Merge(self, pHead1, pHead2):        #首先判断两个链表是不是为空。        if pHead1 == None:            return pHead2        if pHead2 == None:            return pHead1        #比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。        newHead = pHead1 if pHead1.val &lt; pHead2.val else pHead2                pTmp1 = pHead1        pTmp2 = pHead2        #判断 如果新表头 是 表1 的头的话 那么 新表头        if newHead == pTmp1:            pTmp1 = pTmp1.next        else:            pTmp2 = pTmp2.next        #        previousPointer = newHead                while pTmp1 and pTmp2:            if pTmp1.val &lt; pTmp2.val:                previousPointer.next = pTmp1                previousPointer = pTmp1                pTmp1 = pTmp1.next            else:                previousPointer.next = pTmp2                previousPointer = pTmp2                pTmp2 = pTmp2.next        if pTmp1 == None:                    previousPointer.next = pTmp2        else:            previousPointer.next = pTmp1                    return newHead\n\n23. 合并K个升序链表给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：\n12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\n示例 2：\n12输入：lists = []输出：输入：lists = []输出：[]\n\n示例 3：\n12输入：lists = 输入：lists = [[]]输出：[]\n\n思路：每个链表的第一个结点入堆，进行比较，最小的出堆，该链表往后移，然后找出堆链表中的后续入堆\npython3的堆中链表无法比较大小，我们传入的是val和他所在的list(这是第几个链表)方便查找后续heapq 模块传入的 tuple 对象里面不能有引用对象，就只好传一个索引进去了。元组在heapq里比较的机制是从元组首位0开始，即遇到相同，就比较元组下一位，比如(1,2), (1,3)，前者比后者小。\nListNode无法被比较\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        minHeap = []        for index, node in enumerate(lists):            # index 用来记录这是第几个链表            # node 是每个链表的头结点            if node:  # 只要头结点不空                # 把k个链表的头结点的value以及该头结点所在的链表index入堆                heapq.heappush(minHeap, (node.val, index))        linkedlistHead = ListNode(-1)  # 伪头节点        linkedlistTail = linkedlistHead  # 构建链表的结点        while minHeap:            # 堆内链表value最小的出堆，找到他是第几个链表，好找他的下一个位置            val, index = heapq.heappop(minHeap)            linkedlistTail.next = lists[index]  # 加入到了结果集合中            linkedlistTail = linkedlistTail.next  # 开始加下一个位置            lists[index] = lists[index].next  # 找到当前链表的下一个元素            if lists[index]:  # 如果不空的话就让他入堆                heapq.heappush(minHeap, (lists[index].val, index))  # 下一个元素入堆        return linkedlistHead.next  # 返回链表if __name__ == '__main__':    link1 = ListNode(1, ListNode(4, ListNode(5)))    link2 = ListNode(1, ListNode(3, ListNode(4)))    link3 = ListNode(2, ListNode(6))    node = Solution().mergeKLists([link1, link2, link3])    res = []    while node:        res.append(node.val)        node = node.next    print(res)  # [1, 1, 2, 3, 4, 4, 5, 6]    print([link1, link2, link3])    # [&lt;__main__.ListNode object at 0x000001CF45EA6FA0&gt;, &lt;__main__.ListNode object at 0x000001CF45EDD670&gt;, &lt;__main__.ListNode object at 0x000001CF45EDDC70&gt;]    print(type([link1, link2, link3]))  # &lt;class 'list'&gt;# minHeap = []# index = 0# minHeap = [(1, 0)]# index = 1# minHeap = [(1, 0), (1, 1)]# index = 2# minHeap[(1, 0), (1, 1), (2, 2)]# 堆顶元素出栈，调整为最小堆# val = 1, index = 0# minHeap = [(1, 1), (2, 2)]# minHeap = [(1, 1), (2, 2), (4, 0)]# 堆顶元素出栈，调整为最小堆# val = 1, index = 1# minHeap = [(2, 2), (4, 0)]# minHeap = [(2, 2), (4, 0), (3, 1)]# 堆顶元素出栈，调整为最小堆# val = 2, index = 2# minHeap = [(3, 1), (4, 0)]# minHeap = [(3, 1), (4, 0)], (6, 2)]# 第二个队列的第一个# 堆顶元素出栈，调整为最小堆# val = 3, index = 1# minHeap = [(4, 0)], (6, 2)]# 队列剩余元素入堆，调整为最小堆# minHeap = [(4, 0)], (6, 2), (4, 1)]# 堆顶元素出栈，调整为最小堆# val = 4, index = 0# minHeap = [(4, 1), (6, 2)]# 链表剩余元素入堆，调整为最小堆# minHeap = [(4, 1), (6, 2), (5, 0)]# 堆顶元素出栈，调整为最小堆# val = 4, index = 1# minHeap = [(5, 0), (6, 2)]# 第2个链表已经空了# 堆顶元素出栈，调整为最小堆# val = 5, index = 0# minHeap = [(6, 2)]# 第1个链表已经空了# minHeap = [(6, 2)]# 堆顶元素出栈，调整为最小堆# val = 6, index = 2# minHeap = [None, None, None]# 题目只用返回dum.next# 本地测试# res = []# node = dummy.next = 1# res = [1]# node = node.next = 1.next = 1# res = [1, 1]from typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        minHeap = []        for index, node in enumerate(lists):            # index 用来记录这是第几个链表            # node 是每个链表的头结点            if node:  # 只要头结点不空                # 把k个链表的头结点的value以及该头结点所在的链表index入堆                heapq.heappush(minHeap, (node.val, index))        linkedlistHead = ListNode(-1)  # 伪头节点        linkedlistTail = linkedlistHead  # 构建链表的结点        while minHeap:            # 堆内链表value最小的出堆，找到他是第几个链表，好找他的下一个位置            val, index = heapq.heappop(minHeap)            linkedlistTail.next = lists[index]  # 加入到了结果集合中            linkedlistTail = linkedlistTail.next  # 开始加下一个位置            lists[index] = lists[index].next  # 找到当前链表的下一个元素            if lists[index]:  # 如果不空的话就让他入堆                heapq.heappush(minHeap, (lists[index].val, index))  # 下一个元素入堆        return linkedlistHead.next  # 返回链表if __name__ == '__main__':    link1 = ListNode(1, ListNode(4, ListNode(5)))    link2 = ListNode(1, ListNode(3, ListNode(4)))    link3 = ListNode(2, ListNode(6))    node = Solution().mergeKLists([link1, link2, link3])    res = []    while node:        res.append(node.val)        node = node.next    print(res)  # [1, 1, 2, 3, 4, 4, 5, 6]    print([link1, link2, link3])    # [&lt;__main__.ListNode object at 0x000001CF45EA6FA0&gt;, &lt;__main__.ListNode object at 0x000001CF45EDD670&gt;, &lt;__main__.ListNode object at 0x000001CF45EDDC70&gt;]    print(type([link1, link2, link3]))  # &lt;class 'list'&gt;# minHeap = []# index = 0# minHeap = [(1, 0)]# index = 1# minHeap = [(1, 0), (1, 1)]# index = 2# minHeap[(1, 0), (1, 1), (2, 2)]# 堆顶元素出栈，调整为最小堆# val = 1, index = 0# minHeap = [(1, 1), (2, 2)]# minHeap = [(1, 1), (2, 2), (4, 0)]# 堆顶元素出栈，调整为最小堆# val = 1, index = 1# minHeap = [(2, 2), (4, 0)]# minHeap = [(2, 2), (4, 0), (3, 1)]# 堆顶元素出栈，调整为最小堆# val = 2, index = 2# minHeap = [(3, 1), (4, 0)]# minHeap = [(3, 1), (4, 0)], (6, 2)]# 第二个队列的第一个# 堆顶元素出栈，调整为最小堆# val = 3, index = 1# minHeap = [(4, 0)], (6, 2)]# 队列剩余元素入堆，调整为最小堆# minHeap = [(4, 0)], (6, 2), (4, 1)]# 堆顶元素出栈，调整为最小堆# val = 4, index = 0# minHeap = [(4, 1), (6, 2)]# 链表剩余元素入堆，调整为最小堆# minHeap = [(4, 1), (6, 2), (5, 0)]# 堆顶元素出栈，调整为最小堆# val = 4, index = 1# minHeap = [(5, 0), (6, 2)]# 第2个链表已经空了# 堆顶元素出栈，调整为最小堆# val = 5, index = 0# minHeap = [(6, 2)]# 第1个链表已经空了# minHeap = [(6, 2)]# 堆顶元素出栈，调整为最小堆# val = 6, index = 2# minHeap = [None, None, None]# 题目只用返回dum.next# 本地测试# res = []# node = dummy.next = 1# res = [1]# node = node.next = 1.next = 1# res = [1, 1]# return \n\n贪心算法、优先队列思路分析：1、由于是 k 个排序链表，那么这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中最小的结点；\n2、最小结点所在的链表的头结点就要更新了，更新成最小结点的下一个结点（如果有的话），此时还是这 k 个链表，这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中第 2 小的结点。\n每一次都从这 k 个排序的链表头结点中拿出 val 最小的结点“穿针引线”成新的链表，这个链表就是题目要求的“合并后的排序链表”。“局部最优，全局就最优”，这不就是贪心算法的思想吗。\n维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。用最小堆完成，堆的元素个数是链表的个数k个。不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。\n这里我们举生活中的例子来理解这个思路。\n\n假设你是一名体育老师，有 3 个班的学生，他们已经按照身高从矮到高排好成了 3 列纵队，现在要把这 3 个班的学生也按照身高从矮到高排列 1 列纵队。我们可以这么做：1、让 3 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身；2、每一次队首的 3 名同学，请最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后面的所有同学都向前走一步（其实走不走都行，只要你能比较出站在你面前的 3 位在队首的同学同学的高矮即可）；3、重复第 2 步，直到 3 个班的同学全部出列完毕。\n\n具体实现的时候，“每一次队首的 3 名同学，请最矮的同学出列”这件事情可以交给优先队列（最小堆、最小索引堆均可）去完成。在连续的两次出队之间完成“穿针引线”的工作。\n时间复杂度：O(Nlogk)， N 是这 k 个链表的结点总数，考虑优先队列中的元素不超过 k 个弹出操作时，比较操作的代价会被优化到O(logk)，同时找到最小值节点的时间为O(1)，每一次从一个优先队列中选出一个最小结点的时间复杂度是 O(logk)，故时间复杂度为 O(Nlogk)。空间复杂度：O(k)，考虑优先队列中的元素不超过 k 个，“穿针引线”需要常数个空间，因此空间复杂度为 O(k)。O(n):创建一个新的链表空间开销为O(n)O(1):以上代码采用了重复利用原有节点，所以只要O(1)的空间。同时优先队列(通常用堆实现)需要O(k)的空间(远比大多数情况的N要小)\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        l = []        for index in range(len(lists)):            # 针对一些特殊的测试用例，有的链表可能是空链表            if lists[index]:                heapq.heappush(l, (lists[index].val, index))        dummy_node = ListNode(-1)        cur = dummy_node        while l:            #  _ 可以认为是一个变量的名字，因为这个变量后面不会再用到，所以使用 _ ，其实就是不想给这个变量起名字，但又得占一个位子的意思。            _, index = heapq.heappop(l)            # 定位到此时应该出列的那个链表的头结点            head = lists[index]            # 开始“穿针引线”            cur.next = head            cur = cur.next            # 同样不要忘记判断到链表末尾结点的时候            if head.next:                # 刚刚出列的那个链表的下一个结点成为新的链表头结点加入优先队列                heapq.heappush(l, (head.next.val, index))                # 切断刚刚出列的那个链表的头结点引用                lists[index] = head.next                head.next = None        return dummy_node.nextif __name__ == '__main__':    link1 = ListNode(1, ListNode(4, ListNode(5)))    link2 = ListNode(1, ListNode(3, ListNode(4)))    link3 = ListNode(2, ListNode(6))    node = Solution().mergeKLists([link1, link2, link3])    res = []    from typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        l = []        for index in range(len(lists)):            # 针对一些特殊的测试用例，有的链表可能是空链表            if lists[index]:                heapq.heappush(l, (lists[index].val, index))        dummy_node = ListNode(-1)        cur = dummy_node        while l:            #  _ 可以认为是一个变量的名字，因为这个变量后面不会再用到，所以使用 _ ，其实就是不想给这个变量起名字，但又得占一个位子的意思。            _, index = heapq.heappop(l)            # 定位到此时应该出列的那个链表的头结点            head = lists[index]            # 开始“穿针引线”            cur.next = head            cur = cur.next            # 同样不要忘记判断到链表末尾结点的时候            if head.next:                # 刚刚出列的那个链表的下一个结点成为新的链表头结点加入优先队列                heapq.heappush(l, (head.next.val, index))                # 切断刚刚出列的那个链表的头结点引用                lists[index] = head.next                head.next = None        return dummy_node.nextif __name__ == '__main__':    link1 = ListNode(1, ListNode(4, ListNode(5)))    link2 = ListNode(1, ListNode(3, ListNode(4)))    link3 = ListNode(2, ListNode(6))    node = Solution().mergeKLists([link1, link2, link3])    res = []    while node:        res.append(node.val)        node = node.next    print(res)\n\n\n优先队列\n123456789101112131415161718192021222324252627from queue import PriorityQueuefrom typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        head = point = ListNode(0)  # 声明伪头节点和构建链表的节点        queue = PriorityQueue()  # 声明优先队列        for item in lists:  # 将输入的节点放入优先队列            if item:                queue.put((item.val, queue))        while not queue:  # 循环迭代队列，队列为空结束            val, node = queue.get()  # 每次取出队首节点            point.next = ListNode(val)  # 将这个节点值放入最终有序列表之中            point = point.next  # 指针指向下一个节点            node = node.next            if node:  # 下一个节点不为空                queue.put((node.val, node))        from queue import PriorityQueuefrom typing import Listimport heapqclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        head = point = ListNode(0)  # 声明伪头节点和构建链表的节点        queue = PriorityQueue()  # 声明优先队列        for item in lists:  # 将输入的节点放入优先队列            if item:                queue.put((item.val, queue))        while not queue:  # 循环迭代队列，队列为空结束            val, node = queue.get()  # 每次取出队首节点            point.next = ListNode(val)  # 将这个节点值放入最终有序列表之中            point = point.next  # 指针指向下一个节点            node = node.next            if node:  # 下一个节点不为空                queue.put((node.val, node))        return head.next\n\n分治\n123456789101112131415161718192021222324252627282930from queue import PriorityQueueclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        amount = len(lists)  # 输入列表的个数        interval = 1  # 初始间隔设置为1        while interval &lt; amount:  # 将队列两两合并            for i in range(0, amount - interval, interval * 2):                lists[i] = self.merge2Lists(lists[i], lists[i + interval])            interval *= 2        return lists[0] if amount &gt; 0 else None    def merge2Lists(self, l1, l2):        head = point = ListNode(0)  # 声明头节点和构建链表节点        while l1 and l2:  # 将两个链表头节点进行比较            if l1.val &lt;= l2.val:                point.next = l1                l1 = l1.next            else:                point.next = l2                l2 = l1                l1 = point.next.next            point = point.next        if not l1:            point.next = l2        else:            point.next = l1        from queue import PriorityQueueclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        amount = len(lists)  # 输入列表的个数        interval = 1  # 初始间隔设置为1        while interval &lt; amount:  # 将队列两两合并            for i in range(0, amount - interval, interval * 2):                lists[i] = self.merge2Lists(lists[i], lists[i + interval])            interval *= 2        return lists[0] if amount &gt; 0 else None    def merge2Lists(self, l1, l2):        head = point = ListNode(0)  # 声明头节点和构建链表节点        while l1 and l2:  # 将两个链表头节点进行比较            if l1.val &lt;= l2.val:                point.next = l1                l1 = l1.next            else:                point.next = l2                l2 = l1                l1 = point.next.next            point = point.next        if not l1:            point.next = l2        else:            point.next = l1        return head.next\n123456789101112131415161718192021222324252627282930313233343536373839404142class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        \"\"\"分治合并\"\"\"        def merge2Lists(list1, list2):            \"\"\"list1和list2分别是两个链表的头结点\"\"\"            head = ListNode(0)  # 新建一个头节点用来返回list1和list2的排序后结果            dummy = head  # 指向head链表的尾部，用来拆入新节点            while list1 and list2:  # 两个链表都不为空时                if list1.val &lt; list2.val:                    dummy.next = list1  # 插入新节点                    dummy = list1  # dummy指向新插入的节点                    list1 = list1.next  # 移动list1                    continue                dummy.next = list2                dummy = list2                list2 = list2.next            dummy.next = list2 if not list1 else list1  # 如果list1为None，说明list1中的元素全部进入了head链表，所以把list2中剩余的元素直接添加进来，反之亦然。            return head.next        # print(merge2Lists(lists[1], lists[2]))        res = None        def divideMergeKLists(lists):            \"\"\"分治归并k个链表\"\"\"            nonlocal res            k = len(lists)            temp = []            if k == 0: return  # lists为空，直接结束            if k == 1 :  # 归并结束                res = lists[0]  # 保存结果                return            for i in range(0, k, 2):                if i+1 == k:  # k为奇数，i的最后一个取值是k-1，此时i+1已经超出范围                    temp.append(lists[i])                    break                # 如果k为偶数，i的最后一个取值永远是k-2                temp.append(merge2Lists(lists[i], lists[i+1]))            divideMergeKLists(temp)        divideMergeKLists(lists)        class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        \"\"\"分治合并\"\"\"        def merge2Lists(list1, list2):            \"\"\"list1和list2分别是两个链表的头结点\"\"\"            head = ListNode(0)  # 新建一个头节点用来返回list1和list2的排序后结果            dummy = head  # 指向head链表的尾部，用来拆入新节点            while list1 and list2:  # 两个链表都不为空时                if list1.val &lt; list2.val:                    dummy.next = list1  # 插入新节点                    dummy = list1  # dummy指向新插入的节点                    list1 = list1.next  # 移动list1                    continue                dummy.next = list2                dummy = list2                list2 = list2.next            dummy.next = list2 if not list1 else list1  # 如果list1为None，说明list1中的元素全部进入了head链表，所以把list2中剩余的元素直接添加进来，反之亦然。            return head.next        # print(merge2Lists(lists[1], lists[2]))        res = None        def divideMergeKLists(lists):            \"\"\"分治归并k个链表\"\"\"            nonlocal res            k = len(lists)            temp = []            if k == 0: return  # lists为空，直接结束            if k == 1 :  # 归并结束                res = lists[0]  # 保存结果                return            for i in range(0, k, 2):                if i+1 == k:  # k为奇数，i的最后一个取值是k-1，此时i+1已经超出范围                    temp.append(lists[i])                    break                # 如果k为偶数，i的最后一个取值永远是k-2                temp.append(merge2Lists(lists[i], lists[i+1]))            divideMergeKLists(temp)        divideMergeKLists(lists)        return res        \n\n23. 合并K个链表 没有利用各个链表是升序的特点思路：\n\n读取所有链表值\n构造一个最小堆 heapq 很容易实现\n根据最小堆构造一个链表\n\n12345678910111213141516171819202122class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        h = []  # 定义最小堆        # 读取所有节点值        for node in lists:            while node:                h.append(node.val)                node = node.next  # 后移节点        # 构造一个最小堆        if not h:  # h为空，直接返回None            return None        heapq.heapify(h)  # 转换成最小堆        # 构造链表        root = ListNode(heapq.heappop(h))  # 弹出最小的值作为根节点        curnode = root  # 当前节点        while h:            nextnode = ListNode(heapq.heappop(h))  # 构造下一个节点            curnode.next = nextnode  # 当前next指向下一个节点            curnode = nextnode  # 当前节点后移        class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        h = []  # 定义最小堆        # 读取所有节点值        for node in lists:            while node:                h.append(node.val)                node = node.next  # 后移节点        # 构造一个最小堆        if not h:  # h为空，直接返回None            return None        heapq.heapify(h)  # 转换成最小堆        # 构造链表        root = ListNode(heapq.heappop(h))  # 弹出最小的值作为根节点        curnode = root  # 当前节点        while h:            nextnode = ListNode(heapq.heappop(h))  # 构造下一个节点            curnode.next = nextnode  # 当前next指向下一个节点            curnode = nextnode  # 当前节点后移        return root\n\n123456789101112131415161718class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists:            return None        heap = []        # 首先 for 嵌套 while 就是将所有元素都取出放入堆中        for node in lists:            while node:                heapq.heappush(heap, node.val)                node = node.next        dummy = ListNode(None)        cur = dummy        # 依次将小顶堆中的元素取出，每次出来的都是目前堆中值最小的元素，然后重新构建一个列表返回        while heap:            temp_node = ListNode(heappop(heap))            cur.next = temp_node            cur = temp_node        class Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        if not lists:            return None        heap = []        # 首先 for 嵌套 while 就是将所有元素都取出放入堆中        for node in lists:            while node:                heapq.heappush(heap, node.val)                node = node.next        dummy = ListNode(None)        cur = dummy        # 依次将小顶堆中的元素取出，每次出来的都是目前堆中值最小的元素，然后重新构建一个列表返回        while heap:            temp_node = ListNode(heappop(heap))            cur.next = temp_node            cur = temp_node        return dummy.next\n\n\n删除列表中的重复元素\n12345678if list1:    list1.sort()last = list1[-1]for i in range(len(list1)-2,-1,-1):    if last == list1[i]:        del list1[i]    else:        last = list1[if list1:    list1.sort()last = list1[-1]for i in range(len(list1)-2,-1,-1):    if last == list1[i]:        del list1[i]    else:        last = list1[1]\n\n可以使用内置的set方法list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]list2 = list(set(list1))print list2\n速度更快的一种方法list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]list2 = {}.fromkeys(list1).keys()print list2123但是通过这两种方法获得的list2排序变了，如果想维持原来list的排序可以通过以下方法：\n用list类的sort方法l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]l2 = list(set(l1))l2.sort(key=l1.index)print l2\n也可以这样写l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]l2 = sorted(set(l1),key=l1.index)print l2\n也可以用遍历（看起来比较蠢）l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]l2 = []for i in l1:    if not i in l2:        l2.append(i)print l2\n上面的代码也可以这样写l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]l2 = [][l2.append(i) for i in l1 if not i in l2]print l2\n\n83. 删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n示例 1:\n12输入: 1-&gt;1-&gt;2输出: 1-&gt;输入: 1-&gt;1-&gt;2输出: 1-&gt;2\n\n示例 2:\n12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3\n\n由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的肯定连续，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。\n迭代单指针 解题思路用cur表示当前节点初始化 cur 指针指向头部 head\nwhile循环遍历链表结束条件为：遍历完链表，即 cur.next 为空；头结点 head 可能为空，则也需要判断 cur 是否为空，如果所给链表为空直接返回，否则在执行cur.next这部操作时会因为cur为NULL而造成执行时错误当二者有一个不存在时说明链表没有去重复的必要了\n遍历过程中：(1)如果该节点出元素与下一节点元素相同时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果(2)如果不相等则 cur 移动到下一个位置继续循环\n细节分析需要判断 head 是否为空:(1) 可在开头判断 head 是否为空(2) 也可在 while 循环中判断 cur 是否为空\n为什么如果前后两节点元素相同，删除后节点，而不用 cur = cur.next 操作？答：是因为删除该节点的下一节点，该节点仍需要和新的下一节点进行比较\n时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，其中 n 是列表中的结点数。\n空间复杂度：O(1)，没有使用额外的空间。\n123456789101112131415161718192021222324252627282930313233from typing import Listclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        cur = head        while cur and cur.next:            if cur.val == cur.next.val:                cur.next = cur.next.next            else:                cur = cur.next        return headif __name__ == '__main__':    link1 = ListNode(1, ListNode(1, ListNode(5, ListNode(5))))    node = Solution().deleteDuplicates(link1)    res = []    while node:        res.append(node.val)        node = node.next    print(res)  # [1, 5]# cur.val = head.val = 1 = cur.next.val# cur.next.val = cur.next.next.val = 5# cur.val = cur.next.val = 5from typing import Listclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextclass Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        cur = head        while cur and cur.next:            if cur.val == cur.next.val:                cur.next = cur.next.next            else:                cur = cur.next        return headif __name__ == '__main__':    link1 = ListNode(1, ListNode(1, ListNode(5, ListNode(5))))    node = Solution().deleteDuplicates(link1)    res = []    while node:        res.append(node.val)        node = node.next    print(res)  # [1, 5]# cur.val = head.val = 1 = cur.next.val# cur.next.val = cur.next.next.val = 5# cur.val = cur.next.val = 5# cur.next.val = cur.next.next.val = 5.next.next.val = None\n\n法二：双指针定义两个指针，一个指向头节点，另外一个指向头节点的下一节点，不断遍历；\n边遍历边比较这两个指针指向的节点的值，如果值相等的话，当前节点就指向其下下个节点（相当于删除了其下一节点），然后继续遍历，否则不做处理直接继续遍历，直到遍历完整个链表。\n12345678910class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if head is None or head.next is None: return head        cur, next = head, head.next        while cur and next:            if next.val != cur.val: cur = cur.next            else: cur.next = next.next            next = next.next        class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if head is None or head.next is None: return head        cur, next = head, head.next        while cur and next:            if next.val != cur.val: cur = cur.next            else: cur.next = next.next            next = next.next        return head\n\n123456789101112131415161718192021222324252627282930class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        dummy = ListNode(0)        dummy.next = head        slow = dummy        fast = dummy.next        while fast:            if slow.val == fast.val:                fast = fast.next                slow.next = fast            else:                fast = fast.next                slow = slow.next                        return dummy.next# slow = dummy = 0# fast = head = 1# fast = fast.next = 1.next = 1# slow = slow.next = 0.next = 1# fast = fast.next = 1.next = 5# slow.next = fast = 5# fast = fast.next = 5.next = 5# slow = slow.next = 5# fast = fast.next = 5.next = Noneclass Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        dummy = ListNode(0)        dummy.next = head        slow = dummy        fast = dummy.next        while fast:            if slow.val == fast.val:                fast = fast.next                slow.next = fast            else:                fast = fast.next                slow = slow.next                        return dummy.next# slow = dummy = 0# fast = head = 1# fast = fast.next = 1.next = 1# slow = slow.next = 0.next = 1# fast = fast.next = 1.next = 5# slow.next = fast = 5# fast = fast.next = 5.next = 5# slow = slow.next = 5# fast = fast.next = 5.next = None# slow.next = fast = None\n\n法三：递归解题思路递归写法的删除节点操作是 通过返回下一节点 连接到上一节点，实现参数节点(即当前节点)的删除\n把一个链表看成头节点后挂接一个更短的链表，依次类推。所以可以先处理头节点后面挂接的更短的链表，如果头节点的值等于其挂接的更短的链表的头节点的值，则直接返回更短的链表的头节点，否则返回原链表的头节点。\n终止条件: 遍历完链表(1) head 为空，即空链表(2) head.next 为空 链表只有头节点。\n终止处理: 返回当前节点\n提取重复逻辑:(1) 节点的”连接”: 利用函数返回值作为下一节点(2) 节点的”删除”: 判断是否当前节点元素与下一节点元素是否相同, 返回相应的节点\n递归函数返回的不重复子链的头结点，在回溯过程中，比较当前节点和子链头结点的val是否相同，若相同则保留当前节点（删除子链的头结点）。\n12345678910111213141516171819202122232425262728293031323334353637383940class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        head.next = self.deleteDuplicates(head.next)        if head.val == head.next.val:            head.next = head.next.next        return head# 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6# head = 1# self.deleteDuplicates(head.next)#     head = head.next = 1.next = 1#     self.deleteDuplicates(1)#     self.deleteDuplicates(head.next)#         head = head.next = 1.next = 5#         self.deleteDuplicates(5)#         因为 head.next = 5.next = 5，所以#         self.deleteDuplicates(head.next)#             head = head.next = 5.next = 5#             self.deleteDuplicates(5)#             self.deleteDuplicates(head.next)#                 head = head.next = 5.next = 6#                 self.deleteDuplicates(6)#                 因为head.next = 5.next = None，所以#                 return head = 6 return表示本层函数结束。#             返回上一层，#             head.next = return head = 6 return表示本层函数结束。#             head.val = 5 != head.next.val = 6#             return head = 5#         返回上一层#         head.val = 5 = head.next.val#         head.next = head.next.next = 6#         return head = 5#     返回上一层#     head.val = 1 != head.next.val = 5#     return head = 1# 返回上一层# head.val = 1 = head.next.val# head.next = head.next.next = 5class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        head.next = self.deleteDuplicates(head.next)        if head.val == head.next.val:            head.next = head.next.next        return head# 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6# head = 1# self.deleteDuplicates(head.next)#     head = head.next = 1.next = 1#     self.deleteDuplicates(1)#     self.deleteDuplicates(head.next)#         head = head.next = 1.next = 5#         self.deleteDuplicates(5)#         因为 head.next = 5.next = 5，所以#         self.deleteDuplicates(head.next)#             head = head.next = 5.next = 5#             self.deleteDuplicates(5)#             self.deleteDuplicates(head.next)#                 head = head.next = 5.next = 6#                 self.deleteDuplicates(6)#                 因为head.next = 5.next = None，所以#                 return head = 6 return表示本层函数结束。#             返回上一层，#             head.next = return head = 6 return表示本层函数结束。#             head.val = 5 != head.next.val = 6#             return head = 5#         返回上一层#         head.val = 5 = head.next.val#         head.next = head.next.next = 6#         return head = 5#     返回上一层#     head.val = 1 != head.next.val = 5#     return head = 1# 返回上一层# head.val = 1 = head.next.val# head.next = head.next.next = 5# return head = 1\n\n123456789101112131415161718192021222324252627282930313233343536373839class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        # 删除头节点后面挂接的链表中的重复元素        head.next = self.deleteDuplicates(head.next)        # 头节点与后面挂接的链表中的节点值相同，则头节点也删除，否则不删除        return head.next if head.val == head.next.val else head# 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6# head = 1# self.deleteDuplicates(head.next)#     head = head.next = 1.next = 1#     self.deleteDuplicates(1)#     self.deleteDuplicates(head.next)#         head = head.next = 1.next = 5#         self.deleteDuplicates(5)#         因为 head.next = 5.next = 5，所以#         self.deleteDuplicates(head.next)#             head = head.next = 5.next = 5#             self.deleteDuplicates(5)#             self.deleteDuplicates(head.next)#                 head = head.next = 5.next = 6#                 self.deleteDuplicates(6)#                 因为head.next = 5.next = None，所以#                 return head = 6 return表示本层函数结束。#             返回上一层#             head.next = return head = 6#             head.val = 5 != head.next.val = 6#             return head = 5#         返回上一层#         head.val = 5 = head.next.val#         return head.next = 5#     返回上一层#     head.val = 1 != head.next.val = 5#     return head = 1# 返回上一层# head.val = 1 = head.next.valclass Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        # 删除头节点后面挂接的链表中的重复元素        head.next = self.deleteDuplicates(head.next)        # 头节点与后面挂接的链表中的节点值相同，则头节点也删除，否则不删除        return head.next if head.val == head.next.val else head# 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6# head = 1# self.deleteDuplicates(head.next)#     head = head.next = 1.next = 1#     self.deleteDuplicates(1)#     self.deleteDuplicates(head.next)#         head = head.next = 1.next = 5#         self.deleteDuplicates(5)#         因为 head.next = 5.next = 5，所以#         self.deleteDuplicates(head.next)#             head = head.next = 5.next = 5#             self.deleteDuplicates(5)#             self.deleteDuplicates(head.next)#                 head = head.next = 5.next = 6#                 self.deleteDuplicates(6)#                 因为head.next = 5.next = None，所以#                 return head = 6 return表示本层函数结束。#             返回上一层#             head.next = return head = 6#             head.val = 5 != head.next.val = 6#             return head = 5#         返回上一层#         head.val = 5 = head.next.val#         return head.next = 5#     返回上一层#     head.val = 1 != head.next.val = 5#     return head = 1# 返回上一层# head.val = 1 = head.next.val# return head.next = 1\n\n\n12345678class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        if head.val == head.next.val:            return self.deleteDuplicates(head.next)        head.next = self.deleteDuplicates(head.next)        class Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        if head.val == head.next.val:            return self.deleteDuplicates(head.next)        head.next = self.deleteDuplicates(head.next)        return head\n\n\n\n17.圆圈中最后剩下的数 [^本题考点 模拟]每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)\n思路分析：\n这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。\n链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).\n链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).\n这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。\n链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)\n  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。\n但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：\n(iii+m)%n    我们一共是 n 个值，从0-(n-1);\nf(n-1) = iii\n所以 f(n) = f `(n-1) = (iii+m)%n\n所以 f(n) = (f(n-1)+m)\n那么这个通项表达式我们就找到了，再去编写代码。\n1234567891011121314151617181920class Solution:    def LastRemaining_Solution(self, n, m):        # write code here        #通过推导公式可得 f(n) = (f(n-1)+m)%n        #首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.        if n &lt; 1 or m &lt; 1:            return -1        #只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。        if n==1:            return 0        value = 0        #时间复杂度 o(n)        #从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1         for index in range(2,n+1):            #现在数到的 m-1 这个值 的索引。对应上上面的公式。            currentValue = (value+m) % index            #把找到的这个下标值 赋值给 value            value = currentValue        #返回编号        class Solution:    def LastRemaining_Solution(self, n, m):        # write code here        #通过推导公式可得 f(n) = (f(n-1)+m)%n        #首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.        if n &lt; 1 or m &lt; 1:            return -1        #只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。        if n==1:            return 0        value = 0        #时间复杂度 o(n)        #从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1         for index in range(2,n+1):            #现在数到的 m-1 这个值 的索引。对应上上面的公式。            currentValue = (value+m) % index            #把找到的这个下标值 赋值给 value            value = currentValue        #返回编号        return value\n\n\n18.链表中环的入口点 [^本题知识点  链表]给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n\n123456789101112131415161718192021222324252627282930313233343536373839class Solution:    def EntryNodeOfLoop(self, pHead):        # write code here        #首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。        #循环跳        #要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。        if pHead == None:            return None         #定义两个指针，一个快的一个慢的。        fastPointer = pHead        slowPointer = pHead        #当快指针存在时，而且快指针的结点指向的下一个也存在        while fastPointer and fastPointer.next :            #那么让快指针走两步            fastPointer = fastPointer.next.next            #让慢指针走一步            slowPointer = slowPointer.next            #如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break            if fastPointer == slowPointer:                break        #如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。        if fastPointer == None or fastPointer.next == None:            return None        #如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度        #假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d        # 那么  L = s + d        #假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少        # fast 走的长度 就是 ( m + d ) * n + d + s = 2 L        #带入 ( m + d ) * n + d + s = 2 （s + d ）        # s = m + (n-1)(m+d)        #有环的话，那么就让快指针从头开始走，这次一次走一步，        fastPointer = pHead        #此时慢指针还在环里走着，没有走到结点        while fastPointer != slowPointer:            fastPointer = fastPointer.next            slowPointer = slowPointer.next        #当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。        class Solution:    def EntryNodeOfLoop(self, pHead):        # write code here        #首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。        #循环跳        #要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。        if pHead == None:            return None         #定义两个指针，一个快的一个慢的。        fastPointer = pHead        slowPointer = pHead        #当快指针存在时，而且快指针的结点指向的下一个也存在        while fastPointer and fastPointer.next :            #那么让快指针走两步            fastPointer = fastPointer.next.next            #让慢指针走一步            slowPointer = slowPointer.next            #如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break            if fastPointer == slowPointer:                break        #如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。        if fastPointer == None or fastPointer.next == None:            return None        #如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度        #假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d        # 那么  L = s + d        #假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少        # fast 走的长度 就是 ( m + d ) * n + d + s = 2 L        #带入 ( m + d ) * n + d + s = 2 （s + d ）        # s = m + (n-1)(m+d)        #有环的话，那么就让快指针从头开始走，这次一次走一步，        fastPointer = pHead        #此时慢指针还在环里走着，没有走到结点        while fastPointer != slowPointer:            fastPointer = fastPointer.next            slowPointer = slowPointer.next        #当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。        return fastPointer\n\n\n\n定义：\n假设 slow 走了 L 步，那么 fast 就走了 2L 步。\n 我们 链表的头部 到 链表的环的入口结点处 的距离是 S\n那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 \n链表的环中，慢指针走过的距离是d，那么没走过的距离是M。\n我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。\n那么 L = s + d\n2L = 2(s+d) = n*(m + d) + d + s\n由上面公式 推导出 n(m+d) = s + d\n得到：s = n(m+d) -d；\ns = nm + (n-1)(d)s = m + (n-1)(m+d)\n\n19.二进制中的1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示\n输入是整数~ 但是都是二进制存储的，当我们用位运算操作时，就应该展开成二进制来分输出该二进制串的 1 的个数\n知识点:方法一：逐位判断\n\n根据 与运算 定义，设二进制数字 n ，则有：\n若 n&amp;1=0 ，则 n 二进制 最右一位 为 0 ；\n若 n&amp;1=1 ，则 n 二进制 最右一位 为 1 。\n\n\n根据以上特点，考虑以下 循环判断 ：\n判断 n 最右一位是否为 1 ，根据结果计数。\n将 n 右移一位（本题要求把数字 n 看作无符号数unsigned value，因此使用 无符号右移 操作，输入是正数负数都可以）。\n\n\n\n算法流程：1.初始化数量统计变量 res = 0 。2.循环逐位判断： 当 n = 0 时跳出。  1.res += n &amp; 1 ： 若 n&amp;1=1 ，则统计数 res 加一。  2.n &gt;&gt;= 1 ： 将二进制数字 n 无符号右移一位。  对于负数，最高位为 1 ，有符号右移 最高位填1，因此无法达到 n = 0，就无法跳出循环了返回统计数量 res 。\n时间复杂度 O(log_2 n)此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；取决于循环次数，而循环次数取决于数字 n 的“位数”，数字 n 的位数是 log n逐位判断需循环 log_2 n 次，log n 代表数字 n 最高位的 1 的所在位数，因为二进制最高位 $1$ 决定了循环位移次数~（例如 log_2 4 = 2, log_2 16 = 4）。\n空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。\n无符号的整数\n1234567class Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        while n:            res += n &amp; 1            n &gt;&gt;= 1        class Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        while n:            res += n &amp; 1            n &gt;&gt;= 1        return res\n\npython的int无限宽度，是不会溢出的，达到界限后会自己转为long算法中需要用到了32位int的溢出来参与运算，有的结果却需要溢出的int作为参数继续参与运算在python上想实现溢出效果，找到一个函数这个函数可以得到32位int溢出结果\n123456ret = 123456789 &lt;&lt; 20print(ret)# 129453825982464print(bin(ret))# 0b11101011011110011010001010100000000000000000000ret = 123456789 &lt;&lt; 20print(ret)# 129453825982464print(bin(ret))# 0b11101011011110011010001010100000000000000000000# 明显已经超出32位了\n\n在JS上document.writeln(123456789 &lt;&lt; 20);得到结果是-783286272这就是溢出后截取的\n无符号右移&gt;&gt;&gt;，就是将有符号int a和b转为无符号uint后，再进行普通右移&gt;&gt;运算比如-1的有符号int就是-1，无符号int就是4294967295在JS中，可以使用 a&gt;&gt;&gt;b来实现无符号位移，python中没有这个运算符，只能自己实现了\n1234567891011121314151617181920212223242526272829303132import ctypesdef int_overflow(val):    maxint = 2147483647    if not -maxint - 1 &lt;= val &lt;= maxint:        val = (val + (maxint + 1)) % (2 * (maxint + 1)) - maxint - 1    return valret = int_overflow(123456789 &lt;&lt; 20)print(ret)  # -783286272 和JS的结果一样print(bin(ret))# -0b101110101100000000000000000000def unsigned_right_shitf(n, i):    \"\"\"无符号右移\"\"\"    # 数字小于0，则转为32位无符号uint    if n &lt; 0:        n = ctypes.c_uint32(n).value    # 正常位移位数是为正数，但是为了兼容js之类的，    # 负数就右移变成左移好了    if i &lt; 0:        return -int_overflow(n &lt;&lt; abs(i))    # print(n)    return int_overflow(n &gt;&gt; i)ret = unsigned_right_shitf(-1, 20)print(ret)  # 4095import ctypesdef int_overflow(val):    maxint = 2147483647    if not -maxint - 1 &lt;= val &lt;= maxint:        val = (val + (maxint + 1)) % (2 * (maxint + 1)) - maxint - 1    return valret = int_overflow(123456789 &lt;&lt; 20)print(ret)  # -783286272 和JS的结果一样print(bin(ret))# -0b101110101100000000000000000000def unsigned_right_shitf(n, i):    \"\"\"无符号右移\"\"\"    # 数字小于0，则转为32位无符号uint    if n &lt; 0:        n = ctypes.c_uint32(n).value    # 正常位移位数是为正数，但是为了兼容js之类的，    # 负数就右移变成左移好了    if i &lt; 0:        return -int_overflow(n &lt;&lt; abs(i))    # print(n)    return int_overflow(n &gt;&gt; i)ret = unsigned_right_shitf(-1, 20)print(ret)  # 4095# 和JS上执行 -1 >>> 20 一样。\n\n\n如果 python 输入有符号整数时的情况，由于 python 存储负数的特殊性，循环右移操作不能正常终止，因此需要先获取n 的补码，再开始右移~\n12345678910111213141516171819202122232425262728293031323334353637class Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        n &amp;= 0xffffffff        while n:            res += n &amp; 1            n &gt;&gt;= 1        return res``` 方法二：巧用 n&amp;(n − 1)- (n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。- n&amp;(n − 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。算法流程：  1.初始化数量统计变量 res 。  2.循环消去最右边的     1. 当 n = 0 时说明没有一个1了,跳出。  1. res += 1 ： 统计变量加 1 ；  2. n &amp;= n - 1 ： 消去数字 n 最右边的 1    我们消除了多少1变成一个1都没有了， 就说明n有多少个1了  n&amp;(n-1) 还可以用来判断 n 是否是 2 的幂~   3.返回统计数量 res 。时间复杂度 O(M) ： n&amp;(n−1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。```pythonclass Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        while n:            res += 1            n &amp;= n - 1        class Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        n &amp;= 0xffffffff        while n:            res += n &amp; 1            n &gt;&gt;= 1        return res``` 方法二：巧用 n&amp;(n − 1)- (n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。- n&amp;(n − 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。算法流程：  1.初始化数量统计变量 res 。  2.循环消去最右边的     1. 当 n = 0 时说明没有一个1了,跳出。  1. res += 1 ： 统计变量加 1 ；  2. n &amp;= n - 1 ： 消去数字 n 最右边的 1    我们消除了多少1变成一个1都没有了， 就说明n有多少个1了  n&amp;(n-1) 还可以用来判断 n 是否是 2 的幂~   3.返回统计数量 res 。时间复杂度 O(M) ： n&amp;(n−1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。```pythonclass Solution:    def hammingWeight(self, n: int) -&gt; int:        res = 0        while n:            res += 1            n &amp;= n - 1        return res\n\n123456789101112131415161718192021# 第一种：class Solution2:    def NumberOf1(self, n):        # write code here        # 1 出现的次数为0 次        count = 0        #判断 这个数 n 是不是负数，如果是负数的话 求其补码：        if n &lt; 0:            n = n &amp; 0xffffffff        #如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.        while n:            count += 1            #把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。            n = (n - 1) &amp; n        return count    \"\"\"    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.    # 第一种：class Solution2:    def NumberOf1(self, n):        # write code here        # 1 出现的次数为0 次        count = 0        #判断 这个数 n 是不是负数，如果是负数的话 求其补码：        if n &lt; 0:            n = n &amp; 0xffffffff        #如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.        while n:            count += 1            #把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。            n = (n - 1) &amp; n        return count    \"\"\"    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.        \"\"\"\n\n\n给你两个&nbsp;非空 的链表，表示两个非负的整数。它们每位数字都是按照&nbsp;逆序&nbsp;的方式存储的，并且每个节点只能存储&nbsp;一位&nbsp;数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。示例 1：输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2：\n输入：l1 = [0], l2 = [0]输出：[0]示例 3：\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.class ListNode(object):    def __init__(self, x):        self.val = x        self.next = Noneclass Solution(object):    def system_change(self, l3):        pp = l3        while True:            if l3.val &gt;= 10:                l3.val = l3.val - 10                tm, l3 = l3, l3.next                if not l3:                    tm.next = ListNode(1)                else:                    l3.val += 1            else:                l3 = l3.next            if not l3:                return pp    def addTwoNumbers(self, l1, l2):        \"\"\"        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        \"\"\"        p1 = l1        p2 = l2        p3 = p3h = None        while True:            if p1 and p2:                if p3:                    p3.next = ListNode(p1.val + p2.val)                    p3 = p3.next                else:                    p3h = p3 = ListNode(p1.val + p2.val)            p1 = p1.next            p2 = p2.next            if p1 and not p2:                p2 = ListNode(0)            if p2 and not p1:                p1 = ListNode(0)            if not (p1 and p2):                # Definition for singly-linked list.class ListNode(object):    def __init__(self, x):        self.val = x        self.next = Noneclass Solution(object):    def system_change(self, l3):        pp = l3        while True:            if l3.val &gt;= 10:                l3.val = l3.val - 10                tm, l3 = l3, l3.next                if not l3:                    tm.next = ListNode(1)                else:                    l3.val += 1            else:                l3 = l3.next            if not l3:                return pp    def addTwoNumbers(self, l1, l2):        \"\"\"        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        \"\"\"        p1 = l1        p2 = l2        p3 = p3h = None        while True:            if p1 and p2:                if p3:                    p3.next = ListNode(p1.val + p2.val)                    p3 = p3.next                else:                    p3h = p3 = ListNode(p1.val + p2.val)            p1 = p1.next            p2 = p2.next            if p1 and not p2:                p2 = ListNode(0)            if p2 and not p1:                p1 = ListNode(0)            if not (p1 and p2):                return self.system_change(p3h)\n\n\n20.不用加减乘除做加法[^本题考点 按位运算]*写一个函数，求两个整数之和，要求在函数体内不得使用+、-、、/四则运算符号。**\na, b 均可能是负数或 0结果不会溢出 32 位整数 Overflow题目给定的输入值的位数不会超过32，\n题目说不能使用运算符 + 和 -，那么我们就要使用其他方式来替代这两个运算符的功能。\n以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；101 + 10001 = 10110第一步：各位相加 但不进位： 不进位的话 结果为 10100 \n第二步： 记下进位，它只在最后一位相加时产生了一个进位。\n第三步： 把前面两个结果相加，得到的结果是 10110.\n那么现在我们把前面的 二进制的加法用位运算来替代的话\n位运算中的两数加法，不考虑 进位其实来来回回就只有下面这四种：\n12345       无进位和        进位 0 + 0 = 0             00 + 1 = 1             01 + 0 = 1             01 + 1 = 0                    无进位和        进位 0 + 0 = 0             00 + 1 = 1             01 + 0 = 1             01 + 1 = 0             1\n无进位和 符合 相同位为 0，不同位为 1 的异或运算规律，无进位加法。\n123456789a = 5 = 0101b = 4 = 0100a ^ b 如下：0 1 0 10 1 0 0-------0 0 0 a = 5 = 0101b = 4 = 0100a ^ b 如下：0 1 0 10 1 0 0-------0 0 0 1\na ^ b 得到了一个无进位加法结果，如果要得到 a + b 的最终值，我们还要找到进位的数，把这二者相加。在位运算中，我们可以使用与 &amp; 运算：\n12345678a = 5 = 0101b = 4 = 0100a &amp; b 如下：0 1 0 10 1 0 0-------0 1 0 a = 5 = 0101b = 4 = 0100a &amp; b 如下：0 1 0 10 1 0 0-------0 1 0 0\n由计算结果可见，0100 并不是我们想要的进位，1 + 1 所获得的进位应该要放置在它的更高位，即左侧位上，因此我们还要把 0100 左移一位，a&amp;b&lt;&lt;1，得到它 向前进位的值\n总结一下：1.a + b 和 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)2.无进位加法使用异或运算计算得出 a^b3.进位结果使用与运算和左移一位移位运算计算得出 。a&amp;b&lt;&lt;14.将上述两结果“相加”即可得到最终结果，但是，我们没有加号，循环此过程，重复把前面两个步骤的结果再相加，但是这次的 数值 改为上次的两个结果，判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。直到进位为 0，此时 和 = 无进位结果 ，返回 无进位结果\n时间复杂度 O(1) ： 最差情况下，例如 a = 0x7fffffff , b = 1 时，每次循环b左移一位，b 从右数 必增加一个 0 ,循环31次后，b=0x80000000，也就是最高位还是1，还得再循环一次，所以一共32次将 b 变为 0 。每轮中的常数次位操作\n空间复杂度 O(1) ： 使用常数大小的额外空间。\n12345678910111213class Solution:    def add(self, a: int, b: int) -&gt; int:        x = 0xffffffff        a, b = a &amp; x, b &amp; x        while b != 0:            # 由于 b = (a &amp; b) &lt;&lt; 1 &amp; x 中有左移操作，            # 因此需要每轮和 x 与一下，            # 以保证 b 是 32 位数（高位全部为 0 ）            a, b = (a ^ b), (a &amp; b) &lt;&lt; 1 &amp; x        # a &lt;= 0x7fffffff(最大的正数的补码)， a 是正数，        # 正常的补码直接返回自己本身        # 是负数 32 位以上的位取反，1 至 32 位不变        return a if a &lt;= 0x7fffffff class Solution:    def add(self, a: int, b: int) -&gt; int:        x = 0xffffffff        a, b = a &amp; x, b &amp; x        while b != 0:            # 由于 b = (a &amp; b) &lt;&lt; 1 &amp; x 中有左移操作，            # 因此需要每轮和 x 与一下，            # 以保证 b 是 32 位数（高位全部为 0 ）            a, b = (a ^ b), (a &amp; b) &lt;&lt; 1 &amp; x        # a &lt;= 0x7fffffff(最大的正数的补码)， a 是正数，        # 正常的补码直接返回自己本身        # 是负数 32 位以上的位取反，1 至 32 位不变        return a if a &lt;= 0x7fffffff else ~(a ^ x)\nQ :  若数字 a 和 b 中有负数，则变成了减法，如何处理？A ： 在计算机系统中，数值一律用 补码 来表示和存储、运算补码的优势： 加法、减法可以统一处理（CPU只有加法器）。\nc java等是有位数限制的，所以可以直接做。C语言版本输出a时，是采用补码格式输出的，问题是在于C语言版本中int是32位的，进入下最后一个循环后，b左移一位后，最高位的1就溢出了，那么b就变成了0.\n其实和python输出的前32项是一模一样的，在32位的系统中int类型的表示范围为[-231,231-1],在python 是某种程度上位数可以无限扩展，也就无所谓补码，因为补码都是相对于位数来说的，32 位补码和 16 位补码，肯定是不一样的。但是这样就导致了一个问题，就是无法直接得到32位二进制补码。如果补码超过了2**31-1这个边界,那么他代表的原码就是一个负数,我们需要将它转换成对应的源码0x80000000 的二进制是 0b10000000000000000000000000000000，为2^31次方0x8000000是32位有符号整型的最小值,直接输入大于0x80000000的数时，计算机将其处理为原码而非补码。\n结果左移的1跑到33位，b仍然不是0，实际上永远也不是0，于是就无限循环了，不会导致溢出.\n\n剑指 Offer 39. 数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1:\n123输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2长度为9的数组。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2长度为9的数组。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。。\n\n众数（Mode）是指在统计分布上具有明显集中趋势点的数值，代表数据的一般水平。也是一组数据中出现次数最多的数值，有时众数在一组数中有好几个。\n本题超过长度一般\n法一：摩尔投票法Boyer-Moore：\n\n票数和： 由于众数出现的次数超过数组长度的一半；若记候选 众数 的票数为 +1 ，非众数 的票数为 -1 ，则一定有所有数字的 票数和 &gt; 0 。\n\n票数正负抵消： 设数组 nums 中的众数为 candidate ，数组长度为 n 。若 nums 的前 a 个数字的 票数和 = 0 ，则 数组后 (n-a) 个数字的 票数和一定仍 &gt;0（即后 (n−a) 个数字的 众数仍为 candidate ）\n\n\n算法原理：\n\n为构建正负抵消，假设数组首个元素 n_1 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 candidate ）：\n\n当 n_1 = candidate： 抵消的所有数字中，有一半是众数 candidate 。\n当 n_1 !=candidate ： 抵消的所有数字中，少于或等于一半是众数 candidate 。\n\n\n利用此特性，每轮假设都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）。\n\n\n算法流程:  \n\n初始化： 票数统计 votes = 0 ， 众数 candidate可以为任意值；  \n循环抵消： 遍历数组 nums 中的每个元素 num ；\n当 票数 votes 等于 0 ，则假设 当前数字 num 的值赋予为 众数 candidate ；\n当 num = candidate 时，票数 votes 自增 1 ；否则，num != candidate 时，票数 votes 自减 1 。遍历完成后，candidate 即为整个数组的众数。\n返回值： 返回 众数 candidate \n\n若没有选中众数，那么迭代的时候这个数就会因为它出现次数小于一半，而重新选择其他数。如果选中了众数，那么count可能大于零小于0，最终是大于0.如果是其他数，又会count到0.\n时间复杂度 O(N) ： N 为数组 nums 长度，对数组进行了一次遍历。空间复杂度 O(1) ： votes 变量使用常数级别大小的额外空间。\n12345678910111213141516171819202122from typing import Listclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        votes = 0        candidate = None  # 可省略        for num in nums:            if votes == 0:                candidate = num            if num == candidate:                votes += 1            else:                votes += -1            # votes += (1 if num == candidate else -1)        return candidateif __name__ == \"__main__\":    arr = [1, 2, 3, 2, 2, 2, 5, 4, 2]    s = Solution()    print(s.majorityElement(arr))  from typing import Listclass Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        votes = 0        candidate = None  # 可省略        for num in nums:            if votes == 0:                candidate = num            if num == candidate:                votes += 1            else:                votes += -1            # votes += (1 if num == candidate else -1)        return candidateif __name__ == \"__main__\":    arr = [1, 2, 3, 2, 2, 2, 5, 4, 2]    s = Solution()    print(s.majorityElement(arr))  # 2\n\n123456789101112131415161718192021222324252627282930313233343536votes = 0candidate = Nonenum = 1candidate = num = 1votes = vote + 1 = 1num = 2 != candidate = 1votes = vote - 1 = 0num = 3 votes = 0candidate = num = 3votes = vote + 1 = 1num = 2 num = 2 != candidate = 3votes = vote - 1 = 0num = 2votes = 0candidate = num = 2votes = vote + 1 = 1num = 2 = candidatevotes = vote + 1 = 2num = 5 != candidate = 2votes = vote - 1 = 1num = 4 != candidate = 2votes = vote - 1 = 0num = 2 = candidate candidate = num = 2votes = vote + 1 = votes = 0candidate = Nonenum = 1candidate = num = 1votes = vote + 1 = 1num = 2 != candidate = 1votes = vote - 1 = 0num = 3 votes = 0candidate = num = 3votes = vote + 1 = 1num = 2 num = 2 != candidate = 3votes = vote - 1 = 0num = 2votes = 0candidate = num = 2votes = vote + 1 = 1num = 2 = candidatevotes = vote + 1 = 2num = 5 != candidate = 2votes = vote - 1 = 1num = 4 != candidate = 2votes = vote - 1 = 0num = 2 = candidate candidate = num = 2votes = vote + 1 = 1\n\n思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。\n我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution:    def MoreThanHalfNum_Solution(self, numbers):        #dict [key] = count        #o(n) 空间复杂度为O(n)     #第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。        numsCount = {}        numLen = len(numbers)        for num in numbers:            if num in numsCount:                numsCount[num] += 1            else:                numsCount[num] = 1             #如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.            if numsCount[num] &gt; (numLen &gt;&gt; 1):                return num        return 0                #想要空间复杂度为O（1），时间复杂度为o(n)#第二种：        #定义变量 上次出现的数字为0        last = 0        #上次出现的数字的数量为0         lastCount = 0        #遍历数组中的数字        for num in numbers:            #如果说这个数字出现的次数为0了。            if lastCount == 0:                #那么就把上次出现的数字，变为需要保存的那个数字。                last = num                #并把次数设置为1 次，出现了这一次。                lastCount = 1            else:                #否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.                if num == last:                    lastCount += 1                #如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；                else:                    lastCount -= 1        #如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉        if lastCount == 0:            return 0        #否则的话，就说明 数组里面 留下了没有抵消掉的数        else:            #这种情况是last可能是大于一半的数字            #这个时候把 记录数字次数的变量 计数 为0             lastCount = 0            #遍历数组中的数            for num in numbers:                #如果这个数与我们记录的数相等的话                if num == last:                    #让这个计数加1                    lastCount += 1            #最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.            if lastCount &gt; (len(numbers)&gt;&gt; 1):                return last        return class Solution:    def MoreThanHalfNum_Solution(self, numbers):        #dict [key] = count        #o(n) 空间复杂度为O(n)     #第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。        numsCount = {}        numLen = len(numbers)        for num in numbers:            if num in numsCount:                numsCount[num] += 1            else:                numsCount[num] = 1             #如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.            if numsCount[num] &gt; (numLen &gt;&gt; 1):                return num        return 0                #想要空间复杂度为O（1），时间复杂度为o(n)#第二种：        #定义变量 上次出现的数字为0        last = 0        #上次出现的数字的数量为0         lastCount = 0        #遍历数组中的数字        for num in numbers:            #如果说这个数字出现的次数为0了。            if lastCount == 0:                #那么就把上次出现的数字，变为需要保存的那个数字。                last = num                #并把次数设置为1 次，出现了这一次。                lastCount = 1            else:                #否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.                if num == last:                    lastCount += 1                #如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；                else:                    lastCount -= 1        #如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉        if lastCount == 0:            return 0        #否则的话，就说明 数组里面 留下了没有抵消掉的数        else:            #这种情况是last可能是大于一半的数字            #这个时候把 记录数字次数的变量 计数 为0             lastCount = 0            #遍历数组中的数            for num in numbers:                #如果这个数与我们记录的数相等的话                if num == last:                    #让这个计数加1                    lastCount += 1            #最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.            if lastCount &gt; (len(numbers)&gt;&gt; 1):                return last        return 0\n\n\n哈希表统计法： 遍历数组 nums ，用 HashMap 统计每个元素出现的次数。最终超过数组长度一半的数字则为众数。\n算法用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。\n时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 O(n)（可参考下文的空间复杂度分析），那么遍历的时间不会超过 O(n)。因此总时间复杂度为 O(n)。\n空间复杂度：O(n)。哈希表最多包含 n - [n/2] 个键值对，所以占用的空间为 O(n)。这是因为任意一个长度为 n 的数组最多只能包含 n 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） [n/2]+1 个数字。因此最多有 n - ([n/2]+1) 个不同的其他数字，所以最多有 n - [n/2] 个不同的元素。\n123456789class Solution:    def majorityElement(self, nums):        import collections        votes = collections.Counter(nums)        # count.keys()返回是键         # 求的不是票数个数最大的元素key        # max里面比较的就是值（个数）        # 加了key=votes.get表示比较票数的大小，        class Solution:    def majorityElement(self, nums):        import collections        votes = collections.Counter(nums)        # count.keys()返回是键         # 求的不是票数个数最大的元素key        # max里面比较的就是值（个数）        # 加了key=votes.get表示比较票数的大小，        return max(votes.keys(), key=votes.get)\n1234votes = {2: 5, 1: 1, 3: 1, 5: 1, 4: 1}print(votes.keys())  # dict_keys([2, 1, 3, 5, 4])print(max(votes))  # 5print(max(votes.keys()))  # votes = {2: 5, 1: 1, 3: 1, 5: 1, 4: 1}print(votes.keys())  # dict_keys([2, 1, 3, 5, 4])print(max(votes))  # 5print(max(votes.keys()))  # 5\n\n123456789101112131415161718192021class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        if not nums:  # 数组为空            return 0        hashset = {}        for num in nums:            # hashset[num] = hashset[num] + 1 if hashset.get(num) else 1            if hashset.get(num):                hashset[num] = hashset[num] + 1             else:                hashset[num] =  1             # if hashset[num] &gt; len(nums) / 2:               # Python3.6之后下面的字典迭代要比这里的列表迭代要快，            # 所以验证众数使用下面的字典迭代            #     return num        for key, value in hashset.items():            if value &gt; len(nums) / 2:                return key        return 0  class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        if not nums:  # 数组为空            return 0        hashset = {}        for num in nums:            # hashset[num] = hashset[num] + 1 if hashset.get(num) else 1            if hashset.get(num):                hashset[num] = hashset[num] + 1             else:                hashset[num] =  1             # if hashset[num] &gt; len(nums) / 2:               # Python3.6之后下面的字典迭代要比这里的列表迭代要快，            # 所以验证众数使用下面的字典迭代            #     return num        for key, value in hashset.items():            if value &gt; len(nums) / 2:                return key        return 0  # 不存在众数\n\n法三数组排序法：\n如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，由于众数的数量超过数组长度一半，因此 数组中点的元素 下标为 [n/2] 的元素（下标从 0 开始）一定是众数。\n我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。\n对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为⌋ [n/2] 的地方有重叠。因此，无论众数是多少，返回  [n/2]  下标对应的值都是正确的。\n时间复杂度： O(NlogN)， Python内置排序算法Timsort的时间复杂度空间复杂度：不需要用到额外的空间\n1234class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        nums.sort()        return nums[len(nums) // 2]\n\n\n22.数组中只出现一次的数字[^数组]一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。\n思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution:    # 返回[a,b] 其中ab是出现一次的两个数字    def FindNumsAppearOnce(self, array):        # write code here        #如果两个数相同那么两个数的异或操作为0        #数组的长度如果小于2，那么就就不会有数字出现了偶数次。        if len(array) &lt; 2:            return None        #变量赋值 两个数的异或为none        twoNumXor = None        #遍历 数组中的数字        for num in array:            #判断 如果 两个数的数字异或的结果为0 的话，            if twoNumXor == None:                #那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。                twoNumXor = num            #如果数 这个数不为 空 的话            else:                #那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。                twoNumXor = twoNumXor ^ num        #变量  计数 为 0         count = 0        #当异或的 结果 为偶数时        while twoNumXor % 2 == 0 :            #那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。            twoNumXor  = twoNumXor &gt;&gt; 1  # 右移以为 相当于 除以2            count += 1        #以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。                #我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1                mask = 1 &lt;&lt; count   #向左 移 位 count 位。        #为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。                firstNum = None        secondNum = None        for num in array:            if mask &amp; num == 0:                if firstNum == None:                    firstNum = num                else:                    firstNum = firstNum ^ num            else:                if secondNum == None:                    secondNum = num                else:                    secondNum = secondNum ^ num        class Solution:    # 返回[a,b] 其中ab是出现一次的两个数字    def FindNumsAppearOnce(self, array):        # write code here        #如果两个数相同那么两个数的异或操作为0        #数组的长度如果小于2，那么就就不会有数字出现了偶数次。        if len(array) &lt; 2:            return None        #变量赋值 两个数的异或为none        twoNumXor = None        #遍历 数组中的数字        for num in array:            #判断 如果 两个数的数字异或的结果为0 的话，            if twoNumXor == None:                #那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。                twoNumXor = num            #如果数 这个数不为 空 的话            else:                #那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。                twoNumXor = twoNumXor ^ num        #变量  计数 为 0         count = 0        #当异或的 结果 为偶数时        while twoNumXor % 2 == 0 :            #那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。            twoNumXor  = twoNumXor &gt;&gt; 1  # 右移以为 相当于 除以2            count += 1        #以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。                #我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1                mask = 1 &lt;&lt; count   #向左 移 位 count 位。        #为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。                firstNum = None        secondNum = None        for num in array:            if mask &amp; num == 0:                if firstNum == None:                    firstNum = num                else:                    firstNum = firstNum ^ num            else:                if secondNum == None:                    secondNum = num                else:                    secondNum = secondNum ^ num        return firstNum,secondNum\n\n\n23.整数中1出现的次数[^本题考点 数组]求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。\n\n\n解题思路：将 1 ~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。\n密码锁，就是那种几个滚轮的密码锁，固定其中的一位密码，拨动其他位置的密码。每次计算是按照位数来的，而不是看整体的数值，是在计算当 cur 位出现的 1 的数量,一位一位地统计，目标就是防止重复统计啦\n比如当前计算的是十位上的1的个数，那么对于0011来说，虽然出现了两次1，但是十位上1的只有1个。\n1 位数含1最多为: 1 个  12 位数含1最多为: 20 个 1, 11, 12, 13 ..19, 21, 31, 41, 51, …, 91我们要分开两部分讨论：只看个位：这个位置能出现’1’的次数为(十位的最大值+1) * 1位数能出现’1’的最大次数，在这里有10次(1,11,21,…91)只看十位：这个位置能出现’1’，即只有当十位为’1’的时候的次数，即10^位数（这里是2，即十位），在这里有10次(10,11,12,…,19)将个位出现过的次数与十位出现过的次数相加，便是我们的答案 = 20。\n3 位数含1最多为: 300 个 1, 11, 12, 13 ..19, 100~199, 201, 211, 12, 13 ..194 位数含1最多为: 4000 个\n设数字 n 是个 x 位数，记 n 的第 i 位为 n_in，则可将 n 写为 n_{x} n_{x-1} \\cdots n_{2} n_{1}n称 “ n_in “ 为 当前位 ，记为 cur ，将 “ n_{i-1} n_{i-2} \\cdots n_{2} n_{1}n “ 称为 低位 ，记为 low ；将 “ n_{x} n_{x-1} \\cdots n_{i+2} n_{i+1}n “ 称为 高位 ，记为 high 。将 10^i 称为 位因子 ，记为 digit 。某位中 1 出现次数的计算方法：根据当前位 cur 值的不同，分为以下三种情况：1.当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：high×digit\n假如 104，计算十位出现1的个数(此时cur=0)，那么10，11，12···19都符合。出现 1 的数字范围：010019只看高低位：0009易得 1 出现次数为：9-0+1=10 0~9 总共是十个数啊1 x 10 =10\n假如 2304，计算十位出现1的次数(此时cur=0)首先可以把0010~2219范围内，十位是1的所有数字枚举出来。\n123456789100010，0011...0019（1在十位出现10次）0110，0111...0119（1在十位出现10次）...0910，0911...0919（1在十位出现10次）1010，1011...1019（1在十位出现10次）...1910，1911...1919（1在十位出现10次）2010，2011...2019（1在十位出现10次）2110，2111...2119（1在十位出现10次）2210，2211...2219（1在十位出现0010，0011...0019（1在十位出现10次）0110，0111...0119（1在十位出现10次）...0910，0911...0919（1在十位出现10次）1010，1011...1019（1在十位出现10次）...1910，1911...1919（1在十位出现10次）2010，2011...2019（1在十位出现10次）2110，2111...2119（1在十位出现10次）2210，2211...2219（1在十位出现10次）\n可以看到高位（前两位）的变化范围是0022，有23种选择。固定高位是某一种情况时，低位（个位）变化范围是09，有10种选择。高位和低位组合，就有23*10=230种组合。总结规律，你会发现，其实可以把00102219里的十位数字直接“抠”掉，剩下的就是000229，一共就是230个数字。\n因为十位上面的1已经是固定的，所以其实000229里的每个数，和上面所枚举的230个数字是一一对应的。比如000对应着0010，001对应着0011…所以000229范围内数字的个数，就是0010~2219范围内十位出现1的数字个数。因为十位固定了 0， 能变得是 23 、 4 这三位数字。因此当十位固定是 1 时，只能取 0 ~ 229 ，因此是 23 * 10 。\n出现 1 的数字范围：00102219只看高低位：000229易得 1 出现次数为：229-0+1=230结论high×digit = 23 x 10 =230\n2.当 cur = 1 时： 此位 1 的出现次数只由高位 high 和 低位 low 决定，计算公式为：high×digit+low+1\n假如 2314，计算十位出现1的次数(此时cur=1)出现 1 的数字范围：00102314只看高低位：000234易得 1 出现次数为：234-0+1=235high×digit+low+1 = 23 x 10 + 4 +1 = 235\n3.当 cur &gt; 1, 即cur = 2,3,…,9 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：(high+1)×digit\n假如 2324，计算十位出现1的次数(此时cur=2)出现 1 的数字范围：00102319只看高低位：000239易得 1 出现次数为：234-0+1=240(high+1)×digit = (23 + 1) x 10 = 240\n设计按照 “个位、十位、…” 的顺序计算，则 high / cur / low / digit 应初始化为：\n1234high = n // 10  # 整数除法cur = n % 10low = 0digit = 1 high = n // 10  # 整数除法cur = n % 10low = 0digit = 1 # 个位\n\n从个位到最高位的变量递推公式为：\n12345678# 当 cur = 0, high != 0 时，此时还要计算cur# 当 high = 0, cur != 0 时，cur处于最高位，此时还要计算cur# 当 high = cur = 0 时，cur已经越过最高位，因此跳出循环while high != 0 or cur != 0:    low += cur * digit # 将 cur 加入 low ，组成下轮 low   cur = high % 10 # 下轮 cur 是本轮 high 的最低位   high //= 10 # 将本轮 high 最低位删除，得到下轮 high   digit *= 10 # 当 cur = 0, high != 0 时，此时还要计算cur# 当 high = 0, cur != 0 时，cur处于最高位，此时还要计算cur# 当 high = cur = 0 时，cur已经越过最高位，因此跳出循环while high != 0 or cur != 0:    low += cur * digit # 将 cur 加入 low ，组成下轮 low   cur = high % 10 # 下轮 cur 是本轮 high 的最低位   high //= 10 # 将本轮 high 最低位删除，得到下轮 high   digit *= 10 # 位因子每轮 × 10\n32104\n\n从个位开始, digit = 1cur =4&gt;1, low =0, high =3210res += (high+1)×digit = (3210 + 1) x 1 = 3211高位从0~3209变化的过程中，每一个变化中1只出现1次，即（高位1）这样的数字；高位是3210时，因为当前位是4，所以1只能出现一次，即32101。\n\n十位, digit= 10cur =0, low = 4, high =321res += 3211 + high ×digit = 3211 + 321 x 10 = 6421res =  (high - 1 +1）× digit = (321 -1 +1) x 10 = 3210那么高位从0~ 320的过程中，有321种，每一个变化1出现10次，这样的数字i位置要想为1，就必须向高位借1，因此此时低位部分是都可以取到0-9的；高位为321的时候，因为当前位为0，所以不存在出现1的可能性。\n\n\n百位, digit = 100cur =1, low = 04, high =32res += 6421 + high×digit+low+1 = 6421 + 32 x 100 + 4 +1 = 9626高位从0~ 31变化的过程中，32种可能，每一个变化中1出现100次，即（高位10）（高位19）这样的数字，低位部分是可取到0-9的高位为32的时候，因为当前位是1，所以我们要看低位来决定出现的次数，低位部分的每个位置不能取到0-9，低位为4，所以此时出现5次，即3210032104这样的数字。\n千位, digit = 1000cur =2&gt;1, low = 104, high = 3res += 9626 + (high+1)×digit = 9626 + (3+1) x 1000 = 13626高位从02变化的过程中，每一个变化中1只出现1000次，即（高位1）这样的数字；高位是3时，因为当前位是2，所以1能出现1000次，低位部分的每一个位置都可以取到0-9即3100031999。\n万位, digit = 10000cur =3&gt;1, low = 2104, high = 0res += 9626 + (high+1)×digit = 13626 + (0+1) x 10000 = 23626没有高位所以直接看当前位，因为当前位为3，所以1出现的次数为10000，即10000~19999这样的数字。\n因为本题的时间复杂度由 “循环次数” 决定，而循环次数由数字的位数决定，因为十进制数进位出现在 10 100 1000 ……，假设 n = 10 ^ i ，那么 n 的位数就是 i ～所以一个数字 n 的位数是 log_10 n\n因此复杂度即为 log n ~\n12345678910111213class Solution:    def countDigitOne(self, n: int) -&gt; int:        digit, res = 1, 0        high, cur, low = n // 10, n % 10, 0        while high != 0 or cur != 0:            if cur == 0: res += high * digit            elif cur == 1: res += high * digit + low + 1            else: res += (high + 1) * digit            low += cur * digit            cur = high % 10            high //= 10            digit *= 10        class Solution:    def countDigitOne(self, n: int) -&gt; int:        digit, res = 1, 0        high, cur, low = n // 10, n % 10, 0        while high != 0 or cur != 0:            if cur == 0: res += high * digit            elif cur == 1: res += high * digit + low + 1            else: res += (high + 1) * digit            low += cur * digit            cur = high % 10            high //= 10            digit *= 10        return res\n\n如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。\n那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。\n**若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ **\n​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有\n0-3458 个数 那么就一共是 3459 中可能性。\n​    那么十万位 后面 出现1 的情况有多少种 可能性 ？\n​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 10^5. \n那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。\n​    接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？\n如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共34591种情况，后面 是一共 4 位，那么就有        10^4 种情况。\n那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。\n​    我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？\n如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是\n3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有\n3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。\n分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution:    def NumberOf1Between1AndN_Solution(self, n):        #循环的出口是 highValue = 0        #我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。        # 一开始 精准度为1.高位低位中位 先赋值为1.        preceise = 1        highValue = 1        lowValue = 1        midValue =1        #计数 后面的位数。        count = 0        #计数 1 的次数和        sumNum = 0        #循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。        while highValue != 0:            #高位 先将这个数 除以10 得到高位            highValue = n // (preceise * 10)            #中位 先将这个数  与 10 取余。            midValue = (n // preceise)%10            #低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.            lowValue = n % preceise            #每遍历一次 向右移一位，那么就是说 精准度要乘以10.            preceise *= 10            #如果这个数是0 的话，                        if midValue == 0:                #那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，                num = (highValue)* pow(10,count)            #如果这个数 大于1 的话，            elif midValue &gt; 1:                #那么它 就是 最高位加1 乘以 10^后面的位数 次方，                num = (highValue+1)*pow(10,count)            else:                #否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。                num = highValue*pow(10,count)+(lowValue+1)            #最后 我们1 出现的 次数 就是这 三个 num 的和，。            sumNum += num            #没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。            count += 1        #最后返回这个  次数和。        class Solution:    def NumberOf1Between1AndN_Solution(self, n):        #循环的出口是 highValue = 0        #我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。        # 一开始 精准度为1.高位低位中位 先赋值为1.        preceise = 1        highValue = 1        lowValue = 1        midValue =1        #计数 后面的位数。        count = 0        #计数 1 的次数和        sumNum = 0        #循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。        while highValue != 0:            #高位 先将这个数 除以10 得到高位            highValue = n // (preceise * 10)            #中位 先将这个数  与 10 取余。            midValue = (n // preceise)%10            #低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.            lowValue = n % preceise            #每遍历一次 向右移一位，那么就是说 精准度要乘以10.            preceise *= 10            #如果这个数是0 的话，                        if midValue == 0:                #那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，                num = (highValue)* pow(10,count)            #如果这个数 大于1 的话，            elif midValue &gt; 1:                #那么它 就是 最高位加1 乘以 10^后面的位数 次方，                num = (highValue+1)*pow(10,count)            else:                #否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。                num = highValue*pow(10,count)+(lowValue+1)            #最后 我们1 出现的 次数 就是这 三个 num 的和，。            sumNum += num            #没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。            count += 1        #最后返回这个  次数和。        return sumNum\n\n\n24.丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？\n因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。\n1234567891011121314151617181920212223242526272829class Solution:    def GetUglyNumber_Solution(self, index):        # write code here        if index &lt; 1:            return None        #死循环，找丑数        #判断一个数是不是丑数，先循环除以2，直到不能整除，        #循环除以3 直到不能整除，循环除以5 直到不能整除        #这时如果剩余的值是1  我们就说它是丑数        #其他情况就都不是丑数        def isUglyNumber(num):            while num % 2 == 0:                num = num //2            while num % 3 == 0:                num = num //3            while num % 5 == 0:                num = num //5            if num == 1:                return True            else:                return False        count = 0        num = 1        while True:            if isUglyNumber(num):                count += 1            if count == index:                return num            num += class Solution:    def GetUglyNumber_Solution(self, index):        # write code here        if index &lt; 1:            return None        #死循环，找丑数        #判断一个数是不是丑数，先循环除以2，直到不能整除，        #循环除以3 直到不能整除，循环除以5 直到不能整除        #这时如果剩余的值是1  我们就说它是丑数        #其他情况就都不是丑数        def isUglyNumber(num):            while num % 2 == 0:                num = num //2            while num % 3 == 0:                num = num //3            while num % 5 == 0:                num = num //5            if num == 1:                return True            else:                return False        count = 0        num = 1        while True:            if isUglyNumber(num):                count += 1            if count == index:                return num            num += 1\n\n方法二:\nx6 x 2&gt; x9 = x5 x 26 x 2 = 12 &gt; 10 &gt;= 5 x 2 \nx4 x 3&gt; x9 = x3 x 34 x 3 = 12 &gt; 10 &gt;= 3 x 3\nx3 x 5&gt; x9 = x2 x 53 x 5 = 12 &gt; 10 &gt;= 2 x 5x10 = min(12, 12, 15) = 12\n用空间换时间，先排后存创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。\n给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置设置三个指针，这三个指针代表的值  分别为a,b,c.又由于这个列表中的所有的丑数从小到大排列的，1是丑数, 那么1乘以2,3,5得到的乘积也肯定是丑数(根据丑数的定义可知),也就是说每一个已知的丑数, 乘上2,3,5之后都会得到3个更大的丑数(可能有重复)要与前面的丑数比较大小，要把三个指针所在位置的元素做个对比,取最小的那个元素, 就是下一个丑数了.接着三个指针必须往下移动, 直到指向的元素都大于已知丑数才可以停下来,再继续比较，把丑数放入丑数数组中, 继续计算下一个丑数, 直到算出第n个丑数出来即可.\n一开始，丑数只有{1}，1可以同2，3，5相乘，那么 1 * 2 得到的是2,1*3 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 取最小的1×2=2添加到丑数序列中，现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。\n现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，只需要比较2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4 …\n依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，选择最小的那个作为下一个丑数，假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，所以它失去了同i相乘的资格，把对应的i+=1，让pi指向下一个丑数即可。\n动态规划解析：状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。转移方程：当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。\npi的含义是有资格同 i（i=2，3，5）相乘的最小丑数的位置。这里资格指的是：如果一个丑数dp[pi]通过乘以i可以得到下一个丑数，那么这个丑数dp[pi]就永远失去了同i相乘的资格（没有必要再乘了），我们把i+=1让dp[pi]指向下一个丑数即可。\n实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 。dp[a]×2&gt;dp[i−1]≥dp[a−1]×2dp[b]×3&gt;dp[i−1]≥dp[b−1]×3dp[c]×5&gt;dp[i−1]≥dp[c−1]×5\n\n初始状态： dp[0] = 1 ，即第一个丑数为 1 ；\n递推计算 dp[i]=min(dp[a]×2,dp[b]×3,dp[c]×5)​若 dp[i]= dp[a]×2 = dp[b]×3，两个索引都需要加1\n更新索引dp[a]×2 = dp[i] 执行a += 1dp[b]×3 = dp[i] 执行b += 1dp[c]×5 = dp[i] 执行c += 1\n返回值： dp[n-1] ，即返回第 n 个丑数。\n\n时间复杂度 O(N) ： 其中 N = n ，动态规划需遍历计算 dp 列表。空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。\n主要还是通过 丑数可以拆分为几个小丑数 的性质 来得到的。这样每次取到最接近的丑数，对应的因子就 +1，就能保证取到所有的丑数（不会遗漏）\n123456789101112131415161718192021222324252627class Solution:    def nthUglyNumber(self, n: int) -&gt; int:        # 初始化三个指针的 索引位置是0，        dp, a, b, c = [1] * n, 0, 0, 0        # print([1] * 2)  # [1, 1]        # print([1] * 3)  # [1, 1, 1]        # 因此 dp[0] 要对应第 1 个丑数，        #  dp[i] 为 i + 1 个丑数。        # 要求第 n 个丑数，就是要求 dp[n-1] ，        # 因此是 range(1, n) ，最后会遍历到 n - 1        for i in range(1, n):            # 给列表中的 a, b, c 这三个指针所在位置的丑数 分别 乘以2,3,5            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5            dp[i] = min(n2, n3, n5)            # 也可用dp=[1], dp.append(min(n2, n3, n5))            # 更新索引不能使用elif  因为存在2*某个丑数 ,3*某个丑数,5*某个丑数相同的情况，因此对应指针全部都要移动，保证数组中不会加入重复元素。            # 这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位            if dp[i] == n2:                a += 1            if dp[i] == n3:                b += 1            if dp[i] == n5:                c += 1        # 最终返回丑数列表的最后一个值即为第 n 个丑数        return dp[class Solution:    def nthUglyNumber(self, n: int) -&gt; int:        # 初始化三个指针的 索引位置是0，        dp, a, b, c = [1] * n, 0, 0, 0        # print([1] * 2)  # [1, 1]        # print([1] * 3)  # [1, 1, 1]        # 因此 dp[0] 要对应第 1 个丑数，        #  dp[i] 为 i + 1 个丑数。        # 要求第 n 个丑数，就是要求 dp[n-1] ，        # 因此是 range(1, n) ，最后会遍历到 n - 1        for i in range(1, n):            # 给列表中的 a, b, c 这三个指针所在位置的丑数 分别 乘以2,3,5            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5            dp[i] = min(n2, n3, n5)            # 也可用dp=[1], dp.append(min(n2, n3, n5))            # 更新索引不能使用elif  因为存在2*某个丑数 ,3*某个丑数,5*某个丑数相同的情况，因此对应指针全部都要移动，保证数组中不会加入重复元素。            # 这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位            if dp[i] == n2:                a += 1            if dp[i] == n3:                b += 1            if dp[i] == n5:                c += 1        # 最终返回丑数列表的最后一个值即为第 n 个丑数        return dp[-1]\nn2、n3、n5几个变量的声明不用放在循环外，执行到下一轮时，上一轮应该会释放的～ 这个高级语言会帮我们解决啦\n\n两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]\n\n数组中两个值相同的元素并不是相同元素，数组不是集合\n法一：保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。由于哈希查找的时间复杂度为 O(1)，比index索引速度快；dict替换item in list提速\n如果存在则找到了两个值，如果不存在则将当前的 num当作key,i当作value 存入 map 中，继续遍历直到找到为止\n时间复杂度：O(N)空间复杂度：O(N)\n123456789101112131415161718192021from typing import Listclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashset = {}        for i in range(len(nums)):            # if hashset.get(target - nums[i]) is not None:            # return hashset.get(target - nums[i]), i            if target - nums[i] in hashset:                return hashset[target - nums[i]], i            hashset[nums[i]] = iif __name__ == '__main__':    solution = Solution()    nums = [2, 7, 11, 15]    target = from typing import Listclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashset = {}        for i in range(len(nums)):            # if hashset.get(target - nums[i]) is not None:            # return hashset.get(target - nums[i]), i            if target - nums[i] in hashset:                return hashset[target - nums[i]], i            hashset[nums[i]] = iif __name__ == '__main__':    solution = Solution()    nums = [2, 7, 11, 15]    target = 13    index = solution.twoSum(nums, target)    print(index)\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！题干中并没有说 nums 是有序的，当碰到相同的元素时，dct[n] = i 会将最近遍历的元素索引写入字典。\n1234567891011class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashmap = {}        for i, num in enumerate(nums):            # 每个值都判断map中是否存在 target-nums[i] 的 key 值            if target - num in hashmap:                # return [hashmap[target - num],i]                return [i, hashmap[target - num]]            # 如果不存在            # 则将当前的num当作key,i当作value存入 hashmap 中,保证遍历的时候有值            hashmap[num] = i  class Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashmap = {}        for i, num in enumerate(nums):            # 每个值都判断map中是否存在 target-nums[i] 的 key 值            if target - num in hashmap:                # return [hashmap[target - num],i]                return [i, hashmap[target - num]]            # 如果不存在            # 则将当前的num当作key,i当作value存入 hashmap 中,保证遍历的时候有值            hashmap[num] = i  #  给字典创建键值对，不是查找，\n对于每一个新的数，先找是否有存的数能满足条件的，如果没有，或是重复数不满足求和条件，或者不重复数不满足求和条件。重复数的覆盖是不怕的，因为题目说只有一个满足要求的答案，所以这个重复数字如果没找到满足要求的结果，那就可以放弃这个数字了。\n实现去重：每次执行if语句 i，num这一组值还没有加入到字典当中去，所以就可以避免了这句不能放在if语句之前，解决hashmap中有重复值或target-num=num的情况\nnums = [2, 7, 11, 15], target = 13i=0, num=2, 13-2=11不在hashmap={},hashmap={2:0}i=1, num=7, 13-7=6不在hashmap={2:0} hashmap={2:0, 7:1}i=2, num=11, 13-11=2在hashmap={2:0, 7:1} 返回2的下标和11的下标\n 1.每次写入时，判断条件 不是当前的key本身存不存在， 而是key和 tag 之间的差值存不存在，这一点很重要。 2.题目命题说明了一点，假定只有一个解。也就是说重复元素再多都无所谓。 case 1：如果有3个或者以上的重复元素，代表这个重复元素不可能是解，所以写入map的时候直接覆盖也无所谓； case2：如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于tag。这种情况下，当遇到第二个重复元素时，不会写入map，这个时候直接已经取到解了。 所以这种方式，不用考虑hash冲突的问题。\n法三：用1个for循环直接用target 减去 取出的数字，看结果有没有在数组里\n1234567891011121314class Solution:    def twoSum(self,nums,target):        n = len(nums)        for x in range(n):            a = target - nums[x]            if a in nums: # 判断a有没有在nums数组里                y = nums.index(a) # 有的话，那么用index获取到该数字的下标                if x == y:                     continue # 同样的数字不能重复用，所以这里如果是一样的数字，那么就不满足条件，跳过                else: # 否则就返回结果                    return x,y                     break            else:                 continue class Solution:    def twoSum(self,nums,target):        n = len(nums)        for x in range(n):            a = target - nums[x]            if a in nums: # 判断a有没有在nums数组里                y = nums.index(a) # 有的话，那么用index获取到该数字的下标                if x == y:                     continue # 同样的数字不能重复用，所以这里如果是一样的数字，那么就不满足条件，跳过                else: # 否则就返回结果                    return x,y                     break            else:                 continue # 上面的条件都不满足就跳过，进行下一次循环\n\n\n法四 暴力最慢 时间复杂度O（n²），空间复杂度O（1）\n拿数组里的第一个数字和后面的数字分别相加，看是否等于target；如果不等于target，那么就继续拿数组里的第二个数字和后面的数字相加；不停的去一个个试…直到等于target，返回这2个数字所在的下标\n12345678910class Solution:    def twoSum(self,nums,target):        n = len(nums) # 获取nums的长度，是4        # 外层循环先取出下标0，对应着数组里的第一个数字        for x in range(n):             # 内层循环取出下标1，对应着数组里的第二个数字            for y in range(x+1,n):                 # 如果第一个数字+第二个数字=target                if nums[x] + nums[y] == target:                     return x,y class Solution:    def twoSum(self,nums,target):        n = len(nums) # 获取nums的长度，是4        # 外层循环先取出下标0，对应着数组里的第一个数字        for x in range(n):             # 内层循环取出下标1，对应着数组里的第二个数字            for y in range(x+1,n):                 # 如果第一个数字+第二个数字=target                if nums[x] + nums[y] == target:                     return x,y # 上面的判断是对的话，那么就返回下标\n\n123456789101112131415class Solution(object):    def twoSum(self, nums, target):        \"\"\"        :type nums: List[int]        :type target: int        :rtype: List[int]        \"\"\"        for i, itm in enumerate(nums):            other = target - itm            try:                posi = nums.index(other)                if posi != i:                    return sorted([posi, i])            except ValueError:                class Solution(object):    def twoSum(self, nums, target):        \"\"\"        :type nums: List[int]        :type target: int        :rtype: List[int]        \"\"\"        for i, itm in enumerate(nums):            other = target - itm            try:                posi = nums.index(other)                if posi != i:                    return sorted([posi, i])            except ValueError:                pass\n\n20. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n\n注意空字符串可被认为是有效字符串。\n\n示例 1:\n12输入: \"()\"输出: 输入: \"()\"输出: true\n\n示例 2:\n12输入: \"()[]{}\"输出: 输入: \"()[]{}\"输出: true\n\n示例 3:\n12输入: \"(]\"输出: 输入: \"(]\"输出: false\n\n示例 4:\n12输入: \"([)]\"输出: 输入: \"([)]\"输出: false\n\n示例 5:\n12输入: \"{[]}\"输出: 输入: \"{[]}\"输出: true\n\n\n注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。\n辅助栈法\n12345\"{()[()]}\"\"{  [()]}\"\"{  [  ]}\"\"{      }\"\"{()[()]}\"\"{  [()]}\"\"{  [  ]}\"\"{      }\"\"        \"\n\n\n算法原理\n\n栈的先进后出，后进先出的特点恰好与本题括号排序特点一致，即若先遇到左括号入栈，当遇到匹配的最里面右括号时，将这对应左括号从栈中删除，也就是将对应栈顶左括号出栈。\n\n为了快速判断括号的类型，我们可以使用哈希映射（HashMap）存储每一种左右括号对应关系。哈希表 dic的键key 为左括号，值value为相同类型的右括号，这样查询 2 个括号是否对应只需 O(1) 时间复杂度；\n\n\n\n\n建立栈 stack，遍历字符串 s 并按照算法流程一一判断。\n\n空字符串不会进入for循环\n\n\n算法流程\n\n如果 char 是左括号，则入栈 push；\n否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 char 不对应，则提前返回 false。\n\n\n提前返回 false\n\n提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。\n\n解决边界问题： \n\n栈 stack 为空： 此时 stack.pop() 操作会报错；假设s中第一个元素是右括号，此时就会报错了。因此，我们采用一个取巧方法，给 stack 赋初值 ? 就可以避免这个问题并在哈希表 dic 中建立 key: ‘?’，value:’?’ 的对应关系予以配合。有这个 ? 后： 当 stack 为空且 char 为右括号时，可以正常提前返回 false ；若没有则会报错。\n\n字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。则遍历完所有括号后 stack 仍然为空，\n\n\n\n\n\n\n\n复杂度分析\n时间复杂度 O(N)：正确的括号组合或者全是左括号需要遍历 1 遍 s；出栈和入栈都是0(1) n 是字符串 s 的长度。\n空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希映射使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。哈希表和栈使用线性的空间大小。\n\n\n\n12345dict1 = {'a': 1, 'b': 2, '1': 'c'}# 判断的是key是否在字典里而不是判断valueprint('a' in dict1)  # Trueprint(1 in dict1)  # Falseprint('1' in dict1)  dict1 = {'a': 1, 'b': 2, '1': 'c'}# 判断的是key是否在字典里而不是判断valueprint('a' in dict1)  # Trueprint(1 in dict1)  # Falseprint('1' in dict1)  # True\n\n1234567891011121314151617181920212223242526class Solution:    def isValid(self, s: str) -&gt; bool:        # 先排除一半的情形（奇数）        if len(s) % 2 == 1:            return False        dic = {'{': '}', '[': ']', '(': ')', '?': '?'}        # 若stack = [] 栈 stack 为空时，执行 stack.pop() 操作会报错，        # 假设s中单个右括号入栈 ，此时就会报错了。        # 但在最开始加一个?就可以避免这个问题。用一点空间换每次不用判空,        stack = ['?']          # 判断的是key是否在字典里而不是判断value        for char in s:            if char in dic:                stack.append(char)            elif dic[stack.pop()] != char:  # elif不等于if，if 和 elif只能同时执行一个                return False        return len(stack) == 1solution = Solution()# print(solution.isValid(''))  # True# print(solution.isValid('}'))  # Falseprint(solution.isValid('}}'))  # False# print(solution.isValid('[{}()]'))  # True# print(solution.isValid('[}(){()[]}]'))  # Falseprint(solution.isValid('[['))  class Solution:    def isValid(self, s: str) -&gt; bool:        # 先排除一半的情形（奇数）        if len(s) % 2 == 1:            return False        dic = {'{': '}', '[': ']', '(': ')', '?': '?'}        # 若stack = [] 栈 stack 为空时，执行 stack.pop() 操作会报错，        # 假设s中单个右括号入栈 ，此时就会报错了。        # 但在最开始加一个?就可以避免这个问题。用一点空间换每次不用判空,        stack = ['?']          # 判断的是key是否在字典里而不是判断value        for char in s:            if char in dic:                stack.append(char)            elif dic[stack.pop()] != char:  # elif不等于if，if 和 elif只能同时执行一个                return False        return len(stack) == 1solution = Solution()# print(solution.isValid(''))  # True# print(solution.isValid('}'))  # Falseprint(solution.isValid('}}'))  # False# print(solution.isValid('[{}()]'))  # True# print(solution.isValid('[}(){()[]}]'))  # Falseprint(solution.isValid('[['))  # False\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970例子1s = ''len(s) % 2 = 0 % 2 = 0 != 1stack = ['?']for char in s:    char = None 错错错，不会执行这一句直接跳过循环，return len(stack) = len(['?']) = 1return True例子2s = '}'len(s) % 2 = 1 % 2 = 1return False例子3s = '}}'len(s) % 2 = 2 % 2 = 0 != 1stack = ['?']for char in s:    dic[stack.pop()] = dic['?'] = '?' != char = '}'    return False例子4s ='[{}()]'stack = ['?']for char in s:    char  = '['    stack = ['?', '[']    char = '{'     stack = ['?', '[', '{']    char = '}'     dic[stack.pop()] = dic['{'] = '}' = char = '}'    stack = ['?', '[']    char = '('     stack = ['?', '[', '(']    char = ')'     dic[stack.pop()] = dic['('] = ')' = char = ')'    stack = ['?', '[']    char = ']'     dic[stack.pop()] = dic['['] = ']' = char = ']'    stack = ['?']    return len(stack) == 1 = Ture例子5s ='[}(){()[]}]'stack = ['?']for char in s:    char = '['    stack = ['?', '[']        char = '}'    dic[stack.pop()] = dic['['] = ']' != char = '}'    return False例子6s ='[['stack = ['?']for char in s:    char = '['    stack = ['?', '[']        char = '['    stack = ['?', '[', '[']] return len(stack) == 3 != 1 = 例子1s = ''len(s) % 2 = 0 % 2 = 0 != 1stack = ['?']for char in s:    char = None 错错错，不会执行这一句直接跳过循环，return len(stack) = len(['?']) = 1return True例子2s = '}'len(s) % 2 = 1 % 2 = 1return False例子3s = '}}'len(s) % 2 = 2 % 2 = 0 != 1stack = ['?']for char in s:    dic[stack.pop()] = dic['?'] = '?' != char = '}'    return False例子4s ='[{}()]'stack = ['?']for char in s:    char  = '['    stack = ['?', '[']    char = '{'     stack = ['?', '[', '{']    char = '}'     dic[stack.pop()] = dic['{'] = '}' = char = '}'    stack = ['?', '[']    char = '('     stack = ['?', '[', '(']    char = ')'     dic[stack.pop()] = dic['('] = ')' = char = ')'    stack = ['?', '[']    char = ']'     dic[stack.pop()] = dic['['] = ']' = char = ']'    stack = ['?']    return len(stack) == 1 = Ture例子5s ='[}(){()[]}]'stack = ['?']for char in s:    char = '['    stack = ['?', '[']        char = '}'    dic[stack.pop()] = dic['['] = ']' != char = '}'    return False例子6s ='[['stack = ['?']for char in s:    char = '['    stack = ['?', '[']        char = '['    stack = ['?', '[', '[']] return len(stack) == 3 != 1 = False\n\n法二：对给定的字符串 s 进行遍历，对每一个字符进行如下操作当遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。\n当我们遇到一个右括号时，栈为空 或者 该右括号与取出的栈顶的左括号类型不一样，则返回false\n否则，即如果栈非空,且栈顶元素与接下来的字符(闭括号)相同类型,出栈\n在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，若栈非空,意味着开括号多了,返回 False。\n1234567891011121314151617181920class Solution:    def isValid(self, s: str) -&gt; bool:        if len(s) % 2 == 1:            return False        pairs = {            \")\": \"(\",            \"]\": \"[\",            \"}\": \"{\",        }        stack = list()        for ch in s:            if ch in pairs:                if not stack or stack[-1] != pairs[ch]:  # 顺序不能换                    return False                stack.pop()            else:                stack.append(ch)        # 如果栈中如果for遍历完后,栈非空,意味着左括号多了,则非法        return class Solution:    def isValid(self, s: str) -&gt; bool:        if len(s) % 2 == 1:            return False        pairs = {            \")\": \"(\",            \"]\": \"[\",            \"}\": \"{\",        }        stack = list()        for ch in s:            if ch in pairs:                if not stack or stack[-1] != pairs[ch]:  # 顺序不能换                    return False                stack.pop()            else:                stack.append(ch)        # 如果栈中如果for遍历完后,栈非空,意味着左括号多了,则非法        return not stack\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374例子1s = ''len(s) % 2 = 0 % 2 = 0 != 1stack = []for char in s:    char = None 错错错，不会执行这一句直接跳过循环，return not stack = True例子2s = '}'len(s) % 2 = 1 return False例子3s = '}}'len(s) % 2 = 2 % 2 = 0 return Falsestack = []for char in s:    char = '}'     stack = []    return False    例子4s ='[{}()]'len(s) % 2 = 2 % 2 = 0 stack = []for char in s:    char = '['    stack = ['[']    char = '{'     stack = ['[', '{']    char = '}'     stack[-1] = '{' = pairs[char]    stack = ['[']    char = '('     stack = ['[', '(']    char = ')'     stack[-1] = '{' = pairs[char]    char = ']'     stack[-1] = '[' = pairs[char]    stack = []    return not stack = Ture例子5s ='[}(){()[]}]'stack = []for char in s:    char = '['    stack = ['[']        char = '}'    stack[-1] = '[' != pairs[char] = '{'    return False例子6s ='[['stack = ['?']for char in s:    char = '['    stack = ['[']    char = '['    stack = ['[', '[']]return 例子1s = ''len(s) % 2 = 0 % 2 = 0 != 1stack = []for char in s:    char = None 错错错，不会执行这一句直接跳过循环，return not stack = True例子2s = '}'len(s) % 2 = 1 return False例子3s = '}}'len(s) % 2 = 2 % 2 = 0 return Falsestack = []for char in s:    char = '}'     stack = []    return False    例子4s ='[{}()]'len(s) % 2 = 2 % 2 = 0 stack = []for char in s:    char = '['    stack = ['[']    char = '{'     stack = ['[', '{']    char = '}'     stack[-1] = '{' = pairs[char]    stack = ['[']    char = '('     stack = ['[', '(']    char = ')'     stack[-1] = '{' = pairs[char]    char = ']'     stack[-1] = '[' = pairs[char]    stack = []    return not stack = Ture例子5s ='[}(){()[]}]'stack = []for char in s:    char = '['    stack = ['[']        char = '}'    stack[-1] = '[' != pairs[char] = '{'    return False例子6s ='[['stack = ['?']for char in s:    char = '['    stack = ['[']    char = '['    stack = ['[', '[']]return not stack = False\n\n\n1234567891011class Solution:    def isValid(self, s: str) -&gt; bool:        # 入栈与出栈        stack = []        for c in s:            # compare with top element            if stack and ((stack[-1] + c) in ['()', '{}', '[]']):                stack.pop()                continue            stack.append(c)        return len(stack) == class Solution:    def isValid(self, s: str) -&gt; bool:        # 入栈与出栈        stack = []        for c in s:            # compare with top element            if stack and ((stack[-1] + c) in ['()', '{}', '[]']):                stack.pop()                continue            stack.append(c)        return len(stack) == 0\n\n\n最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n示例 1：\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。示例 2：\n输入：nums = [1]输出：1示例 3：\n输入：nums = [0]输出：0示例 4：\n输入：nums = [-1]输出：-1示例 5：\n输入：nums = [-100000]输出：-100000\n\n4. 寻找两个正序数组的中位数给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n示例 1：\n输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2示例 2：\n输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5示例 3：\n输入：nums1 = [0,0], nums2 = [0,0]输出：0.00000示例 4：\n输入：nums1 = [], nums2 = [1]输出：1.00000示例 5：\n输入：nums1 = [2], nums2 = []输出：2.00000\n1234567891011121314151617class Solution(object):    def findMedianSortedArrays(self, nums1, nums2):        \"\"\"        :type nums1: List[int]        :type nums2: List[int]        :rtype: float        \"\"\"        nums1.extend(nums2)        nums1 = sorted(nums1)        num = len(nums1)        if num % 2 == 1:            index = (num + 1) / 2 - 1            return nums1[index]        else:            li = num / 2 - 1            ri = (num + 2) / 2 - 1            return (nums1[li] + nums1[ri]) / class Solution(object):    def findMedianSortedArrays(self, nums1, nums2):        \"\"\"        :type nums1: List[int]        :type nums2: List[int]        :rtype: float        \"\"\"        nums1.extend(nums2)        nums1 = sorted(nums1)        num = len(nums1)        if num % 2 == 1:            index = (num + 1) / 2 - 1            return nums1[index]        else:            li = num / 2 - 1            ri = (num + 2) / 2 - 1            return (nums1[li] + nums1[ri]) / 2.0\n\n\n\n11. 盛最多水的容器给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器。\n示例 1：\n输入：[1,8,6,2,5,4,8,3,7]输出：49解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。示例 2：\n输入：height = [1,1]输出：1示例 3：\n输入：height = [4,3,2,1,4]输出：16示例 4：\n输入：height = [1,2,1]输出：2\n12345678910111213141516171819202122class Solution(object):    def maxArea(self, height):        \"\"\"        :type height: List[int]        :rtype: int        \"\"\"        cap = 0        i = 0        j = len(height) - 1        while i &lt; j:            if height[i] &lt; height[j]:                cur = height[i] * (j - i)                i += 1            else:                cur = height[j] * (j - i)                j -= 1            if cur &gt; cap:                cap = cur        return capclass Solution(object):    def maxArea(self, height):        \"\"\"        :type height: List[int]        :rtype: int        \"\"\"        cap = 0        i = 0        j = len(height) - 1        while i &lt; j:            if height[i] &lt; height[j]:                cur = height[i] * (j - i)                i += 1            else:                cur = height[j] * (j - i)                j -= 1            if cur &gt; cap:                cap = cur        return cap# print Solution().maxArea([1, 2, 3, 4])\n\n\n\n整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n示例 1:\n输入: 3输出: “III”示例 2:\n输入: 4输出: “IV”示例 3:\n输入: 9输出: “IX”示例 4:\n输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3.示例 5:\n输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4.\n12345678910111213141516171819202122232425class Solution(object):    def romanToInt(self, s):        \"\"\"        :type s: str        :rtype: int        \"\"\"        roman_dict = {'I': 1,                      'V': 5,                      'X': 10,                      'L': 50,                      'C': 100,                      'D': 500,                      'M': 1000}        total = 0        last = 0        for i in s.upper():            num = roman_dict[i]            if num &gt; last:                total -= last            else:                total += num            last = num        return totalclass Solution(object):    def romanToInt(self, s):        \"\"\"        :type s: str        :rtype: int        \"\"\"        roman_dict = {'I': 1,                      'V': 5,                      'X': 10,                      'L': 50,                      'C': 100,                      'D': 500,                      'M': 1000}        total = 0        last = 0        for i in s.upper():            num = roman_dict[i]            if num &gt; last:                total -= last            else:                total += num            last = num        return total# print Solution().romanToInt('MCMLXXXIV')\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      ","categories":["数据结构与算法"],"tags":["剑指offer","Leetcode"]}]