<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="熟练度，一个题目默写5遍 任何逻辑都先写特殊情况，然后再一般程序&#x3D;算法+数据结构系统&#x3D;服务+存储。 脚本类语言的特殊性:如JS, Python等可以用来学习算法原理，但是不适于用来考察性能。因为具体的执行是在解释器上执行的，所以代码的执行效率在很多时候是依靠解释器的实现方式，解释器可能会对语言的内部的某一些函数做一些底层的优化，导致如果添加一些逻辑上的优化反而使得底层的优化失效了，最终整个代码的执">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer1~24题">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="熟练度，一个题目默写5遍 任何逻辑都先写特殊情况，然后再一般程序&#x3D;算法+数据结构系统&#x3D;服务+存储。 脚本类语言的特殊性:如JS, Python等可以用来学习算法原理，但是不适于用来考察性能。因为具体的执行是在解释器上执行的，所以代码的执行效率在很多时候是依靠解释器的实现方式，解释器可能会对语言的内部的某一些函数做一些底层的优化，导致如果添加一些逻辑上的优化反而使得底层的优化失效了，最终整个代码的执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%5C%E5%89%91%E6%8C%87offer%5C%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%9A%84%E7%BB%93%E7%82%B9.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%B8%B8%E6%88%8F.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E6%B3%95%E7%AE%97%E5%92%8C%E8%BF%90%E7%AE%97.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-05-31T11:35:55.018Z">
<meta property="article:author" content="外心人D">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/%5C%E5%89%91%E6%8C%87offer%5C%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.png">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/","path":"2020/08/21/jian-zhi-offer1-24-ti/","title":"剑指offer1~24题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>剑指offer1~24题 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%A4%E6%96%AD%E5%8D%A0%E7%94%A8%E6%97%B6%E9%97%B4"><span class="nav-text">判断时间复杂度判断占用时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">判断空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%9A-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E9%98%9F%E5%88%97-%E6%A0%88"><span class="nav-text">1. 两个栈实现一个队列：[^本题考点 队列 栈]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-text">解题思路：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%EF%BC%9A"><span class="nav-text">函数设计：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-text">复杂度分析：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">剑指 Offer 18. 删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95-%E5%88%86%E4%B8%BA%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">二分查找法 分为整数和浮点数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%9F%A5%E6%89%BE"><span class="nav-text">2. 旋转数组的最小数字 [^本题考点 查找]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E3%80%82"><span class="nav-text">数组：是有序的元素序列。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%9C%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%9F%A5%E6%89%BE"><span class="nav-text">3.在二维数组中的查找[^本题考点 查找]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8C%85%E5%90%ABmin-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%A0%88"><span class="nav-text">4.包含min 函数的栈[^本题考点 栈]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.替换空格[^本题考点 字符串]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">6.斐波那契数列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E7%9B%B8%E5%AF%B9%E6%9D%A5%E8%AF%B4%E6%AF%94%E8%BE%83%E7%AE%80%E4%BE%BF%EF%BC%8C%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AE%B2%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%8F%96%E5%87%BA%E8%BF%99%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%A4%E9%A1%B9%E6%B1%82%E5%92%8C%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%88%97%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E9%A1%B9%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83%E5%B0%8F%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA-n"><span class="nav-text">第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">42.连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">41.复杂链表的复制 [^本题考点 链表]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">7.青蛙跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">8.变态跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2-%E6%9C%AC%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%95%B0%E7%BB%84"><span class="nav-text">9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%EF%BC%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%A0%88"><span class="nav-text">10.栈的压入，弹出序列  [^本题考点 栈]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E4%BB%8E%E6%A0%88%E5%B0%BE%E5%88%B0%E6%A0%88%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-%E6%9C%AC%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">11. 从栈尾到栈头打印链表 [^本题知识点 链表]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">12.链表中的倒数第k个结点[^本题考点 链表]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">13.反转链表[^本题考点 链表]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">14.复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="nav-text">15.两个链表之间的第一个公共结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">16.合并两个排序的链表 [^本题考点  链表]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">23. 合并K个升序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E9%93%BE%E8%A1%A8-%E6%B2%A1%E6%9C%89%E5%88%A9%E7%94%A8%E5%90%84%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%8D%87%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">23. 合并K个链表 没有利用各个链表是升序的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">83. 删除排序链表中的重复元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%A8%A1%E6%8B%9F"><span class="nav-text">17.圆圈中最后剩下的数 [^本题考点 模拟]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9-%E6%9C%AC%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9-%E9%93%BE%E8%A1%A8"><span class="nav-text">18.链表中环的入口点 [^本题知识点  链表]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E7%9A%841%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">19.二进制中的1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">知识点:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">20.不用加减乘除做加法[^本题考点 按位运算]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-%E6%95%B0%E7%BB%84"><span class="nav-text">22.数组中只出现一次的数字[^数组]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%95%B0%E7%BB%84"><span class="nav-text">23.整数中1出现的次数[^本题考点 数组]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E4%B8%91%E6%95%B0"><span class="nav-text">24.丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text">20. 有效的括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="nav-text">最大子序和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">4. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">11. 盛最多水的容器</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">339</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer1-24-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指offer1~24题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-31 11:35:55" itemprop="dateModified" datetime="2021-05-31T11:35:55Z">2021-05-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>熟练度，一个题目默写5遍</p>
<p>任何逻辑都先写特殊情况，然后再一般<br>程序=算法+数据结构<br>系统=服务+存储。</p>
<p>脚本类语言的特殊性:如JS, Python等可以用来学习算法原理，但是不适于用来考察性能。<br>因为具体的执行是在解释器上执行的，所以代码的执行效率在很多时候是依靠解释器的实现方式，<br>解释器可能会对语言的内部的某一些函数做一些底层的优化，导致如果添加一些逻辑上的优化反而使得底层的优化失效了，最终整个代码的执行效率变低了</p>
<p>单独的return要怎么理解呢，无返回值 void 类型函数， 需要 return 提前终止~ 由于是无返回值函数，因此无需返回任何变量~</p>
<figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span>(not [])  <span class="meta"># 返回一个布尔值</span></span><br><span class="line"><span class="keyword">print</span>([] == None)  <span class="meta"># False</span></span><br></pre></td></tr></tbody></table></figure>
<p>力扣后台已经帮你定义好 TreeNode 这个类啦，就是默认代码那个被注释掉的部分，在本地你需要把那个树节点的类写上<br>每个节点是 O(1)，总节点数是 O(n) </p>
<p>ListNode这个是类，ListNode(i)实际上是类的实例化，它创建了一个对象，调用了initialization这个初始化函数<br>int(i)倒是直接将i的类型进行改变。</p>
<p>root 是 节点，是一个类的实例；root.val 是此节点的值；<br>[root] 是向当前列表添加一个子列表，子列表包含 root 节点</p>
<p>动态规划与分治的区别：前者自底向上，后者自顶向下</p>
<p>log n 一般和二叉树的高度相关，<br>例如：二叉搜索树的平均查找时间复杂度为 O(log n) 。<br>而树的遍历，一般都是 O(N) 复杂度，<br>例如先序遍历，每开启一个递归函数 遍历到一个节点，而树节点为 N ， 因此复杂度为 O(N)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ListNode(0) 建立一个值为 0 ListNode 类型的变量的节点实例，开辟结点的内存空间，</span></span><br><span class="line"><span class="comment"># 变量 node 引用指向 “节点实例”地址 </span></span><br><span class="line">node = ListNode(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判断时间复杂度判断占用时间"><a href="#判断时间复杂度判断占用时间" class="headerlink" title="判断时间复杂度判断占用时间"></a>判断时间复杂度判断占用时间</h3><ul>
<li>确定问题规模n</li>
<li>循环减半过程 –&gt; logn</li>
<li>K层关于n的循环 —&gt;nk<br>复杂情况：根据算法执行过程判断</li>
</ul>
<h3 id="判断空间复杂度"><a href="#判断空间复杂度" class="headerlink" title="判断空间复杂度"></a>判断空间复杂度</h3><p>评估算法内存占用大小的式子，表达方式与时间复杂度完全一样</p>
<ul>
<li>使用了几个变量：O(1)</li>
<li>使用了长度为n的一维列表：O(n)</li>
<li>使用了m行n列的二维列表：O(mn)</li>
</ul>
<p>算法（Algorithm）：是指解题方案的准确而完整的描述，<br>是一系列解决问题的清明确指令步骤，<br>算法代表着用系统的方法描述解决问题的策略机制。<br>能够对一定规范的输入，在有限时间内获得所要求的输出。<br>算法的实现是指将指令步骤序列转化成计算机能够执行的计算机程序。<br>而这个转化过程就叫计算机编程。</p>
<p>数据结构（Data Structures）：是计算机存储和组织数据的一种方式，可以用来高效地处理数据。<br>举个例子：二分查找就是一个非常经典的算法，而二分查找经常需要作用在一个有序数组上。<br>这里二分就是一种折半的算法思想，<br>很多算法需要特定的数据结构来实现，所以经常把它们放到一块讲。</p>
<p>抽象数据类型(Abstract Data Type)<br>ADT<br>指一个数学模型以及定义在此数学模型上的一组操作。<br>即把数据类型和数据类型上的运算捆在一起，进行封装。<br>引入抽象数据类型的目的是<br>把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。<br>我们自定义的 ADT 必须要有一个实现，<br>而实现 ADT 时我们所做出的选择会影响实现的功能和效率。<br>数据结构可以通过以下两方面来描述：<br>它们如何存储和组织单个数据元素<br>提供哪些操作来存取和处理其上的数据</p>
<p>有很多常用的数据结构，如链表、堆、栈，队列，树等。<br>所有的数据结构都会存储一组数据值，<br>但对于如何组织单个数据项和提供哪些操作来处理数据集上有区别。<br>实现 ADT 时，需要根据具体问题来选择具体的数据结构。<br>例如，实现打印队列最好选择 queue 数据结构，而 B-Tree 适合数据库索引。</p>
<p>实际上，在真正的项目开发中，大部分时间都是<br>从数据库取数据 -&gt; 数据操作和结构化 -&gt; 返回给前端，<br>在数据操作过程中需要合理地抽象， 组织、处理数据，<br>如果选用了错误的数据结构，就会造成代码运行低效。<br>这也是我们需要学习算法和数据结构的原因。</p>
<p>实现新的数据类型时，我们将使用 python 的 class 实现，它包含属性和方法。<br>属性一般是使用某种特定的数据类型，<br>而方法一般是对属性的操作。 </p>
<p>ADT: Abstract Data Type，抽象数据类型，<br>我们在组合已有的数据结构来实现一种新的数据类型，<br>定义的数据类型，它指定了一组数据值的集合及可作用在这些数据值上的一组操作。<br>ADT 的定义与它的具体实现无关，因此我们可以只关注如何使用它，而无需关注它的具体实现。</p>
<p>ADT 可被看作为一个黑盒子。用户程序与 ADT 实例的交互是通过调用定义在 ADT 接口上的操作进行的。这些操作集可分为 4 类：</p>
<p>Constructors: 创建和初始化 ADT 的实例<br>Accessors: 返回实例中的数据，而不进行修改<br>Mutators: 修改 ADT 实例的内容<br>Iterators: 逐个处理单个数据组件</p>
<p>我们以抽象一个背包(Bag) 数据类型来说明，<br>背包是一种容器类型，我们可以给它添加东西，也可以移除东西，<br>并且我们想知道背包里 有多少东西。<br>于是我们可以定义一个新的数据类型叫做 Bag.</p>
<hr>
<h2 id="1-两个栈实现一个队列：-本题考点-队列-栈"><a href="#1-两个栈实现一个队列：-本题考点-队列-栈" class="headerlink" title="1. 两个栈实现一个队列：[^本题考点 队列 栈]"></a>1. 两个栈实现一个队列：[^本题考点 队列 栈]</h2><p><strong>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )。队列中的元素为int类型。</strong></p>
<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ul>
<li>栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。</li>
<li>双栈可实现列表倒序： 设有含三个元素的栈 A = [1,2,3] 和空栈 B = []。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A = [] , B = [3,2,1] ，即 栈 B 元素实现栈 A 元素倒序 。</li>
<li>利用栈 B 删除队首元素： 倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。</li>
</ul>
<h4 id="函数设计："><a href="#函数设计：" class="headerlink" title="函数设计："></a>函数设计：</h4><p>题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p>
<ul>
<li><p>加入队尾 appendTail()函数： 将数字 val 只需要向栈a加入。</p>
</li>
<li><p>删除队首deleteHead()函数： B里面的肯定是先进到A的，所以即便添加删除轮着来，也是先删完B，才会把A的放入B。如果队列（即双栈）中有元素，那么一定是在 栈 B 中。因此要先判断栈 B 是否为空~有以下三种情况。</p>
<ol>
<li>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</li>
<li>否则，当 A 也为空： 即两个栈都为空，无元素，因此返回 −1 。</li>
<li>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</li>
</ol>
</li>
</ul>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>由于问题特殊，以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况。</p>
<ul>
<li><p>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。 ；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 B 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
</li>
<li><p>空间复杂度 O(N) ： 最差情况下，栈 A 和 B 共存储已有的 N 个元素。</p>
</li>
</ul>
<p>一个 [] 既可以当栈、也可以当队列，当然自己写一个栈类也是可以的~<br>题目的本意应该是让我们使用 先进后出 实现 先进先出 ，而不是考察对某一集合框架的具体使用。无论用什么集合框架，都只能当作“栈”来看待，把 [] 看作栈来使用~</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># 本地测试代码</span></span><br><span class="line">    q = CQueue()</span><br><span class="line">    q.appendTail(<span class="number">1</span>)</span><br><span class="line">    q.appendTail(<span class="number">2</span>)</span><br><span class="line">    q.appendTail(<span class="number">3</span>)</span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 1</span></span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 2</span></span><br><span class="line">    print(q.deleteHead())  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="string">'''自己实现栈结构，先进后出'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.items = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span>  <span class="comment"># 返回栈顶值，双端队列右边作为栈顶</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="string">'''使用栈实现队列操作'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1 = Stack()</span><br><span class="line">        self.s2 = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1.push(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2.empty():  <span class="comment"># 只要栈s2不为空直接返回栈s2中元素</span></span><br><span class="line">            <span class="keyword">return</span> self.s2.pop()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():  <span class="comment"># 只要栈s1不为空，将栈s1的元素转到s2中</span></span><br><span class="line">            val = self.s1.pop()</span><br><span class="line">            self.s2.push(val)</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2.empty():  <span class="comment"># 只要栈s2不为空直接返回栈s2中栈顶元素</span></span><br><span class="line">            <span class="keyword">return</span> self.s2.top()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">            val = self.s1.pop()</span><br><span class="line">            self.s2.push(val)</span><br><span class="line">        <span class="keyword">return</span> self.s2.top()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.s1.empty() <span class="keyword">and</span> self.s2.empty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># 我自己写的本地测试代码，可以不要</span></span><br><span class="line">    q = MyQueue()</span><br><span class="line">    q.push(<span class="number">1</span>)</span><br><span class="line">    q.push(<span class="number">2</span>)</span><br><span class="line">    q.push(<span class="number">3</span>)</span><br><span class="line">    print(q.pop())  <span class="comment"># 1</span></span><br><span class="line">    print(q.pop())  <span class="comment"># 2</span></span><br><span class="line">    print(q.pop())  <span class="comment"># 3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p><strong>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</strong><br>返回删除后的链表的头节点。<br>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<p>面试题13：在O（1）时间删除链表结点<br>题目：给定单向链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该结点。<br>链表结点与函数的定义如下：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, next=None</span>):</span></span><br><span class="line">        self.val, self.next = val, next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, headnode, target_node</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        传统方法是从头遍历到要删除的节点，然后让前一个节点指向下一个节点。</span></span><br><span class="line"><span class="string">        思路：把下一个节点节点复制到当前节点就好了。但是要注意只有一个节点的情况</span></span><br><span class="line"><span class="string">        - 链表只有一个节点</span></span><br><span class="line"><span class="string">        - 链表有多个节点并且不是尾节点</span></span><br><span class="line"><span class="string">        - 链表有多个节点并且是尾节点（此时不存在下一个节点了，需要从头遍历）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headnode <span class="keyword">or</span> <span class="keyword">not</span> target_node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target_node.next:</span><br><span class="line">            next_node = target_node.next</span><br><span class="line">            target_node.next = next_node.next</span><br><span class="line">            target_node.val = next_node.val</span><br><span class="line">            <span class="keyword">del</span> next_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> target_node == headnode:</span><br><span class="line">            headnode.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">del</span> target_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># O(n) 删除</span></span><br><span class="line">            cur_node = headnode</span><br><span class="line">            <span class="keyword">while</span> cur_node:</span><br><span class="line">                <span class="keyword">if</span> cur_node.next == target_node:</span><br><span class="line">                    cur_node.next = target_node.next</span><br><span class="line">                    <span class="keyword">del</span> target_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur_node = cur_node.next</span><br></pre></td></tr></tbody></table></figure>

<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可表示为：4 -&gt; 5 -&gt;1 -&gt;9</p>
<p>输入: head = [4,5,1,9], node = 5</p>
<p>输出: [4,1,9]</p>
<p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>说明:<br>链表至少包含两个节点。</p>
<p>链表中所有节点的值都是唯一的。</p>
<p>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</p>
<p>不要从你的函数中返回任何结果。</p>
<p>思路：<br>输入只有一个要删除的节点，无法知道前一个节点。</p>
<p>4 -&gt; 5 -&gt;1 -&gt;9，当我们知道 5 这个节点时，下一个节点 5.next 就知道是 1，下下个节点 9 就是 5.next.next。既然不能直接删除5这个节点，可以让 5 这个值替换成 下一个节点1值，然后可以让 5.next直接指向 9。这样就实现类似删除功能。</p>
<p>由此的可知 5（node），1（node.next），9（node.next.next）</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        也可以类似这样理解node.next在等号右边就是个节点，左边就是个指针。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nextnode = node.next            <span class="comment"># 获取下一个结点</span></span><br><span class="line">        after_nextnode = node.next.next  <span class="comment"># 获取下下个结点</span></span><br><span class="line">        node.val = nextnode.val       <span class="comment"># 当前结点值覆盖为下一个结点的值</span></span><br><span class="line">        node.next = after_nextnode    <span class="comment"># 当前的节点next指向下下个结点</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分查找法-分为整数和浮点数"><a href="#二分查找法-分为整数和浮点数" class="headerlink" title="二分查找法 分为整数和浮点数"></a>二分查找法 分为整数和浮点数</h3><p>适用于<br>1.数据量较大时，但是数据需要先排好顺序<br>2.顺序存储。<br>原因：1.通过下标即可得到关键字<br>2.任取一个关键字的值即可确定所寻找关键字是在它前面还是后面<br>主要思想是：（设查找的数组区间为array[low, high]）<br>（1）确定该区间的中间位置mid<br>（2）将查找的值T与array[mid]比较。若相等，查找成功返回此位置；<br>否则确定新的查找区域，继续二分查找。<br>区域确定如下：</p>
<ul>
<li>a.array[mid]&gt;T 由数组的有序性可知array[mid,mid+1,……,right]&gt;T，故新的区间为array[left,……，mid-1]</li>
<li>b.array[mid]&lt;T 类似上面查找区间为array[mid+1,……，right]。<br>每一次查找与中间值比较，可以确定是否查找成功，不成功当前收缩左边界或右边界，查找区间将缩小一半，递归查找即可。</li>
</ul>
<p>一般二分查找：left=mid+1 right=mid-1<br>原因：确定mid所指元素并非査找元素</p>
<p>把数组内的数据一分为二，然后计算出中间数据的 索引值。</p>
<p>先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，<br>如果相等那么就返回，如果不相等，那么就继续判断。<br>如果说我们找到的 array[mid] 小于  target 这个数;<br>那么 就说明 我们要查找的数在右侧的一半数据中，<br>那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，<br>而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。<br>如果说我们找到的 array[mid]  大于 target 这个数 ，<br>那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，<br>为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。</p>
<p>二分查找中的小技巧<br><code>mid = (left + right) &gt;&gt; 1</code><br><code>mid = left + (right - left) // 2</code> 而不是 <code>(high + low) // 2</code><br>如果left和right很大的话可能会造成溢出越界，使用减法避免了溢出发生<br>除法没有移位的快<br>向右 移一位， 它就相当于 除以2<br>101 = 5 =&gt; 10 = 2<br>1100 = 12 =&gt; 110 = 6</p>
<p>时间复杂度为:<code>O(logn)</code><br>1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)<br>所以T(n)=O(log2n) =O(logn)<br>2.最好情况查找中间元素O(1)查找的元素即为中间元素<br>（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）<br>空间复杂度</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">array, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(array) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果中间的数等于我们要找的数，那么就返回。</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># 如果说中间的数 &lt; 目标的数</span></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">            <span class="comment"># 目标的数在右侧，所以左侧取值的索引需要改变为中间的索引+1</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果说中间的数 &gt; 目标的数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 目标的数在左侧，所以左侧取值的索引需要改变为中间的索引-1</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元素索引值</span></span><br><span class="line">    <span class="comment"># 正常值，包含有和无两种结果</span></span><br><span class="line">    print(binary_search([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">5</span>))  <span class="comment"># 2</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>))  <span class="comment"># None</span></span><br><span class="line">    <span class="comment"># 边界值</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">0</span>))  <span class="comment"># 0</span></span><br><span class="line">    print(binary_search([<span class="number">0</span>], <span class="number">0</span>))  <span class="comment"># 0</span></span><br><span class="line">    <span class="comment"># 异常值</span></span><br><span class="line">    print(binary_search([], <span class="number">1</span>))  <span class="comment"># None</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="2-旋转数组的最小数字-本题考点-查找"><a href="#2-旋转数组的最小数字-本题考点-查找" class="headerlink" title="2. 旋转数组的最小数字 [^本题考点 查找]"></a>2. 旋转数组的最小数字 [^本题考点 查找]</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p>
<p>输入一个递增排序的数组的一个旋转 ，即输入的是旋转，不是递增数组。<br>旋转后的数组局部有序的，实际上可以划分为两个排序的子数组，<br>{3,4,5,1,2}其中前半部分{3,4,5}和后半部分{1,2}都为非减数组，</p>
<p>前面子数组的任一元素都大于或者等于后面子数组的任一元素。</p>
<p>最小的元素是既小于左边的数又小于右边的数，右排序数组 的首个元素 </p>
<p>由于给定的数组是有序的，我们就可以使用二分搜索。<br>然而，数组被旋转了，所以简单的使用二分搜索并不可行。<br>在这个问题中，我们使用一种改进的二分搜索，判断条件与标准的二分搜索有些不同。<br>我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？<br>如果数组没有被旋转，是升序排列，就满足 last element &gt; first element</p>
<p>思考： 是否可以用 numbers[m] 和 numbers[left] 比较做代替？<br>解析： 不可以。因为做比较的目的是判断 mid 在哪个排序数组中。<br>但在 numbers[mid] &gt; numbers[left]情况下，<br>无法判断 m 在哪个排序数组中。<br>本质是因为 right 初始值肯定在右排序数组中；<br>left 初始值无法确定在哪个排序数组中，也就不能确定最小值的位置范围。<br>示例： 当 left = 0, right = 4, mid = 2时，<br>有 numbers[mid] &gt; numbers[left] ，以下两示例得出不同结果。<br>numbers = [1, 2, 3, 4 ,5]   3 4 5 1 2<br>旋转点 min = 0，则 mid 在右排序数组（此示例只有右排序数组）；<br>numbers = [3, 4, 5, 1 ,2]   1 2 3 4 5<br>旋转点 min = 3，则 mid 在左排序数组。</p>
<p>mid = left + (right - left) / 2整数除法是向下取整的```除，mid更靠近left，<br>再结合while循环的条件left &lt; right，索引号<br>mid= (left+right)/2 &gt; (left+left)/2= left，<br>mid= (left+right)/2 &lt; (right+right)/2 = right，索引从0开始，<br>即在while循环内，mid始终小于right。<br>因此在while循环内，nums[mid]要么大于要么小于nums[right]，不会等于。<br>这样else {right = mid;}这句判断可以改为更精确的<br>else if (nums[mid] &lt; nums[right]) {right = mid;}。</p>
<p>[0][1][2][3]<br>1234 说的不是具体的值2&lt;2.5，而是索引号1小于3<br>mid &lt; right</p>
<ul>
<li>循环二分</li>
</ul>
<p>1.若中间索引对应的值大于右侧索引的值，最小值在中间值右侧，34512<br>左半部分一定是有序的，中间数mid在前半个非递减数组，<br>mid肯定不是最小值 left = mid + 1<br>假如最小值在左边，那么在非递减数组中间值就不会大于右边<br>2.若中间索引对应的值小于右侧索引的值，最小值在中间值左侧 45123<br>右半部分一定是有序的，中间数位于后半个非递减数组中，<br>mid有可能是最小值 right = mid<br>假如最小值在右边， 53214，那么不能构成非递减 </p>
<p>在rotateArray[mid]==rotateArray[right]时,<br>1.无法判定 m 在左（右）排序数组，<br>即无法判断旋转点 x 在 [left, m] 还是 [m + 1, right] 区间中。：<br>设以下两个旋转点值为 0 的示例数组，<br>则当 left = 0, right = 4 时 m = 2，两示例结果不同。<br>例 [1, 0, 1, 1, 1] ：旋转点 x = 1 ，因此 m = 2 在 右排序数组 中。<br>例 [1, 1, 1, 0, 1] ：旋转点 x = 3 ，因此 m = 2 在 左排序数组 中。</p>
<p>2.right = right - 1 一个个往前去遍历，复杂度跟直接遍历没差别<br>分析:<br>只需证明每次执行此操作后，旋转点 x 仍在 [left, right] 区间内即可。<br>删除的最后这个元素（下标j），在删除后的区间仍存在，所以不会删除掉旋转点x。<br>简单的说，因为相等，所以删掉一个留下一个，我们在剩下区间搜索，仍可以搜索到删除的那个元素值。</p>
<p>有重复，暴力地从右到左进行遍历，right mid往左移动一位<br>为什么rght-不会对结果产生影响?<br>-产生影响条件：删除的元素为唯一最小元素<br>-执行条件: numbers[right]= numbers[mid]<br>矛盾</p>
<p>返回值<br>如果输入数组多于一个数，循环到最后，会只剩两个数，<br>nums[left] == nums[mid]，以及nums[right]，这里的位置left == mid == right - 1。<br>如果nums[left] == nums[mid] &gt; nums[right]，则左边大、右边小，<br>需要执行left = mid + 1，使得left == right，左右边界位置重合，二分循环结束，nums[left]与nums[right]都保存了最小值。</p>
<p>如果nums[left] == nums[mid] &lt; nums[right]，则左边小、右边大，<br>会执行right = mid，使得left == right，左右边界位置重合，二分循环结束，nums[left]、nums[mid]、nums[right]都保存了最小值。</p>
<p>如果数组只有一个数，左右边界位置重合，left == right，不会进入while跳出二分循环，最小值输出nums[left]或nums[right]均可<br>返回值 numbers[left] 等于旋转点值 numbers[min] ；<br>但在少数特例下 left 不是旋转点 min 。<br>本题目只要求返回 “旋转点的值” ，因此本方法可行。</p>
<p>时间复杂度 O(log_2 N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。<br>空间复杂度 O(1) ： left , right , mid 指针使用常数大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        <span class="comment"># 时间复杂度O(n)</span></span><br><span class="line">        <span class="comment"># minNum = 0</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(rotateArray)):</span></span><br><span class="line">        <span class="comment">#     minNum = minNum if minNum  &lt; rotateArray[i] and minNum != 0 else rotateArray[i]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># return minNum</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时间复杂度O(logn) 对数级别 </span></span><br><span class="line">        <span class="comment"># 若数组大小为0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="comment"># 返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 左侧索引</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 右侧索引</span></span><br><span class="line">        right = len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当左侧索引小于右侧索引时循环</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 直至left&gt;right结束。</span></span><br><span class="line">            <span class="comment"># 中间值为左侧索引和右侧索引求和再除以2，向下取整</span></span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># low + (high - low) // 2 而不是 (high + low) // 2</span></span><br><span class="line">            <span class="comment"># 若中间索引对应的值小于它左侧一个的值，即为要取得值</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &lt; rotateArray[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 返最小标值</span></span><br><span class="line">                <span class="keyword">return</span> rotateArray[mid]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                <span class="comment"># 将右侧索引置为中间索引-1</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># if(rotateArray[mid] &gt; rotateArray[left])</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将左侧索引置为中间索引+1</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>输入一个非减排序的数组的一个旋转，输入为非减排序的数组，即非严格递增的序列，存在重复值，<br>如{1,2,3,3,4,5},旋转后可以是{3,4,5,1,2,3}。<br>输出最小元素。<br>对于未旋转的非减排序array应该有array[start]&lt;array[end]的情况，<br>因此，亦满足array[mid]&lt;array[end];<br>在经过旋转后的rotateArray，<br>满足局部非严格递增，则可以根据rotateArray[mid]&lt;rotateArray[end]<br>初步判断最小值在start-mid之间；<br>否则最小值在mid-end之间。<br>因为存在重复元素，</p>
<p>其他情况对根据需要更新start、mid和end即可，直至start&gt;end结束。<br>可以想到使用二分查找来解决会优化线性查找的性能。<br>没有具体的值用来比较。<br>设置三个指针，left,right,mid。中间值和高低位进行比较，<br>目的：当进行一次比较时，一定能够确定目标值在mid的某一侧。<br>看处于递增还是递减序列，不管是移动第一个还是第二个指针，查找范围都会缩小到原来的一般，<br>接下来再用更新之后的两个指针重复做新一轮的查找。</p>
<p>第一个指针总是指向前面递增数组的元素，<br>而第二个指针总是指向后面递增数组的元素。<br>最终第一个指针将指向前面子数组的最后一个元素，<br>而第二个指针则会指向后面子数组的第一个元素。<br>也就是她们最终会指向两个相邻的元素，<br>而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。    </p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def minArray(self, numbers: List[int]) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[pivot] &lt; numbers[high]:</span><br><span class="line">                high = pivot</span><br><span class="line">            <span class="keyword">elif</span> numbers[pivot] &gt; numbers[high]:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></tbody></table></figure>

<p>转换思路，比较mid与left是先找最大值，最大值偏右，</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def findMin(self, nums: List[int]) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span>   </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:          </span><br><span class="line">            mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>           <span class="comment"># 先加一再除，mid更靠近右边的right     </span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[mid]:         </span><br><span class="line">                left = mid                          <span class="comment"># 向右移动左边界</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &gt; nums[mid]:       </span><br><span class="line">                right = mid - <span class="number">1</span>                     <span class="comment"># 向左移动右边界</span></span><br><span class="line">        <span class="keyword">return</span> nums[(right + <span class="number">1</span>) % len(nums)]        <span class="comment"># 最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h5 id="数组：是有序的元素序列。"><a href="#数组：是有序的元素序列。" class="headerlink" title="数组：是有序的元素序列。"></a>数组：是有序的元素序列。</h5><p>[1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。<br>组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。<br>用于区分数组的各个元素的数字编号称为下标。 [1]<br>这些无序排列的同类数据元素的集合称为数组。*</p>
<p>例如：</p>
<p>int (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。<br>a(0)             a(1)          a(2)</p>
<p>数组与python中的 列表比较相似， 用索引去查找。<br>数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。<br>数组还和元组比较像，元组是初始化后，长度指定了就不可以变。<br>但是元组在初始化时给的值，确定了以后就不可以变了。<br>所以可以理解为数组与list 列表很相似。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = ((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">print(len(A))  <span class="comment"># 4，二维元组的行数</span></span><br><span class="line">print(A[<span class="number">0</span>])  <span class="comment"># (1, 1, 1)</span></span><br><span class="line">print(A[<span class="number">1</span>])  <span class="comment"># (2, 2, 2)</span></span><br><span class="line">print(A[<span class="number">2</span>])  <span class="comment"># (3, 3, 3)</span></span><br><span class="line">print(len(A[<span class="number">0</span>]))  <span class="comment"># 3 二维元组的列数</span></span><br></pre></td></tr></tbody></table></figure>

<p>多维，每一维长度应该是len(A[i])</p>
<hr>
<h2 id="3-在二维数组中的查找-本题考点-查找"><a href="#3-在二维数组中的查找-本题考点-查找" class="headerlink" title="3.在二维数组中的查找[^本题考点 查找]"></a>3.在二维数组中的查找[^本题考点 <em>查找</em>]</h2><p><strong>在一个二维有序数组中（每个一维数组的长度相同），<br>每一行都按照从左到右递增的顺序排序，<br>每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">self, target, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 1 2 3 4</span></span><br><span class="line">        <span class="comment"># 3 4 5 6</span></span><br><span class="line">        <span class="comment"># 4 6 8 10</span></span><br><span class="line">        <span class="comment"># 9 11 13 15</span></span><br><span class="line">        <span class="comment"># 方法1: 暴力算法</span></span><br><span class="line">        <span class="comment"># 直接遍历一遍数组，即可判断目标target是否存在</span></span><br><span class="line">        <span class="comment"># 时间复杂度 o(n**n)，因为最坏情况下，数组中的元素都需要遍历一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(len(array)):  # 横</span></span><br><span class="line">        <span class="comment">#     for j in range(len(array[i])):  # 竖</span></span><br><span class="line">        <span class="comment">#         if target == array[i][j]:</span></span><br><span class="line">        <span class="comment">#             return True</span></span><br><span class="line">        <span class="comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择右上角的数字</span></span><br><span class="line">        <span class="comment"># 为什么不从左上角开始搜寻，左上角向右和向下都是递增，</span></span><br><span class="line">        <span class="comment"># 那么对于一个点，对于向右和向下会产生一个岔路</span></span><br><span class="line">        <span class="comment"># 无法确定下一次二分应该往哪边分，由此无法进行二分下去。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果我们找个位置，每次都能确定的往哪个部分二分，即可达到我们想要的结果。</span></span><br><span class="line">        <span class="comment"># 如果我们选择从右上脚开始搜寻的话，         </span></span><br><span class="line">        <span class="comment"># 右上角的值是这一行的最大数，是这一列的最小数。     </span></span><br><span class="line">        <span class="comment"># 向下数字递增，向左数字递减，</span></span><br><span class="line">        <span class="comment"># 当要查找数字比右上角数字小时，左移，剔除这个数字所在的列</span></span><br><span class="line">        <span class="comment"># 要查找数字比右上角数字大时，下移，剔除这个数字所在的行。</span></span><br><span class="line">        <span class="comment"># 这样每次能比较一行或者一列，每一步都可以剔除一行或一列，查找的速度比较快。</span></span><br><span class="line">        <span class="comment"># 当然也可以选择左下角的数字，思路同上。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 时间复杂度</span></span><br><span class="line">        <span class="comment"># 时间复杂度：O(m+n) ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</span></span><br><span class="line">        <span class="comment"># 这个二维数组的长度是多少，也就是说这个数组有几行；</span></span><br><span class="line">        row_count = len(array)</span><br><span class="line">        i = <span class="number">0</span>  <span class="comment"># 初始行号</span></span><br><span class="line">        <span class="comment"># 这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列</span></span><br><span class="line">        column_count = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 给j 一个值，序号从0开始，就是数组列数的值-1，即为j 的最大值。</span></span><br><span class="line">        j = len(array[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 初始列号</span></span><br><span class="line">        <span class="comment"># 循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; row_count <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 根据两个索引下标可以取到 对应的在数组中的值</span></span><br><span class="line">            value = array[i][j]</span><br><span class="line">            <span class="comment"># 如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回True。</span></span><br><span class="line">            <span class="keyword">if</span> value == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，</span></span><br><span class="line">            <span class="comment"># 因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，</span></span><br><span class="line">            <span class="comment"># 给它减-1，找前一列的数做比较</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; value:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果说取到的值 &lt; 我们的目标值。</span></span><br><span class="line">            <span class="comment"># 那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，</span></span><br><span class="line">            <span class="comment"># 这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="4-包含min-函数的栈-本题考点-栈"><a href="#4-包含min-函数的栈-本题考点-栈" class="headerlink" title="4.包含min 函数的栈[^本题考点 栈]"></a>4.包含min 函数的栈[^本题考点 <em>栈</em>]</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数<br>（时间复杂度应为O（1））。</strong></p>
<p>普通栈的 push() 和 pop() 函数的复杂度为 O(1)；<br>而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)。<br>原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗</p>
<p>第一种方法：辅助栈和数据栈不同步，不考虑两个栈的长度必须要保持一致<br>将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现；</p>
<ul>
<li>数据栈 A ： 栈 A ,用于栈的正常操作 存储所有元素，<br>保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</li>
<li>辅助栈 B ： 非严格的单调栈<br>则栈 A 中的最小元素始终对应栈 B 的栈顶元素，<br>只记录从大到小的顺序元素，<br>B等价于遍历stack所有元素，把升序的数字都删除掉，<br>储栈 A 中所有 非严格降序 的元素，<br>每当pop()这些降序元素，B会将相应的栈顶元素pop()出去，<br>保证其栈顶元素始终是stack中的最小元素。<br>min() 函数只需返回栈 B 的栈顶元素获取最小值，即可实现 O(1) 复杂度。</li>
</ul>
<p>函数设计：</p>
<ul>
<li>push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。<br>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空<br>或<br>② x 小于等于 栈 B 的栈顶元素，<br>则将 x 压入栈 B （即 B.add(x) ），即更新了栈顶最小值；</li>
</ul>
<p>假设先后 push 两个相等的最小数字 x ，此时栈 A 最小数字为 x （且有两个 x ）。<br>若使用“小于”作为判断条件，那么此时栈 B 中只有一个最小数字 x 。<br>此时，执行 pop() ，栈 A 会弹出一个最小数字 x ，还留有一个最小数字 x ；<br>栈 B 也弹出了 x ，但栈 B 栈顶元素不是 x 了，<br>此时执行 <code>min()</code> 函数就会判断出错。</p>
<ul>
<li><p>pop() 函数： 重点为保持栈 A,B 的 元素一致性 。<br>执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</p>
</li>
<li><p>top() 函数： 直接返回栈 A 的栈顶元素</p>
</li>
<li><p>min() 函数： 直接返回栈 B 的栈顶元素</p>
</li>
</ul>
<p>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。<br>不论数据规模多大，都只有有限个步骤，<br>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="comment"># 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def push(self, node: int) -&gt; None:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.A.append(node)</span><br><span class="line">        <span class="comment"># B非空，True, not True =False,</span></span><br><span class="line">        <span class="comment"># B空，False, not False =True,直接加元素</span></span><br><span class="line">        <span class="comment"># B最后一个元素小于node，</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= node:</span><br><span class="line">            self.B.append(node)</span><br><span class="line">        <span class="comment"># if self.B:</span></span><br><span class="line">            <span class="comment"># if node &lt;= self.B[-1]:</span></span><br><span class="line">                <span class="comment"># self.B.append(node)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">            <span class="comment"># self.B.append(node)</span></span><br><span class="line">        <span class="comment"># ##############错误代码##################</span></span><br><span class="line">        <span class="comment"># if not self.B:</span></span><br><span class="line">        <span class="comment">#     self.B.append(node)</span></span><br><span class="line">        <span class="comment"># if self.B[-1] &gt;= node:  # 如果node是最小的</span></span><br><span class="line">        <span class="comment">#     self.B.append(node)</span></span><br><span class="line">        <span class="comment"># B为空的时候一下push了两个相同的数，两个条件都符合</span></span><br><span class="line">        <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def pop(self) -&gt; None:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># pop() 本身就是“出栈”函数， 1、删除栈顶元素，2、返回栈顶元素。</span></span><br><span class="line">            <span class="comment"># 无论if判断是与否，原栈的栈顶是被pop了</span></span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def top(self) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def min(self) -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = MinStack()</span><br><span class="line">    obj.push(<span class="number">9</span>)</span><br><span class="line">    obj.push(<span class="number">10</span>)</span><br><span class="line">    obj.push(<span class="number">7</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    obj.push(<span class="number">5</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3, 5, 3]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3, 5]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 5, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.A)  <span class="comment"># [9, 10, 7, 3]</span></span><br><span class="line">    print(obj.B)  <span class="comment"># [9, 7, 3]</span></span><br><span class="line">    print(obj.min())  <span class="comment"># 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>#第二种方法：辅助栈和数据栈同步，考虑两个栈的长度相同，添加一个，另一个栈也会删除一个</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []  <span class="comment"># 空间换时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给栈中推进去数值，推进去元素node，添加函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="comment"># 如果最小值列表里有值为True</span></span><br><span class="line">        <span class="keyword">if</span> self.minValue:</span><br><span class="line">            <span class="comment"># 如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="keyword">if</span> self.minValue[<span class="number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">            <span class="comment"># 如果列表里面的最后一个值，小于node值，那么就说明node这个值大；</span></span><br><span class="line">            <span class="comment">#   那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.minValue.append(self.minValue[<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 如果最小值列表里面没有值，就在最小值列表里添加node</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">        <span class="comment"># if not self.minValue or self.minValue[-1] &gt;= node:</span></span><br><span class="line">        <span class="comment">#     self.minValue.append(node)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给栈中做删除操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个</span></span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        <span class="comment"># 有值的话，就需要删除一个，删除做pop 操作；返回我们删除的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出最小值，那么就是我们minvalue 中的最后一个值为最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minValue:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.minValue[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    obj.push(<span class="number">9</span>)</span><br><span class="line">    obj.push(<span class="number">10</span>)</span><br><span class="line">    obj.push(<span class="number">7</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    obj.push(<span class="number">5</span>)</span><br><span class="line">    obj.push(<span class="number">3</span>)</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3, 5, 3]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3, 5]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3, 3]</span></span><br><span class="line">    obj.pop()</span><br><span class="line">    print(obj.stack)  <span class="comment"># [9, 10, 7, 3]</span></span><br><span class="line">    print(obj.minValue)  <span class="comment"># [9, 9, 7, 3]</span></span><br><span class="line">    print(obj.min())  <span class="comment"># 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(1)，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，<br>都只是有限个步骤，因此时间复杂度是：O(1)。<br>空间复杂度：O(N)，这里 N 是读出的数据的个数。</p>
<h2 id="5-替换空格-本题考点-字符串"><a href="#5-替换空格-本题考点-字符串" class="headerlink" title="5.替换空格[^本题考点 字符串]"></a>5.替换空格[^本题考点 <em>字符串</em>]</h2><p><strong>请实现一个函数，将一个字符串中的每个空格替换成<code>“%20”</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># 第一种：python中自带的一个替换的函数</span></span><br><span class="line">        <span class="comment"># return s.replace(' ','%20')</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二种遍历来替换字符串中的空格</span></span><br><span class="line">        strlen = len(s)</span><br><span class="line">        <span class="comment"># 借助第三方的列表来实现时间的节省。</span></span><br><span class="line">        aaa = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(strlen):</span><br><span class="line">            <span class="comment"># 如果是空格的话那就替换为%20.</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">" "</span>:</span><br><span class="line">                <span class="comment"># if s[i] isspace:</span></span><br><span class="line">                aaa.append(<span class="string">"%"</span>)</span><br><span class="line">                aaa.append(<span class="string">"2"</span>)</span><br><span class="line">                aaa.append(<span class="string">"0"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(aaa)</span><br><span class="line"><span class="comment"># 从后往前，先计算需要多少空间，然后从后往前移动，每个空格后面的字符只需要移动一次。</span></span><br><span class="line"><span class="comment"># 从前往后，当遇到第一个空格时，要移动第一个空格后所有的字符一次；</span></span><br><span class="line"><span class="comment"># 当遇到第二个空格时，要移动第二个空格后所有的字符一次；以此类推。所以总的移动次数会更多。</span></span><br><span class="line"><span class="comment"># 从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        strLen = len(s)</span><br><span class="line">        <span class="comment"># 定义空字符串准备接收</span></span><br><span class="line">        rep_str = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 遍历，检测到空格就加上"%20"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(strLen):</span><br><span class="line">            <span class="keyword">if</span> s[i].isspace():</span><br><span class="line">                rep_str += <span class="string">'%'</span></span><br><span class="line">                rep_str += <span class="string">'2'</span></span><br><span class="line">                rep_str += <span class="string">'0'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rep_str += s[i]</span><br><span class="line">        <span class="comment"># 返回辅助字符串</span></span><br><span class="line">        <span class="keyword">return</span> rep_str</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6.斐波那契数列"></a>6.斐波那契数列</h2><p><strong>现在要求输入一个整数n，<br>请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong><br>动态规划：<br>原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<ul>
<li>状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i 个数字 。</li>
<li>转移方程： dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1) ；</li>
<li>初始状态： dp[0] = 0, dp[1] = 1 ，即初始化前两个数字；</li>
<li>返回值： dp[n] ，即斐波那契数列的第 nn 个数字。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种方法：下面是使用了for循环，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        a，b代表相邻两个斐波那契数；</span></span><br><span class="line"><span class="string">        a是前一个，b是后一个。</span></span><br><span class="line"><span class="string">        经过一次迭代后a代表fib(1)的值，</span></span><br><span class="line"><span class="string">        两次迭代后a代表fib(2)的值，</span></span><br><span class="line"><span class="string">        因此经过n次迭代a代表的是fib(n)的值，</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):  <span class="comment"># 从0取到n-2</span></span><br><span class="line">            a, b = b, a + b  <span class="comment"># 返回大的</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">        <span class="comment"># for _ in range(n):  # 取到n-1</span></span><br><span class="line">        <span class="comment"># a, b = b, a + b</span></span><br><span class="line">        <span class="comment"># return a % 1000000007  # 返回小的</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为-n"><a href="#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为-n" class="headerlink" title="第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n"></a>第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</h1><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">self</span>, n)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="comment">#初始列表值 为 0 1 第三项为 0+1 = 1；</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="comment">#临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。</span></span><br><span class="line">        <span class="keyword">while</span> len(res) &lt;= <span class="symbol">n:</span></span><br><span class="line">               <span class="comment">#取出列表的最后两项，然后求和，并添加到列表中。</span></span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>用Python实现Fibonacci数列 这里使用迭代器进行实现<br>fabonacci数列：后面的数字等于前面两个数之和，第一个数是0， 第二个数是1</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fabonacci</span>(<span class="params">length</span>):</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; length:</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixed_length_fabonacci</span>(<span class="params">length</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> fabonacci(length)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(fixed_length_fabonacci(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.first = <span class="number">0</span></span><br><span class="line">        self.second = <span class="number">1</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_fibo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num):</span><br><span class="line">            <span class="keyword">yield</span> self.first</span><br><span class="line">            self.first, self.second = self.second, self.first + self.second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(list(Fibonacci(<span class="number">10</span>).generate_fibo()))</span><br></pre></td></tr></tbody></table></figure>


<h4 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h4><p><strong>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</strong></p>
<p>示例1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br></pre></td></tr></tbody></table></figure>
<p>示例2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​输入：{<span class="number">6</span>, <span class="number">-3</span>,<span class="number">-2</span>, <span class="number">7</span>, <span class="number">-15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>}，</span><br><span class="line">输入：</span><br><span class="line">返回值：<span class="number">8</span></span><br><span class="line">解释: 连从第<span class="number">0</span>个开始，到第<span class="number">3</span>个为止 [<span class="number">6</span>, <span class="number">-3</span>,<span class="number">-2</span>, <span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>示例3:</p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1,-2,3,10,-4,7,2,-5]</span></span><br><span class="line">输出: 18</span><br><span class="line">解释: 连续子数组 <span class="comment">[3,10,-4,7,2]</span> </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">常见解法    时间复杂度    空间复杂度</span><br><span class="line">暴力搜索    O(N^2)      O(1)</span><br><span class="line">分治思想    O(NlogN)    O(logN)</span><br><span class="line">动态规划    O(N)        O(1)</span><br><span class="line"></span><br><span class="line">动态规划是本题的最优解法，以下按照标准流程解题。</span><br><span class="line">两种标志DP适用于数组：</span><br><span class="line">  * 1. 常数空间，沿数组移动并子啊原数组修改；</span><br><span class="line">  * 2. 线性空间，首先沿left-&gt;right方向移动，然后沿right-&gt;left方向移动，最后合并结果。</span><br><span class="line"></span><br><span class="line">动态规划实质上就是空间换时间（画表格方法），分为一维列表、二维矩阵。</span><br><span class="line">自底向上（动态规划）和自底向下（记忆化递归）在一些书里都称为「动态规划」，</span><br><span class="line">可以先弄懂它们的区别；</span><br><span class="line">1. 最优子结构 大问题的最优解通常由小问题的最优解得到，那么我们就需要通过分类讨论，得到大问题的小问题究竟是哪些。 </span><br><span class="line">2. 边界 </span><br><span class="line">3. 状态定义 一般数组、字符串相关的状态定义都是 “以 dp<span class="comment">[i]</span> 为结尾的 xxx ” 这样，</span><br><span class="line">xxx 一般就是求最长、最短、最大、最小这种，dp<span class="comment">[i]</span>就是到当前i这个情况下的最优解，</span><br><span class="line">以某个数作为结尾，意思就是这个数一定会加上去，</span><br><span class="line">那么要看的就是这个数前面的部分要不要加上去。</span><br><span class="line">都存在选与不选两种选择，选了就与前面i-1的结果联系起来，不选就独立出来，</span><br><span class="line">「无后效性」是可以应用动态规划的一个特点：</span><br><span class="line">   1. 后面的决策不会影响到前面的决策</span><br><span class="line">   2. 之前的状态怎么来的并不重要。</span><br><span class="line">4. 转移方程</span><br><span class="line"></span><br><span class="line">以阶为例，最优子结构为f(10)=f(9) + f(8)，边界是f(1)=1, f(2)=2，</span><br><span class="line">状态转移公式f(n)=f(n-1) + f(n-2)跳台</span><br><span class="line"></span><br><span class="line">动态规划解析：</span><br><span class="line">- 数组的子结构通常就是子数组，而本题的最优子结构容易想到是 子数组的连续最大和 </span><br><span class="line">把数组分解成把数组长度个子问题</span><br><span class="line"></span><br><span class="line">- 状态定义（抽象出了子问题）： 设动态规划列表 dp ，</span><br><span class="line"> 定义数组元素dp<span class="comment">[i]</span> 代表当前位置 i 的以元素 nums<span class="comment">[i]</span> 为结尾的连续子数组最大和。</span><br><span class="line">动态规划的问题的分类讨论的标准不是 nums<span class="comment">[i]</span> 的正负，</span><br><span class="line">而是上一个状态值 dp<span class="comment">[i - 1]</span> 的正负。</span><br><span class="line"></span><br><span class="line">  - 为何定义最大和 dp<span class="comment">[i]</span> 中必须包含元素 nums<span class="comment">[i]</span> ：</span><br><span class="line">  保证 dp<span class="comment">[i]</span> 递推到 dp<span class="comment">[i+1]</span> 的正确性、转移方程的有效性，</span><br><span class="line">  如果不包含 nums<span class="comment">[i]</span> ，递推时则不满足题目的 连续子数组 要求。</span><br><span class="line"></span><br><span class="line">  - 转移策略，自带剪枝： </span><br><span class="line">    1. 若 dp<span class="comment">[i−1]</span> ≤ 0 ，说明 dp<span class="comment">[i - 1]</span> 没法给 dp<span class="comment">[i]</span> 带来正增益，那么加上前面的数反而越来越小了，即 dp<span class="comment">[i-1]</span> + nums<span class="comment">[i]</span> 还不如 nums<span class="comment">[i]</span> 本身大，抛弃掉前面的子组合，自己单独的一个 nums<span class="comment">[i]</span>就是最大的了。</span><br><span class="line">    2. 若前一个元素dp<span class="comment">[i−1]</span> &gt; 0，则将其加到当前元素上</span><br><span class="line"></span><br><span class="line">  - 状态转移方程</span><br><span class="line">    - 记为「状态转移方程 1」</span><br><span class="line">    当 dp<span class="comment">[i - 1]</span> &gt; 0 时：执行 dp<span class="comment">[i]</span> = dp<span class="comment">[i-1]</span> + nums<span class="comment">[i]</span> ；  </span><br><span class="line">    当 dp<span class="comment">[i - 1]</span> ≤ 0 时：执行 dp<span class="comment">[i]</span> = nums<span class="comment">[i]</span> ；</span><br><span class="line">    - 反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，</span><br><span class="line">    因此还可以写出「状态转移方程 2」。如下：</span><br><span class="line">      dp<span class="comment">[i]</span> = max(dp<span class="comment">[i-1]</span>, 0) + nums<span class="comment">[i]</span></span><br><span class="line"></span><br><span class="line">    - dp 初始状态得根据题意和你的状态定义而来：dp<span class="comment">[0]</span> = nums<span class="comment">[0]</span> 表示以 nums<span class="comment">[0]</span> 结尾的连续子数组最大和为 nums<span class="comment">[0]</span> 而非 0。如果数组元素只有一个元素，它就是最大和</span><br><span class="line">    </span><br><span class="line">  - 返回值：这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。返回 dp 列表中的最大值应该是把每个位置的 dp<span class="comment">[i]</span> 即dp<span class="comment">[0]</span>、dp<span class="comment">[1]</span>、……、dp<span class="comment">[n-1]</span> 都比较得到全局最大值。</span><br><span class="line"></span><br><span class="line">4.设计dp数组，保存子问题的解，避免重复计算，因此将原数组 nums 用作 dp 列表，即直接在原数组 nums 上修改，由于省去 dp 列表使用的额外空间：</span><br><span class="line">nums<span class="comment">[i]</span> += max(nums<span class="comment">[i-1]</span>,0);</span><br><span class="line"></span><br><span class="line">时间复杂度 O(N) ： 线性遍历一次数组 nums ，使用 O(N) 时间。</span><br><span class="line">空间复杂度 O(1) ： 使用常数大小的额外空间。</span><br><span class="line"></span><br><span class="line">优化空间，</span><br><span class="line">由于每次循环中当前状态只依赖于前一个状态，</span><br><span class="line">就是说 dp<span class="comment">[i]</span> 的更新只取决于 dp<span class="comment">[i-1]</span> , </span><br><span class="line">只用一个存储变量 maxnum 各阶段全局最大和</span><br><span class="line">从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List<span class="comment">[int]</span>) -&gt; int:</span><br><span class="line">        # 动态规划，原地修改数组</span><br><span class="line">        max_sum = nums<span class="comment">[0]</span></span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            # 写法一</span><br><span class="line">            # if nums<span class="comment">[i - 1]</span> &gt; 0:</span><br><span class="line">                # nums<span class="comment">[i]</span> += nums<span class="comment">[i - 1]</span></span><br><span class="line">            # 写法二</span><br><span class="line">            nums<span class="comment">[i]</span> += max(nums<span class="comment">[i - 1]</span>, 0)</span><br><span class="line">    </span><br><span class="line">            max_sum = max(max_sum, nums<span class="comment">[i]</span>)</span><br><span class="line"></span><br><span class="line">        return max_sum</span><br></pre></td></tr></tbody></table></figure>
<p>全是正的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">nums[i] = nums[i] + nums[i - <span class="number">1</span>] </span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + nums[<span class="number">0</span>] = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">3</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">1</span>] = <span class="number">3</span> &gt; <span class="number">0</span></span><br><span class="line">nums[i] = nums[i] + nums[i - <span class="number">1</span>] </span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + nums[<span class="number">1</span>] = <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>全是负的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">0</span>] = <span class="number">-2</span> &lt; <span class="number">0</span></span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">-2</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[i - <span class="number">1</span>] = nums[<span class="number">1</span>] = <span class="number">-1</span> &lt; <span class="number">0</span></span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">-2</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>有负有正</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[<span class="number">1</span>] += max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">1</span>] + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">1</span>  </span><br><span class="line">max_sum = max(mmax_sumaxnum,nums[i]) = max(<span class="number">-2</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] += max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">2</span>] + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">-3</span> + <span class="number">1</span> = <span class="number">-2</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">-2</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] += max(nums[<span class="number">3</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">3</span>] + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">4</span> + <span class="number">0</span> = <span class="number">4</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">1</span>, <span class="number">4</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] += max(nums[<span class="number">4</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">4</span>] + max(<span class="number">4</span>, <span class="number">0</span>) = <span class="number">-1</span> + <span class="number">4</span> = <span class="number">3</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">4</span>, <span class="number">3</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] += max(nums[<span class="number">5</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">5</span>] + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">4</span>, <span class="number">5</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] += max(nums[<span class="number">6</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">6</span>] + max(<span class="number">5</span>, <span class="number">0</span>) = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">5</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">nums[<span class="number">7</span>] += max(nums[<span class="number">7</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">7</span>] + max(<span class="number">6</span>, <span class="number">0</span>) = <span class="number">-5</span> + <span class="number">6</span> = <span class="number">1</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">6</span>, <span class="number">4</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">nums[<span class="number">8</span>] += max(nums[<span class="number">8</span> - <span class="number">1</span>], <span class="number">0</span>) = nums[<span class="number">8</span>] + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">4</span> + <span class="number">1</span> = <span class="number">5</span>  </span><br><span class="line">max_sum = max(max_sum,nums[i]) = max(<span class="number">6</span>, <span class="number">5</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_sum = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>未优化的，击败40</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="comment"># max 并不会增加时间复杂度哈。直接代替了以 if else判断相当于把 max 平摊在 for 循环里的 if sum &gt; max: max = sum 操作上，实际上是一样的。</span></span><br><span class="line">            <span class="comment"># 写法一</span></span><br><span class="line">            <span class="comment"># if nums[i - 1] &gt; 0:</span></span><br><span class="line">                <span class="comment"># nums[i] += nums[i - 1]</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.maxSubArray(nums)</span><br><span class="line">    print(res)</span><br><span class="line">    print(nums)  <span class="comment"># [1, 3, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<p>全是正的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">2</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">3</span> + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>全是负的</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-1</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">-1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-3</span> + max(<span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-3</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>有负有正</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">nums[<span class="number">1</span>] = nums[<span class="number">1</span>] + max(nums[<span class="number">1</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">1</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] + max(nums[<span class="number">2</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-3</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">-2</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">nums[<span class="number">3</span>] = nums[<span class="number">3</span>] + max(nums[<span class="number">3</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">4</span> + max(<span class="number">-2</span>, <span class="number">0</span>) = <span class="number">4</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">nums[<span class="number">4</span>] = nums[<span class="number">4</span>] + max(nums[<span class="number">4</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-1</span> + max(<span class="number">4</span>, <span class="number">0</span>) = <span class="number">3</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">nums[<span class="number">5</span>] = nums[<span class="number">4</span>] + max(nums[<span class="number">5</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">2</span> + max(<span class="number">3</span>, <span class="number">0</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">nums[<span class="number">6</span>] = nums[<span class="number">5</span>] + max(nums[<span class="number">6</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">1</span> + max(<span class="number">5</span>, <span class="number">0</span>) = <span class="number">6</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">nums[<span class="number">7</span>] = nums[<span class="number">6</span>] + max(nums[<span class="number">7</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">-5</span> + max(<span class="number">6</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">nums[<span class="number">8</span>] = nums[<span class="number">7</span>] + max(nums[<span class="number">8</span> - <span class="number">1</span>], <span class="number">0</span>) = <span class="number">4</span> + max(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">5</span></span><br><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max(nums) = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：贪心法 O(n)<br>若当前指针所指元素之前的和 cur_sum &lt; 0，则丢弃当前元素之前的数列</p>
<p>cur_sum - 到当前位置i累计最大连续子序列和，<br>max_sum - 全局最大子序列和<br>比较 cur_sum 和 max_sum 的大小，将最大值置为max_sun</p>
<p>cur_sum &lt;= 0，则说明 cur_sum 对结果无增益效果，需要舍弃，则 cur_sum 直接更新为当前遍历数字时，<br>同时更新最大和的值(最大值可能为其中某个值)，<br>当叠加和 cur_sum &gt; 0，则说明 sucur_summ 对结果有增益效果，则 cur_sum 保留并加上当前遍历数字时，<br>同时更新最大和的值，依此继续。</p>
<p>不用max函数快一点，击败95%</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        cur_sum = max_sum = nums[<span class="number">0</span>]  <span class="comment"># 初始值设为列表第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):  <span class="comment"># 遍历列表剩下元素</span></span><br><span class="line">            <span class="comment"># if cur_sum &lt; 0:</span></span><br><span class="line">            <span class="comment">#     cur_sum = nums[i]</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     cur_sum = cur_sum + nums[i]</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            cur_sum = max(nums[i], cur_sum + nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if cur_sum &gt; max_sum:</span></span><br><span class="line">            <span class="comment">#     max_sum = cur_sum</span></span><br><span class="line">            <span class="comment"># 写法二</span></span><br><span class="line">            max_sum = max(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.maxSubArray(nums)</span><br><span class="line">    print(res)</span><br><span class="line">    print(nums)  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">3</span>, <span class="number">1</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">3</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">6</span>, <span class="number">3</span>) = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>]</span><br><span class="line">len(nums) = <span class="number">3</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">0</span> + (<span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-1</span>, <span class="number">-2</span>) = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">-1</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">0</span> + <span class="number">-3</span> = <span class="number">-3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-3</span>, <span class="number">-1</span>) = <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">len(nums) = <span class="number">9</span></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">cur_sum = max(cur_sum, <span class="number">0</span>) + nums[i]</span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">1</span>] = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">1</span>, <span class="number">-2</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">2</span>] = <span class="number">1</span> + <span class="number">-3</span> = <span class="number">-2</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">-2</span>, <span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">cur_sum = max(<span class="number">-2</span>, <span class="number">0</span>) + nums[<span class="number">3</span>] = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">4</span>, <span class="number">1</span>) = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">cur_sum = max(<span class="number">5</span>, <span class="number">0</span>) + nums[<span class="number">4</span>] = <span class="number">4</span> + (<span class="number">-1</span>) = <span class="number">3</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">3</span>, <span class="number">4</span>) = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">cur_sum = max(<span class="number">3</span>, <span class="number">0</span>) + nums[<span class="number">5</span>] = <span class="number">3</span> + <span class="number">2</span> = <span class="number">5</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">5</span>, <span class="number">4</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">cur_sum = max(<span class="number">5</span>, <span class="number">0</span>) + nums[<span class="number">6</span>] = <span class="number">5</span> + <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">6</span>, <span class="number">5</span>) = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">7</span></span><br><span class="line">cur_sum = max(<span class="number">6</span>, <span class="number">0</span>) + nums[<span class="number">7</span>] = <span class="number">6</span> + (<span class="number">-5</span>) = <span class="number">1</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">1</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span></span><br><span class="line">cur_sum = max(<span class="number">1</span>, <span class="number">0</span>) + nums[<span class="number">8</span>] = <span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span></span><br><span class="line">max_sum = max(cur_sum, max_sum) = max(<span class="number">5</span>, <span class="number">6</span>) = <span class="number">6</span></span><br><span class="line"><span class="keyword">return</span> max_sum = <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="41-复杂链表的复制-本题考点-链表"><a href="#41-复杂链表的复制-本题考点-链表" class="headerlink" title="41.复杂链表的复制 [^本题考点 链表]"></a>41.复杂链表的复制 [^本题考点 <em>链表</em>]</h4><p>​    <strong>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># 深拷贝也可以</span></span><br><span class="line">        <span class="comment"># return copy.deepcopy(pHead)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制一个一样的node，并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            node = RandomListNode(pTmp.label)</span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            pTmp.next = node</span><br><span class="line">            pTmp = node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现新建的node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            <span class="keyword">if</span> pTmp.random:</span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开原来的node和新node的连接</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="keyword">if</span> pNewTmp.next:</span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            pTmp = pTmp.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n1 = RandomListNode(<span class="number">1</span>)</span><br><span class="line">    n2 = RandomListNode(<span class="number">2</span>)</span><br><span class="line">    n3 = RandomListNode(<span class="number">3</span>)</span><br><span class="line">    n4 = RandomListNode(<span class="number">4</span>)</span><br><span class="line">    n5 = RandomListNode(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">    n1.next = n2</span><br><span class="line">    n2.next = n3</span><br><span class="line">    n3.next = n4</span><br><span class="line">    n4.next = n5</span><br><span class="line"></span><br><span class="line">    s = Solution()</span><br><span class="line">    newHead = s.Clone(n1)</span><br><span class="line">    tmp = newHead</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        print(tmp.label)</span><br><span class="line">        tmp = tmp.next</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">            <span class="comment">#判断当pHead 为空值的时候 返回的是none</span></span><br><span class="line">            <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#把第一个 A 的值 赋给 node 为A‘</span></span><br><span class="line">                node = RandomListNode(pTmp.label)</span><br><span class="line">                <span class="comment">#此时 node A' 的结点指向的是 原来A 的结点指向的 值</span></span><br><span class="line">                node.next = pTmp.next</span><br><span class="line">                <span class="comment">#将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">                pTmp.next = node</span><br><span class="line">                <span class="comment">#将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素</span></span><br><span class="line">                pTmp = node.next</span><br><span class="line">        <span class="comment"># 实现新建的node的random的指向</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">                <span class="keyword">if</span> pTmp.random:</span><br><span class="line">                    <span class="comment">#那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。</span></span><br><span class="line">                    pTmp.next.random = pTmp.random.next</span><br><span class="line">            <span class="comment">#建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="comment">#当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。</span></span><br><span class="line">                pTmp = pTmp.next.next</span><br><span class="line">            <span class="comment"># 断开原来的node 和 新的node 之间的链接</span></span><br><span class="line">            <span class="comment">#最后 为断开 链接 的操作</span></span><br><span class="line">            pTmp = pHead</span><br><span class="line">            <span class="comment">#复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">            newHead = pHead.next</span><br><span class="line">            <span class="comment">#复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">            pNewTmp = pHead.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> pTmp:</span><br><span class="line">                <span class="comment">#print(pTmp.label)</span></span><br><span class="line">                <span class="comment">#将旧链表 A 的指向结点 改为  A' 的指向的下一个 的B。</span></span><br><span class="line">                pTmp.next = pTmp.next.next</span><br><span class="line">                <span class="comment">#如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">                <span class="keyword">if</span> pNewTmp.next:</span><br><span class="line">                    <span class="comment">#那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’</span></span><br><span class="line">                    pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                    <span class="comment">#然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘</span></span><br><span class="line">                    pNewTmp = pNewTmp.next</span><br><span class="line">            <span class="comment">#上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B</span></span><br><span class="line">                pTmp = pTmp.next</span><br><span class="line">            <span class="comment">#如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#最后返回这个复制好的新链表。</span></span><br><span class="line">            <span class="keyword">return</span> newHead</span><br></pre></td></tr></tbody></table></figure>

<hr>
<hr>
<h2 id="7-青蛙跳台阶"><a href="#7-青蛙跳台阶" class="headerlink" title="7.青蛙跳台阶"></a>7.青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。<br>求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%5C%E5%89%91%E6%8C%87offer%5C%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.png"></p>
<p>1 (1)<br>2 (11,2)<br>3 (12,21,111)<br>4 (1111,22,112,121,211)<br>5 (11111,221,212,122,1121,2111,1112,1211)<br>6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)</p>
<p>假设有n级台阶，<br>青蛙从最后的第n级开始往前跳，<br>有可能是跳1级台阶，之后还有n-1级台阶，此情况共有 f(n-1)中可能性；<br>也有可能跳2级台阶，之后还有n-2级台阶，此情况共有 f(n-2)种可能性。<br>反过来说，最后一步只有两种情况<br>那么可以从第 n - 1 级台阶跳上去（跳一级），<br>也可以从第 n - 2 级台阶跳上去（跳两级），</p>
<p>f(n) 为以上两种情况之和<br>所以从n级开始跳的跳法就有 f(n) = f(n-1) + f(n-2)种，<br>递推性质为斐波那契数列。求斐波那契数列第 n 项的值 ，<br>唯一的不同在于起始数字不同，从1,2开始</p>
<p>青蛙跳台阶问题：<br>f(0)=1 , 题目就是这么规定的，0 层台阶也有一种跳法（即不跳）。<br>之后遇到类似情况，可以输入 0 测试样例看下输出，然后就确定了~<br>递推公式反推~ 显然， f(2) = 2 f(1) = 1，而 f(2) = f(1) + f(0)，因此f(0) = 1`<br>背包问题里，背包里物品价值为0即背包为空也是一种情况，<br>同理本题台阶为0时青蛙什么也不跳也是一种情况<br>理解dp初值的时候，有时候不需要从定义去理解它，<br>只需要保证状态转移的时候，它作为后面要参考到的值，能得到正确的结果即可。<br>f(3)=f(2)+f(1)；<br>当n等于3的时候，他可以从一级台阶上跳两步上来，也可以从二级台阶上跳一步上来<br>斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 </p>
<p>生成第 n 项的做法有以下几种<br>1.递归法：</p>
<ul>
<li>原理： 把 f(n) 问题的计算拆分成 f(n-1) 和 f(n-2) 两个子问题的计算，<br>并递归，以 f(0) 和 f(1) 为终止条件。</li>
<li>缺点： 大量重复的递归计算会超时，例如 f(n) 和 f(n - 1) 两者向下递归都需要计算 f(n−2) 的值。</li>
</ul>
<p>2.记忆化递归法：</p>
<ul>
<li>原理： 在递归法的基础上，新建一个长度为 n 的数组，<br>用于在递归时存储 f(0) 至 f(n) 的数字值，<br>重复遇到某数字时则直接从数组取用，避免了重复的递归计算。</li>
<li>缺点： 记忆化存储的数组需要使用 O(N) 的额外空间。</li>
</ul>
<p>3.动态规划：<br>原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<p>动态规划解析：</p>
<ul>
<li>状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。</li>
<li>转移方程： dp[i + 1] = dp[i] + dp[i - 1] ，<br>即对应数列定义 f(n + 1) = f(n) + f(n - 1) ；</li>
<li>初始状态： dp[0] = 1, dp[1] = 1 ，即初始化前两个数字；<br>这两个作为边界条件就可以继续向后推导出第 n 级的正确结果</li>
<li>返回值： dp[n] ，即斐波那契数列的第 n 个数字。</li>
</ul>
<p>空间复杂度优化：</p>
<blockquote>
<p>若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。</p>
</blockquote>
<ul>
<li>由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，<br>时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。<br>Python 中整数型数字由于可超过 32 位，取决计算机的内存 （可理解为无限大）<br>因此复杂度不再是 O(1)<br>复杂度为O（N^2），虽说题目的n最大为100，<br>Python代码中间过程没有取MOD， 最终a的值会是指数级别大小，<br>每次加法的复杂度不是O(1)而是O(log(2^n)/64)=O(n)。<br>64是加法运算器位数.</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment">#第一种方法：</span></span><br><span class="line">         a = <span class="number">1</span></span><br><span class="line">         b = <span class="number">1</span></span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):  <span class="comment"># 从0取到n-1</span></span><br><span class="line">             a,b = b,a+b</span><br><span class="line">         <span class="keyword">return</span> a % <span class="number">1000000007</span>  <span class="comment"># int表示的范围有限</span></span><br><span class="line">         <span class="comment"># 答案需要取模 1e9+7（1000000007），</span></span><br><span class="line">         <span class="comment"># 如计算初始结果为：1000000008，请返回 1。</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,number+<span class="number">1</span>):  <span class="comment"># 从3加到number</span></span><br><span class="line">            ret = a+b</span><br><span class="line">            a = b</span><br><span class="line">            b = ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="8-变态跳台阶"><a href="#8-变态跳台阶" class="headerlink" title="8.变态跳台阶"></a>8.变态跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1 (1)</span></span><br><span class="line"><span class="string">2 (11,2)</span></span><br><span class="line"><span class="string">3 (111,21,3,12)</span></span><br><span class="line"><span class="string">4 (1111,22,13,31,211,112,121,4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">n  2^(n-1)</span></span><br><span class="line"><span class="string">f(n)  = f(n-1) + f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="string">f(n-1) = f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="string">f(n) = 2f(n-1)  n &gt; 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f(1) = 1 n = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#第一种方法：</span></span><br><span class="line">        <span class="comment"># return pow(2,number-1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#第二种方法：</span></span><br><span class="line">        <span class="comment"># return 2 ** (number - 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#第三种方法：</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,number+<span class="number">1</span>):</span><br><span class="line">            ret = <span class="number">2</span>*n</span><br><span class="line">        <span class="keyword">return</span> n      </span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="9-调整数组顺序使奇数位于偶数前面-本题知识点-数组"><a href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]"></a>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 <em>数组</em>]</h2><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p>
<p>算法流程：<br>初始化： 头指针 left ，尾指针 right，分别指向数组 nums 左右两端；<br>循环交换： 当 i = j 时跳出；<br>指针 left 遇到奇数则执行 left = left + 1 跳过，直到它指向的值为偶数；<br>指针 right 遇到偶数则执行 right = right - 1 跳过，直到它指向的值为奇数；<br>交换 nums[left] 和 nums[right] 值；<br>返回值： 返回已修改的 nums 数组。<br>复杂度分析：<br>时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。<br>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</p>
<p>奇偶性可以由一个整数二进制的最低位决定（想一想一个整数的二进制分解），<br>最低位是 0 是偶数，反之是奇数。</p>
<p>x&amp;1 位运算 等价于 x % 2 取余运算，即皆可用于判断数字奇偶性<br>若 x&amp;1=0 ，则 x 二进制 最右一位 为 0 ，为偶数；<br>若 x&amp;1=1 ，则 x 二进制 最右一位 为 1 ，为奇数。<br>实际编写代码中，编译器一般都会自动优化， $%$ 求余的可读性更好，<br>所以只在解题时候用位运算秀秀操作就好啦~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def exchange(self, nums: List[int]) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="comment"># 因为每次指针移动后，首先要做的是判断索引值的合法性。</span></span><br><span class="line">        <span class="comment"># 只有索引合法才有后续的操作。</span></span><br><span class="line">        <span class="comment"># 因为第二步和第三步循环过程中，有可能遇到 i == j 的边界情况，</span></span><br><span class="line">        <span class="comment"># 此时就应终止，不然 i 就跑到 j 右边了，这和本文方法定义不符。</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#时间复杂度是o(n)</span></span><br><span class="line">        <span class="comment">#空间复杂度o(n)</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>: <span class="keyword">return</span> array</span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># if len(array) &lt; 2: return array</span></span><br><span class="line">        <span class="comment"># for i in array:</span></span><br><span class="line">        <span class="comment">#     # 法一</span></span><br><span class="line">        <span class="comment">#     if i % 2 == 1:</span></span><br><span class="line">        <span class="comment">#         res.append(i)</span></span><br><span class="line">        <span class="comment"># for i in array:</span></span><br><span class="line">        <span class="comment">#     if i % 2 == 0:</span></span><br><span class="line">        <span class="comment">#         res.append(i)</span></span><br><span class="line">        <span class="comment">#     # 法二</span></span><br><span class="line">        <span class="comment">#     # res.append(i) if i % 2 == 1 else even.append(i)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用了冒泡排序的原理，判断奇偶数，</span></span><br><span class="line">        <span class="comment"># 如果一个是偶数而且下一个是奇数，那么两个就互换位置。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array) - i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> array[j] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> array[j + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    array[j], array[j + <span class="number">1</span>] = array[j + <span class="number">1</span>], array[j]</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(Solution.reOrderArray(array))</span><br><span class="line">    <span class="comment"># [1, 3, 5, 2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">i = 0,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 1,  [1, 3, 5, 2, 4, 6]</span></span><br><span class="line"><span class="string">i = 2,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 3,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 4,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">i = 5,  [1, 3, 2, 5, 4, 6]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="10-栈的压入，弹出序列-本题考点-栈"><a href="#10-栈的压入，弹出序列-本题考点-栈" class="headerlink" title="10.栈的压入，弹出序列  [^本题考点 栈]"></a>10.栈的压入，弹出序列  [^本题考点 <em>栈</em>]</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，<br>序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>pushed 是 popped 的排列。</strong></p>
<p>分析：<br>给定一个压入序列 pushed 和弹出序列 popped ，<br>则压入 / 弹出操作的顺序（即排列）是 唯一确定 的</p>
<blockquote>
<p>题目指出 pushed 是 popped 的排列 。<br>因此，无需考虑 pushed 和 popped 长度不同 或 包含元素不同 的情况。</p>
</blockquote>
<blockquote>
<p>如果题目没说明 pushed 是 popped 的排列，代码应该做什么改动呢<br>可能输入的 pushed 和 popped 长度会不一样<br>需要提前判断一下 pushed 和 popped 的长度是否相同，<br>若不同直接返回 false。<br>否则，以下案例会出错：<br>[1,2,3,4,5]<br>[4,5,3,2,1,6]</p>
</blockquote>
<p>示例1<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例2<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。栈的数据操作具有 先入后出 的特性</p>
<p>因为若是4为首位出栈的话，123必定还在栈中，<br>无论5什么时候入栈和出栈，都不可能出现1在2前面的现象</p>
<p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。<br>根据是否模拟成功，即可得到结果。</p>
<ul>
<li>入栈操作： 按照压栈序列的顺序执行。</li>
<li>出栈操作： 每次入栈后，循环判断 “压入栈的栈顶元素 == 弹出序列的当前元素” 是否成立，<br>将符合弹出序列顺序的栈顶元素全部弹出。<blockquote>
<p>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，<br>每个元素出栈的位置的可能性是唯一的<br>（若有重复数字，则具有多个可出栈的位置）。<br>因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</p>
</blockquote>
复杂度分析：<br>时间复杂度 O(N) ： 其中 N 为列表 pushed 和 popped 的长度；<br>每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。<br>空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N 个元素。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: list[int], popped: list[int]</span>) -&gt; bool:</span></span><br><span class="line">        stack= []  <span class="comment"># 使用一个栈，开始为空</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(item)  <span class="comment"># num 入栈</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[index]:  <span class="comment"># 弹出的时候是需要循环判断是否需要弹出</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack  <span class="comment"># stack为空返回true，不为空返回False</span></span><br><span class="line">        <span class="comment"># return True if stack == [] else False</span></span><br><span class="line">        <span class="comment"># return index == len(popped)  # popped的每个元素都与pushed对应，长度相等</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    print(obj.validateStackSequences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># True</span></span><br><span class="line">    print(obj.validateStackSequences([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">    <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed, popped</span>):</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> pushed:</span><br><span class="line">            tmp.append(item)</span><br><span class="line">            <span class="comment"># 同时检测tmp的最后一个元素是否与popped的第一个元素相同，</span></span><br><span class="line">            <span class="keyword">while</span> tmp <span class="keyword">and</span> popped <span class="keyword">and</span> tmp[<span class="number">-1</span>] == popped[<span class="number">0</span>]:</span><br><span class="line">                tmp.pop()  <span class="comment"># tmp中最后一个元素弹出</span></span><br><span class="line">                popped.pop(<span class="number">0</span>)  <span class="comment"># popped的第一个元素也弹出</span></span><br><span class="line"><span class="comment">#最后判断tmp与popped是否正好相反。</span></span><br><span class="line">        <span class="keyword">return</span> tmp[::<span class="number">-1</span>] == popped</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="11-从栈尾到栈头打印链表-本题知识点-链表"><a href="#11-从栈尾到栈头打印链表-本题知识点-链表" class="headerlink" title="11. 从栈尾到栈头打印链表 [^本题知识点 链表]"></a>11. 从栈尾到栈头打印链表 [^本题知识点 <em>链表</em>]</h2><p><strong>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</strong></p>
<p>因为本题输入的是一个链表，因此你需要先建立好一个链表，再将链表的表头节点输入</p>
<p>在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改</p>
<p>通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_linklist_head</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="comment"># 头插</span></span><br><span class="line">    head = Node(li[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">        node = Node(item)  <span class="comment"># 生成节点</span></span><br><span class="line">        node.next = head  <span class="comment"># next指向原来的头部</span></span><br><span class="line">        head = node  <span class="comment"># head 指向在头部插入的节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回头部</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_linklist_tail</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="comment"># 尾插</span></span><br><span class="line">    head = Node(li[<span class="number">0</span>])</span><br><span class="line">    tail = head</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> li[<span class="number">1</span>:]:</span><br><span class="line">        node = Node(item)  <span class="comment"># Node类实例化得到一个node对象。</span></span><br><span class="line">        tail.next = node  <span class="comment"># 把原来尾巴的下一个指针指向当前node</span></span><br><span class="line">        tail = node  <span class="comment"># 尾巴 指向在新部插入的节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回头部</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_linklist</span>(<span class="params">lk</span>):</span></span><br><span class="line">    <span class="keyword">while</span> lk:</span><br><span class="line">        print(lk.val, end=<span class="string">', '</span>)</span><br><span class="line">        lk = lk.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lk_head = create_linklist_head([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">print_linklist(lk_head)  <span class="comment"># 3, 2, 1,</span></span><br><span class="line">print(lk_head)  <span class="comment"># &lt;__main__.Node object at 0x0000029F94CEDE50&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'---'</span>)</span><br><span class="line">lk_tail = create_linklist_tail([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print_linklist(lk_tail)  <span class="comment"># 4, 5, 6,</span></span><br></pre></td></tr></tbody></table></figure>

<p>方法一：递归法 既然想到了栈，其实递归本质上就是一个栈结构，所以也可以使用递归来实现。<br>解题思路：<br>先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
<p>Python 算法流程：<br>1.递推阶段： 每次传入 listNode.next ，将 新插入的节点listNode 添加到末尾<br>listNode 从 链表的第一个元,将链表中的节点的值存入一个栈中<br>只要当前节点不为NULL，也就是链表没到头，就一直递归<br>以 listNode == None（即走过链表尾部节点）为递归终止条件，<br>此时返回空列表 [] 。</p>
<p>2.回溯阶段：<br>递归回溯时每次返回 当前 list + 当前节点值 [listNode.val] </p>
<p>在递归结束时，将元素压入<br>这样当递归到头结束即从尾</p>
<p>复杂度分析：<br>时间复杂度 O(N)： 遍历链表，递归 N 次。<br>空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间。<br>递归函数返回后，内存空间得到释放，因此只用记录最上层函数使用的 O(N) 空间</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reversePrint(self, listNode: ListNode) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        <span class="comment"># return self.reversePrint(listNode.next) + [listNode.val] if listNode else []</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">if</span> listNode:</span><br><span class="line">            <span class="comment"># 先递归到最后一层</span></span><br><span class="line">            temp = self.reversePrint(listNode.next)</span><br><span class="line">            print(listNode.next)</span><br><span class="line">            print(listNode.val)</span><br><span class="line">            print(temp)</span><br><span class="line">            temp.append(listNode.val)</span><br><span class="line">            <span class="comment"># 添加值，退出函数，返回到上一层函数中的这行，继续添加值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = []</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(<span class="string">'------'</span>)</span><br><span class="line">    print(s.reversePrint(lk_head))</span><br><span class="line">    <span class="comment"># None</span></span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="comment"># []</span></span><br><span class="line">    <span class="comment"># &lt;__main__.Node object at 0x000001A05ABC9610&gt;</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># [1]</span></span><br><span class="line">    <span class="comment"># &lt;__main__.Node object at 0x000001A05ACBF640&gt;</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># [1, 2]</span></span><br><span class="line">    <span class="comment"># 打印return</span></span><br><span class="line">    <span class="comment"># [1, 2, 3]</span></span><br><span class="line">    print(s.reversePrint(lk_tail))  <span class="comment"># [6, 5, 4]</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        self.arrayList = []</span><br><span class="line">        <span class="keyword">if</span> listNode:</span><br><span class="line">            <span class="keyword">if</span> listNode.next:</span><br><span class="line">                self.printListFromTailToHead(listNode.next)</span><br><span class="line">            self.arrayList.append(listNode.value)</span><br><span class="line">        <span class="keyword">return</span> self.arrayList</span><br></pre></td></tr></tbody></table></figure>

<p>尾插法的方式不同，则输入不同，后续的代码也不同</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_end_to_head</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""从尾到头打印单链表"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            print(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tmp = []</span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp.insert(<span class="number">0</span>, cur)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">            print(i.item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sl = SingleLinkedList()</span><br><span class="line">    sl.append(SingleNode(<span class="number">1</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">2</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">3</span>))</span><br><span class="line">    sl.append(SingleNode(<span class="number">4</span>))</span><br><span class="line">    sl.print_end_to_head()</span><br><span class="line">    <span class="comment"># 4</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>


<p>方法二：辅助栈法<br>解题思路：</p>
<blockquote>
<p>链表特点： 只能从前至后访问每个节点。<br>题目要求： 倒序输出节点值。<br>这种 先入后出 后进先出 的需求可以借助 栈 来实现。</p>
</blockquote>
<p>算法流程：<br>1.入栈：从链表的头节点开始遍历链表，依次将每个节点值使用 append() 方法 push 入栈。<br>2.出栈：返回 stack 的倒序列表，</p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(n)： 正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。</li>
<li>空间复杂度 O(n)： 额外使用一个栈存储链表中的每个节点。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reversePrint(self, listNode: ListNode) -&gt; List[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        stack = []  <span class="comment"># 初始化栈</span></span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            stack.append(listNode.val)  <span class="comment"># 尾插</span></span><br><span class="line">            listNode = listNode.next  <span class="comment"># 新插入的节点指向上一个头的下一个值</span></span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]  <span class="comment"># 或者 reverse(stack)</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        arrayList = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            arrayList.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        arrayList2 = []</span><br><span class="line">        <span class="keyword">while</span> arrayList:</span><br><span class="line">            arrayList2.append(arrayList.pop())</span><br><span class="line">        <span class="keyword">return</span> arrayList2</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">        stack = []  <span class="comment"># 初始化栈</span></span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            <span class="comment"># 列表.insert(索引，值) 可以在指定位置之前插入元素，</span></span><br><span class="line">            stack.insert(<span class="number">0</span>, listNode.val)  <span class="comment"># 头插</span></span><br><span class="line">            listNode = listNode.next  <span class="comment"># 新插入的节点指向上一个头的下一个值</span></span><br><span class="line">        <span class="keyword">return</span> stack         </span><br></pre></td></tr></tbody></table></figure>


<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h2 id="12-链表中的倒数第k个结点-本题考点-链表"><a href="#12-链表中的倒数第k个结点-本题考点-链表" class="headerlink" title="12.链表中的倒数第k个结点[^本题考点 链表]"></a>12.链表中的倒数第k个结点[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p>
<p>要求链表倒数第 k 个节点，那么正数就应该是从头结点开始往后推（n-k）个，正数第length - k个节点<br>n自然代表所有节点的个数（不包含空节点），也可以说n代表指针的个数，</p>
<p>题目说了返回节点啊，不是返回节点值<br>自己测试还是返回节点值</p>
<p>法一<br>使用双指针则可以不用统计链表长度。<br>算法流程：<br>1.初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head​ 。<br>2.构建双指针距离： 前指针 former 先向前走 k 步，<br>（结束后，双指针 former 和 latter 间相距 k 步）。<br>3.双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，<br>直至 former 走过链表 尾节点 时跳出<br>（跳出后， latter 与尾节点距离为 k-1，latter 与null距离为 k<br>由于index(right) - index(left) = k，<br>所以index(left) = index(right) - k = length - k。<br>即 latter 指向倒数第 k 个节点）。<br>设置两个指针，p2指针先走（k-1）步到达第k个结点，然后再一起走，<br>当p2为最后一个时，p1就为倒数第k个 数</p>
<p>4.返回值： 返回 latter 即可。<br>相当于制造了一个K长度的尺子，把尺子从头往后移动，<br>当尺子的右端与链表的末尾对齐的时候，尺子左端所在的结点就是倒数第k个结点”</p>
<p>复杂度分析：<br>时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k) 步。<br>空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。<br>本题没有 k 大于链表长度的 case ，因此不用考虑越界问题。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        former, latter = head, head</span><br><span class="line">        <span class="comment"># 首先让一个指针先开始移动，那么就是遍历我们的k 值，</span></span><br><span class="line">        <span class="comment"># 让我们的 第一个指针移动 k 步。</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="comment"># 在循环中若是游标为None，则达到临界条件，</span></span><br><span class="line">            <span class="comment"># 说明k比该链表的长度还要长，即返回None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> former:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            former = former.next  <span class="comment"># 第一个指针 移动一步</span></span><br><span class="line">        <span class="keyword">while</span> former:</span><br><span class="line">            former, latter = former.next, latter.next</span><br><span class="line">        <span class="keyword">return</span> latter.val  <span class="comment"># 最后 latter 就指向目标节点</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>先遍历统计链表长度，记为 length ；<br>设置一个指针走 (length-k) 步，即可找到链表倒数第 k 个节点。<br>相当于遍历两遍。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            node = node.next</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; length:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> length - k:  <span class="comment"># 5-2=3 5-3=2 5-4=1</span></span><br><span class="line">            print(length-k)</span><br><span class="line">            print(head.val)  <span class="comment"># 从头节点开始开始遍历</span></span><br><span class="line">            head = head.next</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.val</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = self.getKthFromEnd(head.next, k)</span><br><span class="line"><span class="comment">#执行了一个函数 elf.getKthFromEnd() ，</span></span><br><span class="line"><span class="comment"># 传入了参数 head.next, k ，返回值赋给 node</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主要考虑的点是捕捉目标节点 head ，并在捕捉后就一直返回这个 node</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == k:</span><br><span class="line">            <span class="keyword">return</span> head.val</span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>将所有值使用容器（列表、堆栈、数组等）保存链表，<br>只遍历一遍，然后直接查询</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head)</span><br><span class="line"><span class="comment"># 这样放的是一个引用，不是整个list，根据这个引用地址可以遍历后面的链表。</span></span><br><span class="line"><span class="comment"># 如果是res.append(head.val)，返回的是节点的值。题目要求返回节点。</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> k &gt; len(res) <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.png"></p>
<p>注意你的提示“’NoneType’ object has no attribute ‘next’”，<br>因为你的while判断条件有问题，要改成while head。<br>你想一下，如果是一个空链表，那么head.next肯定会报错的</p>
<hr>
<p>如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。</p>
<h2 id="13-反转链表-本题考点-链表"><a href="#13-反转链表-本题考点-链表" class="headerlink" title="13.反转链表[^本题考点 链表]"></a>13.反转链表[^本题考点 <em>链表</em>]</h2><p><strong>题目：输入一个链表，反转链表后，输入一个链表，反转链表输出新链表的表头。</strong><br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<ul>
<li><p>第一种方法：迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reverseList(self, head: ListNode) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="comment"># 首先判断这个链表里是否为空或只有一个结点，</span></span><br><span class="line">        <span class="comment"># 只有一个结点那么它就不需要发生变化，</span></span><br><span class="line">        <span class="comment"># 它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="comment"># 这个时候就直接返回这个 head，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 反转过后，第一个数值的指针的结点指向的是none</span></span><br><span class="line">        <span class="comment"># 也就是一个指向反转后的头结点 为none</span></span><br><span class="line">        prev = <span class="literal">None</span>  <span class="comment"># 初始化当前节点的上一个节点</span></span><br><span class="line">        cur = head  <span class="comment"># cur始终指向要反转的结点，初始化为头结点</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 在循环过程中，让旧链表的表头的下一个结点等于新表头，</span></span><br><span class="line">            <span class="comment"># 新表头等于旧表头，旧表头等于旧表头的下一个结点，依次循环</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 简单写法</span></span><br><span class="line">            <span class="comment"># cur.next, prev, cur = prev, cur, cur.next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 详细执行过程写法</span></span><br><span class="line">            <span class="comment"># 先找到第一个元素的指针指向的元素，赋值给一个临时变量</span></span><br><span class="line">            temp = cur.next  <span class="comment"># 保存当前节点的下一个节点，因为后面更改了当前节点的next指向，</span></span><br><span class="line">            <span class="comment"># 由于节点没有引用其上一个节点，如果缺少了这一句，更改了当前节点的next指向，那原来后面的节点就找不到了</span></span><br><span class="line">            cur.next = prev  <span class="comment"># 每反转一个结点，把当前结点的下一个结点指向上一个节点prev</span></span><br><span class="line">            prev = cur  <span class="comment"># 将上一个节点前移到当前节点，prev成为反转后首结点 </span></span><br><span class="line">            cur = temp  <span class="comment"># 再把cur向前移动一个结点直至None结束</span></span><br><span class="line">        <span class="comment"># 最终就达到了翻转链表的效果，</span></span><br><span class="line">        <span class="keyword">return</span> prev  <span class="comment"># 题目要求返回表头，cur == None结束，肯定不会返回None</span></span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n)，n 是列表的长度<br>空间复杂度：O(1) 。</p>
</li>
<li><p>第二种方法：递归：<br>我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，<br>所以反转一下我和我的子节点。</p>
</li>
</ul>
<p>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .<br>此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。<br>同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转<br>当递归函数全部出栈后，链表反转完成。</p>
<p>原来的尾节点变为头节点，next原来指向None，尾部的next为空，<br>将从第二个node开始，循环将next指向前一个节点<br>原来的头节点变为尾节点，next原来指向下一个节点，改为指向None</p>
<p>不妨假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，<br>reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，<br>5-&gt;next = 4, 4-&gt;next = null。这时候返回了p这个节点，<br>也就是链表5-&gt;4-&gt;null，接下来执行reverseList（3），<br>代码解析为4-&gt;next = 3,3-&gt;next = null，这个时候p就变成了，<br>5-&gt;4-&gt;3-&gt;null, reverseList(2), reverseList(1)依次类推，p就是:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null</p>
<p>3 需要一直有一个指针指向还没有反转的链表的头部</p>
<p>使用递归函数需要注意防止递归深度溢出，在Python中，通常情况下，<br>这个深度是1000层，超过将抛出异常。<br>在计算机中，函数递归调用是通过栈（stack）这种数据结构实现的，<br>每当进入一个递归时，栈就会加一层，每当函数返回一次，栈就会减一层。<br>由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># def reverseList(self, head: ListNode) -&gt; ListNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件是链表里是否为空或只有一个结点，</span></span><br><span class="line">        <span class="comment"># 只有一个结点那么它就不需要发生变化，</span></span><br><span class="line">        <span class="comment"># 它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="comment"># 这个时候就直接返回这个 head，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        <span class="comment"># 执行了一个函数 elf.reverseList() ，传入了参数 head.next，</span></span><br><span class="line">        <span class="comment"># 直到head.next为空触发终止条件， head.next为最后一个节点作为返回值赋给 cur</span></span><br><span class="line">        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，</span></span><br><span class="line">        <span class="comment"># head.next.next=null,</span></span><br><span class="line">        <span class="comment"># cur = head.next =5</span></span><br><span class="line">        <span class="comment"># head=4</span></span><br><span class="line">        head.next.next = head  <span class="comment"># head的下一个节点head.next不再指向下一个反转指向前一个</span></span><br><span class="line">        <span class="comment"># 4.next.next=4 即5.next=4</span></span><br><span class="line">        <span class="comment"># 不能让cur.next = head，每次拿到的cur都是指向5，如果此时执行到节点2，那么相当于5.next=2，这样就不对了</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># head的下一个指向设置为空，防止循环指向，要断开</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># 判断是否为空值，没有元素</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 判断是否只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> pHead.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="comment"># 左边指针为 头 第一个 指针</span></span><br><span class="line">        leftPointer = pHead</span><br><span class="line">        <span class="comment"># 中间 的指针 为 第二个指针</span></span><br><span class="line">        midPointer = pHead.next</span><br><span class="line">        <span class="comment"># 右边的指针  为 指向 中间 指针后的 所有的元素 </span></span><br><span class="line">        rightPointer = midPointer.next</span><br><span class="line">        <span class="comment"># 左边的指针为 起始 的 元素， 反转后 它的next 为 None；</span></span><br><span class="line">        leftPointer.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。</span></span><br><span class="line">        <span class="keyword">while</span> rightPointer:</span><br><span class="line">            <span class="comment"># 中间指针指向的为上一个 元素 即 leftPointer</span></span><br><span class="line">            midPointer.next = leftPointer</span><br><span class="line">            <span class="comment"># 三个指针开始往右移。每次移一个。</span></span><br><span class="line">            <span class="comment"># 左边指针 往右移一个 就是中间指针的位置</span></span><br><span class="line">            leftPointer = midPointer</span><br><span class="line">            <span class="comment"># 中间指针 往 右 移 一个，就时 右边指针的位置</span></span><br><span class="line">            midPointer = rightPointer</span><br><span class="line">            <span class="comment"># 右边指针往右移 一个 ，就时 右边指针的下一个。</span></span><br><span class="line">            rightPointer = rightPointer.next</span><br><span class="line">        <span class="comment"># 当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。</span></span><br><span class="line">        midPointer.next = leftPointer</span><br><span class="line">        <span class="comment"># 最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。</span></span><br><span class="line">        <span class="keyword">return</span> midPointer</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n) 。假设 n 是列表的长度，那么时间复杂度为 O(n) 。<br>空间复杂度：O(n) 。由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</p>
<p>如图所示：</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h2 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14.复杂链表的复制"></a>14.复杂链表的复制</h2><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>一个指向下一个节点，另一个特殊指针指向任意一个节点），<br>返回结果为复制后复杂链表的head。<br>（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.png"></p>
<hr>
<p>####第一种方法：<br>算法：深度优先搜索<br>1.从头结点 head 开始拷贝；<br>2.由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；<br>3.如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；<br>4.使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</p>
<p>时间复杂度：O(N)。<br>空间复杂度：O(N)。</p>
<p>首先创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点<br>我们将原节点作为key，新节点作为value放入哈希表中</p>
<p>原节点和新节点是一一对应的关系，所以</p>
<p>map.get(原节点)，得到的就是对应的新节点<br>map.get(原节点.next)，得到的就是对应的新节点.next<br>map.get(原节点.random)，得到的就是对应的新节点.random<br>只需要再次遍历原链表，然后设置：<br>新节点.next -&gt; map.get(原节点.next)<br>新节点.random -&gt; map.get(原节点.random)<br>这样新链表的next和random都被串联起来了<br>最后，我们然后map.get(head)，也就是对应的新链表的头节点，就可以解决此问题了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 创建一个哈希表，key是原节点，value是新节点</span></span><br><span class="line">        d = dict()</span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 将原节点和新节点放入哈希表中</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            new_node = Node(p.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            d[p] = new_node</span><br><span class="line">            p = p.next</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历原链表，设置新节点的next和random</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="comment"># p是原节点，d[p]是对应的新节点，p.next是原节点的下一个</span></span><br><span class="line">            <span class="comment"># d[p.next]是原节点下一个对应的新节点</span></span><br><span class="line">            <span class="keyword">if</span> p.next:</span><br><span class="line">                d[p].next = d[p.next]</span><br><span class="line">            <span class="comment"># p.random是原节点随机指向</span></span><br><span class="line">            <span class="comment"># d[p.random]是原节点随机指向  对应的新节点</span></span><br><span class="line">            <span class="keyword">if</span> p.random:</span><br><span class="line">                d[p].random = d[p.random]</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="comment"># 主要是第二种是明白在放入hashmap里时候就已经最后指向了null，</span></span><br><span class="line">        <span class="comment"># 返回头结点，即原节点对应的value(新节点)</span></span><br><span class="line">        <span class="keyword">return</span> d[head]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            <span class="comment"># 创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            <span class="comment">#  visited是一个哈希表，即visited = {键：值}，visited[键]=值</span></span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            <span class="comment"># 反复运行，会递归得越来越深，</span></span><br><span class="line">            <span class="comment"># 当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；</span></span><br><span class="line"></span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="comment"># 回溯时，先从尾结点开始回溯：调用dfs(head.random)时，</span></span><br><span class="line">            <span class="comment"># 由于结点都保存在了哈希表中，因此 return visited[head]，</span></span><br><span class="line">            <span class="comment"># 这时完成random指针，完成了最后一个结点，故return copy。</span></span><br><span class="line">            <span class="comment"># 再进行倒数第二个结点的回溯：</span></span><br><span class="line">            <span class="comment"># 调用dfs(head.random)，return visited[head]，return copy.......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一部分的 return 是 dfs(head.next) 和 dfs(head.random) 的终止条件，</span></span><br><span class="line">            <span class="comment"># 您提到了访问过了就直接返回了，</span></span><br><span class="line">            <span class="comment"># 这里的返回可以理解为找到了递归部分 head.next 或 head.random 的终止条件。</span></span><br><span class="line">            <span class="comment"># 这时 copy 的值，next，random 都找到了，</span></span><br><span class="line">            <span class="comment"># 我们可以最终执行第二部分的 return copy 了。</span></span><br><span class="line">            <span class="comment"># copy 是原链表 head 的复制结点，刚开始 next 和 random 都是 null，</span></span><br><span class="line">            <span class="comment"># 然后只是对 next 和 random 进行了递归，copy 应该一直就在那里没动等于 head，</span></span><br><span class="line">            <span class="comment"># 所以很原链表一样返回 copy就行了。</span></span><br><span class="line">            <span class="comment"># 我想问下你说的【return copy之后继续执行copy.random = dfs(head.random)】</span></span><br><span class="line">            <span class="comment"># 意思是第二部分 return copy 之后又执行dfs了嘛；</span></span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></tbody></table></figure>

<p>####方法二：<br>我们也可以不使用哈希表的额外空间来保存已经拷贝过的结点，<br>而是将链表进行拓展，在每个链表结点的旁边拷贝，<br>比如 A-&gt;B-&gt;C 变成 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，<br>然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’，<br>最后返回 A’-&gt;B’-&gt;C’。<br>原链表上进行操作的，最后分开时也是在原链表上进行的操作，所以可以认为没有占用额外空间。<br>比如假如输入为数组，我们进行原地修改，最后返回数组的切片<br>数组切片是shallow copy, 空间复杂度依靠slice长度决定<br>函数要完成的目标所需的空间一般不算在空间复杂度内，<br>时间复杂度：O(N)<br>空间复杂度：O(1) 没有使用辅助空间或者使用了常数个辅助空间的情况下<br>原链表最后一个节点肯定指向null，所以可以不用处理<br>新旧链表断开后，新链表最后一个节点不需要再处理了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 根据遍历到的链表每个原节点创建对应的新节点，每个新创建的节点是在原节点后面加入链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 克隆新结点，把第一个 A 的值 赋给 node 为A‘，</span></span><br><span class="line">            new_node = Node(cur.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># 此时 node A' 的结点指向的是 原来A 的结点指向的下一个值</span></span><br><span class="line">            new_node.next = cur.next</span><br><span class="line">            <span class="comment"># 克隆新结点在cur 后面，将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">            cur.next = new_node</span><br><span class="line">            <span class="comment"># 将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，</span></span><br><span class="line">            <span class="comment"># 即为 A’ 结点 指向的下一个元素</span></span><br><span class="line">            cur = new_node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现新建的node的随机指针random指向的节点</span></span><br><span class="line">        <span class="comment"># 原节点1的随机指针指向原节点3，新节点1的随机指针指向的是原节点3的next</span></span><br><span class="line">        <span class="comment"># 原节点3的随机指针指向原节点2，新节点3的随机指针指向的是原节点2的next</span></span><br><span class="line">        <span class="comment"># 原节点i的随机指针(如果有的话)，指向的是原节点j</span></span><br><span class="line">        <span class="comment"># 那么新节点i的随机指针，指向的是原节点j的next</span></span><br><span class="line">        cur = head  <span class="comment"># 用头节点的随机指针</span></span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 迭代新创建的列表</span></span><br><span class="line">            <span class="comment"># 如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">            <span class="comment"># B 的 random 指针指向 A ，意味着 B 的下一个复制节点 B' 的 random 指针指向 A的random 的下一个节点A' 。</span></span><br><span class="line">            cur.next.random = cur.random.next <span class="keyword">if</span> cur.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 建好 这个元素的 random 的值，然后移动 指针 到下一个元素，</span></span><br><span class="line">            <span class="comment"># 来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="comment"># 当前元素 下一个的下一个 是复制的元素， 也是需要添加random 指向的元素。</span></span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开原来的node 和 新的node 之间的链接分离成原链表和复制的链表</span></span><br><span class="line">        <span class="comment"># =====法一========</span></span><br><span class="line">        p = head</span><br><span class="line">        dummy = Node(<span class="number">-1</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cur.next = p.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            p.next = cur.next</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># =====法二========</span></span><br><span class="line">        <span class="comment"># cur_old_list = head</span></span><br><span class="line">        <span class="comment"># # 复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        <span class="comment"># cur_new_list = head.next</span></span><br><span class="line">        <span class="comment"># # 复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        <span class="comment"># new_head = head.next</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="comment"># while cur_old_list:</span></span><br><span class="line">        <span class="comment">#     # 将旧链表 A 的指向结点改为 A’ 的指向的下一个 的B。</span></span><br><span class="line">        <span class="comment">#     cur_old_list.next = cur_old_list.next.next</span></span><br><span class="line">        <span class="comment">#     # 如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">        <span class="comment">#     # 那么就把 这个元素的A’ 的结点指向 改为 A’ 下一个 B 的下一个 的B’</span></span><br><span class="line">        <span class="comment">#     if cur_new_list.next:</span></span><br><span class="line">        <span class="comment">#         cur_new_list.next = cur_new_list.next.next</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         cur_new_list.next = None</span></span><br><span class="line">        <span class="comment">#     # 上面新链表的元素指针改好了，再更改 下一个旧链表的 元素</span></span><br><span class="line">        <span class="comment">#     # 改好的 A 的结点指向的B</span></span><br><span class="line">        <span class="comment">#     cur_old_list = cur_old_list.next</span></span><br><span class="line">        <span class="comment">#     # 将新链表的指针移位，来断开下一个链接，也就是 指针改为了 B’</span></span><br><span class="line">        <span class="comment">#     cur_new_list = cur_new_list.next</span></span><br><span class="line">        <span class="comment">#     # 如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line">        <span class="comment"># return new_head  # 最后返回这个复制好的新链表。</span></span><br><span class="line"> ```   </span><br><span class="line">    </span><br><span class="line">第三种方法：对于 python 可直接调用相关函数：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">return</span> copy.deepcopy(head)</span><br></pre></td></tr></tbody></table></figure>

<p>迭代<br>对于一个结点，<br>分别拷贝此结点、next 指针指向的结点、random 指针指向的结点，<br>然后进行下一个结点…如果遇到已经出现的结点，那么我们不用拷贝该结点，<br>只需将 next 或 random 指针指向该结点即可。</p>
<hr>
<h2 id="15-两个链表之间的第一个公共结点"><a href="#15-两个链表之间的第一个公共结点" class="headerlink" title="15.两个链表之间的第一个公共结点"></a>15.两个链表之间的第一个公共结点</h2><p><strong>输入两个链表，找出它们的第一个公共结点</strong><br>如图：<br><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%9A%84%E7%BB%93%E7%82%B9.png"></p>
<hr>
<p>题目要求输入输入的skipA /skipB 表示之前的节点即使值一样，<br>但是 是new 在堆上的 地址会不一样，而后续节点是通过引用进行连接的链表；<br>=》所以题目可以表述为在两个链表中找到共有的 引用链表的头结点<br>示例1里面输入把相交节点前的节点数分别给定死为2和3了，我试了下改为1和2，相交节点就是1了</p>
<p>A=[4,1,8,4,5]<br>B=[5,0,1,8,4,5]<br>1是值相同的两个不同节点，<br>8是存在于两个链表中的唯一节点，相交于结点 8。<br>链表是用类实现的，每个节点都是一个类的实例，<br>公共交点，节点共用，节点的地址（引用）相同，他的特征是数值和指针都相等，仅值相同不一定是同一节点，<br>判断node1 != node2 不是node1.val==node2.val，</p>
<p>法一：<br>两个链表长度分别为L1+C、L2+C，C为公共部分的长度，<br>L1,L2分别为两个链表在交点之前的开头不重复的部分</p>
<p>使用两个指针 node1，node2 分别指向两个链表 headA, headB 的头结点，</p>
<p>因为只有当node1==node2的时候，才会跳出 while (node1 != node2) 循环，<br>此时，返回node1和node2是一样的，因为相等。<br>而且node1此时只有两种情况：<br>1.node1为相交点</p>
<ol>
<li>如果两个链表的长度不一样,同时分别逐结点遍历，两次遍历，<br>当 node1 走了L1+C步后到达链表 headA 的末尾时，重新定位到链表 headB 的头结点，走L2步<br>当 node2 走了L2+C步后到达链表 headB 的末尾时，重新定位到链表 headA 的头结点，走L1步。</li>
</ol>
<p>L1+C+L2+C == L2+C+L1+C<br>L1+C+L2 == L2+C+L1<br>当两个人走的步数都为L1+L2+C时，一定是同时结束。<br>如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 </p>
<ol start="2">
<li>如果两个链表的长度一样，L1=L2，遍历一次就可以找到相交的起始节点</li>
</ol>
<p>2.不相交 C=0<br>a+None + b+None = b+None+ a+None ，<br>a+none+b长度与b+none+a长度相等<br>循环次数最多为a、b长度之和，如果不相交，会在ha==hb=None条件下（最后一个节点），退出循环。</p>
<p>  1.如果长度不相等，两个指针节点都需要遍历完链表L1+L2(L1+L2）长度，同时移动到尾节点指向None<br>然后node1==node2==None，while条件不成立，跳出循环，返回也是None，表示没有相交结点</p>
<ol start="2">
<li>如果两个链表的长度一样，遍历一次L1=L2，尾节点同时指向None，跳出循环了</li>
</ol>
<p>在每一个链表中使用了迭代，最多循环两次，因为每个指针最多遍历两个链表</p>
<p>法二<br>两个指针分别指向两个链表头部，<br>一起向前走直到其中一个到达末端，另一个与末端距离则是两链表的 长度差。<br>再通过长链表指针先走的方式消除长度差，最终两链表即可同时走到相交点。</p>
<p>换个方式消除长度差： 拼接两链表。<br>设长-短链表为 C，短-长链表为 D （分别代表长链表在前和短链表在前的拼接链表），<br>则当 C 走到长短链表交接处时，D 走在长链表中，且与长链表头距离为 长度差;</p>
<p>[5,0,1,8,4,5][4,1,8,4,5]<br>[4,1,8,4,5][5,0,1,8,4,5]  </p>
<p>短链表走到尽头后继续走长链表，就相当于短链表+长链表。<br>长链表走到尽头后又走短链表，相当于长链表+短链表。<br>所以重新走两次其实本质上还是相当于走两次新的拼接的互补链表，<br>这样，当它们相遇时，所指向的结点就是第一个公共结点。<br>当 ha == hb 时跳出，返回即可</p>
<p>我觉得时会有None出现的，因为headA+headB和headB+ headA长度一定是相等的，<br>假设没有相交，最后一位一定是ha.next == None, hb.next == None，退出循环，<br>然后假设有相交，那就是在某一非链尾位置，ha = =hb 就毋庸置疑了，<br>假设headA长度等于headB，<br>那么第一个None一定会退出，不论是否相交，<br>但是如果相交，既然headA和headB相等，<br>那一定在转换前就能完成==退出循环，<br>如果不相交，这时候ha == None，返回值就是None。</p>
<p>如果两个链表的长度不一样，需要两次遍历，第一次遍历是为了消除长度差，<br>找到长链表到尾结点的长度和短链表到尾结点的长度一样的节点处，<br>第二次遍历找到相交的起始节点。</p>
<p>指向长链表的指针先走 “两个链表长度的差值” 步，再两个指针一起走。<br>因为当短的链表指针走到末尾时，长的链表指针刚好距离末尾 “两个链表长度的差值” 步。<br>然后短链表的指针此时指向长链表的开头，两个指针一起走，靠近链表末尾的指针指向空时，<br>靠近开头的指针便走了 长度差值 步。然后此时指向空的指针再指向短链表的开头。<br>这时开始，两个指针距离相交节点的长度就是相同的，两个指针一起走，就能走到相交节点。</p>
<p>空间复杂度 O(1) 时间复杂度为 O(n)<br>其实也并不是常数系数省略，而是这里的两条链表同时在遍历，总路径是2(m+n)但是迭代次数是m+n所以时间复杂度为O(m+n)。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># 不是node1 = node1.next if node1.next else headB</span></span><br><span class="line">            <span class="comment"># 理解为两条链表最后都指向了同一个 null （None）节点，代替了不相交的特殊情况</span></span><br><span class="line">            <span class="comment"># 如果加next的话，那指针到最后一个结点就直接转链表了，</span></span><br><span class="line">            <span class="comment"># 因为你提前判断了它的next是否为空，就不会有null的情况了</span></span><br><span class="line">            <span class="comment"># 会一直死循环（如果不相交）。</span></span><br><span class="line">            <span class="comment"># 没有交点的情况可以约化为 交点为 None 的情况。（即将两链表末端的 None 看作交点）</span></span><br><span class="line">            <span class="comment"># 不用next，最后不相交的话会都等于None而结束循环</span></span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="16-合并两个排序的链表-本题考点-链表"><a href="#16-合并两个排序的链表-本题考点-链表" class="headerlink" title="16.合并两个排序的链表 [^本题考点  链表]"></a>16.合并两个排序的链表 [^本题考点  链表]</h2><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong><br>示例：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>构造链表的这种题一般都是需要两个量，一个存储链表头，一个不断移动进行构造。</p>
<ul>
<li><p>引入伪头节点：<br>由于初始状态合并链表中无节点，<br>因此循环第一轮时无法将节点添加到合并链表中。<br>解决方案：<br>初始化一个辅助节点 dum 作为合并链表的伪头节点， dum 的 val 属性不保存任何值<br>将各节点添加至 dum 之后，在整个链表合并完之后，返回它的下一位置即可指向结果链表的头部 ，哑结点可以不需要重复判空; </p>
</li>
<li><p>cur记录下一个插入位置的前一个位置，相当于一个游标，不断移动构造链表。<br>遍历链表的指针，每一次会指向新加入节点，将已合并链表添加至此节点后面。<br>如果不赋值给cur，用dum代替cur去做迭代的话，<br>那dum最终指向的是l1或l2的尾节点，<br>相当于没保存合并后链表的头结点，在构建完成后就没法找到链表头了。<br>先调整 cur 的 next 属性，再后移 cur</p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cur.next</span> = dum</span><br><span class="line"><span class="attr">cur</span> = cur.next</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第一种方法：  </p>
</li>
</ul>
<p>解题思路：</p>
<ul>
<li><p>根据题目描述， 链表 l<sub>1</sub> , l<sub>2</sub>是 递增 的，<br>因此容易想到使用双指针 l<sub>1</sub> 和 l<sub>2</sub> 遍历两链表，<br>根据 l<sub>1</sub>.val 和 l<sub>2</sub>.val 的大小关系确定节点添加顺序，<br>两节点指针交替前进，直至遍历完毕。</p>
</li>
<li><p>当 l1 和 l2 都不是空链表时，<br>比较两个链表的首结点，将较小值的节点则添加到第三个链表尾结点，<br>将对应链表中的节点向后移一位，并向前移动一个结点。<br>结果会有一个链表先遍历结束，或者没有<br>第三个链表尾结点指向剩余未遍历结束的链表<br>返回第三个链表首结点</p>
</li>
</ul>
<p>算法流程：  </p>
<ol>
<li><p>初始化： 伪头节点 dum ，节点 cur 指向 dum 。  </p>
</li>
<li><p>循环合并： 当 l<sub>1</sub> 或 l<sub>2</sub>    为空时跳出；</p>
</li>
<li><p>当 l<sub>1</sub>.val &lt; l<sub>2</sub>.val 时：<br>cur 的后继节点指定为 l<sub>1</sub> ，并 l<sub>1</sub> 向前走一步；<br>把 l1 当前的节点接在 cur 节点的后面同时将 l1 指针往后移一位</p>
</li>
<li><p>当 l<sub>1</sub>.val  ≥ l<sub>2</sub> .val 时：<br>cur 的后继节点指定为 l<sub>2</sub> ，并 l<sub>2</sub>向前走一步 ；</p>
</li>
<li><p>不管我们将哪一个元素接在了后面，我们都需要把 cur 向后移一位，即 cur = cur.next 。  </p>
</li>
<li><p>合并剩余尾部： 跳出时有两种情况，即 l<sub>1</sub> 为空 或 l<sub>2</sub> 为空。  </p>
</li>
<li><p>若 l<sub>1</sub> != null ： 将 l<sub>1</sub>添加至节点 cur 之后；</p>
</li>
<li><p>否则： 将 l<sub>2</sub> 添加至节点 cur 之后。<br>在循环终止的时候， l1 和 l2 至多有一个是非空的（还未被合并完），<br>由于输入的两个链表都是有序的，所以不管哪个链表是非空的，<br>它包含的所有元素都比前面已经合并链表中的所有元素都要大。<br>这意味着我们只需要简单地将非空链表接在合并链表的后面</p>
</li>
<li><p>返回值： 返回 dum.next 就是合并链表的头节点</p>
</li>
</ol>
<p>原地调整链表元素的 next 指针完成合并</p>
<p>时间复杂度 O(N) ：链表 l<sub>1</sub>, l<sub>2</sub> 的长度和，<br>l1 和 l2 只有一个元素会被放进合并链表中，<br>因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，</p>
<p>空间复杂度 O(1) ：节点引用 dum , cur 使用常数大小的额外空间存放若干变量。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># ListNode(0) 建立一个值为 0 的节点实例，不可变对象0也可以用None，开辟结点的内存空间，dum 引用 指向这个节点对象ListNode(0)</span></span><br><span class="line">        dum = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dum  <span class="comment"># 然后 cur 引用再指向 dum 对象，</span></span><br><span class="line">        <span class="comment"># cur 实际上就是保存 ListNode(0) 的地址，你可以随意声明变量去指向此节点~</span></span><br><span class="line">        <span class="comment"># 但 cur 和 dum 是两个独立变量，改变 cur，dum 仍然指向这个节点，所以没有变化~</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next, l1 = l1, l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next, l2 = l2, l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">or</span> l2  <span class="comment"># 等价于 x if x else y</span></span><br><span class="line">        <span class="keyword">return</span> dum.next  <span class="comment"># 返回第一个值  </span></span><br></pre></td></tr></tbody></table></figure>

<p>####第二种方法：递归<br>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，<br>所以我们只需要返回非空链表。<br>否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，<br>然后递归地决定下一个添加到结果里的节点。<br>如果两个链表有一个为空，递归结束。</p>
<p>我们判断 l1 和 l2 头结点哪个更小，<br>然后较小结点的 next 指针指向其余结点的合并结果。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></tbody></table></figure>
<p>其中时间复杂度可以这样计算：<br>给出一个递归算法，其时间复杂度 O(T) 通常是递归调用的数量（记作 {R}R） 和<br>计算的时间复杂度的乘积（表示为 O(s)）的乘积：(T) = R ∗ O(s)</p>
<p>时间复杂度：O(m+n)。<br>m，n 为 l<sub>1</sub>} 和 l<sub>2</sub> 的元素个数。<br>递归函数每次去掉一个元素，直到两个链表都为空，<br>因此需要调用 R=O(m+n) 次。<br>而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 O(1)，<br>故递归的总时间复杂度为 O(T)=R∗O(1)=O(m+n) 。</p>
<p>空间复杂度：O(m+n)。</p>
<p>对于递归调用 self.mergeTwoLists()，当它遇到终止条件准备回溯时，<br>已经递归调用了 m+nm+n 次，使用了 m+nm+n 个栈帧，<br>故最后的空间复杂度为 O(m+n)。</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8.png" alt="为两个递增的链表"><br><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8.png" alt="合并成一个单调不减链表"></p>
<p>输入的是两个链表的头结点，<br>最后返回的是合并链表的头结点。<br>但是输出结果却是一个完整的链表</p>
<p>因此我认为应该就是修改两个链表的引用指向实现合并~ 应该不用新建节点~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        <span class="comment">#首先判断两个链表是不是为空。</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        <span class="comment">#比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。</span></span><br><span class="line">        newHead = pHead1 <span class="keyword">if</span> pHead1.val &lt; pHead2.val <span class="keyword">else</span> pHead2</span><br><span class="line">        </span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="comment">#判断 如果新表头 是 表1 的头的话 那么 新表头</span></span><br><span class="line">        <span class="keyword">if</span> newHead == pTmp1:</span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        previousPointer = newHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pTmp1 <span class="keyword">and</span> pTmp2:</span><br><span class="line">            <span class="keyword">if</span> pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next = pTmp1</span><br><span class="line">                previousPointer = pTmp1</span><br><span class="line">                pTmp1 = pTmp1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                previousPointer.next = pTmp2</span><br><span class="line">                previousPointer = pTmp2</span><br><span class="line">                pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pTmp1 == <span class="literal">None</span>:</span><br><span class="line">        </span><br><span class="line">            previousPointer.next = pTmp2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            previousPointer.next = pTmp1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h2><p><strong>给你一个链表数组，每个链表都已经按升序排列。</strong><br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2：</p>
<figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="string">[[]]</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure>

<p>思路：每个链表的第一个结点入堆，进行比较，最小的出堆，该链表往后移，然后找出堆链表中的后续入堆</p>
<p>python3的堆中链表无法比较大小，我们传入的是val和他所在的list(这是第几个链表)方便查找后续<br>heapq 模块传入的 tuple 对象里面不能有引用对象，就只好传一个索引进去了。<br>元组在heapq里比较的机制是从元组首位0开始，即遇到相同，就比较元组下一位，比如(1,2), (1,3)，前者比后者小。</p>
<p>ListNode无法被比较</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        minHeap = []</span><br><span class="line">        <span class="keyword">for</span> index, node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="comment"># index 用来记录这是第几个链表</span></span><br><span class="line">            <span class="comment"># node 是每个链表的头结点</span></span><br><span class="line">            <span class="keyword">if</span> node:  <span class="comment"># 只要头结点不空</span></span><br><span class="line">                <span class="comment"># 把k个链表的头结点的value以及该头结点所在的链表index入堆</span></span><br><span class="line">                heapq.heappush(minHeap, (node.val, index))</span><br><span class="line">        linkedlistHead = ListNode(<span class="number">-1</span>)  <span class="comment"># 伪头节点</span></span><br><span class="line">        linkedlistTail = linkedlistHead  <span class="comment"># 构建链表的结点</span></span><br><span class="line">        <span class="keyword">while</span> minHeap:</span><br><span class="line">            <span class="comment"># 堆内链表value最小的出堆，找到他是第几个链表，好找他的下一个位置</span></span><br><span class="line">            val, index = heapq.heappop(minHeap)</span><br><span class="line">            linkedlistTail.next = lists[index]  <span class="comment"># 加入到了结果集合中</span></span><br><span class="line">            linkedlistTail = linkedlistTail.next  <span class="comment"># 开始加下一个位置</span></span><br><span class="line">            lists[index] = lists[index].next  <span class="comment"># 找到当前链表的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> lists[index]:  <span class="comment"># 如果不空的话就让他入堆</span></span><br><span class="line">                heapq.heappush(minHeap, (lists[index].val, index))  <span class="comment"># 下一个元素入堆</span></span><br><span class="line">        <span class="keyword">return</span> linkedlistHead.next  <span class="comment"># 返回链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">4</span>, ListNode(<span class="number">5</span>)))</span><br><span class="line">    link2 = ListNode(<span class="number">1</span>, ListNode(<span class="number">3</span>, ListNode(<span class="number">4</span>)))</span><br><span class="line">    link3 = ListNode(<span class="number">2</span>, ListNode(<span class="number">6</span>))</span><br><span class="line">    node = Solution().mergeKLists([link1, link2, link3])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)  <span class="comment"># [1, 1, 2, 3, 4, 4, 5, 6]</span></span><br><span class="line">    print([link1, link2, link3])</span><br><span class="line">    <span class="comment"># [&lt;__main__.ListNode object at 0x000001CF45EA6FA0&gt;, &lt;__main__.ListNode object at 0x000001CF45EDD670&gt;, &lt;__main__.ListNode object at 0x000001CF45EDDC70&gt;]</span></span><br><span class="line">    print(type([link1, link2, link3]))  <span class="comment"># &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># minHeap = []</span></span><br><span class="line"><span class="comment"># index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 0)]</span></span><br><span class="line"><span class="comment"># index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 0), (1, 1)]</span></span><br><span class="line"><span class="comment"># index = 2</span></span><br><span class="line"><span class="comment"># minHeap[(1, 0), (1, 1), (2, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 1, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment"># minHeap = [(1, 1), (2, 2), (4, 0)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 1, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(2, 2), (4, 0)]</span></span><br><span class="line"><span class="comment"># minHeap = [(2, 2), (4, 0), (3, 1)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 2, index = 2</span></span><br><span class="line"><span class="comment"># minHeap = [(3, 1), (4, 0)]</span></span><br><span class="line"><span class="comment"># minHeap = [(3, 1), (4, 0)], (6, 2)]</span></span><br><span class="line"><span class="comment"># 第二个队列的第一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 3, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 0)], (6, 2)]</span></span><br><span class="line"><span class="comment"># 队列剩余元素入堆，调整为最小堆</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 0)], (6, 2), (4, 1)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 4, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 1), (6, 2)]</span></span><br><span class="line"><span class="comment"># 链表剩余元素入堆，调整为最小堆</span></span><br><span class="line"><span class="comment"># minHeap = [(4, 1), (6, 2), (5, 0)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 4, index = 1</span></span><br><span class="line"><span class="comment"># minHeap = [(5, 0), (6, 2)]</span></span><br><span class="line"><span class="comment"># 第2个链表已经空了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 5, index = 0</span></span><br><span class="line"><span class="comment"># minHeap = [(6, 2)]</span></span><br><span class="line"><span class="comment"># 第1个链表已经空了</span></span><br><span class="line"><span class="comment"># minHeap = [(6, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出栈，调整为最小堆</span></span><br><span class="line"><span class="comment"># val = 6, index = 2</span></span><br><span class="line"><span class="comment"># minHeap = [None, None, None]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 题目只用返回dum.next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地测试</span></span><br><span class="line"><span class="comment"># res = []</span></span><br><span class="line"><span class="comment"># node = dummy.next = 1</span></span><br><span class="line"><span class="comment"># res = [1]</span></span><br><span class="line"><span class="comment"># node = node.next = 1.next = 1</span></span><br><span class="line"><span class="comment"># res = [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># return </span></span><br></pre></td></tr></tbody></table></figure>

<p>贪心算法、优先队列<br>思路分析：<br>1、由于是 k 个排序链表，那么这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中最小的结点；</p>
<p>2、最小结点所在的链表的头结点就要更新了，更新成最小结点的下一个结点（如果有的话），此时还是这 k 个链表，这 k 个排序的链表头结点中 val 最小的结点就是合并以后的链表中第 2 小的结点。</p>
<p>每一次都从这 k 个排序的链表头结点中拿出 val 最小的结点“穿针引线”成新的链表，这个链表就是题目要求的“合并后的排序链表”。“局部最优，全局就最优”，这不就是贪心算法的思想吗。</p>
<p>维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。<br>用最小堆完成，堆的元素个数是链表的个数k个。<br>不断的从堆中获取节点，如果获取到的节点不为空，即还有下一个节点，那么就将下一个节点放到堆中。</p>
<p>这里我们举生活中的例子来理解这个思路。</p>
<blockquote>
<p>假设你是一名体育老师，有 3 个班的学生，他们已经按照身高从矮到高排好成了 3 列纵队，现在要把这 3 个班的学生也按照身高从矮到高排列 1 列纵队。我们可以这么做：<br>1、让 3 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身；<br>2、每一次队首的 3 名同学，请最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后面的所有同学都向前走一步（其实走不走都行，只要你能比较出站在你面前的 3 位在队首的同学同学的高矮即可）；<br>3、重复第 2 步，直到 3 个班的同学全部出列完毕。</p>
</blockquote>
<p>具体实现的时候，“每一次队首的 3 名同学，请最矮的同学出列”这件事情可以交给优先队列（最小堆、最小索引堆均可）去完成。在连续的两次出队之间完成“穿针引线”的工作。</p>
<p>时间复杂度：O(Nlogk)， N 是这 k 个链表的结点总数，考虑优先队列中的元素不超过 k 个<br>弹出操作时，比较操作的代价会被优化到O(logk)，同时找到最小值节点的时间为O(1)，<br>每一次从一个优先队列中选出一个最小结点的时间复杂度是 O(logk)，故时间复杂度为 O(Nlogk)。<br>空间复杂度：O(k)，考虑优先队列中的元素不超过 k 个，“穿针引线”需要常数个空间，因此空间复杂度为 O(k)。<br>O(n):创建一个新的链表空间开销为O(n)<br>O(1):以上代码采用了重复利用原有节点，所以只要O(1)的空间。<br>同时优先队列(通常用堆实现)需要O(k)的空间(远比大多数情况的N要小)</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="comment"># 针对一些特殊的测试用例，有的链表可能是空链表</span></span><br><span class="line">            <span class="keyword">if</span> lists[index]:</span><br><span class="line">                heapq.heappush(l, (lists[index].val, index))</span><br><span class="line"></span><br><span class="line">        dummy_node = ListNode(<span class="number">-1</span>)</span><br><span class="line">        cur = dummy_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            <span class="comment">#  _ 可以认为是一个变量的名字，因为这个变量后面不会再用到，所以使用 _ ，其实就是不想给这个变量起名字，但又得占一个位子的意思。</span></span><br><span class="line">            _, index = heapq.heappop(l)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 定位到此时应该出列的那个链表的头结点</span></span><br><span class="line">            head = lists[index]</span><br><span class="line">            <span class="comment"># 开始“穿针引线”</span></span><br><span class="line">            cur.next = head</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="comment"># 同样不要忘记判断到链表末尾结点的时候</span></span><br><span class="line">            <span class="keyword">if</span> head.next:</span><br><span class="line">                <span class="comment"># 刚刚出列的那个链表的下一个结点成为新的链表头结点加入优先队列</span></span><br><span class="line">                heapq.heappush(l, (head.next.val, index))</span><br><span class="line">                <span class="comment"># 切断刚刚出列的那个链表的头结点引用</span></span><br><span class="line">                lists[index] = head.next</span><br><span class="line">                head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">4</span>, ListNode(<span class="number">5</span>)))</span><br><span class="line">    link2 = ListNode(<span class="number">1</span>, ListNode(<span class="number">3</span>, ListNode(<span class="number">4</span>)))</span><br><span class="line">    link3 = ListNode(<span class="number">2</span>, ListNode(<span class="number">6</span>))</span><br><span class="line">    node = Solution().mergeKLists([link1, link2, link3])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)</span><br></pre></td></tr></tbody></table></figure>


<p>优先队列</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)  <span class="comment"># 声明伪头节点和构建链表的节点</span></span><br><span class="line">        queue = PriorityQueue()  <span class="comment"># 声明优先队列</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lists:  <span class="comment"># 将输入的节点放入优先队列</span></span><br><span class="line">            <span class="keyword">if</span> item:</span><br><span class="line">                queue.put((item.val, queue))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> queue:  <span class="comment"># 循环迭代队列，队列为空结束</span></span><br><span class="line">            val, node = queue.get()  <span class="comment"># 每次取出队首节点</span></span><br><span class="line">            point.next = ListNode(val)  <span class="comment"># 将这个节点值放入最终有序列表之中</span></span><br><span class="line">            point = point.next  <span class="comment"># 指针指向下一个节点</span></span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node:  <span class="comment"># 下一个节点不为空</span></span><br><span class="line">                queue.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></tbody></table></figure>

<p>分治</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        amount = len(lists)  <span class="comment"># 输入列表的个数</span></span><br><span class="line">        interval = <span class="number">1</span>  <span class="comment"># 初始间隔设置为1</span></span><br><span class="line">        <span class="keyword">while</span> interval &lt; amount:  <span class="comment"># 将队列两两合并</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, amount - interval, interval * <span class="number">2</span>):</span><br><span class="line">                lists[i] = self.merge2Lists(lists[i], lists[i + interval])</span><br><span class="line">            interval *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>] <span class="keyword">if</span> amount &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)  <span class="comment"># 声明头节点和构建链表节点</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:  <span class="comment"># 将两个链表头节点进行比较</span></span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                point.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                point.next = l2</span><br><span class="line">                l2 = l1</span><br><span class="line">                l1 = point.next.next</span><br><span class="line">            point = point.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            point.next = l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            point.next = l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""分治合并"""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span>(<span class="params">list1, list2</span>):</span></span><br><span class="line">            <span class="string">"""list1和list2分别是两个链表的头结点"""</span></span><br><span class="line">            head = ListNode(<span class="number">0</span>)  <span class="comment"># 新建一个头节点用来返回list1和list2的排序后结果</span></span><br><span class="line">            dummy = head  <span class="comment"># 指向head链表的尾部，用来拆入新节点</span></span><br><span class="line">            <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:  <span class="comment"># 两个链表都不为空时</span></span><br><span class="line">                <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                    dummy.next = list1  <span class="comment"># 插入新节点</span></span><br><span class="line">                    dummy = list1  <span class="comment"># dummy指向新插入的节点</span></span><br><span class="line">                    list1 = list1.next  <span class="comment"># 移动list1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dummy.next = list2</span><br><span class="line">                dummy = list2</span><br><span class="line">                list2 = list2.next</span><br><span class="line">            dummy.next = list2 <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">else</span> list1  <span class="comment"># 如果list1为None，说明list1中的元素全部进入了head链表，所以把list2中剩余的元素直接添加进来，反之亦然。</span></span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="comment"># print(merge2Lists(lists[1], lists[2]))</span></span><br><span class="line"></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">divideMergeKLists</span>(<span class="params">lists</span>):</span></span><br><span class="line">            <span class="string">"""分治归并k个链表"""</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            k = len(lists)</span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span>  <span class="comment"># lists为空，直接结束</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span> :  <span class="comment"># 归并结束</span></span><br><span class="line">                res = lists[<span class="number">0</span>]  <span class="comment"># 保存结果</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> == k:  <span class="comment"># k为奇数，i的最后一个取值是k-1，此时i+1已经超出范围</span></span><br><span class="line">                    temp.append(lists[i])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 如果k为偶数，i的最后一个取值永远是k-2</span></span><br><span class="line">                temp.append(merge2Lists(lists[i], lists[i+<span class="number">1</span>]))</span><br><span class="line">            divideMergeKLists(temp)</span><br><span class="line"></span><br><span class="line">        divideMergeKLists(lists)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>

<h2 id="23-合并K个链表-没有利用各个链表是升序的特点"><a href="#23-合并K个链表-没有利用各个链表是升序的特点" class="headerlink" title="23. 合并K个链表 没有利用各个链表是升序的特点"></a>23. 合并K个链表 没有利用各个链表是升序的特点</h2><p>思路：</p>
<ol>
<li>读取所有链表值</li>
<li>构造一个最小堆 heapq 很容易实现</li>
<li>根据最小堆构造一个链表</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        h = []  <span class="comment"># 定义最小堆</span></span><br><span class="line">        <span class="comment"># 读取所有节点值</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                h.append(node.val)</span><br><span class="line">                node = node.next  <span class="comment"># 后移节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造一个最小堆</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h:  <span class="comment"># h为空，直接返回None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        heapq.heapify(h)  <span class="comment"># 转换成最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造链表</span></span><br><span class="line">        root = ListNode(heapq.heappop(h))  <span class="comment"># 弹出最小的值作为根节点</span></span><br><span class="line">        curnode = root  <span class="comment"># 当前节点</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            nextnode = ListNode(heapq.heappop(h))  <span class="comment"># 构造下一个节点</span></span><br><span class="line">            curnode.next = nextnode  <span class="comment"># 当前next指向下一个节点</span></span><br><span class="line">            curnode = nextnode  <span class="comment"># 当前节点后移</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="comment"># 首先 for 嵌套 while 就是将所有元素都取出放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                heapq.heappush(heap, node.val)</span><br><span class="line">                node = node.next</span><br><span class="line">        dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment"># 依次将小顶堆中的元素取出，每次出来的都是目前堆中值最小的元素，然后重新构建一个列表返回</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            temp_node = ListNode(heappop(heap))</span><br><span class="line">            cur.next = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>删除列表中的重复元素</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list1:</span><br><span class="line">    list1.sort()</span><br><span class="line">last = list1[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> last == list1[i]:</span><br><span class="line">        <span class="keyword">del</span> list1[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last = list1[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>可以使用内置的set方法<br>list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>list2 = list(set(list1))<br>print list2</p>
<p>速度更快的一种方法<br>list1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>list2 = {}.fromkeys(list1).keys()<br>print list2<br>1<br>2<br>3<br>但是通过这两种方法获得的list2排序变了，如果想维持原来list的排序可以通过以下方法：</p>
<p>用list类的sort方法<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = list(set(l1))<br>l2.sort(key=l1.index)<br>print l2</p>
<p>也可以这样写<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = sorted(set(l1),key=l1.index)<br>print l2</p>
<p>也可以用遍历（看起来比较蠢）<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = []<br>for i in l1:<br>    if not i in l2:<br>        l2.append(i)<br>print l2</p>
<p>上面的代码也可以这样写<br>l1 = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>l2 = []<br>[l2.append(i) for i in l1 if not i in l2]<br>print l2</p>
<hr>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><p><strong>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</strong></p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的肯定连续，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>迭代<br>单指针 解题思路<br>用cur表示当前节点<br>初始化 cur 指针指向头部 head</p>
<p>while循环遍历链表<br>结束条件为：遍历完链表，即 cur.next 为空；头结点 head 可能为空，则也需要判断 cur 是否为空，如果所给链表为空直接返回，否则在执行cur.next这部操作时会因为cur为NULL而造成执行时错误<br>当二者有一个不存在时说明链表没有去重复的必要了</p>
<p>遍历过程中：<br>(1)如果该节点出元素与下一节点元素相同时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果<br>(2)如果不相等则 cur 移动到下一个位置继续循环</p>
<p>细节分析<br>需要判断 head 是否为空:<br>(1) 可在开头判断 head 是否为空<br>(2) 也可在 while 循环中判断 cur 是否为空</p>
<p>为什么如果前后两节点元素相同，删除后节点，而不用 cur = cur.next 操作？<br>答：是因为删除该节点的下一节点，该节点仍需要和新的下一节点进行比较</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，其中 n 是列表中的结点数。</p>
<p>空间复杂度：O(1)，没有使用额外的空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, next=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.next.val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    link1 = ListNode(<span class="number">1</span>, ListNode(<span class="number">1</span>, ListNode(<span class="number">5</span>, ListNode(<span class="number">5</span>))))</span><br><span class="line">    node = Solution().deleteDuplicates(link1)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    print(res)  <span class="comment"># [1, 5]</span></span><br><span class="line"><span class="comment"># cur.val = head.val = 1 = cur.next.val</span></span><br><span class="line"><span class="comment"># cur.next.val = cur.next.next.val = 5</span></span><br><span class="line"><span class="comment"># cur.val = cur.next.val = 5</span></span><br><span class="line"><span class="comment"># cur.next.val = cur.next.next.val = 5.next.next.val = None</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：双指针<br>定义两个指针，一个指向头节点，另外一个指向头节点的下一节点，不断遍历；</p>
<p>边遍历边比较这两个指针指向的节点的值，如果值相等的话，当前节点就指向其下下个节点（相当于删除了其下一节点），然后继续遍历，否则不做处理直接继续遍历，直到遍历完整个链表。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        cur, next = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> next:</span><br><span class="line">            <span class="keyword">if</span> next.val != cur.val: cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>: cur.next = next.next</span><br><span class="line">            next = next.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        slow = dummy</span><br><span class="line">        fast = dummy.next</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> slow.val == fast.val:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow.next = fast</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fast = fast.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line"><span class="comment"># slow = dummy = 0</span></span><br><span class="line"><span class="comment"># fast = head = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 1.next = 1</span></span><br><span class="line"><span class="comment"># slow = slow.next = 0.next = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 1.next = 5</span></span><br><span class="line"><span class="comment"># slow.next = fast = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 5.next = 5</span></span><br><span class="line"><span class="comment"># slow = slow.next = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fast = fast.next = 5.next = None</span></span><br><span class="line"><span class="comment"># slow.next = fast = None</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三：递归<br>解题思路<br>递归写法的删除节点操作是 通过返回下一节点 连接到上一节点，实现参数节点(即当前节点)的删除</p>
<p>把一个链表看成头节点后挂接一个更短的链表，依次类推。所以可以先处理头节点后面挂接的更短的链表，如果头节点的值等于其挂接的更短的链表的头节点的值，则直接返回更短的链表的头节点，否则返回原链表的头节点。</p>
<p>终止条件: 遍历完链表<br>(1) head 为空，即空链表<br>(2) head.next 为空 链表只有头节点。</p>
<p>终止处理: 返回当前节点</p>
<p>提取重复逻辑:<br>(1) 节点的”连接”: 利用函数返回值作为下一节点<br>(2) 节点的”删除”: 判断是否当前节点元素与下一节点元素是否相同, 返回相应的节点</p>
<p>递归函数返回的不重复子链的头结点，<br>在回溯过程中，比较当前节点和子链头结点的val是否相同，若相同则保留当前节点（删除子链的头结点）。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line">        <span class="keyword">if</span> head.val == head.next.val:</span><br><span class="line">            head.next = head.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"><span class="comment"># 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6</span></span><br><span class="line"><span class="comment"># head = 1</span></span><br><span class="line"><span class="comment"># self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#     head = head.next = 1.next = 1</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(1)</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#         head = head.next = 1.next = 5</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#         因为 head.next = 5.next = 5，所以</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#             head = head.next = 5.next = 5</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#                 head = head.next = 5.next = 6</span></span><br><span class="line"><span class="comment">#                 self.deleteDuplicates(6)</span></span><br><span class="line"><span class="comment">#                 因为head.next = 5.next = None，所以</span></span><br><span class="line"><span class="comment">#                 return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             返回上一层，</span></span><br><span class="line"><span class="comment">#             head.next = return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             head.val = 5 != head.next.val = 6</span></span><br><span class="line"><span class="comment">#             return head = 5</span></span><br><span class="line"><span class="comment">#         返回上一层</span></span><br><span class="line"><span class="comment">#         head.val = 5 = head.next.val</span></span><br><span class="line"><span class="comment">#         head.next = head.next.next = 6</span></span><br><span class="line"><span class="comment">#         return head = 5</span></span><br><span class="line"><span class="comment">#     返回上一层</span></span><br><span class="line"><span class="comment">#     head.val = 1 != head.next.val = 5</span></span><br><span class="line"><span class="comment">#     return head = 1</span></span><br><span class="line"><span class="comment"># 返回上一层</span></span><br><span class="line"><span class="comment"># head.val = 1 = head.next.val</span></span><br><span class="line"><span class="comment"># head.next = head.next.next = 5</span></span><br><span class="line"><span class="comment"># return head = 1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 删除头节点后面挂接的链表中的重复元素</span></span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 头节点与后面挂接的链表中的节点值相同，则头节点也删除，否则不删除</span></span><br><span class="line">        <span class="keyword">return</span> head.next <span class="keyword">if</span> head.val == head.next.val <span class="keyword">else</span> head</span><br><span class="line"><span class="comment"># 链表 1 -&gt; 1 -&gt; 5 -&gt; 5 -&gt; 6</span></span><br><span class="line"><span class="comment"># head = 1</span></span><br><span class="line"><span class="comment"># self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#     head = head.next = 1.next = 1</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(1)</span></span><br><span class="line"><span class="comment">#     self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#         head = head.next = 1.next = 5</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#         因为 head.next = 5.next = 5，所以</span></span><br><span class="line"><span class="comment">#         self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#             head = head.next = 5.next = 5</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(5)</span></span><br><span class="line"><span class="comment">#             self.deleteDuplicates(head.next)</span></span><br><span class="line"><span class="comment">#                 head = head.next = 5.next = 6</span></span><br><span class="line"><span class="comment">#                 self.deleteDuplicates(6)</span></span><br><span class="line"><span class="comment">#                 因为head.next = 5.next = None，所以</span></span><br><span class="line"><span class="comment">#                 return head = 6 return表示本层函数结束。</span></span><br><span class="line"><span class="comment">#             返回上一层</span></span><br><span class="line"><span class="comment">#             head.next = return head = 6</span></span><br><span class="line"><span class="comment">#             head.val = 5 != head.next.val = 6</span></span><br><span class="line"><span class="comment">#             return head = 5</span></span><br><span class="line"><span class="comment">#         返回上一层</span></span><br><span class="line"><span class="comment">#         head.val = 5 = head.next.val</span></span><br><span class="line"><span class="comment">#         return head.next = 5</span></span><br><span class="line"><span class="comment">#     返回上一层</span></span><br><span class="line"><span class="comment">#     head.val = 1 != head.next.val = 5</span></span><br><span class="line"><span class="comment">#     return head = 1</span></span><br><span class="line"><span class="comment"># 返回上一层</span></span><br><span class="line"><span class="comment"># head.val = 1 = head.next.val</span></span><br><span class="line"><span class="comment"># return head.next = 1</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == head.next.val:</span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(head.next)</span><br><span class="line">        head.next = self.deleteDuplicates(head.next)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>


<hr>
<h2 id="17-圆圈中最后剩下的数-本题考点-模拟"><a href="#17-圆圈中最后剩下的数-本题考点-模拟" class="headerlink" title="17.圆圈中最后剩下的数 [^本题考点 模拟]"></a>17.圆圈中最后剩下的数 [^本题考点 <em>模拟</em>]</h2><p><strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%B8%B8%E6%88%8F.png"><br>思路分析：</p>
<p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p>
<p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p>
<p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p>
<p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p>
<p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p>
<p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p>
<p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p>
<p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p>
<p>f(n-1) = iii</p>
<p>所以 f(n) = f `(n-1) = (iii+m)%n</p>
<p>所以 f(n) = (f(n-1)+m)</p>
<p>那么这个通项表达式我们就找到了，再去编写代码。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="comment">#返回编号</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="18-链表中环的入口点-本题知识点-链表"><a href="#18-链表中环的入口点-本题知识点-链表" class="headerlink" title="18.链表中环的入口点 [^本题知识点  链表]"></a>18.链表中环的入口点 [^本题知识点  链表]</h2><p><strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span></span><br><span class="line">        <span class="comment">#循环跳</span></span><br><span class="line">        <span class="comment">#要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        <span class="comment">#定义两个指针，一个快的一个慢的。</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        slowPointer = pHead</span><br><span class="line">        <span class="comment">#当快指针存在时，而且快指针的结点指向的下一个也存在</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer <span class="keyword">and</span> fastPointer.next :</span><br><span class="line">            <span class="comment">#那么让快指针走两步</span></span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            <span class="comment">#让慢指针走一步</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">            <span class="comment">#如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span></span><br><span class="line">            <span class="keyword">if</span> fastPointer == slowPointer:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span></span><br><span class="line">        <span class="keyword">if</span> fastPointer == <span class="literal">None</span> <span class="keyword">or</span> fastPointer.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span></span><br><span class="line">        <span class="comment">#假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 那么  L = s + d</span></span><br><span class="line">        <span class="comment">#假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span></span><br><span class="line">        <span class="comment"># fast 走的长度 就是 ( m + d ) * n + d + s = 2 L</span></span><br><span class="line">        <span class="comment">#带入 ( m + d ) * n + d + s = 2 （s + d ）</span></span><br><span class="line">        <span class="comment"># s = m + (n-1)(m+d)</span></span><br><span class="line">        <span class="comment">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        <span class="comment">#此时慢指针还在环里走着，没有走到结点</span></span><br><span class="line">        <span class="keyword">while</span> fastPointer != slowPointer:</span><br><span class="line">            fastPointer = fastPointer.next</span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        <span class="comment">#当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span></span><br><span class="line">        <span class="keyword">return</span> fastPointer</span><br></pre></td></tr></tbody></table></figure>



<p>定义：</p>
<p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p>
<p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p>
<p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p>
<p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p>
<p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p>
<p>那么 L = s + d</p>
<p>2L = 2(s+d) = n*(m + d) + d + s</p>
<p>由上面公式 推导出 n(m+d) = s + d</p>
<p>得到：s = n(m+d) -d；</p>
<p>s = nm + (n-1)(d)<br>s = m + (n-1)(m+d)</p>
<hr>
<h2 id="19-二进制中的1的个数"><a href="#19-二进制中的1的个数" class="headerlink" title="19.二进制中的1的个数"></a>19.二进制中的1的个数</h2><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</strong></p>
<p>输入是整数~ 但是都是二进制存储的，当我们用位运算操作时，就应该展开成二进制来分<br>输出该二进制串的 1 的个数</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a><code>知识点:</code></h4><p>方法一：逐位判断</p>
<ul>
<li>根据 与运算 定义，设二进制数字 n ，则有：<ul>
<li>若 n&amp;1=0 ，则 n 二进制 最右一位 为 0 ；</li>
<li>若 n&amp;1=1 ，则 n 二进制 最右一位 为 1 。</li>
</ul>
</li>
<li>根据以上特点，考虑以下 循环判断 ：<ol>
<li>判断 n 最右一位是否为 1 ，根据结果计数。</li>
<li>将 n 右移一位（本题要求把数字 n 看作无符号数unsigned value，因此使用 无符号右移 操作，输入是正数负数都可以）。</li>
</ol>
</li>
</ul>
<p>算法流程：<br>1.初始化数量统计变量 res = 0 。<br>2.循环逐位判断： 当 n = 0 时跳出。<br>  1.res += n &amp; 1 ： 若 n&amp;1=1 ，则统计数 res 加一。<br>  2.n &gt;&gt;= 1 ： 将二进制数字 n 无符号右移一位。<br>  对于负数，最高位为 1 ，有符号右移 最高位填1，因此无法达到 n = 0，就无法跳出循环了<br>返回统计数量 res 。</p>
<p>时间复杂度 O(log_2 n)此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；<br>取决于循环次数，而循环次数取决于数字 n 的“位数”，数字 n 的位数是 log n<br>逐位判断需循环 log_2 n 次，<br>log n 代表数字 n 最高位的 1 的所在位数，<br>因为二进制最高位 $1$ 决定了循环位移次数~<br>（例如 log_2 4 = 2, log_2 16 = 4）。</p>
<p>空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。</p>
<p>无符号的整数</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<p>python的int无限宽度，是不会溢出的，达到界限后会自己转为long<br>算法中需要用到了32位int的溢出来参与运算，<br>有的结果却需要溢出的int作为参数继续参与运算<br>在python上想实现溢出效果，找到一个函数<br>这个函数可以得到32位int溢出结果</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="number">123456789</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 129453825982464</span></span><br><span class="line">print(bin(ret))</span><br><span class="line"><span class="comment"># 0b11101011011110011010001010100000000000000000000</span></span><br><span class="line"><span class="comment"># 明显已经超出32位了</span></span><br></pre></td></tr></tbody></table></figure>

<p>在JS上<br>document.writeln(123456789 &lt;&lt; 20);<br>得到结果是-783286272<br>这就是溢出后截取的</p>
<p>无符号右移&gt;&gt;&gt;，就是将有符号int a和b转为无符号uint后，再进行普通右移&gt;&gt;运算<br>比如-1的有符号int就是-1，无符号int就是4294967295<br>在JS中，可以使用 a&gt;&gt;&gt;b来实现无符号位移，<br>python中没有这个运算符，只能自己实现了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_overflow</span>(<span class="params">val</span>):</span></span><br><span class="line">    maxint = <span class="number">2147483647</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> -maxint - <span class="number">1</span> &lt;= val &lt;= maxint:</span><br><span class="line">        val = (val + (maxint + <span class="number">1</span>)) % (<span class="number">2</span> * (maxint + <span class="number">1</span>)) - maxint - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = int_overflow(<span class="number">123456789</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">print(ret)  <span class="comment"># -783286272 和JS的结果一样</span></span><br><span class="line">print(bin(ret))</span><br><span class="line"><span class="comment"># -0b101110101100000000000000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsigned_right_shitf</span>(<span class="params">n, i</span>):</span></span><br><span class="line">    <span class="string">"""无符号右移"""</span></span><br><span class="line">    <span class="comment"># 数字小于0，则转为32位无符号uint</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        n = ctypes.c_uint32(n).value</span><br><span class="line">    <span class="comment"># 正常位移位数是为正数，但是为了兼容js之类的，</span></span><br><span class="line">    <span class="comment"># 负数就右移变成左移好了</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -int_overflow(n &lt;&lt; abs(i))</span><br><span class="line">    <span class="comment"># print(n)</span></span><br><span class="line">    <span class="keyword">return</span> int_overflow(n &gt;&gt; i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = unsigned_right_shitf(<span class="number">-1</span>, <span class="number">20</span>)</span><br><span class="line">print(ret)  <span class="comment"># 4095</span></span><br><span class="line"><span class="comment"># 和JS上执行 -1 &gt;&gt;&gt; 20 一样。</span></span><br></pre></td></tr></tbody></table></figure>


<p>如果 python 输入有符号整数时的情况，由于 python 存储负数的特殊性，<br>循环右移操作不能正常终止，因此需要先获取n 的补码，再开始右移~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二：巧用 n&amp;(n − <span class="number">1</span>)</span><br><span class="line">- (n - <span class="number">1</span>) 解析： 二进制数字 n 最右边的 <span class="number">1</span> 变成 <span class="number">0</span> ，此 <span class="number">1</span> 右边的 <span class="number">0</span> 都变成 <span class="number">1</span> 。</span><br><span class="line">- n&amp;(n − <span class="number">1</span>) 解析： 二进制数字 n 最右边的 <span class="number">1</span> 变成 <span class="number">0</span> ，其余不变。</span><br><span class="line"></span><br><span class="line">算法流程：  </span><br><span class="line"><span class="number">1.</span>初始化数量统计变量 res 。  </span><br><span class="line"><span class="number">2.</span>循环消去最右边的   </span><br><span class="line">  <span class="number">1.</span> 当 n = <span class="number">0</span> 时说明没有一个<span class="number">1</span>了,跳出。</span><br><span class="line">  <span class="number">1.</span> res += <span class="number">1</span> ： 统计变量加 <span class="number">1</span> ；</span><br><span class="line">  <span class="number">2.</span> n &amp;= n - <span class="number">1</span> ： 消去数字 n 最右边的 <span class="number">1</span>  </span><br><span class="line">  我们消除了多少<span class="number">1</span>变成一个<span class="number">1</span>都没有了， 就说明n有多少个<span class="number">1</span>了</span><br><span class="line">  n&amp;(n<span class="number">-1</span>) 还可以用来判断 n 是否是 <span class="number">2</span> 的幂~</span><br><span class="line">   </span><br><span class="line"><span class="number">3.</span>返回统计数量 res 。</span><br><span class="line">时间复杂度 O(M) ： n&amp;(n−<span class="number">1</span>) 操作仅有减法和与运算，占用 O(<span class="number">1</span>) ；</span><br><span class="line">设 M 为二进制数字 n 中 <span class="number">1</span> 的个数，则需循环 M 次（每轮消去一个 <span class="number">1</span> ），占用 O(M) 。</span><br><span class="line">空间复杂度 O(<span class="number">1</span>) ： 变量 res 使用常数大小额外空间。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<hr>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>给你两个&nbsp;非空 的链表，表示两个非负的整数。它们每位数字都是按照&nbsp;逆序&nbsp;的方式存储的，并且每个节点只能存储&nbsp;一位&nbsp;数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0&nbsp;开头。<br>示例 1：<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br>示例 2：</p>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]<br>示例 3：</p>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">system_change</span>(<span class="params">self, l3</span>):</span></span><br><span class="line">        pp = l3</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> l3.val &gt;= <span class="number">10</span>:</span><br><span class="line">                l3.val = l3.val - <span class="number">10</span></span><br><span class="line">                tm, l3 = l3, l3.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> l3:</span><br><span class="line">                    tm.next = ListNode(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l3.val += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l3 = l3.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l3:</span><br><span class="line">                <span class="keyword">return</span> pp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        p3 = p3h = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">                <span class="keyword">if</span> p3:</span><br><span class="line">                    p3.next = ListNode(p1.val + p2.val)</span><br><span class="line">                    p3 = p3.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p3h = p3 = ListNode(p1.val + p2.val)</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">and</span> <span class="keyword">not</span> p2:</span><br><span class="line">                p2 = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> p2 <span class="keyword">and</span> <span class="keyword">not</span> p1:</span><br><span class="line">                p1 = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (p1 <span class="keyword">and</span> p2):</span><br><span class="line">                <span class="keyword">return</span> self.system_change(p3h)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="20-不用加减乘除做加法-本题考点-按位运算"><a href="#20-不用加减乘除做加法-本题考点-按位运算" class="headerlink" title="20.不用加减乘除做加法[^本题考点 按位运算]"></a>20.不用加减乘除做加法[^本题考点 <em>按位运算</em>]</h2><p>*<em>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、</em>、/四则运算符号。**</p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E6%B3%95%E7%AE%97%E5%92%8C%E8%BF%90%E7%AE%97.png"><br>a, b 均可能是负数或 0<br>结果不会溢出 32 位整数 Overflow<br>题目给定的输入值的位数不会超过32，</p>
<p>题目说不能使用运算符 + 和 -，那么我们就要使用其他方式来替代这两个运算符的功能。</p>
<p>以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；<br>101 + 10001 = 10110<br>第一步：各位相加 但不进位： 不进位的话 结果为 10100 </p>
<p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p>
<p>第三步： 把前面两个结果相加，得到的结果是 10110.</p>
<p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p>
<p>位运算中的两数加法，不考虑 进位<br>其实来来回回就只有下面这四种：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       无进位和        进位 </span><br><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span>             <span class="number">0</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span>             <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span>             <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span>             <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>无进位和 符合 相同位为 0，不同位为 1 的异或运算规律，无进位加法。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span> = <span class="number">0101</span></span><br><span class="line">b = <span class="number">4</span> = <span class="number">0100</span></span><br><span class="line"></span><br><span class="line">a ^ b 如下：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">-------</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>a ^ b 得到了一个无进位加法结果，如果要得到 a + b 的最终值，<br>我们还要找到进位的数，把这二者相加。<br>在位运算中，我们可以使用与 &amp; 运算：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span> = <span class="number">0101</span></span><br><span class="line">b = <span class="number">4</span> = <span class="number">0100</span></span><br><span class="line"></span><br><span class="line">a &amp; b 如下：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">-------</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>由计算结果可见，0100 并不是我们想要的进位，<br>1 + 1 所获得的进位应该要放置在它的更高位，即左侧位上，<br>因此我们还要把 0100 左移一位，a&amp;b&lt;&lt;1，得到它 向前进位的值</p>
<p>总结一下：<br>1.a + b 和 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)<br>2.无进位加法使用异或运算计算得出 a^b<br>3.进位结果使用与运算和左移一位移位运算计算得出 。a&amp;b&lt;&lt;1<br>4.将上述两结果“相加”即可得到最终结果，但是，我们没有加号，<br>循环此过程，重复把前面两个步骤的结果再相加，但是这次的 数值 改为上次的两个结果，<br>判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。<br>直到进位为 0，此时 和 = 无进位结果 ，返回 无进位结果</p>
<p>时间复杂度 O(1) ： 最差情况下，例如 a = 0x7fffffff , b = 1 时，<br>每次循环b左移一位，b 从右数 必增加一个 0 ,<br>循环31次后，b=0x80000000，也就是最高位还是1，<br>还得再循环一次，所以一共32次将 b 变为 0 。<br>每轮中的常数次位操作</p>
<p>空间复杂度 O(1) ： 使用常数大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, a: int, b: int</span>) -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 由于 b = (a &amp; b) &lt;&lt; 1 &amp; x 中有左移操作，</span></span><br><span class="line">            <span class="comment"># 因此需要每轮和 x 与一下，</span></span><br><span class="line">            <span class="comment"># 以保证 b 是 32 位数（高位全部为 0 ）</span></span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="comment"># a &lt;= 0x7fffffff(最大的正数的补码)， a 是正数，</span></span><br><span class="line">        <span class="comment"># 正常的补码直接返回自己本身</span></span><br><span class="line">        <span class="comment"># 是负数 32 位以上的位取反，1 至 32 位不变</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></tbody></table></figure>
<p>Q :  若数字 a 和 b 中有负数，则变成了减法，如何处理？<br>A ： 在计算机系统中，数值一律用 补码 来表示和存储、运算<br>补码的优势： 加法、减法可以统一处理（CPU只有加法器）。</p>
<p>c java等是有位数限制的，所以可以直接做。<br>C语言版本输出a时，是采用补码格式输出的，<br>问题是在于C语言版本中int是32位的，进入下最后一个循环后，<br>b左移一位后，最高位的1就溢出了，那么b就变成了0.</p>
<p>其实和python输出的前32项是一模一样的，<br>在32位的系统中int类型的表示范围为[-231,231-1],<br>在python 是某种程度上位数可以无限扩展，<br>也就无所谓补码，因为补码都是相对于位数来说的，32 位补码和 16 位补码，<br>肯定是不一样的。但是这样就导致了一个问题，就是无法直接得到32位二进制补码。<br>如果补码超过了2**31-1这个边界,那么他代表的原码就是一个负数,<br>我们需要将它转换成对应的源码<br>0x80000000 的二进制是 0b10000000000000000000000000000000，为2^31次方<br>0x8000000是32位有符号整型的最小值,<br>直接输入大于0x80000000的数时，计算机将其处理为原码而非补码。</p>
<p>结果左移的1跑到33位，b仍然不是0，实际上永远也不是0，<br>于是就无限循环了，不会导致溢出.</p>
<hr>
<h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</strong><br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a><br>示例 1:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">长度为<span class="number">9</span>的数组。由于数字<span class="number">2</span>在数组中出现了<span class="number">5</span>次，超过数组长度的一半，因此输出<span class="number">2</span>。。</span><br></pre></td></tr></tbody></table></figure>

<p>众数（Mode）是指在统计分布上具有明显集中趋势点的数值，代表数据的一般水平。<br>也是一组数据中出现次数最多的数值，有时众数在一组数中有好几个。</p>
<p>本题超过长度一般</p>
<p>法一：<br>摩尔投票法Boyer-Moore：</p>
<ul>
<li><p>票数和： 由于众数出现的次数超过数组长度的一半；<br>若记候选 众数 的票数为 +1 ，非众数 的票数为 -1 ，<br>则一定有所有数字的 票数和 &gt; 0 。</p>
</li>
<li><p>票数正负抵消： 设数组 nums 中的众数为 candidate ，数组长度为 n 。<br>若 nums 的前 a 个数字的 票数和 = 0 ，<br>则 数组后 (n-a) 个数字的 票数和一定仍 &gt;0<br>（即后 (n−a) 个数字的 众数仍为 candidate ）</p>
</li>
</ul>
<p>算法原理：</p>
<ul>
<li><p>为构建正负抵消，假设数组首个元素 n_1 为众数，<br>遍历统计票数，当发生正负抵消时，<br>剩余数组的众数一定不变 ，这是因为（设真正的众数为 candidate ）：</p>
<ul>
<li>当 n_1 = candidate： 抵消的所有数字中，有一半是众数 candidate 。</li>
<li>当 n_1 !=candidate ： 抵消的所有数字中，少于或等于一半是众数 candidate 。</li>
</ul>
</li>
<li><p>利用此特性，每轮假设都可以 缩小剩余数组区间 。<br>当遍历完成时，最后一轮假设的数字即为众数<br>（由于众数超过一半，最后一轮的票数和必为正数）。</p>
</li>
</ul>
<p>算法流程:  </p>
<ol>
<li>初始化： 票数统计 votes = 0 ， 众数 candidate可以为任意值；  </li>
<li>循环抵消： 遍历数组 nums 中的每个元素 num ；</li>
<li>当 票数 votes 等于 0 ，则假设 当前数字 num 的值赋予为 众数 candidate ；</li>
<li>当 num = candidate 时，票数 votes 自增 1 ；<br>否则，num != candidate 时，票数 votes 自减 1 。<br>遍历完成后，candidate 即为整个数组的众数。</li>
<li>返回值： 返回 众数 candidate </li>
</ol>
<p>若没有选中众数，那么迭代的时候这个数就会因为它出现次数小于一半，而重新选择其他数。如果选中了众数，那么count可能大于零小于0，最终是大于0.<br>如果是其他数，又会count到0.</p>
<p>时间复杂度 O(N) ： N 为数组 nums 长度，对数组进行了一次遍历。<br>空间复杂度 O(1) ： votes 变量使用常数级别大小的额外空间。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        votes = <span class="number">0</span></span><br><span class="line">        candidate = <span class="literal">None</span>  <span class="comment"># 可省略</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            <span class="keyword">if</span> num == candidate:</span><br><span class="line">                votes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                votes += <span class="number">-1</span></span><br><span class="line">            <span class="comment"># votes += (1 if num == candidate else -1)</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.majorityElement(arr))  <span class="comment"># 2</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = None</span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">1</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> != candidate = <span class="number">1</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">3</span> </span><br><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">3</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> </span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> != candidate = <span class="number">3</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> = candidate</span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">5</span> != candidate = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">4</span> != candidate = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span> = candidate </span><br><span class="line"><span class="attr">candidate</span> = num = <span class="number">2</span></span><br><span class="line"><span class="attr">votes</span> = vote + <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。<br>首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p>
<p>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="comment">#dict [key] = count</span></span><br><span class="line">        <span class="comment">#o(n) 空间复杂度为O(n)</span></span><br><span class="line">     <span class="comment">#第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。</span></span><br><span class="line">        numsCount = {}</span><br><span class="line">        numLen = len(numbers)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> numsCount:</span><br><span class="line">                numsCount[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numsCount[num] = <span class="number">1</span></span><br><span class="line">             <span class="comment">#如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.</span></span><br><span class="line">            <span class="keyword">if</span> numsCount[num] &gt; (numLen &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#想要空间复杂度为O（1），时间复杂度为o(n)</span></span><br><span class="line"><span class="comment">#第二种：</span></span><br><span class="line">        <span class="comment">#定义变量 上次出现的数字为0</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="comment">#上次出现的数字的数量为0 </span></span><br><span class="line">        lastCount = <span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历数组中的数字</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="comment">#如果说这个数字出现的次数为0了。</span></span><br><span class="line">            <span class="keyword">if</span> lastCount == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#那么就把上次出现的数字，变为需要保存的那个数字。</span></span><br><span class="line">                last = num</span><br><span class="line">                <span class="comment">#并把次数设置为1 次，出现了这一次。</span></span><br><span class="line">                lastCount = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span></span><br><span class="line">                <span class="keyword">if</span> num == last:</span><br><span class="line">                    lastCount += <span class="number">1</span></span><br><span class="line">                <span class="comment">#如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lastCount -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span></span><br><span class="line">        <span class="keyword">if</span> lastCount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#否则的话，就说明 数组里面 留下了没有抵消掉的数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#这种情况是last可能是大于一半的数字</span></span><br><span class="line">            <span class="comment">#这个时候把 记录数字次数的变量 计数 为0 </span></span><br><span class="line">            lastCount = <span class="number">0</span></span><br><span class="line">            <span class="comment">#遍历数组中的数</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">                <span class="comment">#如果这个数与我们记录的数相等的话</span></span><br><span class="line">                <span class="keyword">if</span> num == last:</span><br><span class="line">                    <span class="comment">#让这个计数加1</span></span><br><span class="line">                    lastCount += <span class="number">1</span></span><br><span class="line">            <span class="comment">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span></span><br><span class="line">            <span class="keyword">if</span> lastCount &gt; (len(numbers)&gt;&gt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> last</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>


<p>哈希表统计法： 遍历数组 nums ，用 HashMap 统计每个元素出现的次数。<br>最终超过数组长度一半的数字则为众数。</p>
<p>算法<br>用哈希映射（HashMap）来存储每个元素以及出现的次数。<br>对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。<br>用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。<br>在这之后，遍历哈希映射中的所有键值对，返回值最大的键。<br>我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，<br>这样省去了最后对哈希映射的遍历。</p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 O(n)（可参考下文的空间复杂度分析），那么遍历的时间不会超过 O(n)。因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)。哈希表最多包含 n - [n/2] 个键值对，所以占用的空间为 O(n)。这是因为任意一个长度为 n 的数组最多只能包含 n 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） [n/2]+1 个数字。因此最多有 n - ([n/2]+1) 个不同的其他数字，所以最多有 n - [n/2] 个不同的元素。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        votes = collections.Counter(nums)</span><br><span class="line">        <span class="comment"># count.keys()返回是键 </span></span><br><span class="line">        <span class="comment"># 求的不是票数个数最大的元素key</span></span><br><span class="line">        <span class="comment"># max里面比较的就是值（个数）</span></span><br><span class="line">        <span class="comment"># 加了key=votes.get表示比较票数的大小，</span></span><br><span class="line">        <span class="keyword">return</span> max(votes.keys(), key=votes.get)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">votes = {<span class="number">2</span>: <span class="number">5</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>}</span><br><span class="line">print(votes.keys())  # dict_keys([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">print(max(votes))  # <span class="number">5</span></span><br><span class="line">print(max(votes.keys()))  # <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 数组为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        hashset = {}</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># hashset[num] = hashset[num] + 1 if hashset.get(num) else 1</span></span><br><span class="line">            <span class="keyword">if</span> hashset.get(num):</span><br><span class="line">                hashset[num] = hashset[num] + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashset[num] =  <span class="number">1</span> </span><br><span class="line">            <span class="comment"># if hashset[num] &gt; len(nums) / 2:   </span></span><br><span class="line">            <span class="comment"># Python3.6之后下面的字典迭代要比这里的列表迭代要快，</span></span><br><span class="line">            <span class="comment"># 所以验证众数使用下面的字典迭代</span></span><br><span class="line">            <span class="comment">#     return num</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> hashset.items():</span><br><span class="line">            <span class="keyword">if</span> value &gt; len(nums) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> key</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 不存在众数</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>数组排序法：</p>
<p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，<br>由于众数的数量超过数组长度一半，<br>因此 数组中点的元素 下标为 [n/2] 的元素（下标从 0 开始）一定是众数。</p>
<p>我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。<br>下面的图中解释了为什么这种策略是有效的。<br>在下图中，第一个例子是 n 为奇数的情况，<br>第二个例子是 n 为偶数的情况。</p>
<p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，<br>数组下面的线表示如果众数是数组中的最大值时覆盖的下标。<br>对于其他的情况，这条线会在这两种极端情况的中间。<br>对于这两种极端情况，它们会在下标为⌋ [n/2] 的地方有重叠。<br>因此，无论众数是多少，返回  [n/2]  下标对应的值都是正确的。</p>
<p>时间复杂度： O(NlogN)， Python内置排序算法Timsort的时间复杂度<br>空间复杂度：不需要用到额外的空间</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums) // <span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="22-数组中只出现一次的数字-数组"><a href="#22-数组中只出现一次的数字-数组" class="headerlink" title="22.数组中只出现一次的数字[^数组]"></a>22.数组中只出现一次的数字[^数组]</h2><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</strong></p>
<p>思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#如果两个数相同那么两个数的异或操作为0</span></span><br><span class="line">        <span class="comment">#数组的长度如果小于2，那么就就不会有数字出现了偶数次。</span></span><br><span class="line">        <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#变量赋值 两个数的异或为none</span></span><br><span class="line">        twoNumXor = <span class="literal">None</span></span><br><span class="line">        <span class="comment">#遍历 数组中的数字</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="comment">#判断 如果 两个数的数字异或的结果为0 的话，</span></span><br><span class="line">            <span class="keyword">if</span> twoNumXor == <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。</span></span><br><span class="line">                twoNumXor = num</span><br><span class="line">            <span class="comment">#如果数 这个数不为 空 的话</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。</span></span><br><span class="line">                twoNumXor = twoNumXor ^ num</span><br><span class="line">        <span class="comment">#变量  计数 为 0 </span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#当异或的 结果 为偶数时</span></span><br><span class="line">        <span class="keyword">while</span> twoNumXor % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">            <span class="comment">#那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。</span></span><br><span class="line">            twoNumXor  = twoNumXor &gt;&gt; <span class="number">1</span>  <span class="comment"># 右移以为 相当于 除以2</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1</span></span><br><span class="line">        </span><br><span class="line">        mask = <span class="number">1</span> &lt;&lt; count   <span class="comment">#向左 移 位 count 位。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。</span></span><br><span class="line">        </span><br><span class="line">        firstNum = <span class="literal">None</span></span><br><span class="line">        secondNum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> mask &amp; num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> firstNum == <span class="literal">None</span>:</span><br><span class="line">                    firstNum = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    firstNum = firstNum ^ num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> secondNum == <span class="literal">None</span>:</span><br><span class="line">                    secondNum = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    secondNum = secondNum ^ num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstNum,secondNum</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="23-整数中1出现的次数-本题考点-数组"><a href="#23-整数中1出现的次数-本题考点-数组" class="headerlink" title="23.整数中1出现的次数[^本题考点 数组]"></a>23.整数中1出现的次数[^本题考点 数组]</h2><p><strong>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了<br>把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p>
<p><img src="/2020/08/21/jian-zhi-offer1-24-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png"></p>
<hr>
<p>解题思路：<br>将 1 ~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>
<p>密码锁，就是那种几个滚轮的密码锁，<br>固定其中的一位密码，拨动其他位置的密码。<br>每次计算是按照位数来的，而不是看整体的数值，<br>是在计算当 cur 位出现的 1 的数量,<br>一位一位地统计，目标就是防止重复统计啦</p>
<p>比如当前计算的是十位上的1的个数，那么对于0011来说，<br>虽然出现了两次1，但是十位上1的只有1个。</p>
<p>1 位数含1最多为: 1 个  1<br>2 位数含1最多为: 20 个 1, 11, 12, 13 ..19, 21, 31, 41, 51, …, 91<br>我们要分开两部分讨论：<br>只看个位：这个位置能出现’1’的次数为(十位的最大值+1) * 1位数能出现’1’的最大次数，在这里有10次(1,11,21,…91)<br>只看十位：这个位置能出现’1’，即只有当十位为’1’的时候的次数，即10^位数（这里是2，即十位），在这里有10次(10,11,12,…,19)<br>将个位出现过的次数与十位出现过的次数相加，便是我们的答案 = 20。</p>
<p>3 位数含1最多为: 300 个 1, 11, 12, 13 ..19, 100~199, 201, 211, 12, 13 ..19<br>4 位数含1最多为: 4000 个</p>
<p>设数字 n 是个 x 位数，记 n 的第 i 位为 n_in，<br>则可将 n 写为 n_{x} n_{x-1} \cdots n_{2} n_{1}n<br>称 “ n_in “ 为 当前位 ，记为 cur ，<br>将 “ n_{i-1} n_{i-2} \cdots n_{2} n_{1}n “ 称为 低位 ，记为 low ；<br>将 “ n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}n “ 称为 高位 ，记为 high 。<br>将 10^i 称为 位因子 ，记为 digit 。<br>某位中 1 出现次数的计算方法：<br>根据当前位 cur 值的不同，分为以下三种情况：<br>1.当 cur = 0 时： 此位 1 的出现次数只由高位 high 决定，<br>计算公式为：high×digit</p>
<p>假如 104，计算十位出现1的个数(此时cur=0)，那么10，11，12···19都符合。<br>出现 1 的数字范围：010<del>019<br>只看高低位：00</del>09<br>易得 1 出现次数为：9-0+1=10 0~9 总共是十个数啊<br>1 x 10 =10</p>
<p>假如 2304，计算十位出现1的次数(此时cur=0)<br>首先可以把0010~2219范围内，十位是1的所有数字枚举出来。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0010</span>，<span class="number">0011.</span>.<span class="number">.0019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">0110</span>，<span class="number">0111.</span>.<span class="number">.0119</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line">...</span><br><span class="line"><span class="number">0910</span>，<span class="number">0911.</span>.<span class="number">.0919</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">1010</span>，<span class="number">1011.</span>.<span class="number">.1019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line">...</span><br><span class="line"><span class="number">1910</span>，<span class="number">1911.</span>.<span class="number">.1919</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2010</span>，<span class="number">2011.</span>.<span class="number">.2019</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2110</span>，<span class="number">2111.</span>.<span class="number">.2119</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br><span class="line"><span class="number">2210</span>，<span class="number">2211.</span>.<span class="number">.2219</span>（<span class="number">1</span>在十位出现<span class="number">10</span>次）</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到高位（前两位）的变化范围是00<del>22，有23种选择。<br>固定高位是某一种情况时，低位（个位）变化范围是0</del>9，有10种选择。<br>高位和低位组合，就有23*10=230种组合。<br>总结规律，你会发现，其实可以把0010<del>2219里的十位数字直接“抠”掉，<br>剩下的就是000</del>229，一共就是230个数字。</p>
<p>因为十位上面的1已经是固定的，所以其实000<del>229里的每个数，<br>和上面所枚举的230个数字是一一对应的。<br>比如000对应着0010，001对应着0011…所以000</del>229范围内数字的个数，<br>就是0010~2219范围内十位出现1的数字个数。<br>因为十位固定了 0， 能变得是 23 、 4 这三位数字。<br>因此当十位固定是 1 时，只能取 0 ~ 229 ，因此是 23 * 10 。</p>
<p>出现 1 的数字范围：0010<del>2219<br>只看高低位：000</del>229<br>易得 1 出现次数为：229-0+1=230<br>结论<br>high×digit = 23 x 10 =230</p>
<p>2.当 cur = 1 时： 此位 1 的出现次数只由高位 high 和 低位 low 决定，<br>计算公式为：high×digit+low+1</p>
<p>假如 2314，计算十位出现1的次数(此时cur=1)<br>出现 1 的数字范围：0010<del>2314<br>只看高低位：000</del>234<br>易得 1 出现次数为：234-0+1=235<br>high×digit+low+1 = 23 x 10 + 4 +1 = 235</p>
<p>3.当 cur &gt; 1, 即cur = 2,3,…,9 时： 此位 1 的出现次数只由高位 high 决定，<br>计算公式为：(high+1)×digit</p>
<p>假如 2324，计算十位出现1的次数(此时cur=2)<br>出现 1 的数字范围：0010<del>2319<br>只看高低位：000</del>239<br>易得 1 出现次数为：234-0+1=240<br>(high+1)×digit = (23 + 1) x 10 = 240</p>
<p>设计按照 “个位、十位、…” 的顺序计算，则 high / cur / low / digit 应初始化为：</p>
<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">high</span> = n // <span class="number">10</span>  <span class="comment"># 整数除法</span></span><br><span class="line"><span class="attr">cur</span> = n % <span class="number">10</span></span><br><span class="line"><span class="attr">low</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">digit</span> = <span class="number">1</span> <span class="comment"># 个位</span></span><br></pre></td></tr></tbody></table></figure>

<p>从个位到最高位的变量递推公式为：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 cur = 0, high != 0 时，此时还要计算cur</span></span><br><span class="line"><span class="comment"># 当 high = 0, cur != 0 时，cur处于最高位，此时还要计算cur</span></span><br><span class="line"><span class="comment"># 当 high = cur = 0 时，cur已经越过最高位，因此跳出循环</span></span><br><span class="line"><span class="string">while</span> <span class="string">high</span> <span class="type">!=</span> <span class="number">0</span> <span class="string">or</span> <span class="string">cur</span> <span class="type">!=</span> <span class="attr">0:</span> </span><br><span class="line">   <span class="string">low</span> <span class="string">+=</span> <span class="string">cur</span> <span class="string">*</span> <span class="string">digit</span> <span class="comment"># 将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">   <span class="string">cur</span> <span class="string">=</span> <span class="string">high</span> <span class="string">%</span> <span class="number">10</span> <span class="comment"># 下轮 cur 是本轮 high 的最低位</span></span><br><span class="line">   <span class="string">high</span> <span class="string">//=</span> <span class="number">10</span> <span class="comment"># 将本轮 high 最低位删除，得到下轮 high</span></span><br><span class="line">   <span class="string">digit</span> <span class="string">*=</span> <span class="number">10</span> <span class="comment"># 位因子每轮 × 10</span></span><br></pre></td></tr></tbody></table></figure>
<p>32104</p>
<ul>
<li><p>从个位开始, digit = 1<br>cur =4&gt;1, low =0, high =3210<br>res += (high+1)×digit = (3210 + 1) x 1 = 3211<br>高位从0~3209变化的过程中，每一个变化中1只出现1次，即（高位1）这样的数字；<br>高位是3210时，因为当前位是4，所以1只能出现一次，即32101。</p>
</li>
<li><p>十位, digit= 10<br>cur =0, low = 4, high =321<br>res += 3211 + high ×digit = 3211 + 321 x 10 = 6421<br>res =  (high - 1 +1）× digit = (321 -1 +1) x 10 = 3210<br>那么高位从0~ 320的过程中，有321种，每一个变化1出现10次，<br>这样的数字i位置要想为1，就必须向高位借1，因此此时低位部分是都可以取到0-9的；<br>高位为321的时候，因为当前位为0，所以不存在出现1的可能性。</p>
</li>
</ul>
<p>百位, digit = 100<br>cur =1, low = 04, high =32<br>res += 6421 + high×digit+low+1 = 6421 + 32 x 100 + 4 +1 = 9626<br>高位从0~ 31变化的过程中，32种可能，每一个变化中1出现100次，<br>即（高位10）<del>（高位19）这样的数字，低位部分是可取到0-9的<br>高位为32的时候，因为当前位是1，<br>所以我们要看低位来决定出现的次数，<br>低位部分的每个位置不能取到0-9，低位为4，所以此时出现5次，<br>即32100</del>32104这样的数字。</p>
<p>千位, digit = 1000<br>cur =2&gt;1, low = 104, high = 3<br>res += 9626 + (high+1)×digit = 9626 + (3+1) x 1000 = 13626<br>高位从0<del>2变化的过程中，每一个变化中1只出现1000次，即（高位1）这样的数字；<br>高位是3时，因为当前位是2，所以1能出现1000次，低位部分的每一个位置都可以取到0-9<br>即31000</del>31999。</p>
<p>万位, digit = 10000<br>cur =3&gt;1, low = 2104, high = 0<br>res += 9626 + (high+1)×digit = 13626 + (0+1) x 10000 = 23626<br>没有高位所以直接看当前位，因为当前位为3，<br>所以1出现的次数为10000，即10000~19999这样的数字。</p>
<p>因为本题的时间复杂度由 “循环次数” 决定，<br>而循环次数由数字的位数决定，<br>因为十进制数进位出现在 10 100 1000 ……，<br>假设 n = 10 ^ i ，那么 n 的位数就是 i ～<br>所以一个数字 n 的位数是 log_10 n</p>
<p>因此复杂度即为 log n ~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        digit, res = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        high, cur, low = n // <span class="number">10</span>, n % <span class="number">10</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> high != <span class="number">0</span> <span class="keyword">or</span> cur != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="number">0</span>: res += high * digit</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>: res += high * digit + low + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: res += (high + <span class="number">1</span>) * digit</span><br><span class="line">            low += cur * digit</span><br><span class="line">            cur = high % <span class="number">10</span></span><br><span class="line">            high //= <span class="number">10</span></span><br><span class="line">            digit *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p>
<p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p>
<p>**若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ **</p>
<p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p>
<p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p>
<p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p>
<p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p>
<p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p>
<p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p>
<p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4 </code>种情况。</p>
<p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p>
<p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p>
<p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p>
<p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p>
<p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p>
<p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        <span class="comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        <span class="comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="number">1</span></span><br><span class="line">        highValue = <span class="number">1</span></span><br><span class="line">        lowValue = <span class="number">1</span></span><br><span class="line">        midValue =<span class="number">1</span></span><br><span class="line">        <span class="comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="number">0</span></span><br><span class="line">        <span class="comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="keyword">while</span> highValue != <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="number">10</span>)</span><br><span class="line">            <span class="comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="number">10</span></span><br><span class="line">            <span class="comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="number">10</span></span><br><span class="line">            <span class="comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> midValue == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="keyword">elif</span> midValue &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="number">1</span>)*pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="number">10</span>,count)+(lowValue+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="keyword">return</span> sumNum</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="24-丑数"><a href="#24-丑数" class="headerlink" title="24.丑数"></a>24.丑数</h2><p><strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p>
<p>思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？</p>
<p>因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#死循环，找丑数</span></span><br><span class="line">        <span class="comment">#判断一个数是不是丑数，先循环除以2，直到不能整除，</span></span><br><span class="line">        <span class="comment">#循环除以3 直到不能整除，循环除以5 直到不能整除</span></span><br><span class="line">        <span class="comment">#这时如果剩余的值是1  我们就说它是丑数</span></span><br><span class="line">        <span class="comment">#其他情况就都不是丑数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isUglyNumber</span>(<span class="params">num</span>):</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> isUglyNumber(num):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == index:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            num += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>方法二:</p>
<p>x6 x 2&gt; x9 = x5 x 2<br>6 x 2 = 12 &gt; 10 &gt;= 5 x 2 </p>
<p>x4 x 3&gt; x9 = x3 x 3<br>4 x 3 = 12 &gt; 10 &gt;= 3 x 3</p>
<p>x3 x 5&gt; x9 = x2 x 5<br>3 x 5 = 12 &gt; 10 &gt;= 2 x 5<br>x10 = min(12, 12, 15) = 12</p>
<p>用空间换时间，先排后存<br>创建一个 列表，<br>里面的数字是排好序的 丑数，<br>每个丑数都是前面的丑数乘以2,3，或者5得到的。</p>
<p>给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，<br>第一个丑数为1，那么我们在这个列表的起始位置设置三个指针，<br>这三个指针代表的值  分别为a,b,c.<br>又由于这个列表中的所有的丑数从小到大排列的，<br>1是丑数, 那么1乘以2,3,5得到的乘积也肯定是丑数(根据丑数的定义可知),<br>也就是说每一个已知的丑数, 乘上2,3,5之后都会得到3个更大的丑数(可能有重复)<br>要与前面的丑数比较大小，要把三个指针所在位置的元素做个对比,<br>取最小的那个元素, 就是下一个丑数了.<br>接着三个指针必须往下移动, 直到指向的元素都大于已知丑数才可以停下来,<br>再继续比较，把丑数放入丑数数组中, 继续计算下一个丑数, 直到算出第n个丑数出来即可.</p>
<p>一开始，丑数只有{1}，1可以同2，3，5相乘，<br>那么 1 * 2 得到的是2,1*3 得到的是3，1 乘以5 得到的是5，<br>那么三个数中比较大小，最小的是 1 乘以2，<br>那么 取最小的1×2=2添加到丑数序列中，<br>现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，<br>所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。</p>
<p>现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，<br>但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，<br>只需要比较2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，<br>下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，<br>以此类推，那么现在的到的丑数的顺序就是1,2,3,4 …</p>
<p>依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，<br>选择最小的那个作为下一个丑数，<br>假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，<br>所以它失去了同i相乘的资格，把对应的i+=1，让pi指向下一个丑数即可。</p>
<p>动态规划解析：<br>状态定义： 设动态规划列表 dp ，dp[i] 代表第 i + 1 个丑数。<br>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。</p>
<p>pi的含义是有资格同 i（i=2，3，5）相乘的最小丑数的位置。<br>这里资格指的是：如果一个丑数dp[pi]通过乘以i可以得到下一个丑数，<br>那么这个丑数dp[pi]就永远失去了同i相乘的资格（没有必要再乘了），<br>我们把i+=1让dp[pi]指向下一个丑数即可。</p>
<p>实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，<br>若相等则将对应索引 a , b , c 加 1 。<br>dp[a]×2&gt;dp[i−1]≥dp[a−1]×2<br>dp[b]×3&gt;dp[i−1]≥dp[b−1]×3<br>dp[c]×5&gt;dp[i−1]≥dp[c−1]×5</p>
<ul>
<li>初始状态： dp[0] = 1 ，即第一个丑数为 1 ；</li>
<li>递推计算 dp[i]=min(dp[a]×2,dp[b]×3,dp[c]×5)​<br>若 dp[i]= dp[a]×2 = dp[b]×3，两个索引都需要加1</li>
<li>更新索引<br>dp[a]×2 = dp[i] 执行a += 1<br>dp[b]×3 = dp[i] 执行b += 1<br>dp[c]×5 = dp[i] 执行c += 1</li>
<li>返回值： dp[n-1] ，即返回第 n 个丑数。</li>
</ul>
<p>时间复杂度 O(N) ： 其中 N = n ，动态规划需遍历计算 dp 列表。<br>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。</p>
<p>主要还是通过 丑数可以拆分为几个小丑数 的性质 来得到的。<br>这样每次取到最接近的丑数，<br>对应的因子就 +1，就能保证取到所有的丑数（不会遗漏）</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 初始化三个指针的 索引位置是0，</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># print([1] * 2)  # [1, 1]</span></span><br><span class="line">        <span class="comment"># print([1] * 3)  # [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因此 dp[0] 要对应第 1 个丑数，</span></span><br><span class="line">        <span class="comment">#  dp[i] 为 i + 1 个丑数。</span></span><br><span class="line">        <span class="comment"># 要求第 n 个丑数，就是要求 dp[n-1] ，</span></span><br><span class="line">        <span class="comment"># 因此是 range(1, n) ，最后会遍历到 n - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 给列表中的 a, b, c 这三个指针所在位置的丑数 分别 乘以2,3,5</span></span><br><span class="line">            n2, n3, n5 = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">            dp[i] = min(n2, n3, n5)</span><br><span class="line">            <span class="comment"># 也可用dp=[1], dp.append(min(n2, n3, n5))</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新索引不能使用elif  因为存在2*某个丑数 ,3*某个丑数,5*某个丑数相同的情况，因此对应指针全部都要移动，保证数组中不会加入重复元素。</span></span><br><span class="line">            <span class="comment"># 这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最终返回丑数列表的最后一个值即为第 n 个丑数</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>n2、n3、n5几个变量的声明不用放在循环外，<br>执行到下一轮时，上一轮应该会释放的～ 这个高级语言会帮我们解决啦</p>
<hr>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，<br>请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>数组中两个值相同的元素并不是相同元素，数组不是集合</p>
<p>法一：<br>保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。<br>哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。<br>我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。<br>但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。<br>由于哈希查找的时间复杂度为 O(1)，<br>比index索引速度快；dict替换item in list提速</p>
<p>如果存在则找到了两个值，<br>如果不存在则将当前的 num当作key,i当作value 存入 map 中，<br>继续遍历直到找到为止</p>
<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        hashset = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># if hashset.get(target - nums[i]) is not None:</span></span><br><span class="line">            <span class="comment"># return hashset.get(target - nums[i]), i</span></span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> hashset[target - nums[i]], i</span><br><span class="line">            hashset[nums[i]] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    target = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    index = solution.twoSum(nums, target)</span><br><span class="line">    print(index)</span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的实现使用了两次迭代。在第一次迭代中，<br>我们将每个元素的值和它的索引添加到表中。<br>然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。<br>注意，该目标元素不能是 nums[i] 本身！<br>题干中并没有说 nums 是有序的，当碰到相同的元素时，<br>dct[n] = i 会将最近遍历的元素索引写入字典。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        hashmap = {}</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="comment"># 每个值都判断map中是否存在 target-nums[i] 的 key 值</span></span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># return [hashmap[target - num],i]</span></span><br><span class="line">                <span class="keyword">return</span> [i, hashmap[target - num]]</span><br><span class="line">            <span class="comment"># 如果不存在</span></span><br><span class="line">            <span class="comment"># 则将当前的num当作key,i当作value存入 hashmap 中,保证遍历的时候有值</span></span><br><span class="line">            hashmap[num] = i  <span class="comment">#  给字典创建键值对，不是查找，</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于每一个新的数，先找是否有存的数能满足条件的，<br>如果没有，或是重复数不满足求和条件，或者不重复数不满足求和条件。<br>重复数的覆盖是不怕的，因为题目说只有一个满足要求的答案，<br>所以这个重复数字如果没找到满足要求的结果，那就可以放弃这个数字了。</p>
<p>实现去重：每次执行if语句 i，num这一组值还没有加入到字典当中去，所以就可以避免了<br>这句不能放在if语句之前，解决hashmap中有重复值或target-num=num的情况</p>
<p>nums = [2, 7, 11, 15], target = 13<br>i=0, num=2, 13-2=11不在hashmap={},hashmap={2:0}<br>i=1, num=7, 13-7=6不在hashmap={2:0} hashmap={2:0, 7:1}<br>i=2, num=11, 13-11=2在hashmap={2:0, 7:1} 返回2的下标和11的下标</p>
<p> 1.每次写入时，判断条件 不是当前的key本身存不存在，<br> 而是key和 tag 之间的差值存不存在，这一点很重要。<br> 2.题目命题说明了一点，假定只有一个解。也就是说重复元素再多都无所谓。<br> case 1：如果有3个或者以上的重复元素，代表这个重复元素不可能是解，所以写入map的时候直接覆盖也无所谓；<br> case2：如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于tag。这种情况下，当遇到第二个重复元素时，不会写入map，这个时候直接已经取到解了。 所以这种方式，不用考虑hash冲突的问题。</p>
<p>法三：<br>用1个for循环<br>直接用target 减去 取出的数字，看结果有没有在数组里</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self,nums,target</span>):</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a = target - nums[x]</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> nums: <span class="comment"># 判断a有没有在nums数组里</span></span><br><span class="line">                y = nums.index(a) <span class="comment"># 有的话，那么用index获取到该数字的下标</span></span><br><span class="line">                <span class="keyword">if</span> x == y: </span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># 同样的数字不能重复用，所以这里如果是一样的数字，那么就不满足条件，跳过</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 否则就返回结果</span></span><br><span class="line">                    <span class="keyword">return</span> x,y </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">continue</span> <span class="comment"># 上面的条件都不满足就跳过，进行下一次循环</span></span><br></pre></td></tr></tbody></table></figure>


<p>法四 暴力最慢 时间复杂度O（n²），空间复杂度O（1）</p>
<p>拿数组里的第一个数字和后面的数字分别相加，看是否等于target；<br>如果不等于target，那么就继续拿数组里的第二个数字和后面的数字相加；<br>不停的去一个个试…直到等于target，返回这2个数字所在的下标</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self,nums,target</span>):</span></span><br><span class="line">        n = len(nums) <span class="comment"># 获取nums的长度，是4</span></span><br><span class="line">        <span class="comment"># 外层循环先取出下标0，对应着数组里的第一个数字</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n): </span><br><span class="line">            <span class="comment"># 内层循环取出下标1，对应着数组里的第二个数字</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(x+<span class="number">1</span>,n): </span><br><span class="line">                <span class="comment"># 如果第一个数字+第二个数字=target</span></span><br><span class="line">                <span class="keyword">if</span> nums[x] + nums[y] == target: </span><br><span class="line">                    <span class="keyword">return</span> x,y <span class="comment"># 上面的判断是对的话，那么就返回下标</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i, itm <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            other = target - itm</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                posi = nums.index(other)</span><br><span class="line">                <span class="keyword">if</span> posi != i:</span><br><span class="line">                    <span class="keyword">return</span> sorted([posi, i])</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><strong>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</strong></p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<blockquote>
<p>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"()[]{}"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 4:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 5:</p>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"{[]}"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>


<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p>
<p>辅助栈法</p>
<figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"{()[()]}"</span></span><br><span class="line"><span class="string">"{  [()]}"</span></span><br><span class="line"><span class="string">"{  [  ]}"</span></span><br><span class="line"><span class="string">"{      }"</span></span><br><span class="line"><span class="string">"        "</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>算法原理</p>
<ul>
<li><p>栈的先进后出，后进先出的特点恰好与本题括号排序特点一致，<br>即若先遇到左括号入栈，当遇到匹配的最里面右括号时，将这对应左括号从栈中删除，也就是将对应栈顶左括号出栈。</p>
</li>
<li><p>为了快速判断括号的类型，我们可以使用哈希映射（HashMap）存储每一种左右括号对应关系。哈希表 dic的键key 为左括号，值value为相同类型的右括号，这样查询 2 个括号是否对应只需 O(1) 时间复杂度；</p>
</li>
</ul>
</li>
</ul>
<p>建立栈 stack，遍历字符串 s 并按照算法流程一一判断。</p>
<blockquote>
<p>空字符串不会进入for循环</p>
</blockquote>
<ul>
<li><p>算法流程</p>
<ol>
<li>如果 char 是左括号，则入栈 push；</li>
<li>否则通过哈希表判断括号对应关系，<br>若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 char 不对应，<br>则提前返回 false。</li>
</ol>
</li>
<li><p>提前返回 false</p>
<ul>
<li><p>提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。</p>
</li>
<li><p>解决边界问题： </p>
<ul>
<li><p>栈 stack 为空： 此时 stack.pop() 操作会报错；<br>假设s中第一个元素是右括号，此时就会报错了。<br>因此，我们采用一个取巧方法，给 stack 赋初值 ? 就可以避免这个问题<br>并在哈希表 dic 中建立 key: ‘?’，value:’?’ 的对应关系予以配合。<br>有这个 ? 后： 当 stack 为空且 char 为右括号时，可以正常提前返回 false ；<br>若没有则会报错。</p>
</li>
<li><p>字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，<br>但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，<br>以判断是否是有效的括号组合。则遍历完所有括号后 stack 仍然为空，</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>复杂度分析<ul>
<li>时间复杂度 O(N)：正确的括号组合或者全是左括号需要遍历 1 遍 s；出栈和入栈都是0(1) n 是字符串 s 的长度。</li>
<li>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希映射使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。哈希表和栈使用线性的空间大小。</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict1 = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'1'</span>: <span class="string">'c'</span>}</span><br><span class="line"><span class="comment"># 判断的是key是否在字典里而不是判断value</span></span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">in</span> dict1)  <span class="comment"># True</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> dict1)  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'1'</span> <span class="keyword">in</span> dict1)  <span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 先排除一半的情形（奇数）</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dic = {<span class="string">'{'</span>: <span class="string">'}'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'?'</span>: <span class="string">'?'</span>}</span><br><span class="line">        <span class="comment"># 若stack = [] 栈 stack 为空时，执行 stack.pop() 操作会报错，</span></span><br><span class="line">        <span class="comment"># 假设s中单个右括号入栈 ，此时就会报错了。</span></span><br><span class="line">        <span class="comment"># 但在最开始加一个?就可以避免这个问题。用一点空间换每次不用判空,</span></span><br><span class="line">        stack = [<span class="string">'?'</span>]  </span><br><span class="line">        <span class="comment"># 判断的是key是否在字典里而不是判断value</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> dic:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != char:  <span class="comment"># elif不等于if，if 和 elif只能同时执行一个</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solution = Solution()</span><br><span class="line"><span class="comment"># print(solution.isValid(''))  # True</span></span><br><span class="line"><span class="comment"># print(solution.isValid('}'))  # False</span></span><br><span class="line">print(solution.isValid(<span class="string">'}}'</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># print(solution.isValid('[{}()]'))  # True</span></span><br><span class="line"><span class="comment"># print(solution.isValid('[}(){()[]}]'))  # False</span></span><br><span class="line">print(solution.isValid(<span class="string">'[['</span>))  <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1</span></span><br><span class="line">s = <span class="string">''</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">0</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = None 错错错，不会执行这一句</span><br><span class="line">直接跳过循环，</span><br><span class="line"><span class="keyword">return</span> len(stack) = len([<span class="string">'?'</span>]) = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span></span><br><span class="line">s = <span class="string">'}'</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">1</span> % <span class="number">2</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">3</span></span><br><span class="line">s = <span class="string">'}}'</span></span><br><span class="line">len(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'?'</span>] = <span class="string">'?'</span> != <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">4</span></span><br><span class="line">s =<span class="string">'[{}()]'</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span>  = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'{'</span> </span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'{'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'}'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'{'</span>] = <span class="string">'}'</span> = <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'('</span> </span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'('</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">')'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'('</span>] = <span class="string">')'</span> = <span class="keyword">char</span> = <span class="string">')'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> = <span class="string">']'</span> </span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'['</span>] = <span class="string">']'</span> = <span class="keyword">char</span> = <span class="string">']'</span></span><br><span class="line">    stack = [<span class="string">'?'</span>]    </span><br><span class="line"><span class="keyword">return</span> len(stack) == <span class="number">1</span> = Ture</span><br><span class="line"></span><br><span class="line">例子<span class="number">5</span></span><br><span class="line">s =<span class="string">'[}(){()[]}]'</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    dic[stack.<span class="keyword">pop</span>()] = dic[<span class="string">'['</span>] = <span class="string">']'</span> != <span class="keyword">char</span> = <span class="string">'}'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">例子<span class="number">6</span></span><br><span class="line">s =<span class="string">'[['</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">char</span> in s:</span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'?'</span>, <span class="string">'['</span>, <span class="string">'['</span>]] </span><br><span class="line"><span class="keyword">return</span> len(stack) == <span class="number">3</span> != <span class="number">1</span> = <span class="keyword">False</span></span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>对给定的字符串 s 进行遍历，对每一个字符进行如下操作<br>当遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>
<p>当我们遇到一个右括号时，栈为空 或者 该右括号与取出的栈顶的左括号类型不一样，则返回false</p>
<p>否则，即如果栈非空,且栈顶元素与接下来的字符(闭括号)相同类型,出栈</p>
<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，若栈非空,意味着开括号多了,返回 False。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        pairs = {</span><br><span class="line">            <span class="string">")"</span>: <span class="string">"("</span>,</span><br><span class="line">            <span class="string">"]"</span>: <span class="string">"["</span>,</span><br><span class="line">            <span class="string">"}"</span>: <span class="string">"{"</span>,</span><br><span class="line">        }</span><br><span class="line">        stack = list()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>] != pairs[ch]:  <span class="comment"># 顺序不能换</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        <span class="comment"># 如果栈中如果for遍历完后,栈非空,意味着左括号多了,则非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1</span></span><br><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">0</span> % <span class="number">2</span> = <span class="number">0</span> != <span class="number">1</span></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = None 错错错，不会执行这一句</span><br><span class="line">直接跳过循环，</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = True</span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span></span><br><span class="line">s = <span class="string">'}'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">例子<span class="number">3</span></span><br><span class="line">s = <span class="string">'}}'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> </span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span> </span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">例子<span class="number">4</span></span><br><span class="line">s =<span class="string">'[{}()]'</span></span><br><span class="line"><span class="built_in">len</span>(s) % <span class="number">2</span> = <span class="number">2</span> % <span class="number">2</span> = <span class="number">0</span> </span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'{'</span> </span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'{'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'{'</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'('</span> </span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'('</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">')'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'{'</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">']'</span> </span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'['</span> = <span class="built_in">pairs</span>[<span class="built_in">char</span>]</span><br><span class="line">    stack = []    </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = Ture</span><br><span class="line"></span><br><span class="line">例子<span class="number">5</span></span><br><span class="line">s =<span class="string">'[}(){()[]}]'</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'}'</span></span><br><span class="line">    stack[<span class="number">-1</span>] = <span class="string">'['</span> != <span class="built_in">pairs</span>[<span class="built_in">char</span>] = <span class="string">'{'</span></span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">例子<span class="number">6</span></span><br><span class="line">s =<span class="string">'[['</span></span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> = <span class="string">'['</span></span><br><span class="line">    stack = [<span class="string">'['</span>, <span class="string">'['</span>]]</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">not</span> stack = False</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 入栈与出栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># compare with top element</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((stack[<span class="number">-1</span>] + c) <span class="keyword">in</span> [<span class="string">'()'</span>, <span class="string">'{}'</span>, <span class="string">'[]'</span>]):</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        para_map = {<span class="string">')'</span>:<span class="string">'('</span>, <span class="string">']'</span>:<span class="string">'['</span>, <span class="string">'}'</span>:<span class="string">'{'</span>}</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> para_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack.pop() != para_map.get(c):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>字符串处理版</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>).replace(<span class="string">'[]'</span>, <span class="string">''</span>).replace(<span class="string">'{}'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">while</span> len(s) != length:</span><br><span class="line">            length = len(s)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>).replace(<span class="string">'[]'</span>, <span class="string">''</span>).replace(<span class="string">'{}'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> length == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>




<hr>
<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。<br>示例 2：</p>
<p>输入：nums = [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums = [0]<br>输出：0<br>示例 4：</p>
<p>输入：nums = [-1]<br>输出：-1<br>示例 5：</p>
<p>输入：nums = [-100000]<br>输出：-100000</p>
<hr>
<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：</p>
<p>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：</p>
<p>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：</p>
<p>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：</p>
<p>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        num = len(nums1)</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            index = (num + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> nums1[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li = num / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            ri = (num + <span class="number">2</span>) / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (nums1[li] + nums1[ri]) / <span class="number">2.0</span></span><br></pre></td></tr></tbody></table></figure>


<hr>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p>示例 1：</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。<br>示例 2：</p>
<p>输入：height = [1,1]<br>输出：1<br>示例 3：</p>
<p>输入：height = [4,3,2,1,4]<br>输出：16<br>示例 4：</p>
<p>输入：height = [1,2,1]<br>输出：2</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cap = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                cur = height[i] * (j - i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = height[j] * (j - i)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; cap:</span><br><span class="line">                cap = cur</span><br><span class="line">        <span class="keyword">return</span> cap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print Solution().maxArea([1, 2, 3, 4])</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<ol start="12">
<li>整数转罗马数字<br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</li>
</ol>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: 3<br>输出: “III”<br>示例 2:</p>
<p>输入: 4<br>输出: “IV”<br>示例 3:</p>
<p>输入: 9<br>输出: “IX”<br>示例 4:</p>
<p>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.<br>示例 5:</p>
<p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        roman_dict = {<span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">                      <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">                      <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">                      <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">                      <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">                      <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">                      <span class="string">'M'</span>: <span class="number">1000</span>}</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s.upper():</span><br><span class="line">            num = roman_dict[i]</span><br><span class="line">            <span class="keyword">if</span> num &gt; last:</span><br><span class="line">                total -= last</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total += num</span><br><span class="line">            last = num</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># print Solution().romanToInt('MCMLXXXIV')</span></span><br></pre></td></tr></tbody></table></figure>



<p>桶排序（最快最简单的排序）桶排序的基本思想是将一个数据表分割成许多 buckets，然后每个 bucket 各自排序，或用不同的排序算法，或者递归的使用 bucket sort 算法。也是典型的 divide-and-conquer 分而治之的策略。它是一个分布式的排序，介于 MSD 基数排序和LSD 基数排序之间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 选择最大的数</span></span><br><span class="line">    max_num = max(nums)</span><br><span class="line">    <span class="comment"># 创建一个元素全是0的列表，当做桶</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * (max_num + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 把所有元素的个数放入桶中与其值相等的下标对应的位置</span></span><br><span class="line">    <span class="comment"># 即其值对应位置的元素的值为其在原列表中的个数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        bucket[num] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># sort_nums存储排序好的元素</span></span><br><span class="line">    sort_nums = []</span><br><span class="line">    <span class="comment"># 取出桶中的元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bucket)): <span class="comment"># 下标i 其实就是原列表的值</span></span><br><span class="line">        <span class="keyword">if</span> bucket[i] != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 下标i对应的值不为0的话，说明原列表存在i这个值，bucket[i]就是i在原列表的个数</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(bucket[i]):</span><br><span class="line">                sort_nums.append(i)</span><br><span class="line">    <span class="keyword">return</span> sort_nums</span><br></pre></td></tr></tbody></table></figure>
<p>1、桶排序是稳定的 2、桶排序是常见排序里最快的一种, 大多数情况下比快排还要快3、但是同时也非常耗空间,基本上是最耗空间的一种排序算法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag"># 剑指offer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/property-zhuang-shi-qi/" rel="prev" title="property装饰器">
                  <i class="fa fa-chevron-left"></i> property装饰器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/jian-zhi-offer25-30-ti/" rel="next" title="剑指offer25~30题">
                  剑指offer25~30题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
