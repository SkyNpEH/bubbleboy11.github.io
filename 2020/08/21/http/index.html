<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="HTTP HyperText Transfer Protocol 超文本传输协议 是一个属于应用层的 面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。它是一种详细规定了浏览器和万维网（WWW:World Wide Web ）服务器之间互相通信的规则协议，通过因特网传送万维网文档的数据传送协议。用来传递来传递数据">
<meta property="og:type" content="article">
<meta property="og:title" content="http">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/http/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="HTTP HyperText Transfer Protocol 超文本传输协议 是一个属于应用层的 面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。它是一种详细规定了浏览器和万维网（WWW:World Wide Web ）服务器之间互相通信的规则协议，通过因特网传送万维网文档的数据传送协议。用来传递来传递数据">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-08-19T10:41:20.450Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/http/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/http/","path":"2020/08/21/http/","title":"http"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>http | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-text">浏览器的请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-text">资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-text">媒体类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI"><span class="nav-text">URI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL"><span class="nav-text">URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URN"><span class="nav-text">URN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E7%9A%84%E7%BB%93%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">Web的结构组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">第4章 连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-text">用TCP套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B"><span class="nav-text">服务端套接字编程流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B"><span class="nav-text">客户端套接字编程流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E8%81%9A%E7%84%A6%E5%8C%BA%E5%9F%9F"><span class="nav-text">性能聚焦区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9B%B8%E5%85%B3%E6%97%B6%E5%BB%B6"><span class="nav-text">TCP相关时延</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E9%AB%98HTTP%E8%BF%9E%E6%8E%A5%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">提高HTTP连接性能的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="nav-text">并行连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-text">持久连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%88%96%E7%BC%93%E5%AD%98%E5%93%8D%E5%BA%94%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A6%96%E9%83%A8"><span class="nav-text">不能被代理转发或缓存响应使用的首部</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5-1"><span class="nav-text">持久连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-0"><span class="nav-text">HTTP&#x2F;1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-1"><span class="nav-text">HTTP&#x2F;1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">持久连接的限制</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">344</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          http
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-19 10:41:20" itemprop="dateModified" datetime="2021-08-19T10:41:20Z">2021-08-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>HTTP HyperText Transfer Protocol 超文本传输协议</p>
<p>是一个属于应用层的 面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。<br>它是一种详细规定了浏览器和万维网（WWW:World Wide Web ）服务器之间互相通信的规则协议，通过因特网传送万维网文档的数据传送协议。<br>用来传递来传递数据（HTML 文件, 图片文件, 查询结果等）。<br>是用于从万维网服务器传输超文本到本地浏览器。</p>
<p>客户端与服务端通信时传输的内容我们称之为报文.</p>
<p>HTTP 就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器响应给客户端的报文格式。实际我们要学习的就是这两种报文。<br>客户端发送给服务器的称为”请求报文“，<br>服务器发响应给客户端的称为”响应报文“。</p>
<p>HTTP协议是Web工作的核心，所以要了解清楚Web的工作方式就需要详细的了解清楚HTTP是怎么样工作的。</p>
<p>HTTP是一种让Web服务器与浏览器(客户端)通过Internet发送与接收数据的协议,它建立在TCP协议之上，一般采用TCP的80端口。它是一个请求、响应协议–客户端发出一个请求，服务器响应这个请求。在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。</p>
<p>TCP攻击一样会影响HTTP的通讯，例如比较常见的一些攻击：SYN Flood是当前最流行的DoS（拒绝服务攻击）与DdoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。</p>
<p>它可以使浏览器更加高效，使网络传输减少。<br>保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，<br>以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP协议采用URL作为定位网络资源的标识<br>以明文的形式传输 效率更高，但是不安全</p>
<p>HTTP协议特点</p>
<ol>
<li>支持客户/服务器模式 基于“请求与响应”模式的的应用层协议</li>
</ol>
<ul>
<li>客户/服务器模式工作的方式是由客户端向服务器发出请求，服务器端响应请求，并进行相应服务</li>
</ul>
<ol start="2">
<li>简单快速</li>
</ol>
<ul>
<li>客户向服务器请求服务时，只需传送请求方法和路径</li>
<li>请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li>
</ul>
<ol start="3">
<li>灵活</li>
</ol>
<ul>
<li>HTTP允许传输任意类型的数据对象</li>
<li>正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</li>
</ul>
<ol start="4">
<li>无连接</li>
</ol>
<ul>
<li>无连接的含义是限制每次连接只处理一个请求</li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。不建立持久的连接</li>
</ul>
<ol start="5">
<li>无状态</li>
</ol>
<p>指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。<br>打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。同一个客户端的这次请求和上次请求是没有对应关系的，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端来如何识别用户、分辨链接是谁发起的，就需要我们自己去解决这个问题。不然有些情况下即使是同一个网站我们每打开一个页面也都要登录一下。而Session和Cookie就是为解决维护连接的可持续状态而提出来的两个机制。</p>
<ul>
<li>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li>
</ul>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。</p>
<p>-HTTPS:HTTP + SSL用安全套接字层传送的超文本传输协议，<br>传输之前采用证书密钥加密数据 ，之后解密获取内容<br>默认端口：443<br>-安全 效率较低，</p>
<p>Http与Https的区别：</p>
<ol>
<li>   HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</li>
<li>   HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>   HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>   在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
<li>   HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>   HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<p>HTTP协议由哪些部分组成？可以使用抓包工具去查看和理解<br>请求是发送给接口的数据对象<br>一个HTTP请求由四部分组成：<br>1、请求状态行Request line HTTP请求方法或动作，如：GET或POST；正在请求的接口地址URL<br>2、请求头HTTP Header，包含一些客户端环境信息、身份验证信息、Cookies</p>
<ul>
<li><p>Accept：指定客户端支持接收的数据类型</p>
</li>
<li><p>Accept-Charset：浏览器客户端可以接受的字符编码集。</p>
</li>
<li><p>Accept-Encoding:浏览器告诉服务器它所支持的压缩格式</p>
</li>
<li><p>Accept-language:浏览器告诉服务器它所采用的语言</p>
</li>
<li><p>Authorization: HTTP 授权的授权证书</p>
</li>
<li><p>Content-type：请求的与实体对应的 MIME 信息，发送端实际发送的数据类型<br>表单的数据类型，说明会使用 url 格式编码数据；url 编码的数据都是以“%”为前缀，后面跟随两位的 16 进制，比如“全栈编程”这两个字使用 UTF-8 的 url 编码为 “%E5%85%A8%E6%A0%88%E7%BC%96%E7%A8%8B”；</p>
</li>
<li><p>Referer：浏览器告诉服务器请求来自哪个页面(防盗链) ，比如通过百度搜索到了上面的链接，那么Referer:<a target="_blank" rel="noopener" href="http://www.baidu.com;如果在浏览器的地址栏中直接输入该链接地址,则refer为空/">http://www.baidu.com；如果在浏览器的地址栏中直接输入该链接地址，则Refer为空</a>  来路</p>
</li>
<li><p>User-Agent:用户代理：知道当前请求对方资源的是浏览器类型、版本等信息，请求载体的身份标识</p>
</li>
<li><p>Connection：请求完毕后，是断开连接还是保持连接<br>客户端支持的链接方式，保持一段时间链接，默认为 3000ms</p>
</li>
</ul>
<p>Cookie: 非首次访问时，请求会携带上一次服务器响应给客户端的 Cookie信息<br>Content-Length:100：请求体的长度，这里表示 100个字节。</p>
<p>keyword=全栈编程：请求体内容！全栈编程 是在表单中输入的数据，keyword 是表单字段的名字。</p>
<p>Host:浏览器告诉服务器我想访问服务器哪台主机<br>If-Modified-Since:浏览器告诉服务器它缓存数据时间是多少<br>Date : 浏览器告诉服务器我什么时间访问的</p>
<p>空行,用于分割请求头和消息体<br>消息体,请求资源参数,例如POST传递的参数</p>
<p>3、body 请求体，即请求正文，可包含提交的查询字符串信息、表单信息等。</p>
<p>一个HTTP响应一般由三个部分组成：</p>
<ol>
<li>状态行 HTTP协议版本号， 状态码， 状态消息</li>
<li>响应头</li>
</ol>
<ul>
<li>Location:告诉浏览器你去找谁，配合302状态码使用(转其他路径)</li>
<li>Server: 服务器使用的WEB软件名及版本</li>
<li>Date 响应日期时间</li>
<li>Content-Encoding:告诉浏览器回送的数据采用的压缩格式</li>
<li>Content-Type: 服务器响应回客户端的数据类型</li>
<li>Content-Lenth: 服务器响应回客户端的主体数据长度</li>
<li>Transfer-Encoding: 表示发送HTTP数据包是分段分块形式发的</li>
<li>application/x-www-form-urlencoded: 请求默认方式，数据是简单、平面的key-value键值对</li>
<li>application/json: 数据是复杂的嵌套关系，有多层数据</li>
<li>multipart/form-data 既可发送文本数据，也支持二进制数据上载</li>
<li>Last-Modified:告诉浏览器数据的最后修改时间</li>
<li>Refresh:控制浏览器定时刷新</li>
<li>content-Disposition:告诉浏览器需要以下载方式打开回送的数据</li>
</ul>
<ol start="3">
<li>响应体，即响应正文。<br>​- 请求头之间：\r\n<br>​- 请求头与请求体：\r\n\r\n</li>
</ol>
<p>① 在命令行下查看HTTP协议，可以使用 curl 或 http 命令发起HTTP请求</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># curl www.baidu.com</span></span><br></pre></td></tr></tbody></table></figure>

<p>② 使用http 命令需要首先安装httpie，然后在通过http命令发起HTTP请求</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pip install httpie      # 安装httpie</span></span><br><span class="line">[root@localhost ~]<span class="comment"># http baidu.com          # 使用http发起HTTP请求</span></span><br></pre></td></tr></tbody></table></figure>

<p>查看HTTP协议详细输出过程， http -v 详细输出过程</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># http -v baidu.com</span></span><br><span class="line">GET / HTTP/1.1               <span class="comment"># 状态行包括请求方法、路径uri、http协议及版本</span></span><br><span class="line">Accept: */*                  <span class="comment"># 3~7行是http的请求头 客户端能接收的MIME</span></span><br><span class="line">Accept-Encoding: gzip, deflate    <span class="comment"># 接收的编码 是否支持流压缩</span></span><br><span class="line">Connection: keep-alive            <span class="comment"># 连接，</span></span><br><span class="line">Host: baidu.com                   <span class="comment"># 服务端主机域名</span></span><br><span class="line">User-Agent: HTTPie/1.0.2          <span class="comment"># 请求的代理 浏览器信息</span></span><br><span class="line"><span class="comment"># 请求头和请求体空一行 </span></span><br><span class="line"><span class="comment"># 消息主体（不一定有），这里为空没有显示，一般是由GET请求的时候它就没有消息主体</span></span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">HTTP/1.1 200 OK                  <span class="comment"># 响应行 下面是HTTP响应</span></span><br><span class="line">Accept-Ranges: bytes             <span class="comment"># 3~7行是http的响应头</span></span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 81</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Fri, 02 Aug 2019 10:07:15 GMT</span><br><span class="line">ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">Expires: Sat, 03 Aug 2019 10:07:15 GMT</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">Server: Apache</span><br><span class="line"><span class="comment"># 请求头和请求体空一行 </span></span><br><span class="line">&lt;html&gt;         <span class="comment"># 响应正文。返回的是一个HTML</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>fiddler保存HTTP请求文本<br>打开测试页面→到Fiddler中选中该请求→Shift+Del清空其他请求→右键→Save→Selected Sessions→as Text…  </p>
<p>提交一些表单的时候HTTP请求里面就会包含消息主体。</p>
<p>发送一个POST请求，带上hello=World参数 ，也可以加在url</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># http -f POST baidu.com hello=World -v</span></span><br><span class="line">POST / HTTP/1.1                  <span class="comment"># 请求状态行</span></span><br><span class="line">Accept: */*                      <span class="comment"># 3~9是请求头</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 11</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=utf-8</span><br><span class="line">Host: baidu.com</span><br><span class="line">User-Agent: HTTPie/1.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空已行 用来分割消息头和主体</span></span><br><span class="line">hello=World                    <span class="comment"># 报文消息主体，当然有时候可以为空</span></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">HTTP/1.1 200 OK           <span class="comment"># 响应状态行，包括HTTP版本、状态码、状态消息</span></span><br><span class="line">Accept-Ranges: bytes      <span class="comment"># 14~23是响应头</span></span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 81</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Fri, 02 Aug 2019 10:13:42 GMT</span><br><span class="line">ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">Expires: Sat, 03 Aug 2019 10:13:42 GMT</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">Server: Apache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空一行 用来分割消息头和主体</span></span><br><span class="line">&lt;html&gt;         <span class="comment"># 响应正文。返回的是一个HTML</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>从HTTP/1.1起，Connection默认都开启了Keep-Alive保持长连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p>
<p>HTTP persistent connection，<br>短连接：建立连接…数据传输…关闭连接(连接的建立和关闭开销大)</p>
<p>如何区分不同的 HTTP 请求呢？Content-Length | Transfer-Encoding:chunked。</p>
<p>Content-Length首部告诉浏览器报文中实体主体的大小<br>第一种情况 就是客户端告诉服务端发送的 HTTP 请求多长(Content-Length)，接收这么多字节之后就认为你这次HTTP请求就结束了。(静态发送)<br>非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>第二种情况 请求是动态发送的不知道有多长，HTTP提供了一种分段发送方式(| Transfer-Encoding:chunked),每次发送一个chunk size和chunk body告诉每一次发送多长和发送的内容是什么，直到chunksize为0的时候，服务端就认为结束了。(动态发送)</p>
<p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间。<br>通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p>
<p>HTTP 协议的会话方式</p>
<p>浏览器与 WEB 服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与 WEB 服务器都要建立一次单独的连接。</p>
<p>浏览器到 WEB 服务器之间的所有通讯都是完全独立分开的请求和响应对。</p>
<p>cookie 和 session 区别<br>需要在服务端给用户生成一个标识，然后每次让客户端带过去给后端，识别用户会话。用户会话就是用户识别的一种方式。作用：保持会话</p>
<p>Session“会话控制” 一般是服务器生成存在服务器的一种用来存放用户数据的类HashTable结构。 之后给客户端 （通过 url参数或cookie）<br>对象存储特定用户会话所需的属性及配置信息。<br>这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，<br>而是在整个用户会话中一直存在下去。<br>当用户请求来自应用程序的 Web页时，如果该用户还没有会话，<br>则Web服务器将自动创建一个 Session对象。<br>当会话过期或被放弃后，服务器将终止该会话。<br>Session没有大小限制<br>session数据sessionid 识别用户<br>Session 存储安全性较高的数据。文件、数据库都可以<br>Session过多的时候会消耗服务器资源，所以大型网站会有专门的Session服务器，而Cookie存在客户端所以没什么问题。</p>
<p>session的一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息，这里就用到了session。</p>
<p>　　(什么是hashTable,另一篇文章:–<a target="_blank" rel="noopener" href="https://www.cnblogs.com/goddog1024/p/11174417.html">https://www.cnblogs.com/goddog1024/p/11174417.html</a></p>
<p>当浏览器 第一次发送请求时，服务器自动生成了一个HashTable和一个Session ID用来唯一标识这个HashTable，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。</p>
<p>摘自<a target="_blank" rel="noopener" href="http://caibaojian.com/477.html">http://caibaojian.com/477.html</a></p>
<p>一般这个值会有一个时间限制，超时后毁掉这个值，默认是20分钟。</p>
<p>试想一下，建立一个连接就生成一个session id，那么打开几个页面就好几个了，这显然不是我们想要的，那么该怎么区分呢？<br>这里就用到了Cookie，我们可以把session id存在Cookie中，然后每次访问的时候将Session id带过去就可以识别了，是不是很方便~</p>
<p>Cookie 是实现 session 的一种机制，通过 HTTP cookie 字段实现<br>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>日常登录一个网站，今天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。<br>Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。<br>Cookies是服务器在本地机器上存储用户信息的的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。<br>是某些网站为了辨别用户身份，进行Session跟踪而储存在用户浏览器终端上的数据（通常经过加密）</p>
<p>格式为key:value 的形式，也就是我们说的对应着的名字，值。<br>过期时间是可以设置的，如果不设置，则浏览器关掉就消失了，是存储在内存当中的，<br>否则就是按照我们设置的时间来存储在硬盘上的，当过期后自动清除，比方说我们开机关机关闭再打开浏览器后他都会还存在，<br>前者称之为Session cookie 又叫 transient cookie，临时cookie，在浏览器被关闭时候自动删除<br>后者称之为Persistent cookie 又叫 permenent cookie，持久化cookie<br>路径和域就是对应的域名，域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而<a target="_blank" rel="noopener" href="http://www.a.com的session在api.a.com下都不能用,解决这个问题的办法是jsonp或者跨域资源共享./">www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者跨域资源共享。</a></p>
<p>cookie的值由服务端生成，存在客户端的头信息中，所以用户可以看见，所以也可以编辑伪造，不是十分安全。一般存储安全性要求不高的数据。</p>
<p>-要获取登录后才能访问的页面<br>-对方的服务器会通过cookie来判断是我们是一个爬虫</p>
<p>一般来说 session 的验证需要 cookie 带一个字段来表示这个用户是哪一个 session，所以当客户端禁用cookie时, session将失效<br>采用url重写的方式 ，<br>也就是上面说的将sessionid写在url上，<br>用户登陆之后，需要将用户的信息存到Cookie中，<br>但因为Cookie中只能存储字符串，所以想到了先把用户实体序列化成Json串，存储在Cookie中，用到的时候再拿出来反序列化。<br>Cookie 中存储session id，以此来标记服务器的哪个session 文件是当前用户的。（session 文件：session 存储介质视服务器而定）<br>Cookie 减轻服务器存储压力，<br>Cookie的主要内容包括：名字，值，过期时间，路径和域。不能存储对象<br>使用Fiddler抓包就可以看见，比方说我们打开百度的某个网站可以看到Headers包括Cookie，如下：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">BIDUPSID</span>: <span class="number">9</span>D<span class="number">2194</span>F<span class="number">1</span>CB<span class="number">8</span>D<span class="number">1</span>E<span class="number">56272947</span>F<span class="number">6</span>B<span class="number">0</span>E<span class="number">5</span>D<span class="number">47</span>E</span><br><span class="line"><span class="attribute">PSTM</span>: <span class="number">1472480791</span></span><br><span class="line"><span class="attribute">BAIDUID</span>: <span class="number">3</span>C<span class="number">64</span>D<span class="number">3</span>C<span class="number">3</span>F<span class="number">1753134</span>D<span class="number">13</span>C<span class="number">33</span>AFD<span class="number">2</span>B<span class="number">38367</span>:FG</span><br><span class="line"><span class="attribute">ispeed_lsm</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">MCITY</span>: -<span class="number">131</span>:</span><br><span class="line"><span class="attribute">pgv_pvi</span>: <span class="number">3797581824</span></span><br><span class="line"><span class="attribute">pgv_si</span>: s<span class="number">9468756992</span></span><br><span class="line"><span class="attribute">BDUSS</span>: JhNXVoQmhPYTVENEdIUnQ<span class="number">5</span>S<span class="number">05</span>xcHZMMVY<span class="number">5</span>QzFRNVh<span class="number">5</span>SzZoV<span class="number">0</span>xMVDR<span class="number">6</span>RzV-bEJZSVFBQUFBJCQAAAAAAAAAAAEAAACteXsbYnRfY<span class="number">2</span>hpbGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALlxKVi<span class="number">5</span>cSlYZj</span><br><span class="line"><span class="attribute">BD_HOME</span>: <span class="number">1</span></span><br><span class="line"><span class="attribute">H_PS_PSSID</span>: <span class="number">1423</span>_<span class="number">21080</span>_<span class="number">17001</span>_<span class="number">21454</span>_<span class="number">21408</span>_<span class="number">21530</span>_<span class="number">21377</span>_<span class="number">21525</span>_<span class="number">21193</span>_<span class="number">21340</span></span><br><span class="line"><span class="attribute">BD_UPN</span>: <span class="number">123253</span></span><br><span class="line"><span class="attribute">sug</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">sugstore</span>: <span class="number">0</span></span><br><span class="line"><span class="attribute">ORIGIN</span>: <span class="number">0</span></span><br><span class="line"><span class="attribute">bdime</span>: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>


<p>web访问Server端–&gt;server端对web信息加密生成Cookie返给web端,server端同时生成sessionId–&gt;web带着cookie访问server端,server端进行验证</p>
<p>cookie [A]<br>session [B]<br>用户在【浏览器】当中提交【数据】—》 【服务器】—》 [sessionid]<br>【服务器】—-》 【sessionid]—-》 【浏览器】—-》 cookie[sessionid]<br>【浏览器】-》 cookie[sessionid]—&gt; 【服务器】</p>
<p>【波哥】-》 【浏览器】打开淘宝网<br>【淘宝服务器】 【波哥的信息】<br>【登陆】=》 【淘宝服务器】 –》 sessionid<br>【淘宝服务器】–》 sessionid—》 【波哥】–》 【浏览器】<br>【波哥】–》 【浏览器】 sessionid+手机的信息—》 【淘宝服务器】</p>
<p>同时一个URL请求但是左边栏里面为什么会有那么多的资源请求(这些都是静态文件</p>
<h3 id="浏览器的请求"><a href="#浏览器的请求" class="headerlink" title="浏览器的请求"></a>浏览器的请求</h3><ul>
<li><p>url</p>
</li>
<li><p>在chrome中点击检童，点到network,</p>
</li>
<li><p>url =谓求的协议+网站的域名+资源的路径+参数</p>
</li>
<li><p>浏览器谓求url地址</p>
</li>
<li><p>当前url对应的晌应+js+css+图片—&gt;elements中的内容</p>
</li>
<li><p>爬虫谓求url地址</p>
</li>
<li><p>当前url对应的晌应</p>
</li>
<li><p>elements的内容和爬虫获取到的url地址的晌应不同，爬虫中需要以当 前url地址对应的响应为准提取数据</p>
</li>
<li><p>当前url地址对应的晌应在哪里</p>
</li>
<li><p>从network中找到当前的url地址，点击response</p>
</li>
<li><p>在页面上右键显示网页源码</p>
</li>
</ul>
<p>浏览器的一个功能，第一次请求url，服务器端返回的是html页面，然后浏览器开始渲染HTML：当解析到HTML DOM里面的图片连接，css脚本和js脚本的链接，浏览器就会自动发起一个请求静态资源的HTTP请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。</p>
<p>网页优化方面有一项措施是减少HTTP请求次数，就是把尽量多的css和js资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><ul>
<li>MIME(Multipurpose Internet Mail Extension,多用途英特网邮件扩展)</li>
<li>Web服务器回味所有的HTTP对象数据附加一个MIME类型，以告知Web浏览器该如何处理该对象</li>
<li>Content-Type:image/jpeg ,“image/jpeg”为MIME类型<a id="more"></a>

</li>
</ul>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><ul>
<li>URI(Uniform Resource Identifier,统一资源标识符)</li>
<li>URI 有两种形式，分别称为URL和URN</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li>统一资源定位符</li>
<li>URL包含三个部分,协议类型,服务器地址,资源地址</li>
<li>现在,几乎所有的URI都是URL</li>
<li>URL语法 : <scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag></frag></query></params></port></host></password></user></scheme></li>
</ul>
<h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><ul>
<li>URN 统一资源名</li>
<li>URN是作为特定内容的唯一名称使用的,与目前资源所在地无关</li>
<li>P2P下载中使用的磁力链接是URN的一种实现，它可以持久化的标识一个BT资源，资源分布式的存储在P2P网络中，无需中心服务器用户即可找到并下载它。</li>
</ul>
<h2 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h2><ul>
<li>代理 位于客户端和服务端之间的HTTP中间实体</li>
<li>缓存 HTTP的仓库,使常用的页面或资源保存在离客户端更近的地方</li>
<li>网关 连接其他应用程序的特殊问web服务器</li>
<li>隧道 对HTTP通信报文进行盲转发的特殊代理</li>
<li>Agent代理 发起自动HTTP请求的半智能Web客户端</li>
</ul>
<h1 id="第4章-连接管理"><a href="#第4章-连接管理" class="headerlink" title="第4章 连接管理"></a>第4章 连接管理</h1><h2 id="用TCP套接字编程"><a href="#用TCP套接字编程" class="headerlink" title="用TCP套接字编程"></a>用TCP套接字编程</h2><ul>
<li>网络套接字 操作系统提供的操作TCP连接的工具</li>
</ul>
<h3 id="服务端套接字编程流程"><a href="#服务端套接字编程流程" class="headerlink" title="服务端套接字编程流程"></a>服务端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>绑定端口</li>
<li>监听端口</li>
<li>接收并处理消息</li>
</ol>
<h3 id="客户端套接字编程流程"><a href="#客户端套接字编程流程" class="headerlink" title="客户端套接字编程流程"></a>客户端套接字编程流程</h3><ol>
<li>创建套接字</li>
<li>连接服务端套接字</li>
<li>发送消息</li>
</ol>
<h2 id="性能聚焦区域"><a href="#性能聚焦区域" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h2><h3 id="TCP相关时延"><a href="#TCP相关时延" class="headerlink" title="TCP相关时延"></a>TCP相关时延</h3><ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h2 id="提高HTTP连接性能的方法"><a href="#提高HTTP连接性能的方法" class="headerlink" title="提高HTTP连接性能的方法"></a>提高HTTP连接性能的方法</h2><p>串行事务处理时延</p>
<ul>
<li>并行连接 通过多条TCP连接发起并发的HTTP请求</li>
<li>持久连接 重用TCP连接,以消除连接及关闭时延</li>
<li>管道化连接 通过共享TCP连接发起并发的HTTP请求</li>
<li>复用连接 交替传送请求和响应报文</li>
</ul>
<h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>打开大量连接会消耗很多内存资源<br>浏览器确实使用了并行连接,但他们会将并行连接的总数限制为一个较小的值(通常是4个). 服务器可以随意关闭来自特定客户端的超量连接</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP事务处理结束后仍然保持在打开状态的TCP连接被称为持久连接;持久连接会在不同事务之间保持打开状态,直到客户端或服务器决定将其关闭为止</p>
<h3 id="不能被代理转发或缓存响应使用的首部"><a href="#不能被代理转发或缓存响应使用的首部" class="headerlink" title="不能被代理转发或缓存响应使用的首部"></a>不能被代理转发或缓存响应使用的首部</h3><ul>
<li>Connection</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Connection</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
<h2 id="持久连接-1"><a href="#持久连接-1" class="headerlink" title="持久连接"></a>持久连接</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP/1.0 通过Connection:keep-alive 头部发送持久连接信号 ,服务端响应Connection:keep-alive表示支持持久连接,但是会存在一个盲中继问题<br>盲中继(哑代理)会导致,客户端保持TCP连接,服务端保持TCP连接,他们的TCP连接都是连接在代理上的,代理却什么都不知道</p>
<blockquote>
<p>只是将一个连接转发到另一个连接去,不对Connection首部进行特殊处理</p>
</blockquote>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1使用persistent connection持久连接,改进了HTTP/1.0 中Connection:keep-alive的缺陷,HTTP/1.1中持久连接是默认激活的,要关闭则需要在报文首部显示添加Connection:close关闭持久连接</p>
<h3 id="持久连接的限制"><a href="#持久连接的限制" class="headerlink" title="持久连接的限制"></a>持久连接的限制</h3><ul>
<li>只有当连接上的所有报文都是正确的,自定义报文长度时,也就是说实体部分的长度和相应的Content-length一致,或则是用分块传输编码方式编码的,连接才能持久保持</li>
<li>HTTP/1.1的代理必须能够分别管理与客户端和服务端的持久连接,每个连接都只适用于一跳传输</li>
<li>一个用户客户端对任何服务器或代理最多维持两条持久连接,以防止服务器过载.</li>
</ul>
<p>session有效期短，超过一段时间不访问就会被释放掉；<br>当存在多台服务器（多节点部署）时,再次请求可能会被分配到另一台服务器，如果session没持久化存储可能这台服务器就不能分辨你是哪个用户，<br>访问用户过多时会占用服务器资源，考虑到减轻服务器性能方面，应当使用cookie,<br>其实完全可以只使用cookie或session，仅使用session或cookie达到的效果可能没那么好，二者结合起来可能达到意想不到的效果。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/java-ji-chu/" rel="prev" title="java基础">
                  <i class="fa fa-chevron-left"></i> java基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/http-huan-cun/" rel="next" title="http缓存">
                  http缓存 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
