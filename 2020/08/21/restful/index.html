<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="http是应用协议而非传输协议  REST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义， 是一种以资源为中心的 万维网web软件系统架构设计风格(它既不是一个标准规范也不是一个强制性约束)，   一种分布式系统的应用层解决方案， Representational：数据的表现形式（JSON、XML…..），数据描述简单、可读。 Sta">
<meta property="og:type" content="article">
<meta property="og:title" content="REST">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/restful/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="http是应用协议而非传输协议  REST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义， 是一种以资源为中心的 万维网web软件系统架构设计风格(它既不是一个标准规范也不是一个强制性约束)，   一种分布式系统的应用层解决方案， Representational：数据的表现形式（JSON、XML…..），数据描述简单、可读。 Sta">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-05-22T07:14:11.006Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/restful/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/restful/","path":"2020/08/21/restful/","title":"REST"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>REST | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#REST-Representational-State-Transfer-%E8%A1%A8%E7%A4%BA%EF%BC%88%E8%A1%A8%E8%BF%B0%EF%BC%89%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E4%B9%89%EF%BC%8C"><span class="nav-text">REST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义，</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RESTful-%E5%85%AD%E5%A4%A7%E9%99%90%E5%88%B6"><span class="nav-text">RESTful 六大限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">统一接口的限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RESTful-API%EF%BC%9A"><span class="nav-text">RESTful API：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">322</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/restful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          REST
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-22 07:14:11" itemprop="dateModified" datetime="2021-05-22T07:14:11Z">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ul>
<li>http是应用协议而非传输协议</li>
</ul>
<h3 id="REST-Representational-State-Transfer-表示（表述）性状态转换，表现层状态转义，"><a href="#REST-Representational-State-Transfer-表示（表述）性状态转换，表现层状态转义，" class="headerlink" title="REST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义，"></a>REST - Representational State Transfer 表示（表述）性状态转换，表现层状态转义，</h3><ul>
<li>是一种以资源为中心的 万维网web软件系统架构设计风格(它既不是一个标准规范也不是一个强制性约束)，</li>
</ul>
<ul>
<li>一种分布式系统的应用层解决方案，</li>
<li><strong>Representational：数据的表现形式（JSON、XML…..），数据描述简单、可读。</strong></li>
<li><strong>State: 当前状态或者数据</strong></li>
<li><strong>Transfer: 数据传输通信</strong></li>
</ul>
<ul>
<li>目的：用来创建网络服务的，</li>
<li>可以用 Ajax 和RESTful web服务构建应用</li>
<li>可以降低开发的复杂性，提高系统的可伸缩性。<br>RESTful架构就是：<strong>“每一个URI代表一种资源，客户端通过四个HTTP动词，对服务器端资源进行操作，实现资源的表现层状态转移”。</strong></li>
</ul>
<h5 id="RESTful-六大限制"><a href="#RESTful-六大限制" class="headerlink" title="RESTful 六大限制"></a>RESTful 六大限制</h5><ol>
<li><p><strong>客户-服务器（Client-Server）</strong></p>
<ul>
<li>关注点分离</li>
<li>服务端专注数据存储，提高了简单性</li>
<li>前端专注用户界面，提升了可移植性</li>
</ul>
</li>
<li><p><strong>无状态（StateLess）</strong></p>
<ul>
<li>所有会话信息都保存在客户端</li>
<li>每次请求必须包括所有信息，不能依赖上下文信息</li>
<li>服务端不用保存会话信息，提升简单性、可靠性、可见性（软件工程中接口之间透明程度）</li>
</ul>
</li>
<li><p><strong>缓存（Cache）</strong></p>
<ul>
<li>所有服务端响应都要被表示为可缓存（缓存在客户端（浏览器））或不可缓存</li>
<li>减少前后端交互，提升性能</li>
</ul>
</li>
<li><p><strong>统一接口（Uniform Interface）</strong></p>
<ul>
<li>接口设计尽可能统一通用，提升了简单性、可见性</li>
<li>遵循接口规范，接口与实现解耦，使前后端可以独立开发迭代</li>
</ul>
</li>
<li><p><strong>分层系统（Layered System）</strong></p>
<ul>
<li>每层只知道相邻的一层，后面隐藏的就不知道了</li>
<li>客户端不知道是和代理还是真实服务器通信</li>
<li>其它层：安全层、负载均衡、缓存层等</li>
</ul>
</li>
<li><p><strong>按需代码（Code-On-Demand）（可选）</strong></p>
<ul>
<li>客户端可以下载运行服务端传来的数据（比如JS）</li>
<li>通过减少一些功能，简化了客户端</li>
</ul>
</li>
</ol>
<h5 id="统一接口的限制"><a href="#统一接口的限制" class="headerlink" title="统一接口的限制"></a>统一接口的限制</h5><ol>
<li><strong>资源的标识</strong></li>
</ol>
<ul>
<li>Resources(资源)：任意可以命名的事物抽象为资源，在RESTFul设计里一切都是资源。<br>就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一个用户、或者一个订单或一种服务或数据。<br>每个资源可以通过<code>URI</code>（统一资源标识符）被唯一的标识(identifier)和定位和指向资源而不是操作资源。标识符在网站上的表现形式就是URI。每一个URL 指向的一个实体资源，要获取到这个资源，访问它的URI即可，URI就是资源在互联网上的唯一标识。<br><a target="_blank" rel="noopener" href="https://api.z.cn/v1/product/recent?page=3&amp;size=20">https://api.z.cn/v1/product/recent?page=3&amp;size=20</a></li>
</ul>
<ol start="2">
<li><p><strong>通过表述来操作资源</strong></p>
<ul>
<li>通过表述<code>Representation</code> 操作资源，比如<code>JSON</code>、<code>XML</code>等</li>
<li>客户端不能直接操作（比如<code>SQL</code>）服务端资源</li>
<li>客户端应该通过表述（比如<code>JSON</code>）来操作资源</li>
</ul>
</li>
<li><p><strong>自描述消息</strong></p>
<ul>
<li>每个消息（请求或响应）必须提供足够的信息让接受者理解</li>
<li>消息：如媒体类型（<code>application/json、application/xml</code>）</li>
<li>消息：如HTTP方法： <code>GET、POST、DELETE</code></li>
<li>是否缓存： <code>Cache-Control</code></li>
</ul>
</li>
<li><p><strong>超媒体作为应用状态引擎</strong></p>
<ul>
<li>超媒体： 带文字的链接</li>
<li>应用转态：一个网页</li>
<li>引擎：驱动、跳转</li>
<li>合起来就是：点击链接跳转到另一个网页</li>
</ul>
</li>
</ol>
<h3 id="RESTful-API："><a href="#RESTful-API：" class="headerlink" title="RESTful API："></a>RESTful API：</h3><p>符合REST架构风格的<strong>API</strong>就是 <strong>RESTful API</strong>，设计概念和准则规范，<br>接口实现 是前后端分离的最佳实践，</p>
<p>我们在设计Web应用时，如果需要向客户端提供资源，就可以使用REST风格的URI，这是实现RESTful架构的第一步。当然，真正的RESTful架构并不只是URI符合REST风格，更为重要的是“无状态”和“幂等性”两个词，我们在后面的课程中会为大家阐述这两点。</p>
<ul>
<li><p>轻量，直接通过http(s)做传输协议，不需要额外的协议</p>
</li>
<li><p>面向资源的接口设计 （不同于 SOAP协议，SOAP 是面向服务的）一目了然，具有解释性</p>
<ul>
<li>Representation(表现层)：资源的“表现层、表现形式。资源可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的“表现层”。比如，文本可以用<code>text/plain</code>格式表现，也可以用<code>text/html</code>格式、<code>text/xml</code>格式、<code>application/json</code>格式表现，甚至可以采用二进制格式；图片可以用<code>image/jpeg</code>格式表现，也可以用<code>image/png</code>格式表现。URI只代表资源的实体，不代表它的表现形式。严格地说，有些网址最后的<code>.html</code>后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范畴，而URI应该只代表“资源”的位置，它的具体表现形式，应该在HTTP请求的头信息中用<code>Accept</code>和<code>Content-Type</code>字段指定，这两个字段才是对“表现层”的描述。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>通过表述来操作资源</strong><ul>
<li>通过表述<code>Representation</code> 操作资源，比如传输的数据媒体类型<code>JSON</code>、<code>XML</code>等</li>
<li>客户端不能直接操作（比如<code>SQL</code>）服务端资源</li>
<li>客户端应该通过表述（比如<code>JSON</code>）来操作资源</li>
</ul>
</li>
</ol>
<ul>
<li>State Transfer(状态转化)： </li>
<li>客户端通过对资源的四种HTTP的GET、POST、PUT（或PATCH）、DELETE动词语义的增删改查操作实现这个url对应的资源状态的改变，<br>(把 HTTP 请求方式和数据库的增删改查CRUD(create/retrieve/update/delete)联系结合到一起)，</li>
<li>资源通过接口进行操作实现状态转移，操作本身是无状态的。因为HTTP协议本身就是一个无状态的协议，它只能通过每次发的cookie值来识别用户，但是每两次http之间的请求它们是没有任何关系的、没有先后顺序。</li>
<li>对资源的操作不会改变资源的标识。因为你一旦改变了资源的标识就会导致链接不可用或者资源查找不到。访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。Web应用通常使用HTTP作为其通信协议，客户端想要操作服务器，必须通过HTTP请求，让服务器端发生“状态转移”，而这种转移是建立在表现层之上的，所以就是“表现层状态转移”。</li>
<li>在服务器新建或更新资源-用HTTP POST请求、</li>
<li>从服务器获取资源-用HTTP GET请求、</li>
<li>从服务器获取某个资源的头部信息-用HTTP HEAD请求、</li>
<li>在服务器更新资源-用HTTP PUT（或PATCH）请求、</li>
<li>从服务器删除资源-用HTTP DELETE请求</li>
<li>更“精简”的方式处理返回结果设计<br>对于每一个http请求的响应结果都要指明一个状态码，具体产品由具体产品 api 文档给出。<br>比如修改一个数据的时候，只需要得到http状态码的结果，200或201表示修改成功<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"msg"</span>:<span class="string">"uri_not_found"</span>,</span><br><span class="line">    <span class="attr">"code"</span>:<span class="number">1001</span>,</span><br><span class="line">    <span class="attr">"request"</span>: <span class="string">"GET \/v2\/photo\/132"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>下面的例子给出了一些符合REST风格的URI，供大家在设计URI时参考。<br>REST API 接口实例 url用名词<br>| 请求方法（HTTP动词） | URI后缀                        | 动作解释                               |<br>| ——————– | ————————– | ————————————-|<br>| <strong>head</strong>     | <code>/student/</code>               | 获取学生，请求获取URL位置资源的响应消息报告，头部信息元数据 |<br>| <strong>GET</strong>      | <code>/students/</code>               | 获取所有学生信息列表 ，请求获取URL位置的资源  |<br>| <strong>GET</strong>      | <code>/students/ID/</code>            | 获取指定ID的学生信息                   |<br>| <strong>GET</strong>      | <code>/students/ID/friends/</code>    | 列出查看指定ID的学生的所有朋友信息（商品的所有投资者） |<br>| <strong>GET</strong>      | <code>/students/ID/friends/ID/</code>  | 列出查看指定ID的学生的所有朋友信息 商品的指定投资者信息|<br>| <strong>POST</strong>     | <code>/students/</code>               | 新建一个学生，请求向URL位置的资源后附加新的数据 |<br>| <strong>PUT</strong>      | <code>/students/ID/</code>            | 更新指定ID的学生信息（提供该学生的全部字段信息）请求向URL位置存储一个资源，覆盖原URL位置的资源|<br>| <strong>PATCH</strong>    | <code>/students/ID/</code>            | 更新指定ID的学生信息（提供该学生的部分字段信息）请求局部更新URL位置的资源，覆盖原URL位置的资源|<br>| <strong>DELETE</strong>   | <code>/students/ID/</code>            | 删除指定ID的学生信息，请求删除URL位置存储的资源 |<br>| <strong>DELETE</strong>   | <code>/students/ID/friends/ID/</code> | 删除指定ID的学生的指定ID的朋友           </p>
<ul>
<li>一般 web 框架都有相应的插件支持 RESTful API。比如Django有 rest framework，Flask和Tornado分别有flask restful 和 tornado restful。<br>现在主流的web框架都是相关的RESTful API插件。</li>
</ul>
<p>如何设计RESTful API<br>请求规范：</p>
<ul>
<li>协议：API与用户的通信协议，使用 HTTPs 协议，确保交互数据的传输安全。</li>
<li>域名：应该尽量将 API 部署在专用域名之下。i.e (<a href="https://api.example.com)[https://api.example.com]">https://api.example.com)[https://api.example.com]</a></li>
<li>版本控制：将版本号放在 URL 或者 HTTP头 Header 中 (<a target="_blank" rel="noopener" href="https://api.example.com/v1/)[https://api.example.com/v1/]">https://api.example.com/v1/)[https://api.example.com/v1/]</a></li>
<li>路径：只能包含复数名词且与数据库的表名对应，不能包括动词，因为是定位和指向资源。单⼀资源操作 books/1/</li>
<li>URI使用嵌套表示关联关系，(<a target="_blank" rel="noopener" href="https://api.example.com/v1/users/12/repos/5)[https://api.example.com/v1/users/12/repos/5]">https://api.example.com/v1/users/12/repos/5)[https://api.example.com/v1/users/12/repos/5]</a></li>
<li>请求方法，如：GET/POST/PUT/DELETE</li>
<li>不符合CRUD的情况：POST /action/子资源</li>
</ul>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET <code>/zoo/ID/animals</code> 与 GET <code>/animals?zoo_id=ID</code> 的含义是相同的。</p>
<p>前端向后端传递参数的方式</p>
<ul>
<li>路径，路由中正则提取</li>
<li>查询字符串 GET获取</li>
<li>请求头 META获取</li>
<li>请求体<ul>
<li>表单数据 POST</li>
<li>body json</li>
<li>FILES</li>
</ul>
</li>
<li>根据模型类确定传递的字段 保存或更新 json</li>
<li>字段过滤 分页 查询字符串形式传递<ul>
<li><code>?limit=10</code> 指定返回记录的数量</li>
<li><code>?offset=10</code> 指定返回记录的开始位置。</li>
<li><code>?page=2&amp;per_page=100</code>：指定第几页，以及每页的记录数。</li>
<li><code>?sortby=name&amp;order=asc</code>：指定返回结果按照哪个属性排序，以及排序顺序</li>
<li><code>?animal_type_id=1</code>：指定筛选条件</li>
</ul>
</li>
<li></li>
</ul>
<p>响应设计规范<br>查询</p>
<p>状态码</p>
<p>错误处理（Error handling）<br>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。<br>错误异常信息，决定API的优劣程度，如果返回的错误异常信息不够标准，客户端很难处理错误。</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    'error': "Invalid API key",</span><br><span class="line">    "msg": "xxx", // 错误异常信息</span><br><span class="line">    "error_code": 1000, // 错误码</span><br><span class="line">    "request": url // 当前的http请求url路径</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2.4.3 返回信息分类<br>业务数据信息。<br>操作成功提示信息。</p>
<ol start="3">
<li>异常处理</li>
<li>1 已知异常<br>我们可以预知的异常。 解决办法：抛出APIException。</li>
</ol>
<p>3.2 未知异常<br>我们没有意识到的异常，如何统一数据的返回格式？即json格式。</p>
<p>解决办法：在全局的某个地方捕获到所有未知异常，统一处理未知异常——AOP思想。 将未知异常分为两种：HTTPException/Exception。分别代表HTTP错误和服务器代码错误，最后都包装成APIException抛出。</p>
<ul>
<li>Hypermedia API：在返回结果中提供相关资源的url链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。<br>　　比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{<span class="attr">"link"</span>: { </span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span>}}</span><br></pre></td></tr></tbody></table></figure>
上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>　　Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="attr">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="comment">// ...}</span></span><br></pre></td></tr></tbody></table></figure>
从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span>}</span><br></pre></td></tr></tbody></table></figure>
上面代码表示，服务器给出了提示信息，以及文档的网址。</li>
</ul>
<p>安全</p>
<ul>
<li>HTTPS</li>
<li>限流 Rate limiting</li>
<li>验证鉴权（Authentication）：确定用户是其申明的身份，比如提供账户的密码。</li>
<li>授权（Authorization）：保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访可，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等。</li>
</ul>
<p>开发者友好</p>
<ul>
<li>文档</li>
<li>超媒体</li>
</ul>
<p>DRF通过视图集ViewSet的方式让我们对某一个数据类Model可以进行增删改查，<br>而且不同的操作对应于不同的请求方式，<br>比如查看所有books用get方法，添加一本book用post方法等，让整个后端服务是restful的。</p>
<p>前端的展示和表单，希望达到两个目标，一是能从后端请求到所有的books列表，二是能往后端添加一条book数据。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.route('', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_book</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'get book'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'create book'</span></span><br></pre></td></tr></tbody></table></figure>

<p>REST的使用场景有两个：内部开发API，开放API。</p>
<p>标准的REST 不适合内部开发，适合开放性的API。只负责提供数据，不负责业务逻辑、不关心具体的前端是什么<br>因为标准 REST 有 CURD 四种操作，不一定能够承载业务。<br>缺点</p>
<ol>
<li><p>由于内部的开发，业务逻辑非常复杂，想用简单的四个接口来标示所有的业务逻辑，基本上是不可能的，会在视图函数增加大量的参数适配复杂的逻辑</p>
</li>
<li><p>REST的接口粒度比较粗（返回的资源属性比较多；服务器不会负责处理数据），这样前端的开发是不太方便的<br>比如前端需要用户的年龄，但是 user 类下面有 name、iphone、age、email、password 等，查询返回的就是整个 user 的信息，需要前端而不是服务器再进行筛选！</p>
</li>
<li><p>标准的REST 不考虑业务逻辑，一个接口只返回一个资源，当需要返回多个有关联资源时，无法一次性全部返回，只能发送多个请求依次取得数据，造成 HTTP 请求的数量大幅增加。</p>
</li>
</ol>
<ul>
<li>尽量遵从REST的设计风格规范，同时也不要死板追求 REST 要求，要灵活一些，</li>
<li>如果前端需要接口考虑业务逻辑的话，那么我们的接口就不要完全遵守资源的限制，应该让API具有业务逻辑的性质</li>
<li>如果前端需要几个资源合并在一起的数据，那么我们就为前端定制一个合并数据的接口，一次性把数据全部返回到前端</li>
</ul>
<ol start="4">
<li>Token<br>用户有效身份的凭据。</li>
</ol>
<p>4.1 三个特征<br>有效期，一般为2小时。<br>标识用户的身份，存储用户ID号。<br>Token是加密的。<br>4.2 Token有什么用<br>4.2.1 保护接口（auth拦截器）<br>只有登录的用户，才可访问某些接口，而是否可访问的校验通过Token实现。 访问接口时若令牌没有过期，而且合法，那么可以通过接口进行正确操作。</p>
<p>4.3 Token如何使用<br>可自定义传入账号和密码，但HTTP协议本身就规定了一种传递账号和密码的方法。 将账号和密码放入header中发送：<br>key=Authorization<br>value=basic base64(account:password)<br>将Token当作account发送，password不传任何数据。<br>4.4 验证Token的代码应该写在什么地方？<br>利用装饰器，哪个接口需要Token验证，就在哪个接口上方加入装饰器。</p>
<p>关于用户的思考<br>不管是网站也好，还是API也好，我们都逃脱不了用户这个概念，我们下面就要来讨论用户的相关操作。</p>
<p>对于用户而言，第一件事情，我们就要完成用户注册的操作，说到注册用户，我们想到，可以在视图函数文件中增加一个注册用户的视图函数–create_user，并且我们会在其中接受账号和密码，来完成用户的注册，这个逻辑是通常意义上的用户的概念。</p>
<p>普通用户：使用鱼书的人相对于鱼书来说，就是用户；我们相对于QQ和微信，也是他的用户。</p>
<p>但是我们在做API的时候，不能只考虑这些普通意义的用户，我们还要考虑一些特别的用户。例如：我们开发了一个向外提供数据的API，假如有一天，有一个公司，想使用我们的API开发他们自己的产品（小程序或者APP），这些其他的客户端，都是我们API的用户。</p>
<p>根据以上的分析，我们可以得出几个结论：<br>对于API而言，再叫做用户就不太合适 ，我们更倾向于把人，第三方的产品等同于成为客户端（client）来代替User。</p>
<p>客户端的种类非常多，注册的形式就非常多。如对于普通的用户而言，就是账号和密码，但是账号和密码又可以分成，短信，邮件，社交用户。对于多种的注册形式，也不是所有的都需要密码，如小程序就不需要。<br>API和普通的业务系统是不一样的，他具有开放性和通用性。</p>
<p>因为注册的形式就非常多，所以我们不可能用万能的方式来解决。如果我们不能很好的处理多种多样的形式，我们的代码就会非常的杂乱。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/selenium/" rel="prev" title="selenium">
                  <i class="fa fa-chevron-left"></i> selenium
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/pycharm-kuai-jie-jian-keymap/" rel="next" title="pycharm 快捷键 keymap">
                  pycharm 快捷键 keymap <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
