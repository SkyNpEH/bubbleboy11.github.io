<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号 TCP基于字节流的传输层通信协议，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。 1.面向连接的单播协议：在发送数据前， 通信双方必须先在彼此间建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。 2">
<meta property="og:type" content="article">
<meta property="og:title" content="握手挥手">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号 TCP基于字节流的传输层通信协议，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。 1.面向连接的单播协议：在发送数据前， 通信双方必须先在彼此间建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-07-27T14:21:42.258Z">
<meta property="article:author" content="外心人D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/","path":"2020/08/21/wo-shou-hui-shou/","title":"握手挥手"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>握手挥手 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">三次握手的过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text">TCP四次挥手，状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">为什么需要三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="nav-text">为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">抓包分析三次握手和四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5time-wait%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852msl"><span class="nav-text">为啥time_wait需要等待2msl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E7%9A%84close-wait"><span class="nav-text">为啥会出现大量的close_wait?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E4%B8%BA%E5%95%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">UDP为啥不需要流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP为啥需要流量控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP为啥需要拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="nav-text">TCP粘包、拆包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="nav-text">为什么会出现粘包、拆包?</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">341</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/wo-shou-hui-shou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          握手挥手
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-27 14:21:42" itemprop="dateModified" datetime="2021-07-27T14:21:42Z">2021-07-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号</p>
<p>TCP基于字节流的传输层通信协议，它会处理IP层或以下的层的丢包、重复以及错误问题。<br>在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>1.面向连接的单播协议：<br>在发送数据前， 通信双方必须先在彼此间建立好连接才能进行数据的传输，数据传输完成后，双方必须断开此连接，以释放系统资源。</p>
<p>2.可靠传输：</p>
<ul>
<li>TCP 采用发送应答机制</li>
<li>超时重传</li>
<li>错误校验</li>
<li>流量控制和阻塞管理</li>
</ul>
<p>TCP服务模型<br>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。<br>一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p>
<p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p>
<p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p>
<p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。<br>因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。<br>另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。<br>因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>
<p>TCP头部<br>源端口和目的端口在TCP层确定双方进程，<br>序列号表示的是报文段数据中的第一个字节号，<br>ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p>
<p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p>
<p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p>
<p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p>
<p>TCP的三次握手建立一个连接和四次挥手来关闭一个连接<br>第一状态转换，第二就是发包的内容。</p>
<p>sequence number Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>URG Urgent:紧急位,URG=1,表示紧急数据<br>PSH Push:推送位,PSH=1,尽快吧数据交付给应用层</p>
<p>SYN：Synchronizaion Sequence Numbers 同步序列编号标志位，用于初如化一个连接的序列号。 是TCP/IP建立连接时使用的握手信号。SYN=1表示连接请求报文<br>SYN_SENT 同步已发送状态</p>
<p>Acknowledge，是标志位中的ACK确认号标志；<br>Acknowledgment number， ack是确认序列号 ACK=1,确认序号字段才生效 占32位，Ack=Seq+1。</p>
<p>SYN_RECV 同步收到状态，</p>
<p>ESTABLISHED 已建立连接状态<br>CLOSED 关闭状态<br>LISTEH 收听状态<br>RST —— （reset by peer）重置连接位 RST=1,重新建立连接<br>FIN —— 该报文段的发送方已经结束向对方发送数据。终止位,FIN=1表示释放连接,表明此报文的发送方的数据已经发送完毕，并且要求释放；</p>
<p>ISN(Initial Sequence Number),三次握手的一个重要功能是客户端和服务端交换isn 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号。<br>ISN = M + F(localhost, localport, remotehost, remoteport)<br>M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p>
<p>TCP连接的建立采用客户服务器方式。<br>主动发起连接建立的应用进程叫做客户( client )。<br>被动等待连接建立的应用进程叫做服务器( server )。<br>最初两端的TCP进程都处于 CLOSED(关闭)状态，<br>client 端主动打开链接，<br>而 server 端被动打开链接。</p>
<p>服务器端准备接受连接请求后进入到 LISTEN(收听状态)，等待客户端连接请求。<br>客户端需要建立连接时向服务器端发送请求，请求内容包括同步位 SYN=1 和初始序号 seq =J 即ISN(c)，这时客户端进入SYN_SENT(同步已发送)状态。</p>
<p>服务器接收到请求后作出响应，向客户端发送确认信息，确认信息包括同步位 SYN=1、确认位ACK=1ISN(s)、确认号 ack=J+1 和自己初始序号 seq=K，这时服务端进入 SYN_RECV(同步收到)状态。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</p>
<p>客户端收到服务器端发过来的确认信息后，先进行验证确认号 ack=J + 1，此时还需向服务器端发送确认信息，确认信息包括确认位 ACK=1 和 确认号ack=K+1，这时TCP连接已经建立，客户端进入 ESTABLISHED状态。服务器端接收到确认后，也进入到established状态。</p>
<p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
<h4 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h4><p>第一次握手：<br>客户端发送syn请求包(syn=1)到服务器，Seq=x(随机产生的顺序号码)<br>并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：<br>服务器收到syn请求包，必须确认客户的SYN（确认号ack=x+1），并返回一个ACK应答，同时自己也发送一个SYN请求包 Seq=y(随机产生)，此时服务器进入SYN_RECV状态；<br>客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p>第三次握手：<br>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK=1 ack=y+1，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始建立连接,数据传输。<br>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。客户端收到服务端的SYN请求和ACK应答，发送ACK应答，客户端进入ESTABLISH状态，服务端收到应答后进入ESTABLISH。<br>如果没有收到应答，数据包都会根据TCP的重传机制进行重传。<br>客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p>
<p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>
<p>3次握手就跟早期打电话时的情况一样：1、听得到吗？2、听得到，你呢？3、我也听到了。然后才开始真正对话 4次挥手是：1、老师，下课了。2、好，我知道了，我说完这点。3、好了，说完了，下课吧。4、谢谢老师，老师再见</p>
<p>三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。<br>双工：发送和接收可以同时执行，连接的双方都可以相互发送和接收<br>因为连接是全双工的,双方必须都收到对方的FIN包及确认才可关闭。</p>
<p>但是为什么一定要进行三次握手来保证连接是双工的呢，一次不行么？两次不行么？我们举一个现实生活中两个人进行语言沟通的例子来模拟三次握手。</p>
<p>第一次对话：</p>
<p>   老婆让甲出去打酱油，半路碰到一个朋友乙，甲问了一句：哥们你吃饭了么？</p>
<p>结果乙带着耳机听歌呢，根本没听到，没反应。甲心里想：跟你说话也没个音，不跟你说了，沟通失败。说明乙接受不到甲传过来的信息的情况下沟通肯定是失败的。</p>
<p>如果乙听到了甲说的话，那么第一次对话成功，接下来进行第二次对话。</p>
<p>第二次对话：</p>
<p>   乙听到了甲说的话，但是他是老外，中文不好，不知道甲说的啥意思也不知道怎样回答，于是随便回答了一句学过的中文 ：我去厕所了。甲一听立刻笑喷了，“去厕所吃饭”?道不同不相为谋，离你远点吧，沟通失败。说明乙无法做出正确应答的情况下沟通失败。</p>
<p>如果乙听到了甲的话，做出了正确的应答，并且还进行了反问：我吃饭了，你呢？那么第二次握手成功。</p>
<p>通过前两次对话证明了乙能够听懂甲说的话，并且能做出正确的应答。接下来进行第三次对话。</p>
<p>第三次对话：</p>
<p>甲刚和乙打了个招呼，突然老婆喊他，“你个死鬼，打个酱油咋这么半天，看我回家咋收拾你”，甲是个妻管严，听完吓得二话不说就跑回家了，把乙自己晾那了。乙心想：这什么人啊，得，我也回家吧，沟通失败。说明甲无法做出应答的情况下沟通失败。</p>
<p>如果甲也做出了正确的应答：我也吃了。那么第三次对话成功，两人已经建立起了顺畅的沟通渠道，接下来开始持续的聊天。</p>
<p>通过第二次和第三次的对话证明了甲能够听懂乙说的话，并且能做出正确的应答。</p>
<p>可见，两个人进行有效的语言沟通，这三次对话的过程是必须的。</p>
<p>同理对于TCP为什么需要进行三次握手我们可以一样的理解：</p>
<p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<p>为什么要进行三次握手，不是二次握手<br>谢希仁版《计算机网络》中的例子:<br>“已失效的连接请求报文段”的产生在这样一种情况下：<br>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。<br>本来这是一个早已失效的报文段,但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。<br>于是就向client发出确认报文段，同意建立连接。</p>
<p>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。<br>由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据,但server却以为新的运输连接已经建立，并一直等待client发来数据。<br>这样，server的很多资源就白白浪费掉了。<br>采用“三次握手”的办法可以防止上述现象发生。<br>例如刚才那种情况，client不会向server的确认发出确认,server由于收不到确认，就知道client并没有要求建立连接。”<br>这个例子很清晰的阐释了“三次握手”对于建立可靠连接的意义。</p>
<h3 id="TCP四次挥手，状态转换"><a href="#TCP四次挥手，状态转换" class="headerlink" title="TCP四次挥手，状态转换"></a>TCP四次挥手，状态转换</h3><p>主动方可以是服务器端也可以是客户端。</p>
<p>FIN(FINbit) 终止标志位   |   FIN_WAIT_1 终止等待1状态    |    FIN_WAIT_2 终止等待2状态</p>
<p>ACK(ACKbit) 确认标志位 |   CLOSE_WAIT 关闭等待状态  |    LAST_ACK 最后确认状态</p>
<p>ESTABLISHED 已建立连接状态    |    TIME_WAIT 时间等待状态    |    CLOSED 关闭状态</p>
<p>数据传输结束后，通信的双方都可以释放连接。最初客户端和服务器端都处于extablished状态。例如：客户端主动发起连接释放。</p>
<p>客户端向服务器端发送连接释放请求，主动关闭TCP连接，请求内容包括终止控制位 FIN=1 和 希望接收者看到的自己当前的序列号 seq=x，这时客户端进入 FIN_WAIT_1(终止等待1)状态，等待服务器端的确认。</p>
<p>服务器端收到连接释放请求后即发出确认信息，确认信息包括 确认位 ACK=1 和 确认号ack(ACKnum) = x+1，表明收到了上一个包，上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作进入到CLOSE_WAIT(关闭等待)状态，此时客户端已没有数据发送了，但服务器端还可以向客服端发送数据，服务器端到客户端这个方向的连接并未关闭。客户端收到确认请求后，就进入到 FIN_WAIT_2 ( 终止等待2 )状态。</p>
<p>当服务器端已经没有向客户端要发送的数据时候，会向客户端发送连接释放请求，请求内容包括 终止控制位 FIN=1 、序号seq=y 和 上次已经发送过的确认号 ack(ACKnum) = x+1，这时服务器进入 LAST_ACK(最后确认)状态，等待客户端的确认。</p>
<p>客户端收到连接释放请求，必须给服务器端发送确认，确认信息包括 确认位 ACK=1、确认号ack(ACKnum) = y+1，这时客户端进入TIME_WAIT(时间等待)状态，这时TCP连接还没释放掉，必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，客户端才进入到 CLOSED(关闭)状态。服务器端收到确认后，就进入closed(关闭)状态。</p>
<p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。<br>当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。<br>这时对方会回一个ACK，此时一个方向的连接关闭。<br>但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。<br>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，<br>因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<p>“三次握手，四次挥手”怎么完成？<br>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p>
<p>3次握手是指发送了3个报文段，<br>4次挥手是指发送了4个报文段。<br>SYN和FIN段都是会利用重传进行可靠传输的。</p>
<p>HTTP请求过程<br>一、一个完整的HTTP请求，通常有7个步骤：<br>1、建立TCP连接；<br>2、web浏览器向web服务器发送请求命令；<br>3、浏览器发送请求头信息；<br>4、服务器应答；<br>5、服务器发送应答头信息；<br>6、服务器向浏览器发送数据；<br>7、服务器关闭TCP连接。</p>
<p>readyState属性(返回请求的当前状态)：<br>0：请求未初始化，open还没有调用；<br>1：服务器连接已建立，open已经调用；<br>2：请求已接收，即，接收到头部信息了；<br>3：请求处理中，即，接收到响应体了；<br>4：请求已完成，且响应已就绪，即，响应完成了。</p>
<p>（TCP的标志为：SYN/ACK）<br>1、三次握手<br>（1）发送端——-数据包（SYN）————-&gt;接收端<br>（2）接收端————–数据包（SYN/ACK)——&gt;发送端<br>（3）发送端——-数据包（ACK）————-&gt;接收端</p>
<p>2、四次挥手<br>（1）主动关闭方——TIN（关闭数据传送）—————–&gt;被动关闭方；<br>（2）被动关闭方————ACK（确认序号为收到序号+1）————–&gt;主动关闭方；<br>（3）被动关闭方————FIN（关闭数据传送）———————-&gt;主动关闭方；<br>（4）主动关闭方——ACK（确认序号为收到序号+1）———-&gt;被动关闭方。</p>
<ol start="3">
<li>客户端收到FIN的应答后进入FIN_WAIT2状态</li>
<li>服务端发送FIN请求包，进入LAST_ACK状态</li>
<li>客户端收到FIN请求包后，发送应答进入TIME_WAIT状态</li>
<li>服务器收到ACK应答后，进入close状态。</li>
</ol>
<p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p>
<p>第一次挥手<br>客户端发送FIN=1，请求断开连接，客户端进入FIN_WAIT1状态 Seq=u<br>用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了 数据传完了可以关闭了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</p>
<p>第二次挥手<br>服务端被动关闭方收到FIN包后，返回应答发送一个ACK=1给客户端，进入CLOSE_WAIT状态，确认序号为收到序号ack=u+1（与SYN相同，一个FIN占用一个序号）。</p>
<p>第三次挥手<br>被动关闭方发送一个FIN=1, ack=u+1, Seq=w, ACK=1 用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手<br>主动关闭方收到FIN=1后，发送一个ACK=1给被动关闭方，确认序号为收到序号ack=w+1，Seq=u+1至此，完成四次挥手。连接断开</p>
<h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>已经失效的连接请求报文传送到对方，引起错误<br>如果不进行第三次握手，就会导致一个现象，发送方发送的连接请求由于网络原因(超时重传)，发送多个连接请求，导致建立多个连接.</p>
<h4 id="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h4><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<p><img src="/2020/08/21/wo-shou-hui-shou/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="description"><br><img src="/2020/08/21/wo-shou-hui-shou/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="description"></p>
<h4 id="抓包分析三次握手和四次挥手"><a href="#抓包分析三次握手和四次挥手" class="headerlink" title="抓包分析三次握手和四次挥手"></a>抓包分析三次握手和四次挥手</h4><p><img src="/2020/08/21/wo-shou-hui-shou/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<p>查看正在使用的网卡名：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@VM-0-9-centos</span> <span class="string">~</span>]<span class="comment"># cat /proc/net/dev</span></span><br><span class="line"><span class="string">Inter-|</span>   <span class="string">Receive</span>                                                <span class="string">|</span>  <span class="string">Transmit</span></span><br><span class="line"> <span class="string">face</span> <span class="string">|bytes</span>    <span class="string">packets</span> <span class="string">errs</span> <span class="string">drop</span> <span class="string">fifo</span> <span class="string">frame</span> <span class="string">compressed</span> <span class="string">multicast|bytes</span>    <span class="string">packets</span> <span class="string">errs</span> <span class="string">drop</span> <span class="string">fifo</span> <span class="string">colls</span> <span class="string">carrier</span> <span class="string">compressed</span></span><br><span class="line"><span class="attr">veth91c37ec:</span> <span class="number">4855293</span>   <span class="number">22637</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span>  <span class="number">2435595</span>   <span class="number">26456</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  <span class="attr">eth0:</span> <span class="number">15742648569</span> <span class="number">124304860</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">22557456586</span> <span class="number">124485545</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"><span class="attr">veth5d20c56:</span> <span class="number">232945872</span> <span class="number">1129290</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">235971602</span> <span class="number">1408301</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">    <span class="attr">lo:</span> <span class="number">523617601</span> <span class="number">6698896</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">523617601</span> <span class="number">6698896</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"><span class="attr">vethf71aa18:</span> <span class="number">265381972</span> <span class="number">1842358</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">315445452</span> <span class="number">1476199</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"><span class="attr">br-6247fbae3754:</span> <span class="number">190506345</span>  <span class="number">901637</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">158227422</span>  <span class="number">905225</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"><span class="attr">docker0:</span> <span class="number">9470848</span>   <span class="number">29814</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span>  <span class="number">5014157</span>   <span class="number">34837</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">[<span class="string">root@VM-0-9-centos</span> <span class="string">~</span>]<span class="comment"># sudo tcpdump -n -S -i eth0 host www.baidu.com and tcp port 80</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="为啥time-wait需要等待2msl"><a href="#为啥time-wait需要等待2msl" class="headerlink" title="为啥time_wait需要等待2msl"></a>为啥time_wait需要等待2msl</h4><ul>
<li>msl maximum segment lifetime: 最大段的生命周期 最长包的传输时间（30秒-1分钟）</li>
<li>保证TCP 协议的全双工连接可以可靠关闭</li>
<li>保证这次连接的重复数据段从网络中消失</li>
</ul>
<h4 id="为啥会出现大量的close-wait"><a href="#为啥会出现大量的close-wait" class="headerlink" title="为啥会出现大量的close_wait?"></a>为啥会出现大量的close_wait?</h4><ul>
<li>首先close_wait一般出现在被动关闭方</li>
<li>并发请求太多导致</li>
<li>被动关闭方未及时释放端口资源导致</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">//1、监听端口</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:9090"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Printf(<span class="string">"listen fail, err: %v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2.建立套接字连接</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">            fmt.Printf(<span class="string">"accept fail, err: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//3. 创建处理协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> {</span><br><span class="line">            <span class="comment">//defer conn.Close() //这里不填写，服务端会出现close_wait状态，客户端会有finish_wait状态</span></span><br><span class="line">            <span class="keyword">for</span> {</span><br><span class="line">                <span class="keyword">var</span> buf [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">                n, err := conn.Read(buf[:])</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                    fmt.Printf(<span class="string">"read from connect failed, err: %v\n"</span>, err)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                }</span><br><span class="line">                str := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">                fmt.Printf(<span class="string">"receive from client, data: %v\n"</span>, str)</span><br><span class="line">            }</span><br><span class="line">        }(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="UDP为啥不需要流量控制"><a href="#UDP为啥不需要流量控制" class="headerlink" title="UDP为啥不需要流量控制"></a>UDP为啥不需要流量控制</h4><p>非连接不可靠的通信，每一次发送需要绑定ip和端口，发送出去不需要确认，不需要三次握手</p>
<h4 id="TCP为啥需要流量控制"><a href="#TCP为啥需要流量控制" class="headerlink" title="TCP为啥需要流量控制"></a>TCP为啥需要流量控制</h4><ul>
<li>由于通讯双方，网速不同，通讯方任一方发送过快都会导致对方消息处理不过来，所以就需要吧数据放到缓冲区中</li>
<li>如果缓冲区满了，发送方还在疯狂发送，那接收方只能吧数据包丢弃，因此我们需要控制发送速率。</li>
<li>我们缓冲区剩余大小称之为接收窗口，用变量win表示，如果接收方的win=0，则发送方停止发送</li>
</ul>
<p><a href="%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png"></a></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li>流量控制考虑点对点的通信量的控制</li>
<li>拥塞控制考虑整个网络，是全局性的考虑</li>
</ul>
<h4 id="TCP为啥需要拥塞控制"><a href="#TCP为啥需要拥塞控制" class="headerlink" title="TCP为啥需要拥塞控制"></a>TCP为啥需要拥塞控制</h4><ul>
<li>拥塞控制是调节网络的负载</li>
<li>接收方网络资源繁忙，因未及时响应ack导致发送方重传大量数据，这样将导致网络更加拥塞</li>
<li>拥塞控制是动态调整win大小，不只是依赖缓冲区大小确定窗口大小</li>
</ul>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>tcp 拥塞控制包括2部分</p>
<ul>
<li>慢开始和拥塞避免</li>
<li>快速重传和快速恢复 （如果收到三个重复的ack,执行快速重传，当前窗口值变为原来的一半）<br><img src="/2020/08/21/wo-shou-hui-shou/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"></li>
</ul>
<h3 id="TCP粘包、拆包"><a href="#TCP粘包、拆包" class="headerlink" title="TCP粘包、拆包"></a>TCP粘包、拆包</h3><h4 id="为什么会出现粘包、拆包"><a href="#为什么会出现粘包、拆包" class="headerlink" title="为什么会出现粘包、拆包?"></a>为什么会出现粘包、拆包?</h4><ul>
<li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包</li>
<li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包</li>
<li>进行MSS(最大报文长度)大小的TCP分段，当“TCP报文长度-TCP头部长度&gt;MSS”的时候将发生拆包</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/cao-zuo-xi-tong-de-nei-cun-guan-li-ji-zhi-fen-ye-he-fen-duan-ji-fen-ye-he-fen-duan-de-qu-bie/" rel="prev" title="操作系统的内存管理机制--分页和分段 及 分页和分段的区别">
                  <i class="fa fa-chevron-left"></i> 操作系统的内存管理机制--分页和分段 及 分页和分段的区别
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/jie-kou-ce-shi/" rel="next" title="接口测试">
                  接口测试 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
