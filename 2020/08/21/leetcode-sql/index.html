<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="正常情况下SELECT的书写顺序和执行顺序 写法顺序：SELECT →FROM → JOIN → ON → WHERE → GROUP BY → HAVING → ORDER BY→ LIMIT 123456789SELECT 查询列表                ⑦                    FROM 表 1                    ①">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode sql">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/leetcode-sql/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="正常情况下SELECT的书写顺序和执行顺序 写法顺序：SELECT →FROM → JOIN → ON → WHERE → GROUP BY → HAVING → ORDER BY→ LIMIT 123456789SELECT 查询列表                ⑦                    FROM 表 1                    ①">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-06-29T02:54:28.634Z">
<meta property="article:author" content="外心人D">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/leetcode-sql/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/leetcode-sql/","path":"2020/08/21/leetcode-sql/","title":"leetcode sql"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leetcode sql | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%B3%95%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="nav-text">写法顺序：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="nav-text">执行顺序：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8"><span class="nav-text">175. 组合两个表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#177-%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4"><span class="nav-text">177. 第N高的薪水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#178-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D"><span class="nav-text">178. 分数排名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#180-%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">180. 连续出现的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5"><span class="nav-text">181. 超过经理收入的员工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1"><span class="nav-text">182. 查找重复的电子邮箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7"><span class="nav-text">183. 从不订购的客户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5"><span class="nav-text">184. 部门工资最高的员工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#185-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5"><span class="nav-text">185. 部门工资前三高的所有员工</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">322</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/leetcode-sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode sql
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 02:54:28" itemprop="dateModified" datetime="2021-06-29T02:54:28Z">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Markdown/" itemprop="url" rel="index"><span itemprop="name">Markdown</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>正常情况下SELECT的书写顺序和执行顺序</p>
<h3 id="写法顺序："><a href="#写法顺序：" class="headerlink" title="写法顺序："></a>写法顺序：</h3><p>SELECT →FROM → JOIN → ON → WHERE → GROUP BY → HAVING → ORDER BY→ LIMIT</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 查询列表                ⑦                    </span><br><span class="line"><span class="keyword">FROM</span> 表 <span class="number">1</span>                    ①                                      </span><br><span class="line">【连接类型】 <span class="keyword">JOIN</span> 表 <span class="number">2</span>        ③                           </span><br><span class="line"><span class="keyword">ON</span> 连接条件                    ②</span><br><span class="line"><span class="keyword">WHERE</span> 筛选条件                ④</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组列表            ⑤</span><br><span class="line"><span class="keyword">HAVING</span> 分组后的筛选条件        ⑥</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序的字段            ⑧</span><br><span class="line"><span class="keyword">LIMIT</span> 起始的条目索引，条目数;    ⑨</span><br></pre></td></tr></tbody></table></figure>

<h3 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h3><p>FROM → ON → JOIN → WHERE → GROUP BY → with HAVING → SELECT → ORDER BY→ LIMIT<br>TOP</p>
<p>若 每页显示条目数：<code>pageSize</code>，要显示的页数：<code>page</code><br>则有：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表 <span class="keyword">LIMIT</span> （page<span class="number">-1</span>）* pageSize,pageSize</span><br></pre></td></tr></tbody></table></figure>

<p>解题方法<br>根据考题要搞清楚表的结果和多表之间的关系，根据想要的结果思考使用那种关联方式，通常把要查询的列先写出来，然后分析这些列都属于哪些表，才考虑使用关联查询</p>
<p>其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤</p>
<p>因为ON是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，WHERE也应该比HAVING快点的，因为它过滤数据后才进行SUM，在两个表联接时才用ON的，所以在一个表的时候，就剩下WHERE跟HAVING比较了。</p>
<p>表连接，同时查询多张表格，效率高于子查询<br>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p>
<p>from子句中on条件主要用来连接表，其他不属于连接表的条件可以使用where子句来指定；<br>考虑联接优先顺序：<br>join连接分为三种  外连接的outer 和内连接的inner 都可以省略：</p>
<ol>
<li>内连接 inner join ，默认，所以可以省略inner关键字，又叫等值连接，只返回两个表中不一定必须有同名字段，只要连接字段相等的行、公共数据、符合连接条件。查询条件放在&nbsp;on子句和where子句的返回的结果集是相同的。<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id=B.id</span><br></pre></td></tr></tbody></table></figure>
或者<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">Join</span> b <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> a <span class="keyword">Join</span> b <span class="keyword">on</span> A.id=B.id <span class="keyword">JOIN</span> c <span class="keyword">on</span> B.id=c.id;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>自连接（自身连接）的本质是把一张表复制出多张一模一样的表来使用。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名 </span><br><span class="line"><span class="keyword">from</span> 表名 <span class="keyword">as</span> 别名<span class="number">1</span>,表名 <span class="keyword">as</span> 别名<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> A T2 <span class="keyword">ON</span> T1.id=T2.pid</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><p>外连接 outer join 是指的要保存未匹配信息 包括<br>left join,在mysql是left outer join的简写 ，左外连接，左联结</p>
<p>在使用&nbsp;left jion&nbsp;时，on&nbsp;和&nbsp;where&nbsp;条件的区别如下：<br>• on&nbsp;条件是在生成临时表时使用的补充条件，以左表为主,先查询出左表,不管&nbsp;on&nbsp;上的条件是否为真，都会返回左表的全部数据都会在结果集中，左表有而右表中不匹配的行，右表选择字段列置为null<br>• where&nbsp;条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有&nbsp;left join&nbsp;的含义（必须返回左边表的记录）了，条件不为真的就过滤掉，条件真假直接影响结果实际的执行效果相当于inner join .</p>
</li>
</ol>
<p>right join right outer join ，右外连接，结果表中除了匹配行外，还包括右表有而左表中不匹配的行，对于这样的行，左表选择列置为null </p>
<ol start="3">
<li>full join 是full outer join的简写，全连接，<br>mysql不支持full outer join，Mysql可以用left join+union+right join来解决<br>将多个查询语句的结果进行合并</li>
</ol>
<p>联合查询</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">FROM</span> B <span class="keyword">UNION</span></span><br></pre></td></tr></tbody></table></figure>
<p>就是把多个结果集集中在一起, UNION前的结果为基准,需要注意的是联合查询的列数要相等,相同的记录行会合并,字段个数相同，结果集字段名称相同</p>
<p>SELECT FRoM A left Join b on A id=B id UNIOn<br>SELECT FRoM A RIGHT Join BoN A. id=Bid</p>
<p>查询语句 union （查询语句）union （查询语句）<br>如果使用 UNION ALL,不会合并重复的记录行,会显示重复的数据<br>优化UNION查询 UNION ALL的效率高于UNION</p>
<p>natural join，自然连接，分为natural left outer join和natural right outer join，语义定义与inner join相同 </p>
<p>3：cross join，交叉连接，没有任何关联条件,将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积，就是第一个表的行数乘以第二个表的行数。结果集会很大,没有意义,很少使用</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A B(,C)</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)</span><br></pre></td></tr></tbody></table></figure>

<p>在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>
<p>子查询是一种查询中嵌套在 where子句 from子句 select子句查询的语句，<br>效率不好把握<br>不能写在order子句</p>
<p>当一个SQL语句的结果是作为另外一条SQL语句的条件时则需要用到子查询。</p>
<p>from子查询不是相关子查询，把结果集作为一张表，与其他的数据表做表连接</p>
<p>嵌套子查询：执行不依赖与外部的查询。<br>优化子查询：用关联查询替代<br>执行过程：先执行子查询再执行主查询<br>（1）执行子查询总共执行一次，执行完毕后结果不被显示，而是=将值传递给外部查询，作为外部查询的条件使用。<br>（2）执行外部查询，并显示整个结果。　　<br>嵌套子查询一般可以分为：</p>
<ol>
<li>返回单值的子查询 单行子查询：返回一条记录<br>查询底薪超过公司平均底薪的员工的信息<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHERE 价格 &gt;</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(价格)</span><br><span class="line">    <span class="keyword">FROM</span> Books</span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure></li>
<li>返回一个列表的子查询 ，多行子查询：返回多条记录，只能出现在where from子句<br>select子句中其他字段的一条记录没办法和子查询的多条记录合并</li>
</ol>
<p>相关子查询，先执行主查询再执行子查询。<br>外部查询执行一行，子查询就执行一次。执行依赖于外部查询。<br>优化关联查询<br>确定ON或者USING子句中是否有索引。<br>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。<br>一般是子查询的WHERE子句中引用了外部查询的表。<br>可以用IN、NOT IN、EXISTS、NOT EXISTS引入<br>执行过程：<br>（1）从外层查询中取出一个元组（即一行），将元组相关列的值传给内层查询。<br>什么是元组？关系是一张表，表中的每行bai（即数据库中的每条记录）就是一个元组。<br>（2）执行内层查询，得到子查询操作的值。<br>（3）外查询根据子查询返回的结果或结果集得到满足条件的行。<br>（4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。<br>对于外部查询返回的每一行数据，内部查询都要执行一次。另外，在关联子查询中是信息流是双向的。外部查询的每行数据传递一个值给子查询，然后子查询为每一行数据执行一次并返回它的记录。然后，外部查询根据返回的记录做出决策。</p>
<p>“选取出各商品种类中高于该商品种类的平均销售单价的商品。” 的关联子查询SELECT语句：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_type , product_name, sale_price</span><br><span class="line"><span class="keyword">FROM</span> Product <span class="keyword">AS</span> P1</span><br><span class="line"><span class="keyword">WHERE</span> sale_price &gt; (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sale_price)</span><br><span class="line">    <span class="keyword">FROM</span> Product <span class="keyword">AS</span> P2</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> product_type</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></figure>
<p>这个语句是错误的，原因是sale_price是一行数据，子查询的结果是3行数据，无法进行比较。更无法得到我们想要的“选取出各商品种类中高于该商品种类的平均销售单价的商品。”这个结果。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_type , product_name, sale_price</span><br><span class="line"><span class="keyword">FROM</span> Product <span class="keyword">AS</span> P1</span><br><span class="line"><span class="keyword">WHERE</span> sale_price &gt; (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sale_price)</span><br><span class="line">    <span class="keyword">FROM</span> Product <span class="keyword">AS</span> P2</span><br><span class="line">    <span class="keyword">WHERE</span> P1.product_type = P2.product_type</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> product_type</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></figure>
<p>实际上，‘WHERE P1.product_type = P2.product_type’这个语句是关联子查询，<br>关联子查询的执行逻辑和正常的SELECT语句执行逻辑完全不同<br>下面，我们来说明一下上面的关联子查询代码的执行过程：</p>
<p>先执行主查询， select 语句的 from，，把  Product 表里面每行数据查询出来，查询每一行数据，都要执行一次内层 select 语句，这个时候是完整的执行内层 select 语句，就是内层里面的 from … where … group by … select avg(sale_price)，作用是把和外层查询出来的一行数据里面的 type 相同的所有行取出来，算sale_price列的平均值，然后继续执行外层的 where 条件，最后选出需要的列数据</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_type , product_name, sale_price</span><br><span class="line"><span class="keyword">FROM</span> Product <span class="keyword">AS</span> P1</span><br></pre></td></tr></tbody></table></figure>

<p>该子查询从主查询一个“product_type”的值。而这个值是个变量，随SQLSever检索Product表中的不同行而改变<br>先将Product表中的第一条记录的“product_type”取第一个值=‘衣服’，通过WHERE P1.product_type = P2.product_type传入子查询，子查询变为：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">AVG</span>(sale_price)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    Product <span class="keyword">AS</span> P2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    P2.product_type = ‘衣服’</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    product_type);</span><br></pre></td></tr></tbody></table></figure>
<p>子查询得到的结果为该类product_type的平均价格，AVG(sale_price)=2500，<br>返回主查询：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_type , product_name, sale_price</span><br><span class="line"><span class="keyword">FROM</span> Product <span class="keyword">AS</span> P1</span><br><span class="line"><span class="keyword">WHERE</span> sale_price &gt; <span class="number">2500</span> <span class="keyword">AND</span> product_type = ‘衣服’</span><br></pre></td></tr></tbody></table></figure>
<p>如果WHERE条件为True，则第一条结果包括在结果集中，则否不包括。</p>
<p>然后，product _type取第二个值，得到整个语句的第二结果，依次类推，把product _type全取值一遍，所有行运行相同的过程，最后形成整个语句的的结果集及最后返回结果。</p>
<p>事实上，所有关联子查询的执行过程都和上面的过程一样。<br>（1）先从主查询的Product表中product _type列取出第一个值，进入子查询中，得到子查询结果，然后返回父查询，判断父查询的where子句条件，则返回整个语句的第1条结果。<br>（2）重复上述操作，直到所有主查询中的Product表中product _type列记录取完为止。得出整个语句的结果集，就是最后的答案。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table counttest(name char(1), age char(2));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into counttest values</span><br><span class="line">    -&gt; ('a', '14'),('a', '15'), ('a', '15'), </span><br><span class="line">    -&gt; ('b', NULL), ('b', '16'), </span><br><span class="line">    -&gt; ('c', '17'),</span><br><span class="line">    -&gt; ('d', null), </span><br><span class="line">    -&gt;('e', '');</span><br><span class="line">Query OK, 8 rows affected (0.01 sec)</span><br><span class="line">Records: 8  Duplicates: 0  Warnings: 0</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from counttest;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| name | age  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| a    | 14   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| b    | NULL |</span><br><span class="line">| b    | 16   |</span><br><span class="line">| c    | 17   |</span><br><span class="line">| d    | NULL |</span><br><span class="line">| e    |      |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(<span class="keyword">name</span>), <span class="keyword">count</span>(<span class="number">1</span>), <span class="keyword">count</span>(*), <span class="keyword">count</span>(age), <span class="keyword">count</span>(<span class="keyword">distinct</span>(age))</span><br><span class="line">    -&gt; <span class="keyword">from</span> counttest</span><br><span class="line">    -&gt; <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| a    |           3 |        3 |        3 |          3 |                    2 |</span><br><span class="line">| b    |           2 |        2 |        2 |          1 |                    1 |</span><br><span class="line">| c    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">| d    |           1 |        1 |        1 |          0 |                    0 |</span><br><span class="line">| e    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></tbody></table></figure>

<p>经典topN问题：每组最大的N条记录。<br>涉及到“既要分组，又要排序”的情况，要能想到用窗口函数来实现。</p>
<p>窗口函数，OLAP函数（Online Anallytical Processing，联机分析处理）<br>1）同时具有分组（partition by）和排序（order by）的功能<br>2）不减少原表的行数，所以经常用来在每组内排名<br>group by分组汇总后改变了表的行数，一行只有一个类别。<br>当一条sql语句没有group by的话，整张表的数据会自成一组。</p>
<p>比如下面的业务需求：<br>每组内排名问题：每个部门按业绩来排名<br>topN问题：找出每个部门排名前N的员工进行奖励：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;)</span><br></pre></td></tr></tbody></table></figure>
<p>partition子句可是省略，省略就是不指定分组排名<br>&lt;窗口函数&gt;的位置，可以放以下两种函数：<br>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。<br>2） 聚合函数，如sum. avg, count, max, min等</p>
<p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,</span><br><span class="line">   <span class="keyword">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> ranking,</span><br><span class="line">   <span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> dese_rank,</span><br><span class="line">   row_number() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> 班级</span><br></pre></td></tr></tbody></table></figure>
<p>专用窗口函数后面的括号不需要任何参数，保持()空着就可以。<br>1）rank函数：如果有并列名次的行，会占用下一名次的位置，同薪同名重复但总排名不连续。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。 </p>
<p>2）dense_rank函数：如果有并列名次的行，不占用下一名次的位置，同薪同名但总排名连续。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。 </p>
<p>3）row_number函数：不考虑并列名次的情况，连续排名不重复，。比如前3名是并列的名次，排名是正常的1，2，3，4。每一条数据加一个序号，用于分页查询<br> 例如薪水3000、2000、2000、1000排名结果为1-2-3-4，体现同薪不同名，排名类似于编号</p>
<p>聚和窗口函数和上面提到的专用窗口函数用法完全相同，只需要把聚合函数写在窗口函数的位置即可，但是函数后面括号里面不能为空，需要指定聚合的列名。聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。想要知道所有人成绩的总和、平均等聚合结果，看最后一行即可。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,</span><br><span class="line">   <span class="keyword">sum</span>(成绩) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 学号) <span class="keyword">as</span> current_sum,</span><br><span class="line">   <span class="keyword">avg</span>(成绩) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 学号) <span class="keyword">as</span> current_avg,</span><br><span class="line">   <span class="keyword">count</span>(成绩) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 学号) <span class="keyword">as</span> current_count,</span><br><span class="line">   <span class="keyword">max</span>(成绩) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 学号) <span class="keyword">as</span> current_max,</span><br><span class="line">   <span class="keyword">min</span>(成绩) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 学号) <span class="keyword">as</span> current_min</span><br><span class="line"><span class="keyword">from</span> 班级表</span><br></pre></td></tr></tbody></table></figure>

<p>查询结果排序，默认升序<br>select 字段1，字段2 from 表名 order by 列名 ASC或者DESC;</p>
<p>查询结果分页<br><code>limit y offset x</code>简写成<code>limit x, y</code><br>参数x为可选参数，表示查询结果跳过前 x 条数据，x 默认为 0，从第 x+1 条数据开始取，<br>参数y为必选参数，表示取前 y 条(行)数据</p>
<p>eg1：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">5</span>;     //检索前 5 个记录行</span><br></pre></td></tr></tbody></table></figure>
<p>等价于</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span>;     //检索前 5 个记录行,0可以省略不写</span><br></pre></td></tr></tbody></table></figure>
<p>eg2：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">10</span>;  // 检索记录行 6-15</span><br></pre></td></tr></tbody></table></figure>
<p>eg3：<br>为了检索某行开始到最后的所有数据，可以设置第二个参数为-1</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">95</span>,<span class="number">-1</span>; // 检索记录行 96-last</span><br></pre></td></tr></tbody></table></figure>

<h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a>175. 组合两个表</h3><p><strong>编写一个 SQL 查询，获取 Employee&nbsp;表中第二高的薪水（Salary）。</strong><br>表1: Person</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></tbody></table></figure>
<p>表2: Address</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></tbody></table></figure>
<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供&nbsp;person 的以下信息：</p>
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FirstName,</span> LastName, City, State</span><br></pre></td></tr></tbody></table></figure>

<p>使用 outer join<br>算法</p>
<p>因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。</p>
<p>考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。所以是左连接保留所有的人名。right连接的话是会保留右表所有的地址信息<br>注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息。</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address</span><br><span class="line"><span class="keyword">on</span> Person.PersonId = Address.PersonId;</span><br><span class="line">```~</span><br><span class="line"></span><br><span class="line">```~sql</span><br><span class="line"><span class="keyword">select</span> P.FirstName, P.LastName, A.City, A.State</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">as</span> P <span class="keyword">left</span> <span class="keyword">join</span> Address <span class="keyword">as</span> A </span><br><span class="line"><span class="keyword">on</span> (P.PersonId = A.PersonId);</span><br><span class="line">```~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 176. 第二高的薪水</span></span><br><span class="line">**编写一个 SQL 查询，获取 Employee&nbsp;表中第二高的薪水（Salary）。**</span><br></pre></td></tr></tbody></table></figure>
<p>+—-+——–+<br>| Id | Salary |<br>+—-+——–+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>+—-+——–+</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">例如上述</span>&nbsp;<span class="string">Employee</span>&nbsp;<span class="string">表，SQL查询应该返回</span>&nbsp;<span class="number">200</span> <span class="string">作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回</span> <span class="literal">null</span><span class="string">。</span></span><br></pre></td></tr></tbody></table></figure>
<p>+———————+<br>| SecondHighestSalary |<br>+———————+<br>| 200                 |<br>+———————+</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法一：使用子查询和 <span class="keyword">LIMIT</span> 子句  </span><br><span class="line">降序排列再返回第二条记录可以得到第二大的值。</span><br><span class="line">```<span class="keyword">distinct</span>```排除掉多行数据并列第二的情况，例如只有两行记录都是 <span class="number">100</span>，<span class="number">100</span>，此时结果应当是<span class="keyword">null</span>，如果不用<span class="keyword">distinct</span>，得到结果就是<span class="number">100</span>  </span><br><span class="line"></span><br><span class="line">关键是这个不存在返回<span class="keyword">null</span>，不存在又分为表数据不够，比如表只有一行。或者另一种情况，薪水全部一样，则也不存在第二高的薪水，因此这题除了按薪水降序排序外，还需要筛掉薪水相同的记录。可以像下面这样写使用<span class="keyword">group</span> <span class="keyword">by</span>或者用<span class="keyword">distinct</span> + <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line">```<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">DISTINCT</span> Salary <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    Salary <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>然而，如果没有这样的第二最高工资，不存在第二高记录的话会返回为空的结果集。而不是null，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。 执行返回结果集不为空包含一行为NULL的记录，</p>
<figure class="highlight plain"><figcaption><span>NULL```返回null值，可以不接from单独用，子查询数据出虚表嵌套查询虚表,如果查询不到会返回null。相当于查询的列。</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在oracle中只写查询列没有查询表需要加上 from dual（伪表）。</span><br><span class="line">而mysql不用写</span><br><span class="line">```SQL</span><br><span class="line">SELECT</span><br><span class="line">    (SELECT DISTINCT</span><br><span class="line">            Salary</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1) AS SecondHighestSalary</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        Salary</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Salary </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        Salary </span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">    <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：<br>求最大值。一定要借助于MAX函数<br>先去掉最大的，然后第二大的就是最大的了,<br>考虑了扩展性，求第三，求第四呢?一直套</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Salary) SecondHighestSalary </span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">where</span> Salary &lt; (<span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">from</span> Employee);</span><br></pre></td></tr></tbody></table></figure>

<p>方法三：使用 IFNULL 和 LIMIT 子句</p>
<p>mysql中isnull,ifnull,nullif的用法如下：</p>
<p>isnull(expr) 的用法： 如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。<br>mysql&gt; select isnull(1+1);<br>-&gt; 0<br>mysql&gt; select isnull(1/0);<br>-&gt; 1 使用= 的null 值对比通常是错误的。</p>
<p>isnull() 函数同 is null比较操作符具有一些相同的特性。请参见有关is null 的说明。</p>
<p>IFNULL(expr1,expr2)的用法：条件函数 写在查询条件里面里面<br>判断是否为null的，不是判断是否为空。如下所示。<br>假如expr1 不为 NULL，则 IFNULL() 的返回值为 expr1;<br>假如expr1 为 NULL，其返回值为 expr2。<br>IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。<br>ifnull(x, null) 如果返回null值，不就已经说明 x 的值为null</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT IFNULL(1,0);</span><br><span class="line">-&gt; 1</span><br><span class="line">mysql&gt; SELECT IFNULL(NULL,10);</span><br><span class="line">-&gt; 10</span><br><span class="line">mysql&gt; SELECT IFNULL(1/0,10);</span><br><span class="line">-&gt; 10</span><br><span class="line">mysql&gt; SELECT</span><br><span class="line">IFNULL(1/0,'yes');</span><br><span class="line">-&gt;   'yes</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">IFNULL</span>(</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">       <span class="keyword">FROM</span> Employee</span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">    <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a>177. 第N高的薪水</h3><p><strong>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</strong></p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br></pre></td></tr></tbody></table></figure>
<p>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------------------------+</span></span><br><span class="line">| getNthHighestSalary(2) |</span><br><span class="line"><span class="code">+------------------------+</span></span><br><span class="line">| 200                    |</span><br><span class="line"><span class="code">+------------------------+</span></span><br></pre></td></tr></tbody></table></figure>

<p>思路1：单表查询<br>本题不存在分组排序，只需返回全局第N高的一个，所以自然想到的想法是用order by排序加limit限制得到。需要注意两个细节：</p>
<ol>
<li>同薪同名且不跳级的问题，解决办法是用group by按薪水分组后再order by</li>
<li>排名第N高意味着要跳过N-1个薪水，由于无法直接用limit N-1，所以需先在函数开头用set把N赋值为N=N-1。调整下limit的起始点即可，<br>注：这里不能直接用limit N-1,1，这样写要报语法错误，是因为limit和offset字段后面只接受正整数（意味着负数、小数都不行, limit的偏移从0开始。0是可以 但是没有啥意义）或者单一变量（意味着不能用表达式），也就是说想取一条，limit 2-1、limit 1.1这类的写法都是报错的。<br>注：这种解法形式最为简洁直观，但仅适用于查询全局排名问题，如果要求各分组的每个第N名，则该方法不适用；而且也不能处理存在重复值的情况。</li>
</ol>
<p>第N个变成参数变量时，要改为N-1。不是数字。作者认为出题的目的是不使用变量的情况下解题</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> getNthHighestSalary(N <span class="built_in">int</span>) <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">set</span> n=N<span class="number">-1</span>;  // sql 不区分到小写，所以只有一个N</span><br><span class="line">    return (</span><br><span class="line">        <span class="keyword">select</span>(</span><br><span class="line">            <span class="keyword">select</span> </span><br><span class="line">                <span class="keyword">distinct</span> Salary</span><br><span class="line">            <span class="keyword">from</span> </span><br><span class="line">                Employee</span><br><span class="line">            <span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">                Salary <span class="keyword">desc</span></span><br><span class="line">            <span class="keyword">limit</span> n,<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> n = N<span class="number">-1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">ifnull</span>(</span><br><span class="line">          (</span><br><span class="line">          <span class="keyword">select</span> </span><br><span class="line">              <span class="keyword">distinct</span> Salary </span><br><span class="line">          <span class="keyword">from</span> </span><br><span class="line">              Employee</span><br><span class="line">          <span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">              Salary <span class="keyword">desc</span></span><br><span class="line">          <span class="keyword">limit</span> n, <span class="number">1</span></span><br><span class="line">          )</span><br><span class="line">          , <span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></tbody></table></figure>

<p>窗口函数</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">distinct</span> Salary </span><br><span class="line">      <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">num</span>,Salary <span class="keyword">from</span> Employee</span><br><span class="line">      ) t </span><br><span class="line">      <span class="keyword">where</span> t.num=N</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></tbody></table></figure>

<p>法2：子查询<br>排名第N的薪水意味着该表中存在N-1个比其更高的薪水<br>注意这里的N-1个更高的薪水是指去重后的N-1个，实际对应人数可能不止N-1个<br>最后返回的薪水也应该去重，因为可能不止一个薪水排名第N<br>由于对于每个薪水的where条件都要执行一遍子查询，注定其效率低下</p>
<p>对每一个薪水A，只要大于等于A的不同薪水个数等于N即可。<br>子查询查找比当前薪资大与等于的个数，个数即排名。<br>也就是在做查找当前记录的排名，对salary进行了排名，salary相同的排同一个名次</p>
<p>假设现在给你一个分数X，如何算出它的排名Rank呢？<br>我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。<br>比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> (</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        <span class="keyword">distinct</span> t1.Salary</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">        Employee t1</span><br><span class="line">    <span class="keyword">where</span> N = (</span><br><span class="line">        <span class="keyword">select</span> </span><br><span class="line">            <span class="keyword">count</span>(<span class="keyword">distinct</span> t2.Salary)</span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">            Employee t2</span><br><span class="line">        <span class="keyword">where</span> </span><br><span class="line">            t2.Salary &gt;= t1.Salary</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></tbody></table></figure>
<p>只用一个sql，那么要先查出前N薪水，然后取最小就好了，注意可能总数不够前N，count一下比较即可<br>取的distinct后的前N条吧，去重以后就是N条，但是如果有重复的就会导至原本可能有N条，去重以后就小于 N条，所以最后的选择步骤会加上一个IF条件判断是否有到达第N个，达不到返回NULL。比如原本100个数，其中有60个是相同的，其余40个是不同的；要取第50大的，就会返回NULL，因为不重复的数只有41个，只对这41个数排序取值。</p>
<figure class="highlight plain"><figcaption><span>里面的 列变量。</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```SQL</span><br><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  RETURN (     </span><br><span class="line">  SELECT  IF(count&lt;N,NULL,min) // N &gt; count 那么取 NULL 否者 取 min 的值</span><br><span class="line">  FROM</span><br><span class="line">    (SELECT MIN(Salary) AS min, COUNT(1) AS count</span><br><span class="line">    FROM</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">      FROM Employee ORDER BY Salary DESC LIMIT N) AS a</span><br><span class="line">    ) as b</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> <span class="keyword">count</span>(*) &lt; N </span><br><span class="line"><span class="keyword">then</span> <span class="literal">NULL</span> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">min</span>(Salary) </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> Salary </span><br><span class="line">    <span class="keyword">from</span> Employee </span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> </span><br><span class="line">    <span class="keyword">limit</span> N) </span><br><span class="line">    temp</span><br></pre></td></tr></tbody></table></figure>

<p>mysql中自定义变量需要用@作为前缀符引导符，针对于当前会话（连接）有效，同于会话变量的作用域应用在任何地方<br>定义@r表示排名信息(rank)，<br>定义@p表示前一个薪水(previous) </p>
<p>对用户变量赋值有两种方式，一种是直接用”=”号，另一种是用”:=”号。<br>其区别在于使用set命令对用户变量进行赋值时，两种方式都可以使用；<br>当使用select语句对用户变量进行赋值时，只能使用”:=”方式，因为在select语句中，”=”号被看作是比较操作符。<br>“:=”用来给变量rank赋值</p>
<hr>
<h3 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a>178. 分数排名</h3><p><strong>编写一个 SQL 查询来实现分数排名。</strong></p>
<p>如果两个分数相同，则两个分数排名（Rank）相同。<br>请注意，平分后的下一个名次应该是下一个连续的整数值。<br>换句话说，名次之间不应该有“间隔”。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> Score </span>|</span><br><span class="line">+----+-------+</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string"> 3.50  </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string"> 3.65  </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string"> 4.00  </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string"> 3.85  </span>|</span><br><span class="line">|<span class="string"> 5  </span>|<span class="string"> 4.00  </span>|</span><br><span class="line">|<span class="string"> 6  </span>|<span class="string"> 3.65  </span>|</span><br><span class="line">+----+-------+</span><br></pre></td></tr></tbody></table></figure>

<p>例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">|<span class="string"> Score </span>|<span class="string"> Rank </span>|</span><br><span class="line">+-------+------+</span><br><span class="line">|<span class="string"> 4.00  </span>|<span class="string"> 1    </span>|</span><br><span class="line">|<span class="string"> 4.00  </span>|<span class="string"> 1    </span>|</span><br><span class="line">|<span class="string"> 3.85  </span>|<span class="string"> 2    </span>|</span><br><span class="line">|<span class="string"> 3.65  </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 3.65  </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 3.50  </span>|<span class="string"> 4    </span>|</span><br><span class="line">+-------+------+</span><br></pre></td></tr></tbody></table></figure>
<p>重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <code>Rank</code> rank是mysql的关键字不能使用</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score, </span><br><span class="line">       <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>最后的结果包含两个部分，<br>第一部分是降序排列的分数</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Score <span class="keyword">as</span> Score</span><br><span class="line"><span class="keyword">from</span> Scores a</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.Score <span class="keyword">DESC</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二部分是每个分数对应的排名<br>假设现在给你一个分数X，如何算出它的排名Rank呢？<br>我们可以先提取出大于等于X的所有分数集合H，将H去重后的元素个数就是X的排名。<br>比如你考了99分，但最高的就只有99分，那么去重之后集合H里就只有99一个元素，个数为1，因此你的Rank为1。<br>先提取集合H：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    b.Score </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Scores b </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    b.Score &gt;= X;</span><br></pre></td></tr></tbody></table></figure>
<p>我们要的是集合H去重之后的元素个数就是X的排名，因此升级为：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> b.Score) </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Scores b </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    b.Score &gt;= X <span class="keyword">as</span> <span class="keyword">Rank</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>而从结果的角度来看，第二部分的Rank是对应第一部分的分数来的，<br>所以这里的X就是上面的a.Score，把两部分结合在一起为：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    a.Score <span class="keyword">as</span> Score,</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> </span><br><span class="line">            <span class="keyword">count</span>(<span class="keyword">distinct</span> b.Score) </span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">            Scores b </span><br><span class="line">        <span class="keyword">where</span> </span><br><span class="line">            b.Score &gt;= a.Score</span><br><span class="line">        ) <span class="keyword">as</span> <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Scores a</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">    a.Score <span class="keyword">DESC</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a>180. 连续出现的数字</h3><p><strong>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</strong></p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> Num </span>|</span><br><span class="line">+----+-----+</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string">  1  </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string">  1  </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string">  1  </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string">  2  </span>|</span><br><span class="line">|<span class="string"> 5  </span>|<span class="string">  1  </span>|</span><br><span class="line">|<span class="string"> 6  </span>|<span class="string">  2  </span>|</span><br><span class="line">|<span class="string"> 7  </span>|<span class="string">  2  </span>|</span><br><span class="line">+----+-----+</span><br></pre></td></tr></tbody></table></figure>
<p>例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| ConsecutiveNums |</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| 1               |</span><br><span class="line"><span class="code">+-----------------+</span></span><br></pre></td></tr></tbody></table></figure>

<p>思路：</p>
<ol>
<li><p>由于要获取至少连续三次出现的数字，看到这个题肯定是会变的，<br>如果是至少连续出现四次呢(100次呢)，咱们连接四个表(连接一千个?)？<br>这种方法肯定是不可取的。</p>
</li>
<li><p>找规律，找出这连续起来的数字有什么规律呢，我们会发现连续的数字是相同的数字，<br>但是id有可能不是连续的，工作的生产环境某一行记录经常会被删除,<br>所以id=1之后下一个id可能是3也可以是10000，我们就需要通过对结果集进行再次编号，让其变成连续的。</p>
</li>
<li><p>首先我们获取到对每条数据编号从1开始使用row_number()函数使用id来排序，<code>row_number() over(order by id)</code><br>4、然后我们通过另一种方式排序将，这些num值一样的进行排序，然后对其编号同样使用row_bumber()使用num来分组使用id排序 over(partition by num order by id)<br>5、通过3、4步骤我们能得到什么呢，两个相减之后我们可以得到，只要是相等的，则相减的值是一样的。而且如果不连续的话相减值也不一样。</p>
</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">NUM</span> <span class="keyword">As</span> ConsecutiveNums </span><br><span class="line"><span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> <span class="keyword">Num</span>,<span class="keyword">count</span>(*) <span class="keyword">as</span> Num_count </span><br><span class="line">    <span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> *, </span><br><span class="line">        row_number() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>)</span><br><span class="line">        - row_number() <span class="keyword">over</span> (</span><br><span class="line">            <span class="keyword">PARTITION</span> <span class="keyword">by</span> <span class="keyword">Num</span> </span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span></span><br><span class="line">            )<span class="keyword">AS</span> orde </span><br><span class="line">        <span class="keyword">FROM</span> <span class="keyword">logs</span> </span><br><span class="line">    ) <span class="keyword">as</span> W <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">Num</span>,orde </span><br><span class="line">)<span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">WHERE</span> Num_count&gt;=<span class="number">3</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>对应id的减的是row_number（）函数的排序号<br>如果pre与t.num 相等，则cnt加1， 否则cnt重置为1</p>
<p>法二<br>定义为一张表：(select @pre:= null,@count:=1) as pc<br>Logs与pc叉积，计算出与每行数字连续相同的数字个数。</p>
<p>①首先遍历一遍整张表，找出每个数字的连续重复次数<br>定义两个用户变量并初始化<br>@pre：记录的是当前行的num值，在下一次循环里，pre和下一次循环if（）里的num值比较<br>pre初始值最好不要赋值为一个数字，因为不确定赋值的数字是否会出现在测试表中。</p>
<p>@count：记录上一个数字已经连续出现的次数。与前一行数据连续相同的个数，统计连续次数</p>
<p>然后调用if()函数，与前一行数据比较的逻辑为：<br>如果pre和当前行数字相同，count加1即为连续出现的次数；<br>如果不同，意味着重新开始一个数字，count重新从1开始。<br>最后，将当前的Num数字赋值给pre，开始下一行扫描。</p>
<p>这些结果形成一张新表：a(Num,count,USELESS)。<br>适用连续重复次数为n的情况，无论需要连续重复多少次，只需要改最后的数字就可以了，复用性很好。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">        <span class="keyword">Num</span>,    <span class="comment">#当前的Num 数字</span></span><br><span class="line">        <span class="keyword">if</span>(@pre=<span class="keyword">Num</span>,@<span class="keyword">count</span> := @<span class="keyword">count</span>+<span class="number">1</span>,@<span class="keyword">count</span> := <span class="number">1</span>) <span class="keyword">as</span> nums, <span class="comment">#判断 和 计数</span></span><br><span class="line">        @pre:=<span class="keyword">Num</span>   <span class="comment">#将当前Num赋值给pre</span></span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">Logs</span> <span class="keyword">as</span> l ,</span><br><span class="line">        (<span class="keyword">select</span> @pre:= <span class="literal">null</span>,@<span class="keyword">count</span>:=<span class="number">1</span>) <span class="keyword">as</span> pc <span class="comment">#这里需要别名</span></span><br><span class="line">    <span class="comment">#上面这段代码执行结果就是一张三列为Num,count as nums,pre的表。</span></span><br></pre></td></tr></tbody></table></figure>
<p>②将上面表的结果中，重复次数大于等于3的数字选出，<br>再去重即为连续至少出现三次的数字。最终只要从a中取出count大于等于3的行。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">distinct</span> <span class="keyword">Num</span> <span class="keyword">as</span> ConsecutiveNums </span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">Num</span>,</span><br><span class="line">            <span class="keyword">if</span>(@pre=<span class="keyword">Num</span>,@<span class="keyword">count</span> := @<span class="keyword">count</span>+<span class="number">1</span>,@<span class="keyword">count</span> := <span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">count</span>,</span><br><span class="line">            @pre:=<span class="keyword">Num</span></span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">Logs</span> <span class="keyword">as</span> l ,</span><br><span class="line">            (<span class="keyword">select</span> @pre:= <span class="literal">null</span>,@<span class="keyword">count</span>:=<span class="number">1</span>) <span class="keyword">as</span> pc</span><br><span class="line">    ) <span class="keyword">as</span> n</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">count</span> &gt;=<span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>Every derived table must have its own alias，<br>进行嵌套查询的时候子查询出来的的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果临时表必须要有一个别名，应该是一种规范吧！</p>
<hr>
<h3 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a>181. 超过经理收入的员工</h3><p><strong>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</strong></p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> Name  </span>|<span class="string"> Salary </span>|<span class="string"> ManagerId </span>|</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string"> Joe   </span>|<span class="string"> 70000  </span>|<span class="string"> 3         </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string"> Henry </span>|<span class="string"> 80000  </span>|<span class="string"> 4         </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string"> Sam   </span>|<span class="string"> 60000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string"> Max   </span>|<span class="string"> 90000  </span>|<span class="string"> NULL      </span>|</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></tbody></table></figure>
<p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------+</span></span><br><span class="line">| Employee |</span><br><span class="line"><span class="code">+----------+</span></span><br><span class="line">| Joe      |</span><br><span class="line"><span class="code">+----------+</span></span><br></pre></td></tr></tbody></table></figure>

<p>”和自己的xxx比”这种问题基本都是自连接问题。<br>方法 1：使用 WHERE 语句<br>算法</p>
<p>如下面表格所示，表格里存有每个雇员经理的信息，我们也许需要从这个表里获取两次信息。<br>从两个表里使用 Select 语句可能会导致产生 笛卡尔乘积 。<br>不指定两个表的连接方式、 没有关联条件，这种情况下就会产生笛卡尔积，这是笛卡尔积的定义<br>在这种情况下，输出会产生 4*4=16 个记录。<br>然而我们只对雇员工资高于经理的人感兴趣。<br>所以我们应该用 WHERE 语句加 2 个判断条件。<br>a表的经理Id=b表的员工Id，即b表中的人员都是a表的经理</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.Name <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee <span class="keyword">AS</span> a,</span><br><span class="line">    Employee <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    a.ManagerId = b.Id</span><br><span class="line">        <span class="keyword">AND</span> a.Salary &gt; b.Salary</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<p>方法 2：使用 JOIN 语句<br>JOIN 是一个更常用也更有效的将表连起来的办法，我们使用 ON 来指明条件。<br>因为JOIN 运算优先级高于逗号<br>join相关联查语句，使用小表驱动大表，可以提高效率。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">     a.NAME <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">AS</span> a <span class="keyword">JOIN</span> Employee <span class="keyword">AS</span> b</span><br><span class="line">     <span class="keyword">ON</span> a.ManagerId = b.Id</span><br><span class="line">     <span class="keyword">AND</span> a.Salary &gt; b.Salary</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee E1</span><br><span class="line"><span class="keyword">where</span> Salary &gt; (<span class="keyword">select</span> Salary</span><br><span class="line">                <span class="keyword">from</span> Employee </span><br><span class="line">                <span class="keyword">where</span> <span class="keyword">Id</span> = E1.ManagerId);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> Employee </span><br><span class="line"><span class="keyword">from</span> Employee a </span><br><span class="line"><span class="keyword">where</span> a.Salary &gt; (<span class="keyword">select</span> b.Salary </span><br><span class="line">                    <span class="keyword">from</span> Employee b </span><br><span class="line">                    <span class="keyword">where</span> b.Id = a.ManagerId)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a>182. 查找重复的电子邮箱</h3><p><strong>编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</strong><br>示例：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line"><span class="code">+----+</span>---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line"><span class="code">+----+</span>---------+</span><br></pre></td></tr></tbody></table></figure>
<p>根据以上输入，你的查询应返回以下结果：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------+</span></span><br><span class="line">| Email   |</span><br><span class="line"><span class="code">+---------+</span></span><br><span class="line">| a@b.com |</span><br><span class="line"><span class="code">+---------+</span></span><br></pre></td></tr></tbody></table></figure>
<p>说明：所有电子邮箱都是小写字母。</p>
<p>方法一：看到“找重复”的关键字眼，首先要用分组函数（group by），<br>再用聚合函数中的计数函数count()给电子邮件列计数。</p>
<p>分组汇总后，生成了一个如下的表。使用临时表</p>
<p>从这个表里选出计数大于1的电子邮件，就是重复的电子邮件。<br>重复的电子邮箱存在多次。要计算每封电子邮件的存在次数</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email, <span class="keyword">count</span>(Email) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Email   </span>|<span class="string"> num </span>|</span><br><span class="line">|<span class="string">---------</span>|<span class="string">-----</span>|</span><br><span class="line">|<span class="string"> a@b.com </span>|<span class="string"> 2   </span>|</span><br><span class="line">|<span class="string"> c@d.com </span>|<span class="string"> 1   </span>|</span><br></pre></td></tr></tbody></table></figure>
<p>以此作为临时表，我们可以得到下面的解决方案。<br>将“创建辅助表”的步骤放入子查询<br>选出辅助表中计数大于1的姓名</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> Email, <span class="keyword">count</span>(Email) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">  <span class="keyword">from</span> Person</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line">) <span class="keyword">as</span> statistic</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：使用 GROUP BY 和 HAVING 条件<br>向 GROUP BY 添加条件的一种更常用的方法是使用 HAVING 子句，该子句更为简单高效。<br>在 SQL 中增加 HAVING 子句原因是，where后面不能接聚合函数，<br>因为where子句的运行顺序排在group by之前，表还没有被分组。<br>HAVING 子句对分组后的分组查询的结果进行筛选<br>having子句即可包含聚合函数作用的字段也可包括普通的标量字段<br>having子句必须于group&nbsp;by&nbsp;子句同时使用，不能单独使用<br>where在分组前过滤，having在分组后过滤，两者之间不冲突。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email)&gt;<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>法三自联结。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> p1.Email </span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">as</span> p1, Person <span class="keyword">as</span> p2 </span><br><span class="line"><span class="keyword">where</span> p1.Email =p2.Email <span class="keyword">and</span> p1.Id!=p2.Id;</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a>183. 从不订购的客户</h3><p><strong>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</strong><br>Customers 表：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line"><span class="code">+----+</span>-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line"><span class="code">+----+</span>-------+</span><br></pre></td></tr></tbody></table></figure>
<p>Orders 表：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line"><span class="code">+----+</span>------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line"><span class="code">+----+</span>------------+</span><br></pre></td></tr></tbody></table></figure>
<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-----------+</span></span><br><span class="line">| Customers |</span><br><span class="line"><span class="code">+-----------+</span></span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line"><span class="code">+-----------+</span></span><br></pre></td></tr></tbody></table></figure>
<p>方法：使用子查询和 NOT IN 子句<br>如果我们有一份曾经订购过的客户名单，就很容易知道谁从未订购过。<br>我们可以使用下面的代码来获得这样的列表。<br><code>select customerid from orders;</code><br>然后，我们可以使用 NOT IN 查询不在此列表中的客户。<br>集合差定义：C=A-B。C中的元素等于在A中但是不在B中。因此，对A中的每个元素a，如果元素a不在B中，则元素a就是集合C的元素。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    t1.name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    customers t1</span><br><span class="line"><span class="keyword">where</span> t1.id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> customerid </span><br><span class="line">    <span class="keyword">from</span> orders</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>如果订单表orders太大，那么会导致使用in的时候，信息都放入内存，效率降低；<br>使用left join只是做了个笛卡尔积运算，不占内存，求集合差的方法。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.Name Customers </span><br><span class="line"><span class="keyword">FROM</span> Customers t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders t2 </span><br><span class="line"><span class="keyword">ON</span> t1.Id = t2.CustomerId </span><br><span class="line"><span class="keyword">WHERE</span> t2.CustomerId <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure>
<p> =后面要讲一个确定的值，而null不能算一个确定的值，<br> 因为int型的可为null，varchar型的可为nul</p>
<p>方法三<br>EXISTS是布尔运算符，常用于测试子查询。<br>当subquery返回任何行时，EXISTS返回true，否则返回false。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    select_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    a_table</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    [<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span>(subquery);</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> C.name <span class="keyword">as</span> <span class="string">`Customers`</span></span><br><span class="line"><span class="keyword">from</span> Customers <span class="keyword">as</span> C </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> customerid</span><br><span class="line">    <span class="keyword">from</span> Orders <span class="keyword">as</span> O</span><br><span class="line">    <span class="keyword">where</span> O.customerid = C.id</span><br><span class="line">) ;</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a>184. 部门工资最高的员工</h3><p><strong>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</strong></p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> Name  </span>|<span class="string"> Salary </span>|<span class="string"> DepartmentId </span>|</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string"> Joe   </span>|<span class="string"> 70000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string"> Jim   </span>|<span class="string"> 90000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string"> Henry </span>|<span class="string"> 80000  </span>|<span class="string"> 2            </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string"> Sam   </span>|<span class="string"> 60000  </span>|<span class="string"> 2            </span>|</span><br><span class="line">|<span class="string"> 5  </span>|<span class="string"> Max   </span>|<span class="string"> 90000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></tbody></table></figure>
<p>Department 表包含公司所有部门的信息。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line"><span class="code">+----+</span>----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line"><span class="code">+----+</span>----------+</span><br></pre></td></tr></tbody></table></figure>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------------+</span>----------<span class="code">+--------+</span></span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line"><span class="code">+------------+</span>----------<span class="code">+--------+</span></span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Jim      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line"><span class="code">+------------+</span>----------<span class="code">+--------+</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</p>
<p>方法一：使用 JOIN 和 IN 语句</p>
<p>首先对 DepartmentId 字段分组查询每个部门内查询最高工资。<br>有可能有多个员工同时拥有最高工资，所以最好在这个查询中不包含雇员名字的信息，<br>包含 Salary 和 DepartmentId 字段，<br>例如技术部最高20k 但是客服部有个人20k 这样没有部门ID的话条件不足的</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    DepartmentId, <span class="keyword">MAX</span>(Salary)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> DepartmentId </span>|<span class="string"> MAX(Salary) </span>|</span><br><span class="line">|<span class="string">--------------</span>|<span class="string">-------------</span>|</span><br><span class="line">|<span class="string"> 1            </span>|<span class="string"> 90000       </span>|</span><br><span class="line">|<span class="string"> 2            </span>|<span class="string"> 80000       </span>|</span><br></pre></td></tr></tbody></table></figure>

<p>然后判断表中每条数据的分组和Salary是否和这个相等<br>把表 Employee 和 Department 连接，<br>再在这张临时表里用where或者IN语句筛选出 符合【工资=这个部门最高工资】 的员工信息。根据 Salary 和 DepartmentId 查找 Department.Name 字段</p>
<p>当两列同时作为关键字段进行条件查询时，是将两列合成二元组(部门id,部门最高薪水)作为一个值来查找。<br>，结合in判断 是否在已存在的组合中。<br>比如这个案例里是(课程号,成绩) in，<br>比如，“语文”和“90”合并为值“语文 90”。<br>如果部门A的最高薪水和部门B第二高的薪水是一样的，<br>此时不把DepartmentId对应起来的话，<br>仅仅是通过薪水查询则会把部门A薪水第二高的员工也查询出来，这是不符合要求的。</p>
<p>所以这两列的顺序要和子查询里列的顺序保持一致。<br>如果列的段顺序不一样，比如“90 语文”和“语文 90”就匹配不上，那么查询结果就是空的了。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Department.name <span class="keyword">AS</span> <span class="string">'Department'</span>,</span><br><span class="line">    Employee.name <span class="keyword">AS</span> <span class="string">'Employee'</span>,</span><br><span class="line">    Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    Department <span class="keyword">ON</span> Employee.DepartmentId = Department.Id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (Employee.DepartmentId , Salary) <span class="keyword">IN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            DepartmentId, <span class="keyword">MAX</span>(Salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            Employee</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">            DepartmentId</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<p>使用left join 要注意 部门名字 不能是NULL 。所以，如果使用Left join在官方解答后面加上一句判断 AND Department.name is not null… 。两张表都有可能为空，所以不能left和right，departmentid是null，leftjoin就会保留null</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Department.name <span class="keyword">AS</span> <span class="string">'Department'</span>,</span><br><span class="line">    Employee.name <span class="keyword">AS</span> <span class="string">'Employee'</span>,</span><br><span class="line">    Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    Department <span class="keyword">ON</span> Employee.DepartmentId = Department.Id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (Employee.DepartmentId , Salary) <span class="keyword">IN</span></span><br><span class="line">    (   <span class="keyword">SELECT</span></span><br><span class="line">            DepartmentId, <span class="keyword">MAX</span>(Salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            Employee</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">AND</span> Department.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>连接临时表<br>Employee和查询出来的每个分组的最大值连接。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e.Name <span class="keyword">as</span> Employee, e.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e </span><br><span class="line"><span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id </span><br><span class="line"><span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary) <span class="keyword">as</span> Salary</span><br><span class="line">    <span class="keyword">from</span> Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br><span class="line">    ) t </span><br><span class="line">    <span class="keyword">on</span> e.DepartmentId = t.DepartmentId <span class="keyword">and</span> e.Salary = t.Salary;</span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>Employee和自身连接，on的条件为部门相同且同时约束Salary的大小。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e1.Name <span class="keyword">as</span> Employee, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 </span><br><span class="line"><span class="keyword">join</span> Department d <span class="keyword">on</span> e1.DepartmentId = d.Id </span><br><span class="line"><span class="keyword">join</span> Employee e2 <span class="keyword">on</span> e1.DepartmentId = e2.DepartmentId <span class="keyword">and</span> e1.Salary &lt;= e2.Salary</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e1.Id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary) = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>


<hr>
<h3 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a>185. 部门工资前三高的所有员工</h3><p><strong>Employee 表包含所有员工信息，每个员工有其对应的工号&nbsp;Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。</strong></p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> Name  </span>|<span class="string"> Salary </span>|<span class="string"> DepartmentId </span>|</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string"> Joe   </span>|<span class="string"> 85000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string"> Henry </span>|<span class="string"> 80000  </span>|<span class="string"> 2            </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string"> Sam   </span>|<span class="string"> 60000  </span>|<span class="string"> 2            </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string"> Max   </span>|<span class="string"> 90000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 5  </span>|<span class="string"> Janet </span>|<span class="string"> 69000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 6  </span>|<span class="string"> Randy </span>|<span class="string"> 85000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">|<span class="string"> 7  </span>|<span class="string"> Will  </span>|<span class="string"> 70000  </span>|<span class="string"> 1            </span>|</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></tbody></table></figure>
<p>Department 表包含公司所有部门的信息。</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----+</span>----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line"><span class="code">+----+</span>----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line"><span class="code">+----+</span>----------+</span><br></pre></td></tr></tbody></table></figure>
<p>编写一个&nbsp;SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">|<span class="string"> Department </span>|<span class="string"> Employee </span>|<span class="string"> Salary </span>|</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">|<span class="string"> IT         </span>|<span class="string"> Max      </span>|<span class="string"> 90000  </span>|</span><br><span class="line">|<span class="string"> IT         </span>|<span class="string"> Randy    </span>|<span class="string"> 85000  </span>|</span><br><span class="line">|<span class="string"> IT         </span>|<span class="string"> Joe      </span>|<span class="string"> 85000  </span>|</span><br><span class="line">|<span class="string"> IT         </span>|<span class="string"> Will     </span>|<span class="string"> 70000  </span>|</span><br><span class="line">|<span class="string"> Sales      </span>|<span class="string"> Henry    </span>|<span class="string"> 80000  </span>|</span><br><span class="line">|<span class="string"> Sales      </span>|<span class="string"> Sam      </span>|<span class="string"> 60000  </span>|</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></tbody></table></figure>
<p>IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。<br>销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p>
<p>感觉应该改为各部门工资级别前三的员工<br>不能理解为前三名员工，如果拿90000的有四个人的话，你只取三个人，那怎么取都是错的了</p>
<p>方法：使用 JOIN 和子查询<br>公司里前 3 高的薪水意味着有不超过 3 个工资值比这些值大。</p>
<p>统计了有多少人的工资比 e1.Salary 高</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> <span class="string">'Employee'</span>, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1</span><br><span class="line"><span class="keyword">where</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary)</span><br><span class="line">    <span class="keyword">from</span> Employee e2</span><br><span class="line">    <span class="keyword">where</span> e2.Salary &gt; e1.Salary</span><br><span class="line">    ) &lt; <span class="number">3</span> </span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>
<p>样例的输出应该如下所示。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Employee </span>|<span class="string"> Salary </span>|</span><br><span class="line">|<span class="string">----------</span>|<span class="string">--------</span>|</span><br><span class="line">|<span class="string"> Joe      </span>|<span class="string"> 85000  </span>|</span><br><span class="line">|<span class="string"> Henry    </span>|<span class="string"> 80000  </span>|</span><br><span class="line">|<span class="string"> Max      </span>|<span class="string"> 90000  </span>|</span><br><span class="line">|<span class="string"> Randy    </span>|<span class="string"> 85000  </span>|</span><br></pre></td></tr></tbody></table></figure>
<p>当 &lt;3 改为 =0,第一高工资 比他高的工资 个数为0 </p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Employee </span>|<span class="string"> Salary </span>|</span><br><span class="line">|<span class="string">----------</span>|<span class="string">--------</span>|</span><br><span class="line">|<span class="string"> Max      </span>|<span class="string"> 90000  </span>|</span><br></pre></td></tr></tbody></table></figure>
<p>当 &lt;3 改为 =1，第二高工资 ,比他的高的 工资个数为1，</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Employee </span>|<span class="string"> Salary </span>|</span><br><span class="line">|<span class="string">----------</span>|<span class="string">--------</span>|</span><br><span class="line">|<span class="string"> Joe      </span>|<span class="string"> 85000  </span>|</span><br><span class="line">|<span class="string"> Randy    </span>|<span class="string"> 85000  </span>|</span><br></pre></td></tr></tbody></table></figure>
<p>当 &lt;3 改为 =2，有2个比某个数大，就是最3大，</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Employee </span>|<span class="string"> Salary </span>|</span><br><span class="line">|<span class="string">----------</span>|<span class="string">--------</span>|</span><br><span class="line">|<span class="string"> Henry    </span>|<span class="string"> 80000  </span>|</span><br></pre></td></tr></tbody></table></figure>

<p>题目要查出为同一部门的前三高工资，在同一部门内 其他的工资&gt;该员工的薪资 的个数小于3  ，即为子查询里面的条件<br>把表 Employee 和表 Department 连接来获得部门信息。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">工资是同一个部门里的，不加这个条件的话，就会所有部门比较了</span><br><span class="line">SQL查询e1表是按行查询的，每查询一行，执行一次where后面的内容，</span><br><span class="line">也就是拿这一行的salary跟e2表里同部门的所有salary作比较，</span><br><span class="line">得到不超过这一行里salary值的个数。</span><br><span class="line">```SQL</span><br><span class="line">SELECT</span><br><span class="line">    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary</span><br><span class="line">FROM</span><br><span class="line">    Employee e1</span><br><span class="line">JOIN</span><br><span class="line">    Department d ON e1.DepartmentId = d.Id</span><br><span class="line">WHERE (SELECT</span><br><span class="line">            COUNT(DISTINCT e2.Salary)</span><br><span class="line">        FROM</span><br><span class="line">            Employee e2</span><br><span class="line">        WHERE</span><br><span class="line">            e2.Salary &gt; e1.Salary</span><br><span class="line">                AND e1.DepartmentId = e2.DepartmentId</span><br><span class="line">        ) &lt; 3 </span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解题思路:先对Employee表进行部门分组工资排名，</span></span><br><span class="line"><span class="comment">再关联Department表查询部门名称，</span></span><br><span class="line"><span class="comment">再使用WHERE筛选出排名小于等于3的数据（也就是每个部门排名前3的工资）。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">D.Name <span class="keyword">AS</span> Department,</span><br><span class="line">A.Name <span class="keyword">AS</span> Employee,</span><br><span class="line">A.Salary</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentId <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">AS</span> ranking,DepartmentId,<span class="keyword">Name</span>,Salary</span><br><span class="line">      <span class="keyword">FROM</span> Employee) <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">JOIN</span> Department <span class="keyword">AS</span> D <span class="keyword">ON</span> A.DepartmentId=D.id</span><br><span class="line"><span class="keyword">WHERE</span> A.ranking&lt;=<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">d.Name <span class="keyword">AS</span> <span class="string">'Department'</span>, e1.Name <span class="keyword">AS</span> <span class="string">'Employee'</span>, e1.Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> Employee e1</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">Department d <span class="keyword">ON</span> e1.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="comment">#工资级别数量小于等于3，即最多只有3个工资级别，也就是前三高</span></span><br><span class="line"> <span class="number">3</span> &gt;= (</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> e2.Salary)</span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line">Employee e2</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line"><span class="comment">#e2的工资级别大于等于e1的工资级别</span></span><br><span class="line"> e2.Salary &gt;= e1.Salary</span><br><span class="line"> <span class="keyword">AND</span> e1.DepartmentId = e2.DepartmentId</span><br><span class="line"> )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e1.DepartmentId,e1.Salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    t2.Name <span class="keyword">as</span> Department,</span><br><span class="line">    t1.Name <span class="keyword">as</span> Employee,</span><br><span class="line">    t1.Salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    Employee <span class="keyword">as</span> t1,</span><br><span class="line">    Department <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    t1.DepartmentId = t2.Id <span class="keyword">and</span></span><br><span class="line">    <span class="number">3</span> &gt; (</span><br><span class="line">            <span class="keyword">select</span> </span><br><span class="line">                <span class="keyword">count</span>(<span class="keyword">distinct</span> Salary)</span><br><span class="line">            <span class="keyword">from</span></span><br><span class="line">                Employee</span><br><span class="line">            <span class="keyword">where</span></span><br><span class="line">                Salary&gt;t1.Salary <span class="keyword">and</span></span><br><span class="line">                DepartmentId = t1.DepartmentId</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t2.Name,t1.Salary <span class="keyword">desc</span></span><br></pre></td></tr></tbody></table></figure>
<p>这一题做的有点混乱了，本来按自己的想法来说，前几前几这种问题，一般都是排好序之后用limit，但是好像很多题目都是两表连接，用比较符盒count判断，这个思路要学会转换。还有就是看了一些别人题解，发现也有用自定义变量等这些方法的，姿势还是很多的，哎，太菜了。</p>
<p>为了记录足球比赛的结果，设计表如下：<br>team：参赛队伍表<br>match：赛程表<br>match赛程表中的 hostTeamID与 guestTeamID都和team表中的 teamID关联,查询2006-6-1到2006-7-1之间举行的所有比赛,并且用以下形式列出:<br>拜仁 2:0 不莱梅 2006-6-21<br>首先列出需要查询的列：<br>参赛队伍表 team<br>字段名称 字段类型 描述<br>teamID int 主键<br>teamName varchar(20) 队伍名称<br>赛程表match<br>字段名称 字段类型 描述<br>match ID int 主键<br>hostTeamID int 主队的ID<br>guestTeamID int 客队的ID<br>matchTime date   比赛开始时间<br>matchResult varchar(20) 比赛结果，如（2:0）<br>其次列出结果列：<br>主队 结果 客对 时间</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建参赛队伍表CREATE TABLE team(</span></span><br><span class="line">teamID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, teamName VARCHAR(30) NOT NULL</span><br><span class="line">);</span><br><span class="line"><span class="comment">#向参赛队伍表中插入记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">' 拜 仁 '</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">' 不 莱 梅 '</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">'皇家马德里'</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">'巴塞罗那'</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">' 切 尔 西 '</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">' 曼 联 '</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">'AC 米 兰 '</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> team(teamName) <span class="keyword">VALUES</span>(<span class="string">'国际米兰'</span>);</span><br><span class="line"><span class="comment">#创建 match 赛程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mat(</span><br><span class="line">matchID <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEy</span>,</span><br><span class="line">hostTeamID <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, guestTeamID <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">matchResult <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, matchTime <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">#向赛程表中插入几条记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mat(hostTeamID,guestTeamID,matchResult,matchTime) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3:1'</span>,<span class="string">'2006-6-15'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mat(hostTeamID,guestTeamID,matchResult,matchTime) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">'2:2'</span>,<span class="string">'2006-6-28'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mat(hostTeamID,guestTeamID,matchResult,matchTime) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="string">'0:2'</span>,<span class="string">'2006-7-10'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mat(hostTeamID,guestTeamID,matchResult,matchTime) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="string">'5:3'</span>,<span class="string">'2006-5-30'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>1、先进行一次左连接 得到主队的名字</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hid,m1.tname,mres,gid,matime  <span class="keyword">from</span> m <span class="keyword">left</span> <span class="keyword">join</span> t <span class="keyword">as</span> m1 <span class="keyword">on</span> m.hid= m1.tid;</span><br><span class="line">1、先进行一次左连接 得到主队的名字</span><br></pre></td></tr></tbody></table></figure>

<p>2、再进行一次左连接 得到客队的名字</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hid,m1.tname,mres,gid,t1.tname <span class="keyword">from</span> m <span class="keyword">left</span> <span class="keyword">join</span> t <span class="keyword">as</span> m1 <span class="keyword">on</span> m.hid= m1.tid <span class="keyword">left</span> <span class="keyword">join</span> t <span class="keyword">as</span> t1 <span class="keyword">on</span> m.gid=t1.tid;</span><br><span class="line">1、先进行一次左连接 得到主队的名字</span><br></pre></td></tr></tbody></table></figure>

<p>通过外键联表，完成最终SQL：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.teamName,m.matchResult,t2.teamName,m.matchTime </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">match</span> <span class="keyword">as</span> m </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> team <span class="keyword">as</span> t1 <span class="keyword">on</span> m.hostTeamID = t1.teamID, </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> team <span class="keyword">as</span> t2 <span class="keyword">on</span> m.guestTeamID = t2.TeamID </span><br><span class="line"><span class="keyword">where</span> matchTime <span class="keyword">between</span> <span class="string">"2006-6-1"</span> <span class="keyword">and</span> <span class="string">"2006-7-1"</span></span><br></pre></td></tr></tbody></table></figure>


<p>问题22：一个6亿的表a，一个3亿的表b，通过外键tid关联，<br>你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</p>
<p>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> a,b </span><br><span class="line"><span class="keyword">where</span> a.tid = b.id <span class="keyword">and</span> a.tid&gt;<span class="number">50000</span> </span><br><span class="line"><span class="keyword">limit</span> <span class="number">200</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> b , </span><br><span class="line">    (<span class="keyword">select</span> tid </span><br><span class="line">    <span class="keyword">from</span> a </span><br><span class="line">    <span class="keyword">limit</span> <span class="number">50000</span>,<span class="number">200</span>) a </span><br><span class="line"><span class="keyword">where</span> b.id = a .tid;</span><br></pre></td></tr></tbody></table></figure>

<p>拷贝表( 拷贝数据, 源表名：a 目标表名：b)</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> b(a, b, c) <span class="keyword">select</span> d,e,f <span class="keyword">from</span> a;</span><br></pre></td></tr></tbody></table></figure>

<p>Student(S#,Sname,Sage,Ssex) 学生表 Course(C#,Cname,T#) 课程表 SC(S#,C#,score) 成绩表 Teacher(T#,Tname) 教师表 查询没学过“叶平”老师课的同学的学号、姓名</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.S<span class="comment">#,Student.Sname</span></span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> S<span class="comment"># not in (select distinct( SC.S#) </span></span><br><span class="line">    <span class="keyword">from</span> SC,Course,Teacher </span><br><span class="line">    <span class="keyword">where</span> SC.C<span class="comment">#=Course.C# and Teacher.T#=Course.T# and Teacher.Tname=’叶平’);</span></span><br></pre></td></tr></tbody></table></figure>

<p>随机取出10条数据</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;= (</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> <span class="keyword">users</span>)-(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> <span class="keyword">users</span>)</span><br><span class="line">    ) * <span class="keyword">RAND</span>() + (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> <span class="keyword">users</span>) </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>#此方法效率比直接用高很多</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/sql/" rel="tag"># sql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/jian-zhi-offer-shi-ti/" rel="prev" title="剑指offer试题">
                  <i class="fa fa-chevron-left"></i> 剑指offer试题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/jian-zhi-offer40-50/" rel="next" title="剑指offer40 -50">
                  剑指offer40 -50 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
