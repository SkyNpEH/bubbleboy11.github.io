<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bubbleboy11.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="树的知识点：什么叫做树？树是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，是根朝上，而叶朝下的。它具有以下的特点：  每个结点至多只有两颗子树 二叉树的子树有左右之分，其次序不能任意颠倒 没有父节点的节点称为根节点； 每一个非根节点有且只有">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer25~30题">
<meta property="og:url" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/index.html">
<meta property="og:site_name" content="外心人D的博客">
<meta property="og:description" content="树的知识点：什么叫做树？树是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，是根朝上，而叶朝下的。它具有以下的特点：  每个结点至多只有两颗子树 二叉树的子树有左右之分，其次序不能任意颠倒 没有父节点的节点称为根节点； 每一个非根节点有且只有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/Users/Administrator/Desktop/剑指offer/二叉树.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%89%8D%E4%B8%AD.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png">
<meta property="article:published_time" content="2020-08-20T16:21:41.000Z">
<meta property="article:modified_time" content="2021-10-09T12:32:04.790Z">
<meta property="article:author" content="外心人D">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/Users/Administrator/Desktop/剑指offer/二叉树.png">


<link rel="canonical" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/","path":"2020/08/21/jian-zhi-offer25-30-ti/","title":"剑指offer25~30题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>剑指offer25~30题 | 外心人D的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="外心人D的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">外心人D的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="nav-text">树的知识点：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E6%A0%91%EF%BC%9F"><span class="nav-text">什么叫做树？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-text">二叉树的遍历：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">28.从上往下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">25.重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">26.树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">27.二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0"><span class="nav-text">输入描述:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%8D%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%EF%BC%88val%EF%BC%89%EF%BC%8C%E6%98%AFroot%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E6%AD%A4%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%AD%90%E6%A0%91%E4%B9%9F%E9%9A%8F%E7%9D%80%E4%B8%80%E8%B5%B7%E8%A2%AB%E4%BA%A4%E6%8D%A2"><span class="nav-text">交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E6%A0%91%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%98%AF%E6%A0%B9-%E2%80%94-%E6%9E%9D-%E2%80%94-%E5%8F%B6-%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%82"><span class="nav-text">和现实中的树是一样的，是根 — 枝 — 叶 的结构。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E6%88%91%E4%BB%AC%E5%89%AA%E4%B8%8B%E4%B8%A4%E4%B8%AA%E6%A0%91%E6%9E%9D%EF%BC%88%E4%B8%8A%E9%9D%A2%E5%88%86%E5%88%AB%E6%9C%89%E6%A0%91%E6%9E%9D%E5%88%86%E5%8F%89%E3%80%81%E7%9B%B4%E5%88%B0%E5%8F%B6%EF%BC%89%EF%BC%8C"><span class="nav-text">当我们剪下两个树枝（上面分别有树枝分叉、直到叶），</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%B0%86%E6%AD%A4%E4%BA%8C%E6%A0%91%E6%9E%9D%E4%BA%A4%E6%8D%A2%E4%BD%8D%E7%BD%AE-%E5%AB%81%E6%8E%A5%E5%9B%9E%E6%A0%91%E4%B8%8A%E3%80%82"><span class="nav-text">并将此二树枝交换位置 嫁接回树上。 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A4%E6%97%B6%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%AD%A4%E4%B8%A4%E6%A0%91%E6%9E%9D%E7%9A%84%E6%A0%B9%E5%92%8C%E5%85%B6%E6%A0%91%E6%9E%9D%E5%88%86%E5%8F%89-%E5%8F%B6-%E9%83%BD%E4%BA%A4%E6%8D%A2%E4%BA%86%E3%80%82"><span class="nav-text">此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%A0%91"><span class="nav-text">35.对称的二叉树 [^本题考点 树]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-text">54. 二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#38-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-%E6%9C%AC%E9%A2%98%E8%80%83%E7%82%B9-%E6%A0%91"><span class="nav-text">38.二叉搜索树的第k个结点 [^本题考点 树]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-text">29.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">30.二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">31.二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%95%B0%E6%80%BB%E5%92%8C"><span class="nav-text">组数总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">二叉树的序列化与反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">反序列化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">344. 反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-text">9. 回文数</span></a></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">外心人D</p>
  <div class="site-description" itemprop="description">本博客大多内容为慕课和网上博客，并非原创</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">362</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bubbleboy11.github.io/2020/08/21/jian-zhi-offer25-30-ti/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="外心人D">
      <meta itemprop="description" content="本博客大多内容为慕课和网上博客，并非原创">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="外心人D的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指offer25~30题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-20T16:21:41Z">2020-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-09 12:32:04" itemprop="dateModified" datetime="2021-10-09T12:32:04Z">2021-10-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h4 id="树的知识点："><a href="#树的知识点：" class="headerlink" title="树的知识点："></a>树的知识点：</h4><h5 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h5><p>树是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，<br>用来模拟具有树状结构性质的数据集合。<br>它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。<br>把它叫做“树”是因为它看起来像一棵倒挂的树，<br>是根朝上，而叶朝下的。<br>它具有以下的特点：</p>
<ul>
<li>每个结点至多只有两颗子树</li>
<li>二叉树的子树有左右之分，其次序不能任意颠倒</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
<p>树的术语</p>
<ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树的度：一棵树中，最大的节点的度称为树的度；</li>
<li>叶节点或终端节点：度为零的节点；没有子节点</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由 m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ul>
<p>树的种类</p>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li>二叉树：每个节点最多含有两个子树的树，子树被称作“左子树”（left subtree）和“右子树”（right subtree）二叉树常被用于实现二叉查找树和二叉堆。<br>二叉树的一些性质，这些性质可以很简单得到证明：<ol>
<li>: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）  </li>
<li>: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</li>
<li>: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</li>
<li>: 具有n个结点的完全二叉树的深度必为 log2(n+1)  (log2n)+1。（(log2n)表示不大于x的最大整数）。可以理解为性质2的倒推</li>
<li>:对完全二叉树，若从上至下、从左至右按照层序编号，则编号为i 的结点，<br>对任意一个节点（1&lt;=i&lt;=n）有：<br>如果i=1，则节点i是完全二叉树的根，无双亲；如果i&gt;1，其双亲节点是[i/2]<br>如果2i&gt;n，则节点i无左孩子（节点i为叶子节点）；否则左孩子是2i<br>如果2i+1&gt;n，则节点i无右孩子；否则其右孩子是节点2i+1<br>其左孩子编号必为2i，其右孩子编号必为2i＋1；<br>其双亲的编号必为i/2（i＝1 时为根,除外）</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>- 完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。
除了第d层外，其它各层（1~d-1）的节点数目均已达最大值，
且第d层有叶子结点所有节点从左向右连续地紧密排列，
并且最后一层或者是满的，或者是在右边缺少连续若干节点，

满二叉树的定义是所有叶节点都在最底层的完全二叉树;
除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树
一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。
特点是每一层上的节点数都是最大节点数。
</code></pre>
<p>深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点<br>    - 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<br>    - 二叉搜索树：Binary Search Tree<br>    左子树中所有节点的值 =&lt; 根节点的值 =&lt; 右子树中所有节点的值</p>
<ul>
<li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li>
</ul>
<p>树的存储与表示<br>顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，<br>但因所占空间比较大，是非主流二叉树。<br>二叉树通常以链式存储。</p>
<p>二叉树的节点表示以及树的创建<br>通过使用Node类中定义三个属性，分别为elem本身的值，<br>还有lchild左孩子和rchild右孩子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">""" 定义树的存储结构 Definition of a binary tree node."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>


<p>树的创建，创建一个树的类，并给一个root根节点，一开始为空，随后添加节点</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">"""树类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root=None</span>):</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""为树添加节点"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line">        <span class="comment">#如果树是空的，则对根节点赋值</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="comment">#弹出队列的第一个元素</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.lchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.lchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> cur.rchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.rchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果左右子树都不为空，加入队列继续判断</span></span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></tbody></table></figure>


<p>常见的一些树的应用场景<br>1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树<br>2.路由协议就是使用了树的算法<br>3.mysql数据库索引<br>4.文件系统的目录结构<br>5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构</p>
<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/Users\Administrator\Desktop\剑指offer\二叉树.png">)</p>
<h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，<br>使每一个结点都被访问一次且只仅访问一次。<br>由于二叉树是非线性结构，<br>因树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p>
<p>深度优先搜索(Depth First Search DFS)<br>沿着树的深度遍历树的节点，<br>尽可能深的搜索树的分支，<br>从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。<br>这三种方式常被用于访问树的节点，可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）</p>
<p>当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
<p>深度优先遍历、递归、栈，它们三者的关系背后统一的逻辑都是「后进先出」</p>
<p>解决可达性的问题。<br>两个要点：<br>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。<br>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</p>
<p>找到开始节点-&gt;访问节点并进行操作-&gt;递归调用dfs遍历下一个节点-&gt;遇到边界或已访问节点就return返回-&gt;全部遍历结束返回到开始节点，结束dfs</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">7</span>     <span class="number">8</span> <span class="number">9</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>层次遍历： 0 1 2 3 4 5 6 7 8 9<br>先序遍历： 0 1 3 7 8 4 9 2 5 6<br>中序遍历： 7 3 8 1 9 4 0 5 2 6<br>         738认作一个左子树，94认作一个右子树，该子树的根节点 1<br>         738认作一个左子树，94认作一个节点，该子树的根节点 1<br>         134认作一个左子树，256认作一个右子树<br>后序遍历： 7 8 3 9 4 1 5 6 2 0</p>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> /  <span class="tag">\</span></span><br><span class="line">B    F</span><br><span class="line"> <span class="tag">\<span class="name"> </span></span>   <span class="tag">\</span></span><br><span class="line">  C    G</span><br><span class="line">    / <span class="tag">\<span class="name"> </span></span> /</span><br><span class="line">   D   E H</span><br></pre></td></tr></tbody></table></figure>
<p>先序:a b c d e f g h<br>中序:b d c e a f h g<br>后序:d e c b h g f a</p>
<ul>
<li>先(前)序遍历 我们先访问根节点，然后递归使用先序遍历访问左子树，<br>再递归使用先序遍历访问右子树<br>根节点-&gt;左子树-&gt;右子树<br>Top-&gt;Bottom 和 Left-&gt;Right</li>
</ul>
<p>迭代<br>使用栈来完成，先将根节点放入栈中，<br>将根节点出栈，将根节点值放入结果数组中<br>然后遍历左子树、右子树，<br>因为栈是先进后出，<br>先压右节点右子树入栈，再压左节点左子树入栈，<br>出栈的时候才是先左后右的顺序，整体顺序才是中左右<br>每次迭代弹出当前栈顶元素，<br>继续出栈（左子树被出栈）……<br>依次循环出栈遍历入栈，直到栈为空，遍历完成</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">前序</span><br><span class="line">                               |<span class="string">3</span>|</span><br><span class="line">                     |<span class="string">1</span>|<span class="string">       </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">            </span>|<span class="string">5</span>|</span><br><span class="line">      |<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                             |<span class="string">6</span>|</span><br><span class="line">                                                        |<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                                              |<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">                                         |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                                    |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                          </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|</span><br><span class="line">res   |<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        <span class="comment"># [root, ]这个‘,’是什么意思呀?这个是方便多行定义的时候复制的,</span></span><br><span class="line">        <span class="comment">#否则容易在添加元素的过程中缺少逗号出现语法错误.</span></span><br><span class="line">        <span class="comment">#具体可以查python data structure trailing comma这个关键词. </span></span><br><span class="line">        <span class="comment">#对于tuple的定义就有差别了,因为(1)这个东西有二意性,</span></span><br><span class="line">        <span class="comment"># 所以tuple声明单元素的时候必须加逗号,也就是(1,)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 第一步的，先访问的是根节点，辅助栈的</span></span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                output.append(root.val)  <span class="comment"># 把根节点加入到结果集</span></span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    stack.append(root.right)  <span class="comment"># 加入到辅助栈</span></span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    stack.append(root.left)  <span class="comment"># 加入到辅助栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。<br>空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。</p>
<p>先将根节点 cur 和遍历所有的左子树入栈并加入结果中，直至 cur 为空，<br>用一个 while 循环实现：<br>然后，每弹出一个栈顶元素 tmp，就到达它的右孩子，<br>再将这个节点当作 cur 重新按上面的步骤来一遍，直至栈为空。<br>这里又需要一个 while 循环。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">前序</span><br><span class="line">                |<span class="string">3</span>|<span class="string">       </span>|<span class="string">4</span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                             |<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                                                   |<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">    </span></span><br><span class="line"><span class="string">                                              </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>

<p>两个操作，一个是处理：将元素放进res数组中，一个是访问：遍历节点。<br>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，<br>因为要访问的元素和要处理的元素（也就是在把节点的数值放进result数组中）<br>顺序是一致的，都是中间节点。遇到节点直接把它的值存到输出数组里面，<br>所以刚刚才能写出相对简洁的代码</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        cur = root  <span class="comment"># 将树压入栈中</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack :  <span class="comment"># 循环栈</span></span><br><span class="line">            <span class="comment"># 根节点和左子树入栈</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left  <span class="comment"># 移至最左</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每弹出一个元素，就到达右子树</span></span><br><span class="line">            temp  = stack.pop()  <span class="comment"># 根节点等于出栈的节点</span></span><br><span class="line">            cur = temp.right</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>中序（根）遍历<br>左子树-&gt;根节点-&gt;右子树<br>先访问的是二叉树顶部的节点，<br>然后一层一层向下访问，直到到达树左面的最底部，<br>再开始处理节点（也就是在把节点的数值放进result数组中），<br>这就造成了处理顺序和访问顺序是不一致的。</li>
</ul>
<p>就需要借用指针的遍历来帮助访问节点，<br>栈则用来处理节点上的元素。<br>创建一个Stack，然后按 左 中 右的顺序输出节点。<br>尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，<br><u>其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，<br>并且在寻找的过程中记录了来源，才能返回上层</u>,<br>同时在返回上层的时候已经处理完毕左子树了。<br>当处理完最小单位的子树时，返回到上层处理了中间节点。<br>如果有右节点，其也要进行中序遍历。</p>
<p>和前序遍历的代码完全相同，<br>只是在出栈的时候才将节点 tmp 的值加入到结果中。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">中序</span><br><span class="line">                                         </span><br><span class="line">           |<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">                               </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|</span><br><span class="line">res   |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">            0</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          1    2</span></span><br><span class="line"><span class="string">         / \  / \</span></span><br><span class="line"><span class="string">        3  4 5   6</span></span><br><span class="line"><span class="string">中序</span></span><br><span class="line"><span class="string">                </span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string"> </span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                                  |<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                                                   |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">     </span></span><br><span class="line"><span class="string">                                              </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span></span><br><span class="line"><span class="string">                          </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span></span><br><span class="line"><span class="string">res   </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">   </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack :</span><br><span class="line">            <span class="comment"># cur 节点不为空一直压栈，并到达最左端的叶子节点</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 考虑左子树</span></span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 节点为空就出栈 </span></span><br><span class="line">            temp = stack.pop()</span><br><span class="line">            <span class="comment"># 出栈元素加入结果</span></span><br><span class="line">            res.append(temp.val)  </span><br><span class="line">            <span class="comment"># 考虑右子树</span></span><br><span class="line">            cur = temp.right</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>后序遍历 左子树-&gt;右子树-&gt;根节点 从下到上、从左至右</li>
</ul>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">1</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">4</span>  <span class="number">5</span>    </span><br><span class="line">```       </span><br><span class="line">当遍历完某个根节点的左子树，回到根节点的时候，</span><br><span class="line">对于中序遍历和先序遍历可以把当前根节点从栈里弹出，然后转到右子树</span><br><span class="line">当遍历完 <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span> 的时候，回到 <span class="number">1</span> 之后我们就可以把 <span class="number">1</span> 弹出，</span><br><span class="line">然后通过 <span class="number">1</span> 到达右子树继续遍历。</span><br><span class="line"></span><br><span class="line">而对于后序遍历，当我们到达 <span class="number">1</span> 的时候并不能立刻把 <span class="number">1</span> 弹出，</span><br><span class="line">因为遍历完右子树，我们还需要将这个根节点加入到 <span class="type">list</span> 中。</span><br><span class="line">所以我们就需要判断是从左子树到的根节点，还是右子树到的根节点。</span><br><span class="line">如果是从左子树到的根节点，此时应该转到右子树。</span><br><span class="line">如果是从右子树到的根节点，那么就可以把当前节点弹出，并且加入到 <span class="type">list</span> 中。</span><br><span class="line"></span><br><span class="line">当然，如果是从左子树到的根节点，此时如果根节点的右子树为 None， </span><br><span class="line">此时也可以把当前节点弹出，并且加入到 <span class="type">list</span> 中。</span><br><span class="line"></span><br><span class="line">基于上边的思想，可以写出一些不同的代码。</span><br><span class="line"></span><br><span class="line">法一：</span><br><span class="line">从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，</span><br><span class="line">然后依次压入它的所有孩子节点，</span><br><span class="line">而这里是先把左节点压入栈，再把右节点压入栈（根 - 右 - 左），</span><br><span class="line">按照从上到下、从左至右的顺序依次压入栈中。</span><br><span class="line">需要将输出列表逆序输出（左 - 右 -根），即后续遍历。</span><br><span class="line"></span><br><span class="line">只是能返回遍历的结果，并不是严格意义上树拓扑结构的遍历。</span><br><span class="line">虽然结果是正确，但是如果需要按照后续遍历的顺序对树节点进行访问（或操作），此解法就无法满足。</span><br><span class="line"></span><br><span class="line">时间复杂度为 O(N)：访问每个节点恰好一次，其中 N 是节点的个数，也就是树的大小。</span><br><span class="line">空间复杂度为 O(N)：取决于树的结构，最坏情况需要保存整棵树</span><br><span class="line"></span><br><span class="line">先序遍历：root-&gt;left-&gt;right </span><br><span class="line">后序遍历：left-&gt;right-root，两者反过来当然不相等了，</span><br><span class="line">但是如果把先序遍历改成root-&gt;right-left，再逆序一下就相等了</span><br></pre></td></tr></tbody></table></figure>
<pre><code>        0
       /  \
      1    2
</code></pre>
<p>后序</p>
<pre><code>       | |  | |  |2|  | |
</code></pre>
<p>stack |0|  | |  |1|  |1|  |1|  | | </p>
<pre><code>                           |1| 
            | |  | |  |2|  |2| 压入根左右
</code></pre>
<p>res   | |  |0|  |0|  |0|  |0|  |0| 弹出根右左————逆序：左右根</p>
<pre><code>        0
       /  \
      1    2
     / \  / \
    3  4 5   6
</code></pre>
<p>后序<br>                          |6|  | |<br>           | |  |2|  | |  |5|  |5|  | |  | |  | |  |4|  | |  | |<br>stack |0|  | |  |1|  |1|  |1|  |1|  |1|  | |  |3|  |3|  |3|  | |<br>      —  —  —  —  —  —  —  —  —  —  —  — </p>
<pre><code>                                                         |3|
                                               | |  |4|  |4|    
                                     |1|  |1|  |1|  |1|  |1|
                      | |  | |  |5|  |5|  |5|  |5|  |5|  |5|
            | |  | |  | |  |6|  |6|  |6|  |6|  |6|  |6|  |6| 
       | |  | |  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|  |2|
</code></pre>
<p>res   | |  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|  |0|<br>      —  —  —  —  —  —  —  —  —  —  —  —</p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```<span class="keyword">python</span></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, roo<span class="variable">t:</span> TreeNode) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">res</span> = []</span><br><span class="line">        <span class="keyword">if</span> not roo<span class="variable">t:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line">        stack = [root,]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.<span class="keyword">pop</span>()</span><br><span class="line">            <span class="keyword">res</span>.<span class="keyword">append</span>(node.val)</span><br><span class="line">            # <span class="keyword">res</span>.<span class="keyword">insert</span>(<span class="number">0</span>, node.val)  # 直接插入头部，不用反转</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.<span class="keyword">left</span> :</span><br><span class="line">                stack.<span class="keyword">append</span>(node.<span class="keyword">left</span>)</span><br><span class="line">            <span class="keyword">if</span> node.righ<span class="variable">t:</span></span><br><span class="line">                stack.<span class="keyword">append</span>(node.<span class="keyword">right</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span>[::-<span class="number">1</span>]</span><br><span class="line">        # <span class="keyword">return</span> <span class="keyword">res</span>  # 直接插入头部，不用反转</span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>从「根-左-右」<br>节点插入结果数组尾部的逻辑，修改为将节点插入结果数组的头部，数组变成<br>—&gt; 「右-左-根」<br>遍历的顺序先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点<br>—&gt; 「左-右-根」这刚好是后序遍历的顺序</p>
<p>节点 cur 先到达最右端的叶子节点并将路径上的节点入栈；<br>然后每次从栈中弹出一个元素后，cur 到达它的左孩子，<br>并将左孩子看作 cur 继续执行上面的步骤。</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">后序</span><br><span class="line">                                         </span><br><span class="line">           |<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">                          </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> 压入根左右</span></span><br><span class="line"><span class="string">res   </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> 弹出根右左————逆序：左右根</span></span><br><span class="line"></span><br><span class="line"><span class="string">            0</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          1    2</span></span><br><span class="line"><span class="string">         / \  / \</span></span><br><span class="line"><span class="string">        3  4 5   6</span></span><br><span class="line"><span class="string">后序</span></span><br><span class="line"><span class="string">                </span>|<span class="string">6</span>|<span class="string">       </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">                 </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">stack |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                                                                  |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|</span><br><span class="line">                                                   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">    </span></span><br><span class="line"><span class="string">                                         </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|</span><br><span class="line">                          |<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, stack = [], []</span><br><span class="line">        cur = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:  </span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.insert(<span class="number">0</span>, cur.val)  <span class="comment"># 插入头部不用逆序</span></span><br><span class="line">                <span class="comment"># res.append(cur.val)  # 插入尾部要逆序</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                <span class="comment"># 每次先遍历右节点</span></span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再遍历左节点</span></span><br><span class="line">            cur = stack.pop().left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 插入头部不用逆序，更快</span></span><br><span class="line">        <span class="comment"># return res[::-1]  # 插入尾部要逆序输出，要慢很多 </span></span><br></pre></td></tr></tbody></table></figure>


<p>因此掌握标准的栈操作解法是必要的。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">laterOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="keyword">while</span> tmpNode <span class="keyword">or</span> stack :</span><br><span class="line">        <span class="keyword">while</span> tmpNode:</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node = stack[<span class="number">-1</span>]</span><br><span class="line">        tmpNode = node.right</span><br><span class="line">        <span class="keyword">if</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> node == stack[<span class="number">-1</span>].right:</span><br><span class="line">                node =  stack.pop()</span><br><span class="line">                print(node.val)</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>递归算法的三个要素<br>1.确定递归函数的参数和返回值：<br>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，<br>并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
<p>2.确定终止条件：<br>写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，<br>就是没写终止条件或者终止条件写的不对，<br>操作系统也是用一个栈的结构来保存每一层递归的信息，<br>如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
<p>3.确定单层递归的逻辑：<br>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
<p>它们的模板相对比较固定，一般都会新增一个 dfs 函数：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">        dfs(root.right)</span><br></pre></td></tr></tbody></table></figure>

<p>对于前序、中序和后序遍历，<br>只需将递归函数里的 res.append(root.val) 放在不同位置即可，<br>然后调用这个递归函数就可以了，代码完全一样。</p>
<p>1.前序遍历</p>
<ol>
<li>确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，<br>所以参数里需要传入root在放节点的数值，<br>除了这一点就不需要在处理什么数据了也不需要有返回值，<br>所以递归函数返回类型就是</li>
<li>确定终止条件：在递归的过程中，如何算是递归结束了呢，<br>当然是当前遍历的节点是空了，那么本层递归就要要结束了，<br>所以如果当前遍历的这个节点是空，就直接return</li>
<li>确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>2.中序遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```                </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>后序遍历</span><br><span class="line">```python </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res  <span class="comment"># 为了让上一级定义的 res 能在这个函数用</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 右</span></span><br><span class="line">            res.append(root.val)  <span class="comment"># 根节点root 的处理在此处完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```                     </span><br><span class="line"></span><br><span class="line">- 广度优先遍历（Breath First Search）bfs</span><br><span class="line">返回其按 层序遍历 得到的节点值。</span><br><span class="line">从树的root开始，从上到下从从左到右遍历整个树的节点</span><br><span class="line">按照高度顺序逐层遍历的访问整棵树，</span><br><span class="line">示例：</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br></pre></td></tr></tbody></table></figure>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回其层次遍历结果：</span><br></pre></td></tr></tbody></table></figure>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</span><br><span class="line">每层遍历都以上一层遍历的结果作为起点，遍历一个长度，遍历一个距离能访问到的所有节点。</span><br><span class="line">要求我们区分每一层，同一层的节点应该放在一起，也就是返回一个二维数组，故使用模板二。</span><br><span class="line"></span><br><span class="line">使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，</span><br><span class="line">再把每个元素的非空左右子节点进入队列。</span><br><span class="line">因此即可得到每层的遍历。</span><br><span class="line">用到 deque 的结构用来模拟队列（先进先出），当前层的节点肯定会优先访问，</span><br><span class="line">先将根节点放到队列中，然后不断遍历队列</span><br><span class="line">然后每次处理从队列中出队一个元素</span><br><span class="line">要明确要从那些点开始扩张(具体如何扩张需要根据题目要求)</span><br><span class="line">对于扩张后满足某条件的点再进行处理，根据需要进入队列，</span><br><span class="line">进入队列的点就是扩到下一层的点(不同题目需要处理的方法不同，大家灵活运用)</span><br><span class="line">然后接着循环处理 deque 中的元素，直到 deque 为空，则代表所有点都已经完成扩张</span><br><span class="line">最后根据题目要求输出结果(当然这已经不属于 BFS 模板的范围了)</span><br><span class="line"></span><br><span class="line">BFS总共有两个模板：</span><br><span class="line">  1. 如果不需要确定当前遍历到了哪一层，BFS模板如下。</span><br><span class="line">```py</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    <span class="keyword">for</span> 节点 <span class="keyword">in</span> cur的所有相邻节点：</span><br><span class="line">        <span class="keyword">if</span> 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>如果要确定当前遍历到了哪一层，BFS模板如下。<br>这里增加了level表示当前遍历到二叉树中的哪一层了，<br>也可以理解为在一个图中，现在已经走了多少步了。<br>size表示在当前遍历层有多少个元素，<br>也就是队列中的元素数，<br>我们把这些元素一次性遍历完，<br>即把当前层的所有元素都向外走了一步。<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level = 0</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    <span class="keyword">while</span> (size --) {</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> 节点 <span class="keyword">in</span> cur的所有相邻节点：</span><br><span class="line">            <span class="keyword">if</span> 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    }</span><br><span class="line">    level ++;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点对象list1初始仅包含根节点，后续仅保存一层节点</span><br><span class="line">节点值list2初始为空，后续累积保存整棵树的所有节点值</span><br><span class="line"><span class="keyword">while</span> 节点对象list1不为空:</span><br><span class="line">    收集当前层节点对象list1的每一个值，添加保存至节点值list2</span><br><span class="line">    收集当前层节点对象list1的每一个子节点，覆盖保存至节点对象list1</span><br><span class="line">返回收集完全的节点值list2</span><br></pre></td></tr></tbody></table></figure>

<p>实现 BFS 时需要考虑以下问题：<br>队列：用来存储每一轮遍历的节点；<br>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</p>
<p>适用场景：求解目标：「层序遍历」、「最短路径」。<br>输入数据：没什么特征，不像深搜，需要有“递归”的性质。<br>如果是树或者状态转换图，概率更大。</p>
<p>算法流程：</p>
<ol>
<li>特例处理： 当根节点为空，则返回空列表 [] ；</li>
<li>初始化： 打印最终结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li>
<li>BFS 循环： 当队列 queue 为空时跳出；</li>
<li>新建一个临时列表 cur_layer ，用于存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）<br>避免定义了一个新队列存放下一层的节点，<ol>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 将 node.val 添加至 cur_layer 尾部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
</ol>
</li>
<li>将当前层结果 cur_layer 添加入 res 。</li>
<li>返回值： 返回打印结果列表 res 即可。</li>
</ol>
<p>时间复杂度 O(N)：每个点进队出队各一次，BFS 需循环 n 次。n 为二叉树的节点数量<br>空间复杂度 O(N)： 因为是按层打印，最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。<br>假定是满二叉树，也就是叶子节点那一层全满，那么每一层应该是2^(n-1)，<br>然后采用等比数列求和，就是2^n-1，<br>所以 (2^n-1) / (2^n-1) 约等于2，<br>所以可以看到几乎就是N/2<br>这个 N / 2 是一个数量级的表示，代表平衡情况下 最后一层节点数量是 所有节点数量的一半。<br>准确来说，最后一层节点的数量是 (N+1)/2 ~</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span>  <span class="comment"># 返回含列表的列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># root为空遇到叶子节点返回[] </span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)  <span class="comment"># 根元素入队列</span></span><br><span class="line">        res = []  <span class="comment"># 层序遍历结果列表</span></span><br><span class="line">        <span class="keyword">while</span> queue:  <span class="comment"># 直到队列为空，无法再次向队列中推入节点，循环结束。</span></span><br><span class="line">            <span class="comment"># 当队列不为空的时候</span></span><br><span class="line">            cur_layer = []  <span class="comment"># 临时变量，记录当前层的节点</span></span><br><span class="line">            <span class="comment"># 第i次迭代得到二叉树的第i层的len(queue)个结点进行拓展</span></span><br><span class="line">            <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                <span class="comment"># range() 的工作机制是在开启循环时建立一个列表，然后循环按照这个列表进行，因此“只会在进入循环前执行一次 len(queue) ” </span></span><br><span class="line">                cur = queue.popleft()  <span class="comment"># 从弹出队列的头部元素开始将队列中的元素都拿出来(也就是获取这一层的节点)</span></span><br><span class="line">                <span class="comment"># 不用判断 if cur: 因为不是序列化，None时不会append</span></span><br><span class="line">                cur_layer.append(cur.val)  <span class="comment"># 节点加入到当前层cur_layer</span></span><br><span class="line">                <span class="comment"># 如果当前节点有左右子节点，则先左后右压入队列，作为下一层的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)  <span class="comment"># 左子树，移动一层，不是最左</span></span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="comment">#  某一层的节点都处理完之后，将临时的当前层的结果压入最终返回结果中</span></span><br><span class="line">            res.append(cur_layer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line">                                    |<span class="string">6</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">               </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">queue |<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string"> </span></span><br><span class="line"><span class="string">cur_l </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span></span><br><span class="line"></span><br><span class="line"><span class="string">                                                        </span>|<span class="string">6</span>|</span><br><span class="line">                                                        |<span class="string">5</span>|</span><br><span class="line">                                                        |<span class="string">4</span>|</span><br><span class="line">                                                        |<span class="string">3</span>|<span class="string">     </span></span><br><span class="line"><span class="string">                                                        </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                                    </span>|<span class="string">2</span>|<span class="string">                 </span>|<span class="string">2</span>|</span><br><span class="line">                                    |<span class="string">1</span>|<span class="string">                 </span>|<span class="string">1</span>|<span class="string">   </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">res   </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  </span></span><br></pre></td></tr></tbody></table></figure>

<p>当访问根结点 3 的时候需要把它的左右孩子结点 [9, 20]先保存起来，访问[9, 20]把它两个结点的左右孩子结点保存起来[none, none, 15, 7], 访问[15, 7]的时候左右孩子结点为 [ ]。返访问为空结束层遍历。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># root为空时直接返回[]</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []  <span class="comment"># 返回的最终结果</span></span><br><span class="line">        cur_nodes = [root]  <span class="comment"># 当前访问层</span></span><br><span class="line">        next_nodes = []  <span class="comment"># 下一层需要访问的</span></span><br><span class="line">        res.append([i.val <span class="keyword">for</span> i <span class="keyword">in</span> cur_nodes])  <span class="comment"># 先把第一层的值放入res中</span></span><br><span class="line">        <span class="keyword">while</span> cur_nodes <span class="keyword">or</span> next_nodes:  <span class="comment"># 当前结点或下一层结点不为空</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur_nodes:  <span class="comment"># 当前结点的所有孩子都加入next_nodes</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_nodes.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_nodes.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> next_nodes:  <span class="comment"># 下一层结点不为空时加入res</span></span><br><span class="line">                res.append([i.val <span class="keyword">for</span> i <span class="keyword">in</span> next_nodes])</span><br><span class="line">            cur_nodes = next_nodes  <span class="comment"># 更新当前结点为next_nodes</span></span><br><span class="line">            next_nodes = []  <span class="comment"># 下一层结点置空</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            0</span><br><span class="line">           /  \</span><br><span class="line">          1    2</span><br><span class="line">         / \  / \</span><br><span class="line">        3  4 5   6</span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line">                               |<span class="string">6</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">               </span></span><br><span class="line"><span class="string">           </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">cur_n |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"><span class="string">                </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">next_ |<span class="string"> </span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  --- </span><br><span class="line"></span><br><span class="line">                          |<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string"> </span></span><br><span class="line"><span class="string">                          </span>|<span class="string">5</span>|<span class="string">  </span>|<span class="string">5</span>|</span><br><span class="line">                          |<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line">                          |<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">   </span></span><br><span class="line"><span class="string">           </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">           </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string">  </span>|<span class="string">1</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|<span class="string">  </span>|<span class="string">-</span>|</span><br><span class="line">res   |<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string">  </span>|<span class="string">0</span>|<span class="string"> </span></span><br><span class="line"><span class="string">      ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  ---  </span></span><br></pre></td></tr></tbody></table></figure>


<p>递归<br>相同层的节点归于同一个数组<br>传入辅助的level参数决定层次</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">depth, r</span>):</span></span><br><span class="line">            <span class="comment"># 在第一次遍历到某一层是是没有"[]"的, 需要补一个"[]",用来存储该层节点值</span></span><br><span class="line">            <span class="comment"># 多维列表的长度</span></span><br><span class="line">            <span class="comment"># print(len([[1, 2], [3, 4], [5, 6]]))  # 3</span></span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            <span class="comment">#  将当前节点的值加入到res中，depth代表当前层，假设depth是3，节点值是99</span></span><br><span class="line">            <span class="comment"># res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]</span></span><br><span class="line">            res[depth - <span class="number">1</span>].append(r.val)</span><br><span class="line">            <span class="comment"># 递归的处理左子树，右子树，同时将层数depth+1</span></span><br><span class="line">            <span class="keyword">if</span> r.left:  <span class="comment"># 左节点存在，只在本次以左节点为根节点递归函数中深度加一</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right:  <span class="comment"># 右节点存在，只在本次以右节点为根节点递归函数中深度加一</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, r.right)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">1</span>, root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">            <span class="number">0</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">         / \  / \</span><br><span class="line">        <span class="number">3</span>  <span class="number">4</span> <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">层序 队列 删除第一个 最下面的</span><br><span class="line"></span><br><span class="line">①root = <span class="number">0</span></span><br><span class="line">len(res) = <span class="number">0</span> &lt; depth = <span class="number">1</span></span><br><span class="line">res = [ [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">0</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>] ]</span><br><span class="line"></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">1</span> &lt; depth = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">0</span>], [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">1</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">2</span> = depth = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">1</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">②root = <span class="number">1</span></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">2</span> &lt; depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">3</span> = depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] ]</span><br><span class="line"></span><br><span class="line">②root = <span class="number">2</span></span><br><span class="line">root.left存在root = root.left</span><br><span class="line">len(res) = <span class="number">3</span> &lt; depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line"></span><br><span class="line">root.right存在root = root.right</span><br><span class="line">len(res) = <span class="number">3</span> = depth = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line">res[depth - <span class="number">1</span>].append(r.val)=res[<span class="number">2</span>].append(r.val)</span><br><span class="line">res = [ [<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] ]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">"""递归法"""</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_to_result</span>(<span class="params">level, node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> level &gt; len(result) - <span class="number">1</span>:</span><br><span class="line">                result.append([])</span><br><span class="line">                </span><br><span class="line">            result[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                add_to_result(level+<span class="number">1</span>, node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                add_to_result(level+<span class="number">1</span>, node.right)</span><br><span class="line">        </span><br><span class="line">        add_to_result(<span class="number">0</span>, root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>本题使用 DFS 同样能做，DFS 不是按照层次遍历的。<br>为了让递归的过程中同一层的节点放到同一个列表中，<br>在递归时要记录每个节点的深度 level。<br>递归到新节点要把该节点放入 level 对应列表的末尾。</p>
<p>当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，<br>应该在 res 中新建一个列表用来保存该 level 的所有节点。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, depth</span>):</span></span><br><span class="line">            <span class="comment"># 相等于给当层返回值提供一个容器先，</span></span><br><span class="line">            <span class="comment"># 如果size的数量正好等于level，说明正好需要提供下一层的容器</span></span><br><span class="line">            <span class="comment"># 遍历到新的一个 level 时，需要新建一列表保存该层的所有节点</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left: helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> root.right: helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="28-从上往下打印二叉树"><a href="#28-从上往下打印二叉树" class="headerlink" title="28.从上往下打印二叉树"></a>28.从上往下打印二叉树</h2><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong><br>例如:<br>给定二叉树:&nbsp;[3,9,20,null,null,15,7],</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：</p>
<ul>
<li>二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。</li>
<li>BFS 通常借助 队列 的先入先出特性来实现。</li>
</ul>
<p>算法流程：</p>
<ol>
<li>特例处理：当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化：打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li>
<li>BFS 循环：当队列 queue 为空时跳出；</li>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 将 node.val 添加至列表 tmp 尾部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
<li>返回值： 返回打印结果列表 res ，一个一维数组，不用区分每一层。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，满二叉树的最下面那层 该层有N/2个节点，<br>即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</p>
<p>collections 中的双端队列 deque() 的 popleft() 方法 O(1) 时间复杂度；<br>列表 list 的 pop(0) 方法时间复杂度为 O(N) 。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span>  <span class="comment">#　返回含数字的列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []  <span class="comment"># 如果根结点为空，直接返回空列表</span></span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment"># 写成queue=[root]， pop(0) 方法时间复杂度为 O(N) </span></span><br><span class="line">        <span class="keyword">while</span> queue:  <span class="comment"># 当队列不为空时一直循环</span></span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span>          queue=[<span class="number">3</span>]</span><br><span class="line"> / \         res=[]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[]</span><br><span class="line"> / \         res=[<span class="number">3</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点  queue=[<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span>   </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[<span class="number">2</span>] # 队列默认删除第一个元素</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">9</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[<span class="number">2</span>]</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span>   </span><br><span class="line"> </span><br><span class="line">  <span class="number">3</span>          </span><br><span class="line"> / \         queue=[]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">  /  \       queue添加左右子节点 queue=[<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[<span class="number">7</span>]</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">1</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[<span class="number">7</span>] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[]</span><br><span class="line"> / \         res=[<span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        queue添加左右子节点：节点 <span class="number">7</span> 无左右子节点，直接跳过</span><br><span class="line">  /  \       queue=[] </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>     </span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>          queue=[], queue为空</span><br><span class="line"> / \         跳出循环，返回res</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span>        </span><br><span class="line">  /  \        </span><br><span class="line"> <span class="number">1</span>    <span class="number">7</span>        </span><br></pre></td></tr></tbody></table></figure>

<p><strong>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</strong></p>
<p>例如:<br>给定二叉树:&nbsp;[3,9,2,null,null,1,7],</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>   <span class="number">2</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">1</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>奇数层正序打印顺序是从左边节点到右边节点，<br>偶数层倒序打印顺序是从右边节点到左边节点<br>双端队列的方法省了倒序的时间，</p>
<p>方法一：层序遍历 + 双端队列</p>
<ul>
<li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：<ul>
<li>奇数层 则添加至 tmp 尾部 ，</li>
<li>偶数层 则添加至 tmp 头部 。<br>算法流程：</li>
</ul>
</li>
</ul>
<ol>
<li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；</li>
<li>BFS 循环： 当 deque 为空时跳出；<ol>
<li>新建列表 tmp ，用于临时存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<ol>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；</li>
</ol>
</li>
<li>将当前层结果 tmp 转化为 list 并添加入 res ；</li>
</ol>
</li>
<li>返回值： 返回打印结果列表 res 即可；</li>
</ol>
<p>代码简短、容易实现；<br>但需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。</p>
<p>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；<br>双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                <span class="comment"># 每打印一层， res 长度就会加 1 ；</span></span><br><span class="line">                <span class="comment"># 因此，在遍历第 1 层时， res 长度为 0 ；</span></span><br><span class="line">                <span class="comment"># 在遍历第 2 层时， res 长度为 1；以此类推。 </span></span><br><span class="line">                <span class="comment"># 因此， res 的长度为 奇数 ，说明当前是偶数层。</span></span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span>:  <span class="comment"># if len(res) % 2 ，与位运算比除法更快</span></span><br><span class="line">                <span class="comment"># len(res)对2求余是1，代表是 1 3 5 7，此时在遍历 2 4 6 8 ……层，因此偶数层 -&gt; 队列头部</span></span><br><span class="line">                    tmp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># len(res)对2求余是0，即为奇数层 -&gt; 队列尾部</span></span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: deque.append(node.right)</span><br><span class="line">            res.append(list(tmp))  <span class="comment"># list() 这个函数时间复杂度是O（N）</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []  len(res)= <span class="number">0</span> <span class="number">0</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">deque = [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">tem = [] </span><br><span class="line">len(deque) = <span class="number">1</span> </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">tem = [<span class="number">3</span>] </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ] len(res)= <span class="number">1</span> <span class="number">1</span>%<span class="number">2</span>=<span class="number">1</span>!=<span class="number">0</span> 下一层插入队列头部</span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">2</span>]</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">tem = [<span class="number">9</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">tem = [<span class="number">2</span>，<span class="number">9</span>] </span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]  len(res)= <span class="number">2</span> <span class="number">2</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部 </span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">tem = [<span class="number">1</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">tem = [<span class="number">1</span>，<span class="number">7</span>] </span><br><span class="line">deque = []</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>，<span class="number">7</span>] ] </span><br><span class="line"></span><br><span class="line">deque = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>queue也可以直接用列表来存储，使用列表迭代来取节点，这样可以省略pop操作。<br>但是要注意不能直接给queue列表添加元素，这样会导致跳不出for循环，<br>要使用中间变量temp2来存储下一层节点。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = collections.deque()</span><br><span class="line">            temp2 = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span>:  <span class="comment"># 偶数层</span></span><br><span class="line">                    tmp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 奇数层</span></span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp2.append(node.right)</span><br><span class="line">            res.append(list(tmp))</span><br><span class="line">            queue = temp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []  len(res)= <span class="number">0</span> <span class="number">0</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">queue = [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">temp = [] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">temp = [<span class="number">3</span>] </span><br><span class="line">temp2 = [<span class="number">9</span>]</span><br><span class="line">temp2 = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ] len(res)= <span class="number">1</span> <span class="number">1</span>%<span class="number">2</span>=<span class="number">1</span>!=<span class="number">0</span> 下一层插入队列头部</span><br><span class="line">queue = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line">temp2 = []</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">temp = [<span class="number">9</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">temp = [<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line">temp2 = [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ] len(res)= <span class="number">2</span> <span class="number">2</span>%<span class="number">2</span>=<span class="number">0</span> 下一层插入队列尾部</span><br><span class="line">queue = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line">temp2 = []</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">temp = [<span class="number">1</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">temp = [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line">temp2 = [] </span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>，<span class="number">7</span>] ] </span><br><span class="line">queue = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>方法三：层序遍历 + 双端队列（奇偶层逻辑分离）<br>通过将奇偶层逻辑拆分，可以消除冗余的判断。<br>算法流程：<br>与方法一对比，仅 BFS 循环不同。</p>
<ul>
<li>BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；<ol>
<li>打印奇数层： 从左向右 打印，先左后右 加入下层节点；</li>
<li>若 deque 为空，说明向下无偶数层，则跳出；</li>
<li>打印偶数层： 从右向左 打印，先右后左 加入下层节点；</li>
</ol>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># 打印奇数层</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="comment"># 从左向右打印</span></span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="comment"># 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span> node.left: </span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: </span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> deque: <span class="keyword">break</span> <span class="comment"># 若为空则提前跳出</span></span><br><span class="line">            <span class="comment"># 打印偶数层</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="comment"># 从右向左打印</span></span><br><span class="line">                node = deque.pop()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="comment"># 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span> node.right: deque.appendleft(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: deque.appendleft(node.left)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">deque = [<span class="number">3</span>]</span><br><span class="line">tem = [] </span><br><span class="line">len(deque) = <span class="number">1</span></span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">tem = [<span class="number">3</span>] </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">res = [ [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">9</span>]</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">tem = [<span class="number">2</span>] </span><br><span class="line">deque = [<span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">node = <span class="number">9</span> </span><br><span class="line">deque = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]  </span><br><span class="line"></span><br><span class="line">tem = []</span><br><span class="line">len(deque) = <span class="number">2</span> </span><br><span class="line">deque = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">tem = [<span class="number">1</span>] </span><br><span class="line">deque = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">tem = [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>] ] </span><br><span class="line"></span><br><span class="line">deque = []为空跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>法四<br>奇偶层的判断可以用标志符做判断，利用乘法“正负得负，负负得正”，<br>每层遍历完后做一次乘法，可以很简单的实现标志符的奇偶层转变。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># True False都可以只要反转就行</span></span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            flag = <span class="keyword">not</span> flag  <span class="comment"># 每次都进行反转</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                <span class="keyword">if</span> flag:  <span class="comment"># 从左向右打印</span></span><br><span class="line">                    node = deque.popleft()</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        deque.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        deque.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 从右向左，出队顺序为头进尾出，右节点早于左节点</span></span><br><span class="line">                    node = deque.pop()</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        deque.appendleft(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        deque.appendleft(node.left)</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">res</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">3</span>]</span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">3</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">2</span>] </span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">9</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">7</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">1</span>] </span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">7</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">1</span>, <span class="number">7</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>] ]</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        queue = deque([root])  <span class="comment">#储存每一层节点的队列</span></span><br><span class="line">        level = <span class="number">0</span>  <span class="comment">#表示节点的层级</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res.append([])</span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#偶数层</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    node = queue.popleft()</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        queue.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">#奇数层</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    node = queue.pop()</span><br><span class="line">                    res[level].append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        queue.appendleft(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        queue.appendleft(node.left)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">res</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">3</span>]</span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [] </span><br><span class="line"><span class="string">len(deque)</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">node</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>]</span><br><span class="line"><span class="string">deque</span> <span class="string">=</span> [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line"><span class="string">tem</span> <span class="string">=</span> [<span class="number">3</span>] </span><br><span class="line"><span class="string">res</span> <span class="string">=</span> [ [<span class="number">3</span>] ]</span><br></pre></td></tr></tbody></table></figure>

<p>法五<br>双栈<br>如果当前层是偶数层(0,2,4),就访问queue1并依次读取左子树和右子树,<br>如果当前层是奇数层,就访问queue2并先读取右子树再读取左子树</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line">        level = <span class="number">0</span>  <span class="comment"># 表示节点的层级</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果当前是奇数层</span></span><br><span class="line">                <span class="comment"># 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(stack1)):</span><br><span class="line">                    node = stack1.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack2.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack2.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前是偶数层</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(stack2)):</span><br><span class="line">                    node = stack2.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack1.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack1.append(node.left)</span><br><span class="line">            res.append(temp)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span>      </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">1</span>    <span class="number">7</span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">queue1 = [<span class="number">3</span>]</span><br><span class="line">queue2 = []</span><br><span class="line">level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">res=[ [] ]</span><br><span class="line">len(queue1) = <span class="number">1</span></span><br><span class="line">queue1 = []</span><br><span class="line">node = <span class="number">3</span></span><br><span class="line">res = [ [<span class="number">3</span>] ]</span><br><span class="line">queu2 = [<span class="number">9</span>]</span><br><span class="line">queue2 = [<span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">level = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res = [ [<span class="number">3</span>], [] ]</span><br><span class="line">len(queue2) = <span class="number">2</span></span><br><span class="line">queue2 = [<span class="number">9</span>]</span><br><span class="line">node = <span class="number">2</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>] ]</span><br><span class="line">queue1 = [<span class="number">7</span>]</span><br><span class="line">queue1 = [<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">queue2 = []</span><br><span class="line">node = <span class="number">9</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>] ]</span><br><span class="line">queue1 = [<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">level = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [] ]</span><br><span class="line">len(queue1) = <span class="number">2</span></span><br><span class="line">queue1 = [<span class="number">7</span>]</span><br><span class="line">node = <span class="number">1</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>] ]</span><br><span class="line">queue1 = []</span><br><span class="line">node = <span class="number">7</span></span><br><span class="line">res = [ [<span class="number">3</span>], [<span class="number">2</span>, <span class="number">9</span>], [<span class="number">1</span>] ]</span><br><span class="line">level = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">queue1 = queue2 = [] 都为空，跳出循环</span><br></pre></td></tr></tbody></table></figure>

<p>不需要level</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack2:  <span class="comment"># 如果当前是奇数层</span></span><br><span class="line">                <span class="comment"># 清空stack1过程中，依次将栈顶节点子节点（先左后右）压入stack2</span></span><br><span class="line">                <span class="keyword">while</span> stack1:</span><br><span class="line">                    node = stack1.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack2.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack2.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果当前是偶数层</span></span><br><span class="line">                <span class="keyword">while</span> stack2:</span><br><span class="line">                    node = stack2.pop()</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        stack1.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        stack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; [[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack1 = [root]  <span class="comment"># 栈1存放奇数层的节点。</span></span><br><span class="line">        stack2 = []  <span class="comment"># 栈2存放偶数层的节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:  <span class="comment"># 直到stack1和stack2都为空。</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> stack1:</span><br><span class="line">                node = stack1.pop()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack2.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack2.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                res.append(temp)</span><br><span class="line">            temp2 = []</span><br><span class="line">            <span class="keyword">while</span> stack2:</span><br><span class="line">                node = stack2.pop()</span><br><span class="line">                temp2.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack1.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> temp2:</span><br><span class="line">                res.append(temp2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>



<p>层序遍历 + 倒序<br>此方法的优点是只用列表即可，无需其他数据结构。<br>偶数层倒序： 若 res 的长度为 奇数 ，说明当前是偶数层，则对 tmp 执行 倒序 操作。<br>复杂度分析：<br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        q = collections.deque()  <span class="comment"># BFS模板，需要用队列实现</span></span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)): <span class="comment"># 模板操作</span></span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果当前的res的长度是偶数，说明本次tmp中存储的是偶数层(设根为 0 层)</span></span><br><span class="line">                res.append(tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(tmp[::<span class="number">-1</span>])  <span class="comment"># 否则将tmp翻转再加入结果集</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h2 id="25-重建二叉树"><a href="#25-重建二叉树" class="headerlink" title="25.重建二叉树"></a>25.重建二叉树</h2><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">首先根据 preorder 找到根节点是 <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">然后根据根节点将 inorder 分成左子树和右子树</span><br><span class="line">左子树</span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">把相应的前序遍历的数组也加进来</span><br><span class="line">左子树</span><br><span class="line">preorder[<span class="number">9</span>] </span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">preorder[<span class="number">20</span> <span class="number">15</span> <span class="number">7</span>] </span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题</span><br><span class="line">然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 <span class="literal">null</span> 即可</span><br></pre></td></tr></tbody></table></figure>

<p>我们不需要真的把 preorder 和 inorder 切分了，只需要用分别用两个指针指向开头和结束位置即可。<br>注意下边的两个指针指向的数组范围是包括左边界，不包括右边界。</p>
<p>给出</p>
<figure class="highlight mathematica"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前序遍历preorder = [<span class="keyword">E</span>,B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,F,H,G,<span class="keyword">I</span>,<span class="keyword">K</span>,J]</span><br><span class="line">中序遍历 inorder = [A,B,<span class="keyword">C</span>,<span class="keyword">D</span>,<span class="keyword">E</span>,F,G,H,<span class="keyword">I</span>,J,<span class="keyword">K</span>]</span><br><span class="line"></span><br><span class="line">根为第一个为 <span class="keyword">E</span>，则A,B,<span class="keyword">C</span>,<span class="keyword">D</span>为<span class="keyword">E</span>的左子树，F,G,H,<span class="keyword">I</span>,J,<span class="keyword">K</span>为<span class="keyword">E</span>的右子树</span><br><span class="line">A,B,<span class="keyword">C</span>,<span class="keyword">D</span>为左子树，B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,中的根为第一个为B,</span><br><span class="line">那么A 为根B的左子树，<span class="keyword">C</span>,<span class="keyword">D</span> 为根B的右子树</span><br><span class="line">B,A,<span class="keyword">D</span>,<span class="keyword">C</span>,中的右子树的根为第一个<span class="keyword">D</span>，<span class="keyword">C</span>为根<span class="keyword">D</span>的左子树</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    E </span><br><span class="line">   / <span class="tag">\<span class="name"> </span></span></span><br><span class="line">  B   F</span><br><span class="line"> / <span class="tag">\<span class="name"> </span></span>  <span class="tag">\</span></span><br><span class="line">A   D   H</span><br><span class="line">    /  / <span class="tag">\<span class="name"> </span></span> </span><br><span class="line">   C  G   I</span><br><span class="line">           <span class="tag">\</span></span><br><span class="line">            K</span><br><span class="line">           /</span><br><span class="line">          J</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%89%8D%E4%B8%AD.png"></p>
<p>没有重复的元素：表明树中每个节点值都是唯一的，<br>保证节点的数值和它在中序遍历中的下标可以一一对应，<br>这样还原的二叉树才是可以唯一确定的</p>
<p>在中序遍历中搜索根节点 root 的索引 ，<br>可将此树的中序遍历划分为 [ 左子树 | 根节点 | 右子树 ] 。</p>
<p>根据中序遍历中的左（右）子树的节点数量，<br>可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ] 。</p>
<p>左子树区间 和 右子树区间 有对应的 左/右边界<br>这些边界分别用于递归左子树和右子树；</p>
<p>子树特点： 子树的前序和中序遍历仍符合以上特点，<br>通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。<br>此递推性质让我们联想到用 递归方法 处理。<br>知道inorder中，当前root的左侧的所有点就是其左子树，<br>root的右侧的所有点就是当前root的右子树，<br>就把这左右两堆数字想成当前root的左右2个节点就好，然后扔到函数里进行下一层的递归。</p>
<p>分治法的思想：把原问题分解（Divide）成若干个与原问题结构相同但规模更小的子问题，待子问题解决（Conquer）以后，再合并（Combine）它们，原问题就得以解决。</p>
<p>递归某子树解析：</p>
<ul>
<li><p>传入形参： </p>
<ol>
<li>当前递归到此子树根节点在先序遍历中的索引 pre_root 、</li>
<li>当前递归到此子树在中序遍历列表中的左 / 右边界的索引 in_left / in_right</li>
</ol>
</li>
<li><p>终止条件： 当 in_left &gt; in_right ，子树为空，已经越过叶子节点，此时返回空节点 。</p>
</li>
<li><p>递推工作：<br>recur(pre_root, in_left, in_right)自定义的递归函数，</p>
<ol>
<li><p>创建当前根节点root：当前节点在前序遍历中的索引为pre_root的节点<br>前序遍历的首个元素即为根节点 root 的值</p>
</li>
<li><p>搜索树的根节点root在中序遍历的索引i，从而将数组分为左子树和右子树<br> 就是代码中在HashMap中搜索到的 i ；<br> 每次搜索的时间复杂度为 O(1)。<br> 为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（中序遍历的元素，下标）键值对的哈希表。</p>
</li>
<li><p>实参<br>构建根节点root的左子树和右子树：通过调用 recur() 方法开启下一层递归。</p>
<ul>
<li>左子树：<br>根节点索引为 preL + 1 ，<br>左子树长度 x -(preL + 1) = i - 1 -inL<br>左子树右边界 x = i - 1 -inL + preL + 1 = i -inL + preL<br>左子树右边界不用传入递归函数，但是能方便算右子树的左边界<br>中序遍历的左右边界分别为 in_left 和 i - 1。</li>
<li>右子树： 根节点索引在前序遍历中为 i - in_left + preL + 1（即：根节点索引 + 左子树长度 + 1），<br>中序遍历的左右边界分别为 i + 1 和 in_right。</li>
</ul>
</li>
</ol>
</li>
<li><p>返回值： 返回 root 当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。<br>最后一层的结点p的话，他的左右子结点都返回一个空，下面会接着执行return root，也就是这个结点</p>
</li>
</ul>
<p>in_left：对当前节点递归时传入；<br>i - 1：中序遍历列表中当前节点的左边一定全部是左子树。</p>
<p>root.right = self.recur(pre_root + i - in_left + 1, i + 1, in_right)：<br>当前节点的序号做为0起点，加上中序遍历中左子树的长度，再右移1位得到右子树的根节点的序号；<br>i + 1：中序遍历列表中当前节点的右边一定全部是右子树；in_right：对当前节点递归时传入。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list2 = [<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>, <span class="string">'Google'</span>]</span><br><span class="line">dic = {}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list2)):</span><br><span class="line">    dic[list2[i]] = i</span><br><span class="line">    print(dic)</span><br><span class="line"><span class="comment"># {'Runoob': 0}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1, 'Google': 2}</span></span><br><span class="line"><span class="comment"># {'Runoob': 0, 'Taobao': 1, 'Google': 2}</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；</span></span><br><span class="line">        <span class="comment"># 为什创建 po</span></span><br><span class="line">        <span class="comment"># 将self.po 指向 preorder 是为了在 recur() 中访问 preorder 。</span></span><br><span class="line">        <span class="comment"># 因为 recur() 中要用到前序遍历，所以要建立一个全局变量 po 。</span></span><br><span class="line">        <span class="comment"># 也可以把 preorder 作为参数传给 recur() 方法</span></span><br><span class="line">        <span class="comment"># 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例</span></span><br><span class="line">        self.dic, self.po = {}, preorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            <span class="comment"># 将中序遍历中序列的节点值及索引全部记录在哈希表中</span></span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">            <span class="comment"># 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，</span></span><br><span class="line">            <span class="comment"># 用字典搜索是 O(1) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根节点 root 的 pre_root, in_left 都是 0</span></span><br><span class="line">        <span class="comment"># 开启递归并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, pre_root, in_left, in_right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None</span></span><br><span class="line">        <span class="comment"># 前序遍历的首个元素即为当前子树的根节点 root 的TreeNode对象</span></span><br><span class="line">        root = TreeNode(self.po[pre_root])</span><br><span class="line">        <span class="comment"># 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树</span></span><br><span class="line">        idx = self.dic[self.po[pre_root]]    </span><br><span class="line">        <span class="comment"># idx = inorder.index(preorder[pre_root])</span></span><br><span class="line">        <span class="comment"># index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1) </span></span><br><span class="line">        <span class="comment"># 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。</span></span><br><span class="line">        <span class="comment"># 开启左子树的下层递归，找左子树的根：</span></span><br><span class="line">        root.left = self.recur(pre_root + <span class="number">1</span>, in_left, idx - <span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 开启右子树的下层递归，找右子树的根：</span></span><br><span class="line">        root.right = self.recur(idx - in_left + pre_root + <span class="number">1</span>, idx + <span class="number">1</span>, in_right) </span><br><span class="line">        <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">pre_root, in_left, in_right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span> <span class="comment"># 终止条件：中序遍历为空</span></span><br><span class="line">            <span class="comment"># 直接用 preorder </span></span><br><span class="line">            root = TreeNode(preorder[pre_root])  <span class="comment"># 建立当前子树的根节点</span></span><br><span class="line">            i = dic[preorder[pre_root]]  <span class="comment"># 搜索根节点在中序遍历中的索引，从而可对根节点、左子树、右子树完成划分。</span></span><br><span class="line">            root.left = recur(pre_root + <span class="number">1</span>, in_left, i - <span class="number">1</span>) <span class="comment"># 开启左子树的下层递归</span></span><br><span class="line">            root.right = recur(i - in_left + pre_root + <span class="number">1</span>, i + <span class="number">1</span>, in_right) <span class="comment"># 开启右子树的下层递归</span></span><br><span class="line">            <span class="keyword">return</span> root <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line"></span><br><span class="line">        dic = {}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="comment"># 如果分割到没有左子树或者右子树的时候，</span></span><br><span class="line">        <span class="comment"># 那么就意味着根节点的left或者right要指向None</span></span><br><span class="line">        <span class="comment"># 实际上inorder 和 preorder一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:  </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归条件：任一节点了若有左节点，那你必须先遍历它的左节点</span></span><br><span class="line">          </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])  <span class="comment"># 取出preorder 的第一个值就是根节点</span></span><br><span class="line"></span><br><span class="line">        idx = inorder.index(preorder[<span class="number">0</span>])  <span class="comment"># 获取在中序遍历中的根节点的索引值</span></span><br><span class="line">        <span class="comment"># idx还能当长度用，相当于 左+根 的长度，因为 左+根 和 根+左 是等长的</span></span><br><span class="line">        <span class="comment"># 索引值代表了左子树的长度，idx从0开始，</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 下面递归对root的左右子树求解即可</span></span><br><span class="line">        <span class="comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="comment"># 传入子数组参数比较耗时，相当于每次开启递归都要建立两个新的数组，其实是没有必要的</span></span><br><span class="line">        inLeft = inorder[<span class="number">0</span>:idx]</span><br><span class="line">        inRight = inorder[idx + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = preorder[<span class="number">1</span>:idx + <span class="number">1</span>]</span><br><span class="line">        preRight = preorder[idx + <span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        root.left = self.buildTree(preLeft, inLeft)</span><br><span class="line">        <span class="comment"># 右子树</span></span><br><span class="line">        root.right = self.buildTree(preRight, inRight)</span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 返回构造后树的根节点</span></span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度在最坏情况下(即左侧链，此时先序遍历与中序遍历相反，每一个根都需要在中序中查找一次)为O(n^2)</p>
<p>迭代法</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">"""思路为官方题解的迭代法思路，注意每次遍历比较的是什么，</span></span><br><span class="line"><span class="string">        一定要在纸上模拟一遍，不要光想"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        stack = []</span><br><span class="line">        L = len(preorder)</span><br><span class="line">        stack.append(root)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, L):</span><br><span class="line">            preorderval = preorder[i]</span><br><span class="line">            <span class="keyword">if</span> inorder[index] != stack[<span class="number">-1</span>].val: <span class="comment"># 比较栈顶元素和inorder</span></span><br><span class="line">                node = stack[<span class="number">-1</span>]</span><br><span class="line">                node.left = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == inorder[index]:</span><br><span class="line">                    node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                node.right = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        length = len(preorder)</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            preorderval = preorder[i]</span><br><span class="line">            node = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> node.val != inorder[index]: <span class="comment"># 每次比较栈顶元素和inorder[index]</span></span><br><span class="line">                node.left = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].val == inorder[index]:<span class="comment"># 栈顶元素等于inorder[index],弹出；并且index += 1</span></span><br><span class="line">                    node = stack[<span class="number">-1</span>]</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                node.right = TreeNode(preorderval)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p><strong>根据一棵树的中序遍历与后序遍历构造二叉树。</strong><br>你可以假设树中没有重复的元素。<br>例如，给出</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD.png"></p>
<p>根据中序遍历和后续遍历的特性我们进行树的还原过程分析<br>首先在后序遍历序列中找到最后一个元素为根节点<br>根据根节点在中序遍历序列中找到根节点的位置<br>根据根节点的位置将中序遍历序列分为左子树和右子树，和子树节点个数<br>根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置<br>递归构造左子树和右子树<br>返回根节点结束</p>
<p><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E5%90%8E%E4%B8%AD%E4%BA%8C%E5%8F%89%E6%A0%91.png"><br><img src="/2020/08/21/jian-zhi-offer25-30-ti/%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%5C%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png"></p>
<p>中序序列 表示中序遍历的输出序列；<br>后序序列 表示后序遍历的输出序列。</p>
<p>先定义变量：<br>in_left: 在中序序列中的左边界，初始化为 0；<br>in_right: 在中序序列中的右边界，初始化为序列末尾索引位置；<br>in_root: 在中序序列中根节点的位置；<br>post_left：在后序序列中的左边界，初始化为 0；<br>post_right：在后序序列中的右边界，初始化为序列末尾索引位置；<br>post_root：在后序序列中根节点的位置。</p>
<p>后序<br>左子树右边界x<br>①：都用左边<br>in_root -1 - in_left = x - post_left<br>x = in_root - 1 - in_left + post_left </p>
<p>②：都用in_right<br>post_right - x = in_right - (in_root - 1)<br>x = post_right - in_right + (in_root - 1)</p>
<p>右子树左边界y<br>①：都用左边<br>y - post_left = in_root - in_left<br>y = in_root - in_left + post_left<br>②：都用in_right<br>in_R - (in_root + 1) = post_right - 1 - y<br>y = post_right -1 - in_R + (in_root + 1)<br>y = post_right - in_R + in_root<br>先用法②</p>
<p>要先创建右子树，再创建左子树的依赖关系。<br>可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，<br>如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。<br>因为是根据后序建立的索引，是从后往前递减的</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3]<br>从后序里先拿了3，然后找到中序里3的位置，就能知道9是左子树，15 20 7是右子树 接下来再从后序里拿20，<br>这时候是应该先算中序里的右子树，等右子树三个点都算完了，<br>index才会到9这个点，也就是开始算左子树<br>返回根节点 root。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 初始化dic为字典存储中序遍历的索引，方便查找某节点在中序遍历中的位置的；</span></span><br><span class="line">        <span class="comment"># 为什创建 po</span></span><br><span class="line">        <span class="comment"># 将self.po 指向 postorder 是为了在 recur() 中访问 postorder 。</span></span><br><span class="line">        <span class="comment"># 因为 recur() 中要用到后序遍历，所以要建立一个全局变量 po 。</span></span><br><span class="line">        <span class="comment"># 也可以把 postorder 作为参数传给 recur() 方法</span></span><br><span class="line">        <span class="comment"># 定义在类的函数中，并且要绑定在 self 身上的变量称为成员变量，只作用于当前实例</span></span><br><span class="line">        self.dic, self.po = {}, postorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            <span class="comment"># 将中序遍历中序列的节点值及索引全部记录在哈希表中</span></span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">            <span class="comment"># 列表有查找值对应的索引的函数index() 的时间复杂度为 O(N) ，</span></span><br><span class="line">            <span class="comment"># 用字典搜索是 O(1) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根节点 root 的 pre_root, in_right 都是 len(inorder) - 1</span></span><br><span class="line">        <span class="comment"># 开启递归并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(len(inorder) - <span class="number">1</span>, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, post_right, in_left, in_right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 终止条件：左指针大于右指针，说明 指向的 中序遍历子数组 是 空数组，说明已经越过叶子节点，此时返回 None</span></span><br><span class="line">        <span class="comment"># 后序序列末尾元素就是根节点</span></span><br><span class="line">        post_root = post_right</span><br><span class="line">        <span class="comment"># 根节点 root 的TreeNode对象</span></span><br><span class="line">        root = TreeNode(self.po[post_root])</span><br><span class="line">        <span class="comment"># 搜索根节点在中序遍历中的索引，此时 idx 左边是左子树，右边是右子树</span></span><br><span class="line">        idx = self.dic[self.po[post_root]]    </span><br><span class="line">        <span class="comment"># idx = inorder.index(preorder[post_root])</span></span><br><span class="line">        <span class="comment"># index() 方法的时间复杂度为 O(N) ，用字典搜索是 O(1) </span></span><br><span class="line">        <span class="comment"># 目的是计算根节点在中序中的坐标，有点繁琐，可以直接i=self.dic[root.val]。</span></span><br><span class="line">        <span class="comment"># 开启右子树的下层递归，找右子树的根：</span></span><br><span class="line">        root.right = self.recur(post_right - <span class="number">1</span>, idx + <span class="number">1</span>, in_right) </span><br><span class="line">        <span class="comment"># 开启左子树的下层递归，找左子树的根：</span></span><br><span class="line">        root.left = self.recur(idx + post_right - in_right - <span class="number">1</span>, in_left, idx - <span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 返回根节点，作为上层递归的左（右）子节点</span></span><br><span class="line">        <span class="keyword">return</span> root  </span><br></pre></td></tr></tbody></table></figure>

<p>定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，<br>递归入口为helper(0, n - 1) ：<br>如果 in_left &gt; in_right，说明子树为空，返回空节点。<br>选择后序遍历的最后一个节点作为根节点。<br>利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。<br>从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。<br>根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">in_left, in_right</span>):</span></span><br><span class="line">            <span class="comment"># 如果这里没有节点构造二叉树了，就结束</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 选择 post_idx 位置的元素作为当前子树根节点</span></span><br><span class="line">            val = postorder.pop()</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据 root 所在位置分成左右两棵子树</span></span><br><span class="line">            index = idx_map[val]</span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 构造右子树</span></span><br><span class="line">            root.right = helper(index + <span class="number">1</span>, in_right)</span><br><span class="line">            <span class="comment"># 构造左子树</span></span><br><span class="line">            root.left = helper(in_left, index - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建立（元素，下标）键值对的哈希表</span></span><br><span class="line">        idx_map = {val:idx <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(inorder)} </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。<br>空间复杂度：O(n)。我们需要使用 O(n) 的空间存储哈希表，<br>以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">in_left, in_right, post_left, post_right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 后序序列末尾元素就是根节点</span></span><br><span class="line">            post_root = post_right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构造节点</span></span><br><span class="line">            root = TreeNode(postorder[post_root])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在中序序列定位根节点位置</span></span><br><span class="line">            in_root = inorder_map[root.val]    </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># size_of_right = in_right - in_root</span></span><br><span class="line">            <span class="comment"># 获取中序序列中左子树的节点数</span></span><br><span class="line">            size_of_left = in_root - in_left</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># root.left = build_tree(in_left, in_root-1, post_left, post_right-size_of_right-1)</span></span><br><span class="line">            <span class="comment"># 递归构建左子树</span></span><br><span class="line">            root.left = build_tree(in_left, in_root<span class="number">-1</span>, post_left, post_left+size_of_left<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># root.right = build_tree(in_root+1, in_right, post_right-size_of_right, post_right-1)</span></span><br><span class="line">            <span class="comment"># 递归构建右子树</span></span><br><span class="line">            root.right = build_tree(in_root+<span class="number">1</span>, in_right, post_left+size_of_left, post_root<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        size = len(inorder)</span><br><span class="line">        <span class="comment"># 先用字典存储中序序列，元素及其对应的索引位置</span></span><br><span class="line">        inorder_map = {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            inorder_map[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build_tree(<span class="number">0</span>, size<span class="number">-1</span>, <span class="number">0</span>, size<span class="number">-1</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">树A：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">树 B：</span><br><span class="line">①</span><br><span class="line">   <span class="number">3</span> </span><br><span class="line">  /</span><br><span class="line"> <span class="number">4</span></span><br><span class="line">②</span><br><span class="line">   <span class="number">5</span> </span><br><span class="line">    \</span><br><span class="line">     </span><br><span class="line">③</span><br><span class="line">   <span class="number">4</span> </span><br><span class="line">  / </span><br><span class="line"> <span class="number">1</span>  </span><br></pre></td></tr></tbody></table></figure>

<p>名词规定：树 A 的根节点记作 节点 A ，树 B 的根节点称为 节点 B 。</p>
<p>解题思路：<br>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。<br>因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 n_A；（对应函数 isSubStructure(A, B)）</li>
<li>判断树 A 中 以 n_A 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>
</ol>
<p>如果a树和b树的当前节点的值相同，那么比较a的左右节点和b的左右子树是否相同<br>如果a树和b树的当前节点的值不同，那么比较a的左子树和B是否相同，或者比较a的右子树和B是否相同</p>
<p>recur判断A,B的根结点是否相同，相同的话继续递归左右子节点判断是否相同，一直相同的话就返回true，若不相同就调用A的左节点或者右几点为根结点与B比较，都要重新匹配整个树 B </p>
<p>算法流程：<br>isSubStructure(A, B) 函数：</p>
<ol>
<li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</li>
<li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol>
<li>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；</li>
<li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；<br>以上 2. 3. 实质上是在对树 A 做 先序遍历 。</li>
</ol>
</li>
</ol>
<p>recur(A, B) 函数：在匹配子结构，因此要 左子树相同 “且”右子树相同才是子结构。</p>
<ol>
<li>终止条件：<ol>
<li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li>
<li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li>
<li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
</ol>
</li>
<li>返回值：</li>
<li>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
<p>复杂度分析：<br>时间复杂度 O(MN)： 其中 M,N 分别为树 A 和 树 B 的节点数量；<br>先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。</p>
<p>空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。<br>当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；<br>当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。<br>当达到 M 时， 树 B 只遍历一层就会返回 因为 树 A 已经到底了~ </p>
<p>空间复杂度要看在同一时刻，有多少递归函数未返回，而不是总共执行了多少函数。<br>因为递归过程中是会回溯的，返回了的函数就不计入空间复杂度计算啦</p>
<p>这类题目与字符串匹配有些神似，求解过程大致分为两步：<br>先将根节点匹配；<br>根节点匹配后，对子树进行匹配。<br>而参与匹配的二叉树可以是一棵，与自身匹配；也可以是两棵，即互相匹配。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 定义一个标志位res用来做判断</span></span><br><span class="line">        res = <span class="literal">False</span>  <span class="comment"># 如果没这句 local variable 'res' referenced befored assignment</span></span><br><span class="line">        <span class="comment"># 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> B <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> A.val == B.val:</span><br><span class="line">                res = self.helper(A, B)</span><br><span class="line">            <span class="comment"># 如果根结点开始的没有找到，那么就再去TreeA的左子节点当作起点，去判断是否包含TreeB</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.isSubStructure(A.left, B)</span><br><span class="line">            <span class="comment"># 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.isSubStructure(A.right, B)</span><br><span class="line">        <span class="comment"># 最后返回help()里面的res即得到结果</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">        <span class="comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">        <span class="comment"># 如果颠倒顺序，会先判断A是否为None，当A为空B为空时，B的结点已经遍历完成确定相等了，但是返回了False，判断错误先</span></span><br><span class="line">        <span class="comment"># 如果TreeB已经遍历完了，还没发现不一样的，</span></span><br><span class="line">        <span class="comment"># B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构</span></span><br><span class="line">        <span class="keyword">if</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果TreeB还没有遍历完，TreeA却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果以上情况都不是，说明A.val == B.val，根节点对应的上，</span></span><br><span class="line">        <span class="comment"># 那么继续向下递归判断子节点里是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A.left, B.left) <span class="keyword">and</span> self.helper(A.right, B.right)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 若两个结点有一个为空，不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> B == <span class="literal">None</span> <span class="keyword">or</span> A == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 当TreeA和TreeB都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> B <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果找到了对应TreeB的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span> A.val == B.val <span class="keyword">and</span> self.helper(A,B):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br><span class="line">            <span class="comment"># 如果还找不到，那么就再去TreeA的右子树当作起点，去判断是否包含TreeB</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">        <span class="comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">        <span class="comment"># 如果颠倒顺序，会先判断A是否为None，其实这个时候B的结点已经遍历完成确定相等了，但是返回了False，判断错误</span></span><br><span class="line">        <span class="comment"># 如果TreeB已经遍历完了，还没发现不一样的，</span></span><br><span class="line">        <span class="comment"># B 所有节点都和 A 匹配上了，因此 B “被包含于” A ，即 B 是 A 的子结构，则可以返回 true 了，如果 b 没匹配完 就遇到值不一样的或 a 结束，则不是子结构</span></span><br><span class="line">        <span class="keyword">if</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果TreeB还没有遍历完，TreeA却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果以上情况都不是，说明A.val == B.val，根节点对应的上，</span></span><br><span class="line">        <span class="comment"># 那么继续向下递归判断子节点里是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A.left, B.left) <span class="keyword">and</span> self.helper(A.right, B.right)</span><br></pre></td></tr></tbody></table></figure>


<hr>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><code>输入描述:</code></h5><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">            <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">        镜像二叉树</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>二叉树镜像定义：<br>对于二叉树中任意节点 root ，设其左 / 右子节点分别为 left, right ；<br>则在二叉树的镜像中的对应 root 节点，其左 / 右子节点分别为 right, left 。</p>
<p>方法一：递归 （dfs）二叉树</p>
<h4 id="交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换"><a href="#交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换" class="headerlink" title="交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换"></a><code>交换的不是每个节点的左右子节点的值（val），是root的左右子树的指针，此两个节点的子树也随着一起被交换</code></h4><h4 id="和现实中的树是一样的，是根-—-枝-—-叶-的结构。"><a href="#和现实中的树是一样的，是根-—-枝-—-叶-的结构。" class="headerlink" title="和现实中的树是一样的，是根 — 枝 — 叶 的结构。"></a><code>和现实中的树是一样的，是根 — 枝 — 叶 的结构。</code></h4><h4 id="当我们剪下两个树枝（上面分别有树枝分叉、直到叶），"><a href="#当我们剪下两个树枝（上面分别有树枝分叉、直到叶），" class="headerlink" title="当我们剪下两个树枝（上面分别有树枝分叉、直到叶），"></a><code>当我们剪下两个树枝（上面分别有树枝分叉、直到叶），</code></h4><h4 id="并将此二树枝交换位置-嫁接回树上。"><a href="#并将此二树枝交换位置-嫁接回树上。" class="headerlink" title="并将此二树枝交换位置 嫁接回树上。 "></a><code>并将此二树枝交换位置 嫁接回树上。 </code></h4><h4 id="此时，你会发现，此两树枝的根和其树枝分叉-叶-都交换了。"><a href="#此时，你会发现，此两树枝的根和其树枝分叉-叶-都交换了。" class="headerlink" title="此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。"></a><code>此时，你会发现，此两树枝的根和其树枝分叉+叶 都交换了。</code></h4><p>仔细看下题目的输入和输出，输出的左右子树的位置跟输入正好是相反的，<br>于是我们可以递归的交换左右子树来完成这道题。</p>
<p>①前序遍历，是基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。<br>递归解析：</p>
<ol>
<li>终止条件： 当节点 root 为空时（即越过叶节点），则返回 None ；</li>
<li>递推工作：<ol>
<li>初始化节点 tmp ，用于暂存 root 的左子节点；</li>
<li>交换当前节点的左右节点，整个子树交换但它们内部的子树还没翻转，并将返回值作为 root 的节点</li>
<li>再递归的交换当前节点的左节点，递归的交换当前节点的右节点，并将返回值作为 root 的 子节点 。</li>
</ol>
</li>
<li>返回值： 返回当前节点 root ；  </li>
</ol>
<p>时间复杂度：每个元素都必须访问一次，所以是O(n)<br>空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)</p>
<p>Q： 为何需要暂存 root 的左子节点？<br>A： 在递归右子节点 “root.left = mirrorTree(root.right);” 执行完毕后，<br>root.left 的值已经发生改变，此时递归左子节点 mirrorTree(root.left) 则会出问题。</p>
<p>这个节点不存在，比如叶子节点返回左子树，就是返回空<br>相当于 root = None ，交换只是把 None 赋给了一个变量，不会报错，<br>只要不执行 None.left 这种就好</p>
<p>在交换左右孩子的时候，temp指针在函数体结束返回后，temp 会被销毁，temp所指向的数据不会销毁，销毁指针数据的方法是delete temp;</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.left = root.right = <span class="number">7</span></span><br><span class="line">root.right = tmp = <span class="number">2</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">tmp = root.left = <span class="number">6</span></span><br><span class="line">root.left = root.right = <span class="number">9</span></span><br><span class="line">root.right = tmp = <span class="number">6</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">第一个递归函数的函数root不断改变不影响第二个递归函数的函数root的初始值</span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">tmp = root.left = <span class="number">1</span></span><br><span class="line">root.left = root.right = <span class="number">3</span></span><br><span class="line">root.right = tmp = <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将当前节点的左右子树交换</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        <span class="comment"># 递归交换当前节点的 左子树和右子树</span></span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="comment"># 返回时就表示当前这个节点，以及它的左右子树都已经交换完了    </span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p>②后序遍历，基于DFS，都是先遍历根节点、再遍历左子树、再遍历右子树。<br>递归解析：</p>
<ol>
<li>终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；</li>
<li>递推工作：<ol>
<li>从根节点开始，递归地对树进行遍历，直到遇到 null 节点，结束递归调用。</li>
<li>并从叶子结点先开始翻转。</li>
<li>如果当前遍历到的节点 root 的左右两棵子树都已经翻转，<br>那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</li>
</ol>
</li>
<li>返回值： 返回当前节点 root ；  </li>
</ol>
<p>时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。<br>空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归压栈压到底</span></span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        tmp = root.left</span><br><span class="line">        <span class="comment"># 执行交换</span></span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">9</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">        <span class="number">3</span>   <span class="number">1</span> <span class="number">9</span>   <span class="number">6</span>            </span><br><span class="line"><span class="string">```</span> </span><br><span class="line"></span><br><span class="line"><span class="string">③</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">终止条件：</span> <span class="string">当节点</span> <span class="string">root</span> <span class="string">为空时（即越过叶节点），则返回</span> <span class="literal">null</span> <span class="string">；</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">递推工作：</span></span><br><span class="line">   <span class="number">1</span><span class="string">.</span> <span class="string">初始化节点</span> <span class="string">tmp</span> <span class="string">，用于暂存</span> <span class="string">root</span> <span class="string">的左子节点；</span></span><br><span class="line">   <span class="number">2</span><span class="string">.</span> <span class="string">开启递归</span> <span class="string">右子节点</span> <span class="string">mirrorTree(root.right)</span> <span class="string">，并将返回值作为</span> <span class="string">root</span> <span class="string">的</span> <span class="string">左子节点</span> <span class="string">。</span></span><br><span class="line">   <span class="number">3</span><span class="string">.</span> <span class="string">开启递归</span> <span class="string">左子节点</span> <span class="string">mirrorTree(tmp)</span> <span class="string">，并将返回值作为</span> <span class="string">root</span> <span class="string">的</span> <span class="string">右子节点</span> <span class="string">。</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">返回值：</span> <span class="string">返回当前节点</span> <span class="string">root</span> <span class="string">；</span>  </span><br><span class="line"><span class="string">```py</span></span><br><span class="line"><span class="attr">class Solution:</span></span><br><span class="line">    <span class="string">def</span> <span class="string">mirrorTree(self,</span> <span class="attr">root:</span> <span class="string">TreeNode)</span> <span class="string">-&gt;</span> <span class="attr">TreeNode:</span></span><br><span class="line">        <span class="attr">if not root:</span> <span class="string">return</span></span><br><span class="line">        <span class="string">tmp</span> <span class="string">=</span> <span class="string">root.left</span></span><br><span class="line">        <span class="comment"># 开始递归，重头开始执行原来右边的完成，终止时root为最右下角的节点</span></span><br><span class="line">        <span class="string">root.left</span> <span class="string">=</span> <span class="string">self.mirrorTree(root.right)</span></span><br><span class="line">        <span class="comment"># 执行原来左边的</span></span><br><span class="line">        <span class="string">root.right</span> <span class="string">=</span> <span class="string">self.mirrorTree(tmp)</span></span><br><span class="line">        <span class="string">return</span> <span class="string">root</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.right = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">7</span></span><br><span class="line">tmp = root.left = <span class="number">6</span> 暂存 <span class="number">7</span> 的左子节点 <span class="number">6</span></span><br><span class="line">root.right = <span class="number">9</span></span><br><span class="line">开启递归 <span class="number">7</span> 的右子节点为 <span class="number">9</span></span><br><span class="line">root = root.right = <span class="number">9</span></span><br><span class="line">tmp = root.left = None  # 暂存 <span class="number">9</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">9</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line">开启递归 <span class="number">9</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">9</span> 赋值给 <span class="number">7</span> 的左子节点为 <span class="number">9</span></span><br><span class="line">root = <span class="number">7</span></span><br><span class="line">root.left  = <span class="number">9</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /   \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">9</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">tmp = <span class="number">6</span></span><br><span class="line">开启递归 <span class="number">7</span> 的左子节点为 <span class="number">6</span></span><br><span class="line">root = tmp = <span class="number">6</span></span><br><span class="line">tmp = root.left = None  # 暂存 <span class="number">6</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">6</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line"><span class="keyword">return</span> 空</span><br><span class="line">开启递归 <span class="number">6</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">6</span> 赋值 <span class="number">7</span> 的右子节点</span><br><span class="line">root = <span class="number">7</span> </span><br><span class="line">root.right = <span class="number">6</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">2</span>     <span class="number">7</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">1</span>   <span class="number">3</span> <span class="number">9</span>   <span class="number">6</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回节点 <span class="number">7</span>，<span class="number">7</span>的子节点都用过，跳到上一层节点<span class="number">4</span>  </span><br><span class="line">root = <span class="number">4</span> </span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">root.right = <span class="number">7</span> </span><br><span class="line">开启递归 <span class="number">4</span> 的右子节点 <span class="number">7</span></span><br><span class="line">root = root.right = <span class="number">7</span> </span><br><span class="line">tmp = root.left = None  # 已经用过了 暂存 <span class="number">6</span> 的左子节点 None</span><br><span class="line">root.right = None  </span><br><span class="line">开启递归 <span class="number">7</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root = root.right = None </span><br><span class="line"><span class="keyword">return</span> 空</span><br><span class="line">开启递归 <span class="number">7</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">root = tmp = None</span><br><span class="line">函数返回 <span class="number">7</span> 赋值 <span class="number">4</span> 的左子节点</span><br><span class="line">root.left = <span class="number">7</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">tmp = <span class="number">2</span> 开启递归<span class="number">4</span>的左子节点<span class="number">2</span></span><br><span class="line">root = tmp = <span class="number">2</span></span><br><span class="line">tmp = root.left = <span class="number">1</span></span><br><span class="line">root.right = tmp = <span class="number">3</span></span><br><span class="line">开启递归<span class="number">2</span>的右子节点<span class="number">3</span></span><br><span class="line">root = root.right = <span class="number">3</span></span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">3</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">3</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">函数返回 <span class="number">3</span> 赋值给 <span class="number">2</span> 的左子节点</span><br><span class="line">root.left = <span class="number">3</span></span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">3</span>   <span class="number">3</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">开启递归<span class="number">2</span>的左子节点<span class="number">1</span> tmp</span><br><span class="line">root = tmp = <span class="number">1</span></span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">1</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">1</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">  <span class="number">2</span>       <span class="number">7</span>     <span class="number">7</span></span><br><span class="line"> / \      / \   / \</span><br><span class="line"><span class="number">3</span>   <span class="number">1</span>    <span class="number">9</span>   <span class="number">6</span> <span class="number">9</span>   <span class="number">6</span>  </span><br><span class="line"></span><br><span class="line">返回节点<span class="number">1</span>，<span class="number">2</span>的子节点都用过，跳到上一层返回节点<span class="number">4</span>  </span><br><span class="line">开启递归节点<span class="number">4</span> </span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tmp = root.left = <span class="number">2</span></span><br><span class="line">开启递归 <span class="number">4</span> 的左子节点 <span class="number">2</span></span><br><span class="line">root = tmp = <span class="number">2</span>  </span><br><span class="line">root.right = None</span><br><span class="line">tmp = root.left = None   # 暂存 <span class="number">3</span> 的左子节点 None</span><br><span class="line">开启递归 <span class="number">1</span> 的右子节点 None ，触发终止条件并返回 </span><br><span class="line">root.right = tmp = None</span><br><span class="line">开启递归 <span class="number">1</span> 的左子节点 None，触发终止条件并返回</span><br><span class="line">函数返回 <span class="number">2</span> 赋值给 <span class="number">4</span> 的右子节点</span><br><span class="line">root.right = <span class="number">2</span></span><br><span class="line">其子树一起移动</span><br><span class="line">             <span class="number">4</span></span><br><span class="line">           /  \</span><br><span class="line">          <span class="number">7</span>     <span class="number">2</span></span><br><span class="line">         / \   / \</span><br><span class="line">        <span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>迭代<br>①<br>辅助栈（或队列）<br>利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。<br>算法流程：<br>特例处理： 当 root 为空时，直接返回 null ；<br>初始化： 栈（或队列），本文用栈，并加入根节点 root 。<br>循环交换： 当栈 stack 为空时跳出；<br>出栈： 记为 node ；<br>添加子节点： 将 node 左和右子节点入栈；<br>交换： 交换 node 的左 / 右子节点。<br>返回值： 返回根节点 root 。</p>
<p>入栈的时候 顺序是 2 7 ，所以出栈顺序是 7 2 鸭~ 和 节点是否交换没有关系的</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">4</span>         stack=[<span class="number">4</span>]</span><br><span class="line">   /  \       node = <span class="number">4</span></span><br><span class="line">  <span class="number">2</span>    <span class="number">7</span></span><br><span class="line"> / \  / \</span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack=[]</span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">  <span class="number">2</span>    <span class="number">7</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>  <span class="number">9</span>                                                              </span><br><span class="line">             </span><br><span class="line">    <span class="number">4</span>         交换 <span class="number">2</span>, <span class="number">7</span></span><br><span class="line">   /  \       所以出栈顺序是 <span class="number">7</span> <span class="number">2</span> 鸭~ 和 节点是否交换没有关系的</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      stack=[<span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>  <span class="number">3</span>                                                      | |</span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack=[<span class="number">2</span>]</span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">6</span>   <span class="number">9</span> <span class="number">1</span>  <span class="number">3</span>   </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         交换<span class="number">6</span>, <span class="number">9</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>   </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">9</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">6</span></span><br><span class="line">   /  \       stack=[<span class="number">2</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">2</span></span><br><span class="line">   /  \       stack=[]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      stack=[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">1</span>  <span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         交换 None 和 None</span><br><span class="line">   /  \       stack=[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      </span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">3</span></span><br><span class="line">   /  \       stack=[<span class="number">1</span>]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         弹出 <span class="number">1</span></span><br><span class="line">   /  \       stack=[]</span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      无子节点可加入stack</span><br><span class="line"> / \  / \     交换 None 和 None</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>         stack 为空</span><br><span class="line">   /  \       跳出循环，返回<span class="number">4</span></span><br><span class="line">  <span class="number">7</span>    <span class="number">2</span>      </span><br><span class="line"> / \  / \     </span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>  <span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure>

<p>②<br>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。<br>深度优先遍历的特点是一竿子插到底，不行了再退回来继续；<br>而广度优先遍历的特点是层层扫荡。<br>所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：</p>
<ul>
<li>判断其左子树是否为空，不为空就放入队列中</li>
<li>判断其右子树是否为空，不为空就放入队列中</li>
</ul>
<p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是n/2个，所以时间复杂度是0(n)</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 每次都从队列中拿一个节点，并交换这个节点的左右子树</span></span><br><span class="line">            tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            tmp.left, tmp.right = tmp.right, tmp.left</span><br><span class="line">            <span class="comment"># 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> tmp.left:</span><br><span class="line">                queue.append(tmp.left)</span><br><span class="line">            <span class="comment"># 如果当前节点的右子树不为空，则放入队列等待后续处理    </span></span><br><span class="line">            <span class="keyword">if</span> tmp.right:</span><br><span class="line">                queue.append(tmp.right)</span><br><span class="line">        <span class="comment"># 返回处理完的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             4</span><br><span class="line">           /  \</span><br><span class="line">          2     7</span><br><span class="line">         / \   / \</span><br><span class="line">        1   3 6   9</span><br><span class="line">                                                                   </span><br><span class="line">                                                   |<span class="string">1</span>|</span><br><span class="line">                                    |<span class="string">6</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">3</span>|<span class="string">  </span>|<span class="string">3</span>|</span><br><span class="line">           |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string"> </span>|</span><br><span class="line">queue |<span class="string">4</span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">9</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string"> </span></span><br><span class="line"><span class="string">             4</span></span><br><span class="line"><span class="string">           /  \</span></span><br><span class="line"><span class="string">          2     7</span></span><br><span class="line"><span class="string">         / \   / \</span></span><br><span class="line"><span class="string">        1   3 6   9</span></span><br><span class="line"><span class="string">                                         </span>|<span class="string">7</span>|</span><br><span class="line">                     |<span class="string"> </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|<span class="string">  </span>|<span class="string">2</span>|</span><br><span class="line">tmp   |<span class="string"> </span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">4</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">7</span>|<span class="string">  </span>|<span class="string">6</span>|<span class="string">  </span>|<span class="string">4</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h4 id="35-对称的二叉树-本题考点-树"><a href="#35-对称的二叉树-本题考点-树" class="headerlink" title="35.对称的二叉树 [^本题考点 树]"></a>35.对称的二叉树 [^本题考点 <em>树</em>]</h4><p>​    <strong>题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</strong><br>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>
<p>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp;/ \ / <br>3 &nbsp;4 4 &nbsp;3<br>但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp; &nbsp;\ &nbsp; <br>&nbsp; &nbsp; 3 &nbsp; 3</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
<p>解题思路：</p>
<ul>
<li>对称二叉树定义：对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val = R.val ：即此两对称节点值相等。</li>
<li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<p>算法流程：<br>isSymmetric(root) ：</p>
<ul>
<li>特例处理： 若根节点 root 为空，则直接返回 true 。</li>
<li>返回值： 即 recur(root.left, root.right) ;</li>
</ul>
<p>recur(L, R) ：<br>先“递（推）”至底，再“归”。两个参数的递归，<br>通过「同步移动」两个指针的方法来遍历这棵树，L 指针和 R 指针一开始都指向这棵树的根，随后 R 右移时，L 左移，R 左移时，L 右移。每次检查当前 L 和 R 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p>终止条件：</p>
<ul>
<li>当 L 和 R 同时越过叶节点： 左右都为空，也就是判断到了最后，还没返回false，那么此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点 但另一个还没有，此树不对称，因此返回 false ；</li>
<li>当节点 L 值 \ne= 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
<p>当 L.val = R.val且不为空，递推工作：</p>
<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；<br>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp; 连接。</li>
</ul>
<p>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法，事实上这个递归方法就是在做树的遍历，每个结点访问一次；</p>
<p>空间复杂度 O(N) ： 最差情况下，根节点的左子节点 有 N/2 长度的链表，右子节点有 N/2 长度的链表，那么递归深度会达到 N/2。因为一直先执行 recur(L.left, R.right) 。<br>只需要保证每个左节点的左边和右节点的右边相同(其余的我可以都为空)，就可以一直走走到最底端，如果是这样的话，应该是O(n/2)，约等于O(n)这样就是线性级别了</p>
<p>递归复杂度要看递归的深度，因为剪枝or回溯后，内存会被释放。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">    <span class="comment"># 如果此二叉树为空，则其也是对称的</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">L, R</span>):</span></span><br><span class="line">            <span class="comment"># 如果两侧都为空，则是镜像的了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 若有一侧不为空，则不是镜像的 或者 如果左侧的值不等于右侧额值，就不是镜像的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">or</span> <span class="keyword">not</span> R <span class="keyword">or</span> L.val != R.val:</span><br><span class="line">            <span class="comment"># if L.val!=R.val or not L or not R 会报错，当 L == None 时，直接访问 L.val 会报错的 </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># if L.val = R.val: </span></span><br><span class="line">            <span class="keyword">return</span> recur(L.left, R.right) <span class="keyword">and</span> recur(L.right, R.left)</span><br><span class="line">        <span class="comment"># 返回判断此二叉树的左侧和右侧</span></span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; <span class="number">1</span></span><br><span class="line">&nbsp; &nbsp;/ \</span><br><span class="line">&nbsp; <span class="number">2</span> &nbsp; <span class="number">2</span></span><br><span class="line">&nbsp;/ \ / \</span><br><span class="line"><span class="number">3</span> &nbsp;<span class="number">4</span> <span class="number">4</span> &nbsp;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">root = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(root.left, root.right)</span></span> </span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">1</span>.left, <span class="number">1</span>.right)</span></span> </span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span></span><br><span class="line">L<span class="selector-class">.val</span> = R.val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>.left, R=<span class="number">2</span>.right)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span> recur(L<span class="selector-class">.right</span>, R.<span class="attribute">left</span>)</span><br><span class="line"><span class="number">3</span><span class="selector-class">.left</span> = <span class="number">3</span><span class="selector-class">.right</span> = <span class="number">3</span><span class="selector-class">.right</span> = <span class="number">3</span><span class="selector-class">.left</span> = None</span><br><span class="line">L和R同时越过叶子节点，访问了叶节点的 <span class="attribute">left</span> 和 right， 其 left 和 right 都是 None</span><br><span class="line">返回true</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.right, R.left)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">2</span>.right, <span class="number">2</span>.left)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">recur</span><span class="params">(L.left, R.right)</span></span> recur(L<span class="selector-class">.right</span>, R.<span class="attribute">left</span>)</span><br><span class="line"><span class="number">4</span><span class="selector-class">.left</span> = <span class="number">4</span><span class="selector-class">.right</span> = <span class="number">4</span><span class="selector-class">.right</span> = <span class="number">4</span><span class="selector-class">.left</span> = None</span><br><span class="line">L和R同时越过叶子节点</span><br><span class="line">返回true</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 现在获取的 mir = node 就是新建的树的根节点了</span></span><br><span class="line">        mir = self.mirror(root) </span><br><span class="line">        <span class="keyword">return</span> self.recur(root,mir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self,root,mir</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">and</span> <span class="keyword">not</span> mir: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mir <span class="keyword">or</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (root.val == mir.val) <span class="keyword">and</span> self.recur(root.left,mir.left) <span class="keyword">and</span> self.recur(root.right,mir.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        node = TreeNode(root.val) <span class="comment"># 建立节点 node</span></span><br><span class="line">        node.left, node.right = self.mirror(root.right), self.mirror(root.left) </span><br><span class="line">        <span class="comment"># 即镜像之 node.left = root.right , node.right = root.left</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：非递归写法（层序遍历）<br>这个方法有点像层序遍历，故使用队列，<br>但是根据对称性，队首和队尾其实都需要能够执行入队和出队操作，因此使用双端队列（Deque）；</p>
<p>时间复杂度：O(N)，这里 N 为树的结点个数，事实上这个递归方法就是在做树的遍历，每个结点访问一次；<br>空间复杂度：O(L)，这里 L 表示树的相邻两层结点个数之和的最大值。</p>
<p>首先从队列中拿出两个节点(left和right)比较<br>将left的left节点和right的right节点放入队列<br>将left的right节点和right的left节点放入队列</p>
<figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; 2</span><br><span class="line">&nbsp; &nbsp;/ <span class="tag">\</span></span><br><span class="line">&nbsp; ３ &nbsp; ３</span><br><span class="line">&nbsp;/ <span class="tag">\<span class="name"> </span></span>  / <span class="tag">\</span></span><br><span class="line">４ &nbsp;５ N   4&nbsp;</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        queue = deque()  <span class="comment"># 辅助双端队列</span></span><br><span class="line">        queue.appendleft(root.left)  <span class="comment"># 初始节点依次入队</span></span><br><span class="line">        queue.append(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 从队列中取出两个节点，再比较这两个节点</span></span><br><span class="line">            left_node = queue.popleft()</span><br><span class="line">            right_node = queue.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 深度优先，如果两个节点都为空就继续循环，只是越过了某一对叶子节点，而不是检查完了所有的叶子节点，所以不能return true。</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 代码走到这里一定有 left_node 和 right_node 非空</span></span><br><span class="line">            <span class="comment"># 因此可以取出 val 进行判断了</span></span><br><span class="line">            <span class="keyword">if</span> left_node.val != right_node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 将左节点的右孩子，右节点的左孩子入队（以便两节点一起出队，进行比较）</span></span><br><span class="line">            queue.appendleft(left_node.right)</span><br><span class="line">            queue.appendleft(left_node.left)</span><br><span class="line">            <span class="comment"># 将左节点的左孩子， 右节点的右孩子入队（以便两节点一起出队，进行比较）</span></span><br><span class="line">            queue.append(right_node.left)</span><br><span class="line">            queue.append(right_node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&nbsp; &nbsp; 1</span><br><span class="line">&nbsp; &nbsp;/ \</span><br><span class="line">&nbsp; 2 &nbsp; 2</span><br><span class="line">&nbsp;/ \ / \</span><br><span class="line">3 &nbsp;4 4 &nbsp;3</span><br><span class="line"></span><br><span class="line">root = 1</span><br><span class="line"></span><br><span class="line">queue = [2, 2]</span><br><span class="line">left_node = 2</span><br><span class="line">right_node = 2</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(2.right)</span><br><span class="line">queue = [4]</span><br><span class="line">queue.appendleft(2.left)</span><br><span class="line">queue = [3, 4]</span><br><span class="line">            # 将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(2.left)</span><br><span class="line">queue = [3, 4, 4]</span><br><span class="line">queue.append(2.right)</span><br><span class="line">queue = [3, 4, 4, 3]</span><br><span class="line"></span><br><span class="line">left_node = queue.popleft() = 3</span><br><span class="line">queue = [4, 4, 3]</span><br><span class="line">right_node = queue.pop() = 3</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(3.right)</span><br><span class="line">queue = [4, 4]</span><br><span class="line">queue.appendleft(left_node.left)</span><br><span class="line">queue.appendleft(3.left)</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(3.left)</span><br><span class="line">queue = [4, 4]</span><br><span class="line">queue.append(right_node.right)</span><br><span class="line">queue.append(4.right)</span><br><span class="line">queue = [4, 4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">left_node = queue.popleft() = 4</span><br><span class="line">queue = [4]</span><br><span class="line">right_node = queue.pop() = 4</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">queue.appendleft(left_node.right)</span><br><span class="line">queue.appendleft(4.right)</span><br><span class="line">queue = []</span><br><span class="line">queue.appendleft(left_node.left)</span><br><span class="line">queue.appendleft(3.left)</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">queue.append(right_node.left)</span><br><span class="line">queue.append(4.left)</span><br><span class="line">queue = []</span><br><span class="line">queue.append(right_node.right)</span><br><span class="line">queue.append(4.right)</span><br><span class="line">queue = [] 退出循环</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h2><p><strong>给定一棵二叉搜索树，请找出其中第k大的节点。</strong><br>示例 1:</p>
<p>输入: root = [3,1,4,null,2], k = 1</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br></pre></td></tr></tbody></table></figure>
<p>示例 2:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：<br>1、看到这题首先想到的是递归遍历每一个节点，然后存在一个数组中，遍历结束后把数组 sort 排序一下就可以取得第 K 大的值了。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.right, res)</span><br><span class="line">        dfs(root, res)</span><br><span class="line">        <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></tbody></table></figure>

<p>2、继续看题会发现是二叉搜索树，发现中序遍历的数组结果刚好是排好序的，这样就可以想到反中序遍历,遍历结束后直接获取数组第 K-1 位的数值就是结果了（当然上面说的都可以不用倒序，直接用中序遍历获取 array.lenth-k 大的值也是所需结果）<br>3、在第二种解法上利用反中序遍历，优化就是直接遍历到第 k 大的值就停止遍历，直接返回需要的值，即第三种解法。<br>本文解法基于此性质：二叉搜索树的中序遍历为 递增序列 。</p>
<p>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。<br>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。从右节点遍历可以早点退出</p>
<p>中序遍历 为 “左、根、右” 顺序，递归法代码模板如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure>

<p>中序遍历的倒序 为 “右、根、左” 顺序，递归法代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历倒序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br></pre></td></tr></tbody></table></figure>

<p>为求第 k 个节点，需要实现以下 三项工作 ：</p>
<ol>
<li>递归遍历时计数，统计当前节点的序号；</li>
<li>递归到第 k 个节点时，应记录结果 res ；</li>
<li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
</ol>
<p>递归解析：</p>
<ol>
<li><p>终止条件： 当节点 root 为空（越过叶节点），则直接返回；</p>
</li>
<li><p>递归右子树： 即 dfs(root.right) ；</p>
</li>
<li><p>三项工作：</p>
<ol>
<li><p>提前返回： 若 k = 0 ，代表已找到目标节点，无需继续遍历，提前终止中序遍历，因此直接返回提升效率，在某些特例下尤其明显，例如：树有 10000 个节点，求第 1 大的节点。<br>不加 if(k == 0) return 是做不到提前返回的，会降低效率</p>
</li>
<li><p>统计序号： 执行 k = k - 1 （即从 k 减至 0 ），每遍历一个节点 k 的值就减一；</p>
</li>
<li><p>记录结果： 若 k = 0 ，代表当前节点为第 k 大的节点，因此记录 res = root.val ；</p>
</li>
</ol>
</li>
<li><p>递归左子树： 即 dfs(root.left) ；</p>
</li>
</ol>
<p>时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。<br>空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</p>
<p>题目指出：1≤k≤N （二叉搜索树节点个数）；因此无需考虑 k &gt; N 的情况。<br>若考虑，可以在中序遍历完成后判断 k &gt; 0 是否成立，若成立则说明 k &gt; N 。</p>
<p>如果修改了函数外部变量的引用，比方说 k -= 1，相当于 k = k - 1，<br>就是给k重新赋值了，那它就变成了内部函数的局部变量，局部变量 k 不能在 dfs() 函数内访问，<br>此时可以声明 self.k = k 则建立了类成员变量 self.k<br>或者在函数内部声明 nonlocal k 说明 k 不会因为引用修改而成为局部变量。<br>需要对于函数 $dfs()$ 的全局变量，因此在 dfs() 内就可以正常访问 k</p>
<p>不能把两个k==0写在一起，因为此方法在访问每个节点时，需要将 “k -= 1” 前 和 “k -= 1” 后的逻辑分开~<br>如果直接在第一次遇到 k = 0 时，就返回 self.res，下面还会遇到 k -= 1， k 会被减到 -1 , -2 , … ，因此 K 就不 == 0 了，因此就会继续中序遍历，而不会终止。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  <span class="comment"># 第一次遇到 k == 0 时 ，记录结果</span></span><br><span class="line">                self.res = root.val</span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">dfs(root.right)</span><br><span class="line">    root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">    dfs(<span class="number">6</span>)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">6.</span>right = None</span><br><span class="line">        dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">6</span></span><br><span class="line">    k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    dfs(root.left)</span><br><span class="line">        root = root.left = <span class="number">6.</span>left = None</span><br><span class="line">        dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">6</span></span><br><span class="line">返回上一层 root = <span class="number">5</span></span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">dfs(<span class="number">5.</span>left)</span><br><span class="line">    root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">    dfs(<span class="number">3</span>)</span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">        dfs(<span class="number">4</span>)</span><br><span class="line">        dfs(root.right)</span><br><span class="line">            root = root.right = <span class="number">4.</span>right = None</span><br><span class="line">            dfs(None)</span><br><span class="line">        返回上一层 root = <span class="number">4</span></span><br><span class="line">        k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">        res = root.val = <span class="number">4</span></span><br><span class="line">        dfs(root.leftt)</span><br><span class="line">        root = root.right = <span class="number">4.</span>left = None</span><br><span class="line">            dfs(None)</span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">    <span class="keyword">return</span> res = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果不想要上面的 if ，并且想保留提前返回，<br>实际上也执行了dfs(root.left)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> self.k == <span class="number">0</span>: </span><br><span class="line">                    self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<p>右根左的顺序，非递归遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 右根左 非递归遍历</span></span><br><span class="line">        stack,count = [],<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == k:</span><br><span class="line">                    <span class="keyword">return</span> curr.val</span><br><span class="line">                root = cur.left</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>]</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">root = root.right = <span class="number">6.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">1</span> &lt; k = <span class="number">3</span></span><br><span class="line">root = cur.left = <span class="number">6.</span>left = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">5</span></span><br><span class="line">stack = []</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">2</span> &lt; k = <span class="number">3</span></span><br><span class="line">root = cur.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">root = root.right = <span class="number">4.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">count = count + <span class="number">1</span> = <span class="number">3</span> = k</span><br><span class="line"><span class="keyword">return</span> cur.val = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>


<p>迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> len(res)==k: </span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line">中序遍历倒序 [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 递减序列</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.right = <span class="number">5.</span>right = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">root = root.right = <span class="number">6.</span>right = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">6</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">res = [<span class="number">6</span>]</span><br><span class="line">len(res) = <span class="number">1</span></span><br><span class="line">root = root.left = <span class="number">6.</span>left = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">5</span></span><br><span class="line">stack = []</span><br><span class="line">res = [<span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">len(res) = <span class="number">2</span></span><br><span class="line">root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">root = root.right = <span class="number">4.</span>right = None</span><br><span class="line"></span><br><span class="line">root = stack.pop() = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">3</span>]</span><br><span class="line">res = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>] </span><br><span class="line">len(res) = <span class="number">3</span> = k</span><br><span class="line"><span class="keyword">return</span> res[<span class="number">-1</span>] = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h4 id="38-二叉搜索树的第k个结点-本题考点-树"><a href="#38-二叉搜索树的第k个结点-本题考点-树" class="headerlink" title="38.二叉搜索树的第k个结点 [^本题考点 树]"></a>38.二叉搜索树的第k个结点 [^本题考点 <em>树</em>]</h4><p>​    <strong>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。<br>例如,（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</strong></p>
<p>示例 1:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">root</span> <span class="string">=</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  <span class="string">/</span> <span class="string">\</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">\</span></span><br><span class="line">&nbsp;  <span class="number">2</span></span><br><span class="line"><span class="string">输入:</span> <span class="string">k</span> <span class="string">=</span> <span class="number">1</span> </span><br><span class="line"><span class="string">输出:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">输入:</span> <span class="string">k</span> <span class="string">=</span> <span class="number">0</span> </span><br><span class="line"><span class="string">输出:</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">root</span> <span class="string">=</span> [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>]<span class="string">,</span> <span class="string">k</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      <span class="string">/</span> <span class="string">\</span></span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    <span class="string">/</span> <span class="string">\</span></span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">/</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"><span class="string">输出:</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化&nbsp;kthSmallest&nbsp;函数？</p>
<p>方法一：<br>算法：通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">r</span>):</span></span><br><span class="line">            <span class="keyword">return</span> inorder(r.left) + [r.val] + inorder(r.right) <span class="keyword">if</span> r <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> inorder(root)[k - <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：O(N)，遍历了整个树。<br>空间复杂度：O(N)，用了一个数组存储中序序列。</p>
<p>方法二：迭代<br>算法：<br>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p>
<p>时间复杂度：O(H+k)，其中 H 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(logN+k)。<br>当树是一个不平衡树时：复杂度为 O(N+k)，此时所有的节点都在左子树。<br>空间复杂度：O(H+k)<br>当树是一个平衡树时：O(logN+k)。<br>当树是一个非平衡树时：O(N+k)。<br>当迭代到最小的那个数时需要O(H)的复杂度，然后O(K)的复杂度就找第k小的元素的迭代</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">root = root.left = <span class="number">3.</span>left = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">root = root.left = <span class="number">2.</span>left = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">root = root.left = <span class="number">1.</span>left = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">root = cur.right = <span class="number">1.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">root = cur.right = <span class="number">2.</span>right = None</span><br><span class="line"></span><br><span class="line">cur = stack.pop() = <span class="number">3</span></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line">k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> cur.val = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>


<p>递归</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)  <span class="comment"># BFS，不断左侧下探到叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span>  <span class="comment"># 左侧下探返回后，节点数+1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:  <span class="comment"># 判断当前节点是否是目标节点，即第k小</span></span><br><span class="line">                self.res = root.val</span><br><span class="line">            dfs(root.right)  <span class="comment"># 右侧递归</span></span><br><span class="line"></span><br><span class="line">        self.k = k  <span class="comment"># 全局变量，self不能少</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,None,None,<span class="number">1</span>],</span><br><span class="line">中序遍历 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] 递增序列 </span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">dfs(root.left)</span><br><span class="line">    root = root.left = <span class="number">5.</span>left = <span class="number">3</span></span><br><span class="line">    dfs(<span class="number">3</span>)</span><br><span class="line">    dfs(root.left)</span><br><span class="line">        root = root.left = <span class="number">3.</span>left = <span class="number">2</span></span><br><span class="line">        dfs(<span class="number">2</span>)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">            root = root.left = <span class="number">2.</span>left = <span class="number">1</span></span><br><span class="line">            dfs(<span class="number">1</span>)</span><br><span class="line">            dfs(root.left)</span><br><span class="line">                root = root.left = <span class="number">1.</span>left = None</span><br><span class="line">                dfs(None)</span><br><span class="line">            返回上一层 root = <span class="number">1</span></span><br><span class="line">            k = k - <span class="number">1</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">                root = root.right = <span class="number">2.</span>right = None</span><br><span class="line">                dfs(None)</span><br><span class="line">            返回上一层 root = <span class="number">1</span></span><br><span class="line">        返回上一层 root = <span class="number">2</span></span><br><span class="line">        k = k - <span class="number">1</span> = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">            root = root.right = <span class="number">2.</span>right = None</span><br><span class="line">            dfs(None)</span><br><span class="line">        返回上一层 root = <span class="number">2</span></span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = k - <span class="number">1</span> = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">    res = root.val = <span class="number">3</span></span><br><span class="line">    dfs(root.right)</span><br><span class="line">        root = root.right = <span class="number">3.</span>right = <span class="number">4</span></span><br><span class="line">        dfs(<span class="number">4</span>)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">            root = root.left = <span class="number">4.</span>left = None</span><br><span class="line">        返回上一层 root = <span class="number">4</span>   </span><br><span class="line">        k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">    返回上一层 root = <span class="number">3</span></span><br><span class="line">    k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line">返回上一层 root = <span class="number">5</span></span><br><span class="line">k = <span class="number">0</span> <span class="keyword">return</span> 函数结束</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self.res = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="29-二叉搜索树的后序遍历序列"><a href="#29-二叉搜索树的后序遍历序列" class="headerlink" title="29.二叉搜索树的后序遍历序列"></a>29.二叉搜索树的后序遍历序列</h2><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 1：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>题目只是说能不能是，而不是所有后序是这样的都是。<br>解题思路：</p>
<p>题目：假设输入的数组的任意两个数字都互不相同<br>左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值<br>其左、右子树也分别为二叉搜索树。</p>
<p>后序遍历定义： 遍历顺序为 “左、右、根” 。<br>后序遍历 的序列中，最后一个数字是树的根节点</p>
<p>左右子树分界点 与根节点作比较<br>数组中前面的数字可以分为两部分：<br>第一部分是左子树节点 的值，都比根节点的值小；<br>第二部分 是右子树 节点的值，都比 根 节点 的值大，</p>
<p>方法一：递归分治</p>
<ul>
<li>根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性<br>（即其后序遍历是否满足二叉搜索树的定义） ，<br>若所有子树都正确，则此序列为二叉搜索树的后序遍历。</li>
</ul>
<p>递归解析：<br>i, j 是递归过程中 后序遍历的左右边界， i, j 命名规范用left, right吧<br>i, j 之间的节点是当前子树包含的节点。 </p>
<p>当 i &gt; j 时，没有节点。</p>
<ul>
<li>终止条件： 当 i \geq j i≥j ，说明此子树节点数量 \leq 1 ≤ 1 ，无需判别正确性，直接返回 true ，递归到“空”则说明所有子树满足</li>
</ul>
<p>当 i = m = j - 1 时，<br>向下递归 recur(i, m - 1) 时 i &gt; j ，<br>本质上就是左子树为空的情况</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<p>[6, 5]<br>第一个大于 root = 5 的后面都是5的右子节点[6]。<br>这个数组只有一个根节点，没有子节点<br>m = 0 = i = 0, recur(i, m - 1) = recur(0, 0 - 1), 0 &gt; -1</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">6</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p>[7, 6, 5]<br>第一个大于 root = 5 的后面都是5的右子树[7，6]。<br>然后再递归这个数组，6是根节点，第一个比6大的后面都是6的右子节点[7]，<br>只有一个根节点，没有子节点</p>
<p>所以我们能确定这棵树是二叉搜索树。<br>本来left= 0,right = 2, 通过第一个while循环m= cur = 7,<br>那么return中的第二个recur(i, m - 1)就是recur(0, 0 - 1)，这是只有右子树的情况，<br>i &gt; j，返回True</p>
<p>[1, 2, 3] 可能不是二叉搜索树的后序遍历，但也可能是。<br>根据题意，只要能构成二叉搜索树的后序遍历，就应返回 true 。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   /  </span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /     </span><br><span class="line"><span class="number">1</span>       </span><br></pre></td></tr></tbody></table></figure>
<p>本来left= 0,right = 2, 通过第一个while循环 m = cur = 2,<br>那么return中的第二个recur(m, j - 1)就是recur(2, 2 - 1)，这是只有左子树的情况，<br>i &gt; j，返回True</p>
<ul>
<li><p>递推工作：</p>
<ol>
<li><p>划分左右子树： 遍历后序遍历的 [i, j] 区间元素，<br>从头、左往右找出第一个大于或等于根节点的节点，索引记为 m ，数组的任意两个数字都互不相同，<br>如果没有大于第一个大于根节点 的节点，则根节点索引也记为 m，<br>此时，可划分出左子树区间 [i, m-1] 、右子树区间 [m, j - 1] 、根节点索引 j 。</p>
</li>
<li><p>判断是否为二叉搜索树：</p>
</li>
</ol>
<ul>
<li><p>左子树区间 [i, m - 1] 内的所有节点都应 &lt;&lt; postorder[j] 。<br>而第 1. 划分左右子树 步骤已经保证左子树区间的正确性，<br>因此只需要判断右子树区间即可。</p>
</li>
<li><p>右子树区间 [m, j-1] 内的所有节点都应 &gt;&gt; postorder[j] 。<br>实现方式为遍历，当遇到 \leq ≤postorder[j] 的节点则跳出；<br>则可通过 cur = j 判断是否为二叉搜索树。</p>
</li>
</ul>
</li>
<li><p>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符and 连接。</p>
<ol>
<li>cur = j ： 判断 “当前树”的后序遍历满足二叉搜索树的性质，<br>若未将postoerder[i, j)遍历完，则非后序遍历序列 返回false</li>
<li>recur(i, m - 1) ： 判断 此树的左子树 是否正确。</li>
<li>recur(m, j - 1) ： 判断 此树的右子树 是否正确。</li>
</ol>
</li>
</ul>
<p>时间复杂度 O(N^2) ： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；<br>最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。<br>空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: [int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="comment"># 如果left==right，就一个节点不需要判断了，</span></span><br><span class="line">            <span class="comment"># 如果left&gt;right说明只有左子树的情况，如果只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = i</span><br><span class="line">            <span class="keyword">while</span> postorder[cur] &lt; postorder[j]: cur += <span class="number">1</span></span><br><span class="line">            <span class="comment"># cur继续保留已经循环了的次数的数值</span></span><br><span class="line">            m = cur  <span class="comment"># 第一个大于根节点 的节点的索引记为 m</span></span><br><span class="line">            <span class="keyword">while</span> postorder[cur] &gt; postorder[j]: cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cur == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>法二<br>步骤：</p>
<ol>
<li>确定根节点root；</li>
<li>遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；</li>
<li>遍历右子树，若发现有小于root的值，则直接返回false；</li>
<li>分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。<br>时间复杂度(n) 击败90%</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> postorder <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        length = len(postorder)</span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 在二叉搜索树中左子树节点都小于根节点，找到左子树的区间，</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 二叉搜索树中右子树的节点都大于根节点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length):</span><br><span class="line">            <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断左子树是否为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            left = self.verifyPostorder(postorder[<span class="number">0</span>:i])  <span class="comment"># 左闭右开</span></span><br><span class="line">        <span class="comment"># 判断右子树是否为二叉搜索树</span></span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; length - <span class="number">1</span>:</span><br><span class="line">            right = self.verifyPostorder(postorder[i:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isTree</span>(<span class="params">postorder</span>):</span></span><br><span class="line">            root = postorder[<span class="number">-1</span>]</span><br><span class="line">            length = len(postorder)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length): </span><br><span class="line">                <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            left = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                left = isTree(postorder[:i])</span><br><span class="line">            right = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; length <span class="number">-1</span> :</span><br><span class="line">                right = isTree(postorder[i:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br><span class="line">        <span class="keyword">return</span> isTree(postorder)</span><br></pre></td></tr></tbody></table></figure>

<p>法三<br>出发点不是检索子树的正确性。 而是“所有递减节点的父节点 root 性质” 得到满足即可</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>后序遍历    [1, 3, 2, 6, 5]<br>后序遍历倒序 [5, 6, 2, 3, 1]<br>后序遍历倒序： [ 根节点 | 右子树 | 左子树 ] 。<br>类似 先序遍历的镜像，即先序遍历为 “根、左、右” 的顺序，</p>
<ul>
<li><p>设后序遍历倒序列表为 [r_{n}, r_{n-1},…,r_1]，<br>遍历此列表，设索引为 i ，若为 二叉搜索树 ，则有规律：</p>
<ul>
<li><p>当节点值 r_i &gt; r_{i+1} 时： 节点 r_i 一定是节点 r_{i+1} 的右子节点。<br>例如5和6是挨着的并且5 &lt; 6，所以6是5的右子节点。<br>证明：比arr[i+1]大的肯定都是他的右子节点，如果还是挨着他的，<br>肯定是在后续遍历中所有的右子节点最后一个遍历的，<br>所以他一定是arr[i]的右子节点</p>
</li>
<li><p>当节点值 r_i &lt; r_{i+1} 时： 节点 r_i 一定是某节点 root 的左子节点，且 root 为节点 r_{i+1}, r_{i+2},…, r_{n}r 中值大于且最接近 r_i 的节点（∵ root 直接连接 左子节点 r_i ）。<br>比如6，2是降序的，那么2肯定是他前面某一个节点的左子节点，并且这个值是大于2中最小的，我们看到5和6都是大于2的，但5最小，所以2就是5的左子节点。<br>同理我们可以观察到3和1是降序，1前面大于1中最小的是2，所以1就是12的左子节点。</p>
</li>
</ul>
</li>
<li><p>当遍历时遇到递减节点 r_i &lt; r_{i+1}，若为二叉搜索树，则对于后序遍历中节点 r_i 右边的任意节点 r_x \in [r_{i-1}, r_{i-2}, …, r_1]，必有节点值 r_x &lt; root 。<br>序列中节点2右边的所有节点(即节点3，1)都应小于节点5。</p>
</li>
</ul>
<p>节点 r_x 只可能为以下两种情况：<br>① r_x 为 r_i 的左、右子树的各节点；<br>② r_x 为 root 的父节点或更高层父节点的左子树的各节点。<br>在二叉搜索树中，以上节点都应小于 root 。</p>
<ul>
<li>遍历 “后序遍历的倒序” 会多次遇到递减节点 r_i ，若所有的递减节点 r_i 对应的父节点 root 都满足以上条件，则可判定为二叉搜索树。</li>
<li>根据以上特点，考虑借助 单调栈 实现：<ol>
<li>借助一个单调栈 stack 存储值递增的节点；</li>
<li>每当遇到值递减的节点 r_i，则通过出栈来更新节点 r_i 的父节点 root ；</li>
<li>每轮判断 r_i 和 root 的值关系：<ol>
<li>若 r_i &gt; root 则说明不满足二叉搜索树定义，直接返回 false 。</li>
<li>若 r_i &lt; root 则说明满足二叉搜索树定义，则继续遍历。</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>算法流程：</p>
<ol>
<li>初始化： 单调栈 stack ，父节点值 root = +\inf root=+∞<br>（初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；</li>
<li>倒序遍历 postorder ：记每个节点为 r_i；</li>
<li>判断： 若 r_i&gt;root ，说明此后序遍历序列不满足二叉搜索树定义，直接返回 false ；</li>
<li>更新父节点 root ： 当栈不为空 且 r_i &lt; stack[-1] 时，循环执行出栈，并将出栈节点赋给 root 。</li>
<li>入栈： 将当前节点 r_i入栈；</li>
<li>若遍历完成，则说明后序遍历满足二叉搜索树定义，返回 true 。</li>
</ol>
<p>时间复杂度 O(N) ： 遍历 postorder 所有节点，各节点均入栈 / 出栈一次，使用 O(N) 时间。递归判断需要重复遍历节点，而单调栈不用。<br>空间复杂度 O(N) ： 最差情况下，单调栈 stack 存储所有节点，使用 O(N) 额外空间。</p>
<p>把先序遍历的功能通过单调栈实现了12356 13265 56231 inf根5(右)-inf左 562 231 ，<br>并且通过局部性使得左中右的顺序在每个节点处都进行判断，太妙了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: [int]</span>) -&gt; bool:</span></span><br><span class="line">        stack, root = [], float(<span class="string">"+inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># root是在什么情况下赋的值，root并不一定都是根节点的值，</span></span><br><span class="line">            <span class="comment"># 相对于遇到了左子节点的时候他是左子节点的根节点。</span></span><br><span class="line">            <span class="comment"># 如果是右子节点，parent就是他的某一个祖先节点，</span></span><br><span class="line">            <span class="comment"># 并且这个右子节点是这个祖先节点的一个左子树的一部分，所以不能超过他，</span></span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，</span></span><br><span class="line">            <span class="comment"># 说明当前节点是前面某个节点的左子节点，我们要找到他的根节点</span></span><br><span class="line">            <span class="keyword">while</span>(stack <span class="keyword">and</span> postorder[i] &lt; stack[<span class="number">-1</span>]):</span><br><span class="line">                root = stack.pop()</span><br><span class="line">            <span class="comment"># 只要遇到了某一个左子节点，才会执行上面的代码，</span></span><br><span class="line">            <span class="comment"># 才会更新root的值，否则root就是一个非常大的值，</span></span><br><span class="line">            <span class="comment"># 也就是说如果一直没有遇到左子节点，那么右子节点可以非常大</span></span><br><span class="line">            stack.append(postorder[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">self, sequence</span>):</span></span><br><span class="line">        <span class="keyword">if</span> sequence == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rootNum = sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">del</span> sequence[<span class="number">-1</span>]</span><br><span class="line">        index = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sequence)):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="literal">None</span> <span class="keyword">and</span> sequence[i] &gt; rootNum:</span><br><span class="line">                index = i</span><br><span class="line">            <span class="keyword">if</span> index != <span class="literal">None</span> <span class="keyword">and</span> sequence[i] &lt; rootNum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> sequence[:index] == []:</span><br><span class="line">            leftRet = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            leftRet = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        <span class="keyword">if</span> sequence[index:] == []:</span><br><span class="line">            rightRet = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rightRet = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftRet <span class="keyword">and</span> rightRet</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先找到根节点的右子节点，然后判断右子树的值是否全大于root；</span></span><br><span class="line"><span class="comment"># 然后再递归根节点的左右子树即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        cur_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt;= root:</span><br><span class="line">                cur_index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        left = postorder[:cur_index]</span><br><span class="line">        right = postorder[cur_index : <span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 检查左右子树是否有不符合要求的节点</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> right:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 检查左、右子树是否分别是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> self.verifyPostorder(left) <span class="keyword">and</span> self.verifyPostorder(right)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="30-二叉树中和为某一值的路径"><a href="#30-二叉树中和为某一值的路径" class="headerlink" title="30.二叉树中和为某一值的路径"></a>30.二叉树中和为某一值的路径</h2><p><strong>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定如下二叉树，以及目标和&nbsp;sum = <span class="number">22</span>，</span><br><span class="line"></span><br><span class="line">              <span class="number">5</span></span><br><span class="line">             / \</span><br><span class="line">            <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">           /   / \</span><br><span class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line">         /  \    / \</span><br><span class="line">        <span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路：<br>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。</p>
<ul>
<li>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。</li>
<li>路径记录： 在先序遍历中，记录从根节点到当前节点的路径。<br>当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</li>
</ul>
<p>算法流程：<br>pathSum(root, sum) 函数：</p>
<ul>
<li>初始化： 结果列表 res ，路径列表 path 。</li>
<li>返回值： 返回 res 即可。</li>
</ul>
<p>recur(root, tar) 函数：</p>
<ul>
<li>递推参数： 当前节点 root ，当前目标值 tar 。</li>
<li>终止条件： 若节点 root 为空，则直接返回。</li>
<li>递推工作：<ol>
<li>路径更新： 将当前节点值 root.val 加入路径 path ；</li>
<li>目标值更新： tar = tar - root.val（即目标值 tar 从 sum 减至 0 ）；</li>
<li>路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 只有当前函数终止才会向上回溯前，所有变量恢复到原来的状态，需要将当前节点从路径 path 中弹出删除，即执行 path.pop()</li>
</ol>
</li>
</ul>
<p>状态是指完成一件事情进行到哪一个阶段，在上面的代码中：path 、tar 都是状态变量</p>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，先序遍历需要遍历所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。<br>res 作为返回值，是必须要使用的空间，因此不计入计算范围内~ 这里的空间复杂度只计算“额外空间”</p>
<p>击败50%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment">#  res 保存最终的所有路径结果， path 保存每条路径。</span></span><br><span class="line">        res, path = [], []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, tar</span>):</span></span><br><span class="line">            <span class="comment"># 递归终止条件 1：解决子问题，如果输入结点为空结点，返回空列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:   </span><br><span class="line">                <span class="comment"># recur() 函数实际上是 void 函数，最后return 的是 res ,写成return [] 都可以</span></span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="comment"># 有节点</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="comment"># 递归终止条件 2：tar == 0，并且节点为叶子节点 </span></span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="comment"># 对引用类型参数（Reference Data Type Arguments）动态变量，</span></span><br><span class="line">                <span class="comment"># 在调用函数时，将实际参数的 内存地址（引用，而不是真正的变量） 复制传递到函数中。</span></span><br><span class="line">                <span class="comment"># 可变对象如列表，字典等，原本就可以改变，如果在函数中对参数修改，将会影响到实际参数。</span></span><br><span class="line">                <span class="comment"># 记录路径时若执行 res.append(path) ，</span></span><br><span class="line">                <span class="comment"># 把 path 列表对象在“方法传参”中传递所在的内存地址（引用）加到 res 中 ；</span></span><br><span class="line">                <span class="comment"># 所有递归函数始终对唯一的内存地址的同一个 path 对象做处理，因此回溯时，也应将 path 还原至此递归函数执行前的形式 </span></span><br><span class="line">                <span class="comment"># 不断地变长变短、变长变短的 path 变量所指向的列表在深度优先遍历的过程中只有一份，</span></span><br><span class="line">                <span class="comment"># 后续 path 对象改变时，后面又进栈 append 又出栈 pop 的，</span></span><br><span class="line">                <span class="comment"># res 中的 path 对象 也会随之改变</span></span><br><span class="line">                <span class="comment"># 深度优先遍历完成以后，最终回溯回根节点root，path回到空列表。</span></span><br><span class="line">                <span class="comment"># 实际上指向的是同一块内存地址，指向的那块内存区域没有变，因此会看到 6 个空的列表对象。</span></span><br><span class="line">                <span class="comment"># res 里面是这样的：[path 在内存中的地址, path 在内存中的地址,</span></span><br><span class="line">                <span class="comment"># path 在内存中的地址, path 在内存中的地址, path 在内存中的地址]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 深拷贝 copy.deepcopy，没有拷贝对象的地址(引用)，只是拷贝对象的值，</span></span><br><span class="line">                <span class="comment"># 当一条path找到的时候，我想要完整的保存它，</span></span><br><span class="line">                <span class="comment"># 每次都要新复制了一个 path 列表，把新复制的列表的地址复制到 res 中，因此不会受到 path 变化的影响。</span></span><br><span class="line">                <span class="comment"># 在它遍历到符合条件的状态时候，把其中的在某个特定时期的状态的变量的地址复制下来</span></span><br><span class="line">                <span class="comment"># 解决的方法，list(path)或path[:]或path.copy()</span></span><br><span class="line">                <span class="comment"># 本文中的 path 列表对象对于 dfs() 函数来说仍是 ”全局的“ </span></span><br><span class="line">                res.append(list(path))</span><br><span class="line">            recur(root.left, tar)  <span class="comment"># 递归处理左边或函数已返回（左子树已递归完成）</span></span><br><span class="line">            recur(root.right, tar)  <span class="comment"># 递归处理右边或函数已返回（右子树已递归完成）</span></span><br><span class="line">            path.pop()  <span class="comment"># 递归完成以后，必须重置变量</span></span><br><span class="line">            <span class="comment"># 为什么仅path.pop() 而不tar += root.val呢？</span></span><br><span class="line">            <span class="comment"># 而且加上了tar += root.val也能通过？</span></span><br><span class="line">            <span class="comment"># tar 是数值不可变对象值传递，因此每轮递归函数里的修改的 tar 都是独立的数字，</span></span><br><span class="line">            <span class="comment"># 上层递归的 tar 还保存在系统调用dfs的栈中，是没有变的，相当于tar没有减去那个数，因此tar不用回溯 不用重置</span></span><br><span class="line">            <span class="comment"># 在记录路径时，一旦涉及本节点的路径都检查并记录完毕，就要去掉本节点，但未完毕前不能去掉，所以放在最后。</span></span><br><span class="line">            <span class="comment"># 另外，递归思考过程中需要且仅需要着眼当下，如果实在纠结递归的进行过程，要从函数调用栈的角度思考。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 函数执行完就会自己结束的～因为本题 recur() 不需要有返回值，因此就不用 return</span></span><br><span class="line"></span><br><span class="line">        recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">tar = <span class="number">22</span></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">11</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">tar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">7</span>]</span><br><span class="line">tar = <span class="number">-5</span></span><br><span class="line"></span><br><span class="line">不满足回到上一层</span><br><span class="line">root = <span class="number">11</span></span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">8</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">13</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line">tar = <span class="number">-4</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">8</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>],  ]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">root = root.right = <span class="number">1</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">tar = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>



<p>递归先序遍历树，把结点加入路径。<br>若该结点是叶子结点则比较当前路径和是否等于期待和。<br>弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</p>
<p>方法二，击败95%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, tar</span>):</span></span><br><span class="line">            <span class="comment"># print(path)</span></span><br><span class="line">            <span class="comment"># 递归终止条件 1：如果遍历到的结点为空结点，返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 递归终止条件 2：如果遍历到的叶子结点，且 tar 恰好等于叶子结点的值</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.val == tar <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                path.pop()</span><br><span class="line">                <span class="comment"># 在叶子结点处，并且找到了一个解以后，就可以返回，所以要加上 return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 缩进错了，下面 3 行都是 dfs 函数里的内容</span></span><br><span class="line">            dfs(root.left, tar - root.val)</span><br><span class="line">            dfs(root.right, tar - root.val)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在这里要调用一下 dfs 方法</span></span><br><span class="line">        dfs(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">path = []</span><br><span class="line"></span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">tar = <span class="number">22</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">4</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">tar = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">11</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line">tar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">7</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">7</span>]</span><br><span class="line">tar = <span class="number">-5</span></span><br><span class="line"></span><br><span class="line">不满足回到上一层</span><br><span class="line">root = <span class="number">11</span></span><br><span class="line">root = root.right = <span class="number">2</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>]</span><br><span class="line">tar = <span class="number">0</span></span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>] ]</span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">5</span></span><br><span class="line">tar = <span class="number">22</span></span><br><span class="line">path = [<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">8</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">13</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">8</span></span><br><span class="line">tar = <span class="number">17</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">4</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">root = root.left = <span class="number">5</span></span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">res = [ [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">4</span></span><br><span class="line">tar = <span class="number">9</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">root = root.right = <span class="number">1</span></span><br><span class="line">tar = <span class="number">5</span></span><br><span class="line">path = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">tar = <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, sum_: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, path, sum_</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> sum_ - root.val == <span class="number">0</span>:</span><br><span class="line">                path += [root.val]</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="comment"># path + [root.left.val] 返回一个新的列表，所有递归函数里的 path 操作不会互相干扰。 </span></span><br><span class="line">            <span class="comment"># path.append(root.left.val)是对path进行修改，无返回值</span></span><br><span class="line">            <span class="comment"># 记录到达每个节点时的sum - 「路径和」</span></span><br><span class="line">            <span class="comment"># 如果遍历到叶子节点的时候，sum - 「路径和」恰好等于叶子节点的值，</span></span><br><span class="line">            <span class="comment"># 那么这条从根节点到叶子节点的路径即为一条满足题目的路径。</span></span><br><span class="line">            helper(root.left, path + [root.val], sum_ - root.val)</span><br><span class="line">            helper(root.right, path + [root.val], sum_ - root.val)</span><br><span class="line">        helper(root, [], sum_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="31-二叉搜索树与双向链表"><a href="#31-二叉搜索树与双向链表" class="headerlink" title="31.二叉搜索树与双向链表"></a>31.二叉搜索树与双向链表</h2><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</strong></p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">4</span></span><br><span class="line">   / \ </span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。<br>对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，<br>树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>解题思路：<br>本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。<br>因此把标准中序遍历中 改变每个父节点的左右指向即可<br>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p>
<ol>
<li>排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点；</li>
<li>双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right = cur ，也应 cur.left = pre 。</li>
<li>循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right = head 。</li>
</ol>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure>
<p>根据以上分析，考虑使用中序遍历访问树的各节点 cur ；<br>并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；<br>中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p>
<p>算法流程：<br>dfs(cur): 递归法中序遍历；</p>
<ol>
<li>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 dfs(cur.left) ；</li>
<li>构建链表：<ol>
<li>当 pre 为空时：代表正在访问链表头节点，记为 head 。</li>
<li>当 pre 不为空时：修改双向节点引用，<br>即 pre.right = cur ， cur.left = pre ；</li>
<li>保存 cur ：更新 pre = cur ，即节点 cur 是后继节点的 pre ；</li>
</ol>
</li>
<li>递归右子树，即 dfs(cur.right) ；<br>并没有创建新节点，pre 、 head 只是两个引用，指向现有节点的地址。</li>
</ol>
<p>treeToDoublyList(root)：</p>
<ol>
<li>特例处理： 若节点 root 为空，则直接返回；</li>
<li>初始化： 空节点 pre ；</li>
<li>转化为双向链表： 调用 dfs(root) ；</li>
<li>构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可。</li>
<li>返回值： 返回链表的头节点 head 即可。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</p>
<p>pre = ListNode() ，如果不加self的话，pre和head是dfs函数内部的变量，那么就是类中方法的私有变量，是无法被类所访问的，外函数和内函数不能共享<br>由于中序遍历完还需要用到 pre 去实现循环链表，<br>此时可以声明 self.pre = pre 则建立了类成员变量 self.pre<br>或者在函数内部声明 nonlocal pre 说明 pre 不会因为引用修改而成为局部变量。<br>这样此变量就能在所属类的任何方法中访问。类里面的全局变量<br>使其在两个函数 dfs()中都可以正常访问 head 和 pre，</p>
<p>list 类型是外部变量全局变量，函数中的函数也可以访问。<br>内部调用 list.append() 等方法，<br>不会改变引用，也就不需要做 self 和 nonlocal 等操作。</p>
<p>head是个指针变量，（这里你就当成个普通int型变量来理解就行了），指针变量作为函数参数传入时和普通变量一样，也就是，如你在dfs函数中怎么修改它，当函数结束返回的时候，指针变量或者普通变量还是传入之前的值。但是加上引用就不一样了，此时你在dfs中修改head指针，函数返回时，head指针是被修改过的。</p>
<p>值传递与引用传递的区别，因为函数是void的，想要把函数内部对指针的修改传出来就得用引用（或者指针的指针也可以），别去管head和pre是不是指针（指针本质上也是一个对象），最后修改一下函数的返回值也是可以的。<br>因为你修改的对象是Node<em>本身，而不是指向的那个东西，所以要对Node</em>再加个引用。（指针参数本质上也是一种值传递，传递的就是地址）</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="comment"># 递归出口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left)  <span class="comment"># # 中序遍历，先递归左子树</span></span><br><span class="line">            <span class="comment"># pre 用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur</span></span><br><span class="line">            <span class="comment"># pre!=None时，cur左侧存在节点pre，需要进行 pre.right=cur 的操作</span></span><br><span class="line">            <span class="comment"># pre 相对于递归函数是全局变量，因此需要加 self</span></span><br><span class="line">            <span class="comment"># 中序遍历，然后父节点</span></span><br><span class="line">            <span class="keyword">if</span> self.pre:  <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="comment"># 当pre==None时，cur左侧没有节点，即此时cur为双向链表中的头节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.head = cur  <span class="comment"># 记录初始头节点</span></span><br><span class="line">            self.pre = cur  <span class="comment"># 保存 cur, pre指向当前的cur</span></span><br><span class="line">            dfs(cur.right)  <span class="comment"># 中序遍历，最后 递归右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 中序遍历全部迭代完后，head 指向头节点，pre 指向尾节点，</span></span><br><span class="line">        <span class="comment"># 构建循环链表：因此修改 head 和 pre 的双向节点引用即可。</span></span><br><span class="line">        <span class="comment"># 进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的</span></span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></tbody></table></figure>

<p>不是把二叉树的根节点当作链表的头，应该是将最左下的叶节点作为链表的头结点。<br>排序：树的中序遍历 1 2 3 4 5<br>双向：2.right = 3 ,  3.left = 2<br>循环：5.right = 1， 1.left = 5</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pre</span> = None</span><br><span class="line"><span class="attr">root</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">cur</span> = root</span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">left</span> = None</span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">head</span> = <span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">right</span> = <span class="number">3</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">3</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">2</span> </span><br><span class="line">回到上一层</span><br><span class="line"><span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cur</span> = cur.<span class="attr">right</span> = <span class="number">5</span></span><br><span class="line">pre.<span class="attr">right</span> = <span class="attr">cur</span> = <span class="number">5</span></span><br><span class="line">cur.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">pre</span> = <span class="attr">cur</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">self.head.<span class="attr">left</span> = self.<span class="attr">pre</span> = <span class="number">5</span></span><br><span class="line">self.pre.<span class="attr">right</span> = self.<span class="attr">head</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>


<p>法二：不用递归，利用栈中序遍历，顺便更改节点左右指向，头结点和尾结点的指针。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        head = node = stack.pop()</span><br><span class="line">        pre = node</span><br><span class="line">        node = node.right</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pre.right = node</span><br><span class="line">            node.left = pre</span><br><span class="line">            pre = node</span><br><span class="line">            node = node.right</span><br><span class="line">        pre.right = head</span><br><span class="line">        head.left = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= root</span> = <span class="number">4</span></span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = <span class="number">2</span></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = <span class="number">1</span></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">head = <span class="keyword">node</span> <span class="title">= 1</span></span><br><span class="line">pre = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line">node.left = pre = <span class="number">1</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 2</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line">stack = [<span class="number">4</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line">node.left = pre = <span class="number">2</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 3</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line">node.left = pre = <span class="number">3</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 4</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack = [<span class="number">5</span>]</span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.left = None</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line">pre.right = <span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line">node.left = pre = <span class="number">4</span></span><br><span class="line">pre = <span class="keyword">node</span> <span class="title">= 5</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">= node</span>.right = None</span><br><span class="line">stack 和 <span class="keyword">node</span> <span class="title">同时为空</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">pre</span>.right = head = <span class="number">1</span></span><br><span class="line">head.left = pre = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>法三：分治 递归遍历<br>第一步：需要把 left 指针指向上一个比该元素小的值，<br>right 指针指向下一个比当前元素大的值。但是这个值不一定是该节点的父亲或者儿子。<br>所以递归的时候需要传递当前元素已知的界限给儿子。</p>
<p>而且传给左孩子的右界限是自己，左界限是当前元素的父亲传下来的界限。<br>给右孩子的则正好相反。</p>
<p>递归的起始根节点的左右界限都设为 None</p>
<p>第二步：把最小值和最大值连接起来</p>
<p>如何找到最小值和最大值，最小值和最大值不一定是叶子节点。我刚开始犯了这个错误。</p>
<p>最小值一定是某个节点的左儿子，而且他没有左儿子。是整个树最左边的左儿子。</p>
<p>所以我定义的找最小节点的条件是：没有左儿子 + 父亲传来的左界限为 None<br>最大节点：没有右儿子 + 父亲传来的右界限为 None</p>
<p>这个方法将dfs()的输出改为头和尾，然后左节点尾连根节点再连右节点头，接着递归即可<br>时间复杂度：O(N)，所有节点遍历一次。<br>空间复杂度：O(N)，当二叉搜索树退化为链表时，树的深度为 N.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root: <span class="string">'Node'</span></span>) -&gt; ('Node', 'Node'):</span></span><br><span class="line">            <span class="comment"># 根为空，那么 对应的双向链表的 头节点 和 尾节点 也为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 左子树 对应的 双向链表的头节点和尾节点</span></span><br><span class="line">            left_head, left_tail = dfs(root.left)</span><br><span class="line">            <span class="comment"># 右子树 对应的 双向链表的头节点和尾节点</span></span><br><span class="line">            right_head, right_tail = dfs(root.right)</span><br><span class="line">            <span class="comment"># 根的 左节点 与 左子树的尾节点 互相连接</span></span><br><span class="line">            <span class="comment"># 根的 右节点 与 右子树的头节点 互相连接</span></span><br><span class="line">            root.left, root.right = left_tail, right_head</span><br><span class="line">            <span class="keyword">if</span> left_tail: </span><br><span class="line">                left_tail.right = root</span><br><span class="line">            <span class="keyword">if</span> right_head: </span><br><span class="line">                right_head.left = root</span><br><span class="line">            <span class="comment"># 左子树的头节点 如果存在则作为当前 双向链表的头节点，否则使用 根节点。尾节点同理。</span></span><br><span class="line">            <span class="keyword">return</span> left_head <span class="keyword">if</span> left_head <span class="keyword">else</span> root, right_tail <span class="keyword">if</span> right_tail <span class="keyword">else</span> root</span><br><span class="line">        head, tail = dfs(root)</span><br><span class="line">        <span class="comment"># 改造成循环双向链表</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> tail:</span><br><span class="line">            head.left, tail.right = tail, head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            lh, lt = merge(root.left)</span><br><span class="line">            rh, rt = merge(root.right)</span><br><span class="line">            res = [lh, rt]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lh:</span><br><span class="line">                res[<span class="number">0</span>] = root                </span><br><span class="line">            root.left = lt</span><br><span class="line">            <span class="keyword">if</span> lt:</span><br><span class="line">                lt.right = root</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rt:</span><br><span class="line">                res[<span class="number">1</span>] = root</span><br><span class="line">            root.right = rh</span><br><span class="line">            <span class="keyword">if</span> rh:</span><br><span class="line">                rh.left = root</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        head, tail = merge(root)</span><br><span class="line">        head.left, tail.right = tail, head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>回溯法<br>一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p>
<p>采用试错的思想，它尝试分步的去解决一个问题。<br>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。<br>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案；</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案。</li>
</ol>
<p>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。<br>「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。<br>而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。<br>至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。</p>
<p>搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。</p>
<p>与动态规划的区别<br>共同点<br>用于求解多阶段决策问题。多阶段决策问题即：</p>
<ol>
<li>求解一个问题分为很多步骤（阶段）；</li>
<li>每一个步骤（阶段）可以有多种选择。<br>不同点</li>
<li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li>
<li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li>
</ol>
<p>怎么前进（进入下一个状态）；<br>怎么回退（回到上一个状态）；<br>什么时候停止。 其中比较重要的是：采取何种方式处理好状态的前进和回退。</p>
<p>回溯问题本身是在树形问题上的遍历，且是深度优先遍历。所以有回退的过程，需要撤销选择。<br>单从代码上看可能看不出来，<br>一定要先理解「深度优先遍历」这个思想，然后再去理解为什么可以用「一个变量」去在「所有可能的状态集合」里搜索要求的状态。</p>
<p>我在标题和题解的一开始都在强调这件事情。怎样构建一个「树」的模型，去执行深度优先遍历，是解决这一类问题的关键思想</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<p>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。<br>以数组 [1, 2, 3] 的全排列为例。</p>
<p>按顺序枚举每一个位置可能出现的数字，之前已经出现的数字在接下来要选择的数字中不能出现</p>
<p>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p>
<p>说明：</p>
<ul>
<li>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；</li>
<li>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。<br>例如：从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。<br>不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；</li>
</ul>
<p>正是因为修改的都是同一个对象，在回到来过的地方的时候，这个对象的值要和之前来到的时候是一样的。</p>
<ul>
<li>深度优先遍历，借助系统栈空间，已经选了哪些树的 path，保存每一个结点的所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；</li>
<li>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。</li>
</ul>
<p>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p>
<p>设计状态变量：表示了在求解一个问题的时候所处的阶段。</p>
<ul>
<li>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；</li>
<li>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；</li>
<li>布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应下标设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</li>
</ul>
<p>需要根据问题的场景设计合适的状态变量。</p>
<p>剪枝<br>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p>
<p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。<br>总结<br>做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：<br>分支如何产生；递归到叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？<br>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p>
<p>在前进时，需要查看当前数字是否已经在组合的路径中，也就是要回避非法状态；<br>在回退时，要将当前数字从组合的路径中删除，以达到回溯、不影响进入到下一个状态的目的。 </p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, length, depth, path, used, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> depth == length:  <span class="comment"># 递归结束条件：当前递归的层数=输入数组的长度</span></span><br><span class="line">                res.append(list(path))</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment"># 在满足条件return之后，depth-1=2，i =2顺次执行状态重置的代码。path = [1, 2], used = [True, True, False]</span></span><br><span class="line">                <span class="comment"># 至于它为什么可以继续执行上一步的状态重置，而不需要再次进入if语句是因为！！！在我们把第三个True置为False，并把3 pop之后，本层调用已经结束了,因为所有的可能已经都调用完了，该函数的子孙们都被解决掉了，[1, 2]后面不会在加上除了3以外的数字</span></span><br><span class="line">                <span class="comment"># 回到上一层，depth = 1, i = 1 </span></span><br><span class="line">                <span class="comment"># dfs(nums, length, depth + 1, path, used, res)就是个单纯的语句了，就继续往下执行代码啦，</span></span><br><span class="line">                <span class="comment"># 然后又来到了状态重置这里，改变第二个位置的状态[True, False, False]，pop(), path = [1],</span></span><br><span class="line">                <span class="comment"># 进入for</span></span><br><span class="line">                <span class="comment"># depth = 1, i = 2, used = [True, False, True], path = [1, 3]</span></span><br><span class="line">                <span class="comment"># dfs(nums, length, depth + 1, path, used, res)进入下一层</span></span><br><span class="line">                <span class="comment"># depth = 2, i = 0, used[0] = True, path = [1, 3], </span></span><br><span class="line">                <span class="comment"># depth = 2, i = 1, used[1] = False, used = [True, True, True], path = [1, 3, 2], </span></span><br><span class="line">                <span class="comment"># return i =1,</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在非叶子结点处，产生不同的分支，</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:  <span class="comment"># 当前未选择的数中依次选择一个元素作为下一个位置的元素，flase才能</span></span><br><span class="line">                    used[i] = <span class="literal">True</span>  <span class="comment"># 标记为已经选择的元素</span></span><br><span class="line">                    path.append(nums[i])  <span class="comment"># 把选择的元素添加到栈的末尾</span></span><br><span class="line">                    print(<span class="string">'递归前 used ='</span>, used, <span class="string">', path ='</span>, path)</span><br><span class="line"></span><br><span class="line">                    dfs(nums, length, depth + <span class="number">1</span>, path, used, res)</span><br><span class="line">                    <span class="comment"># 下一层结点的递归执行结束以后，</span></span><br><span class="line">                    <span class="comment"># 它后面的语句是表示程序要回退到上一个结点进行相关操作</span></span><br><span class="line">                    <span class="comment"># （这里要结合图形来理解）。</span></span><br><span class="line">                    <span class="comment"># 不是因为写了 used[i] = False 和 path.pop() 才有回退</span></span><br><span class="line">                    print(<span class="string">'递归后 used ='</span>, used, <span class="string">', path ='</span>, path)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 下面这两行代码发生 「回溯」，为了保证在回退的时候，相关数据也正确，最终结果才会正确。</span></span><br><span class="line">                    <span class="comment"># 回溯发生在从 深层结点 回到 浅层结点 的过程，</span></span><br><span class="line">                    <span class="comment"># 代码在形式上和递归之前是对称的</span></span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        length = len(nums)  <span class="comment"># 输入数组的长度</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:  <span class="comment"># 如果输入数组是一个空数组</span></span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment"># 返回一个空列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化每个元素都为 false，表示这些数还没有被选择，空间换时间</span></span><br><span class="line">        used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]</span><br><span class="line">        <span class="comment"># print([False for _ in range(3)])  # [False, False, False]</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        dfs(nums, length, <span class="number">0</span>, [], used, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.permute(nums)</span><br><span class="line">    print(res)</span><br></pre></td></tr></tbody></table></figure>

<p>因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。</p>
<p>它们的区别仅在于</p>
<p>1、二进制右边是低位，数组左边是索引为 0 的位置；</p>
<p>2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。</p>
<p>因此，完全可以用一个整数表示一个布尔型数组。</p>
<p>我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。</p>
<p>异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。</p>
<p>具体说来：</p>
<p>把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。</p>
<p>因为一个整数的二进制表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。</p>
<p>它们的区别仅在于</p>
<p>1、二进制右边是低位，数组左边是索引为 0 的位置；</p>
<p>2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。</p>
<p>因此，完全可以用一个整数表示一个布尔型数组。</p>
<p>我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。</p>
<p>异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。</p>
<p>具体说来：</p>
<p>把数组索引为 i 的位置从 0 变成 1（或者由 1 变成 0）就等价于把一个整数异或上 1 &lt;&lt; i。只不过布尔数组中是从左向右第 i 位的的值变化了，在整型变量中，是从右向左第 i 位的值变化了（这里 i 从 0 开始）。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = k = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_func</span>(<span class="params">first=<span class="number">0</span></span>):</span></span><br><span class="line">            <span class="comment"># first等于k时返回，代表着是计算A(n,k)的全排列问题，应题目要求此时k==n</span></span><br><span class="line">            <span class="keyword">if</span> first == k:</span><br><span class="line">                res.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">                <span class="comment"># 用first选定nums中每个位置，取值是[0, n-1]</span></span><br><span class="line">                <span class="comment"># 用交换来选定first位置上所有可能的元素</span></span><br><span class="line">                <span class="comment"># 当first=0时有n个元素可以放到first位置</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">                <span class="comment"># first位置放好元素之后，用递归去放first+1位置的元素，它有n-1种取值</span></span><br><span class="line">                back_func(first+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 当将k个位置都放好元素之后函数会return，但别忘了撤销交换操作，</span></span><br><span class="line">                <span class="comment"># 因为此时的first位置还要继续for循环和其它的i位置交换元素</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">        back_func()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">first = <span class="number">0</span></span>):</span></span><br><span class="line">            <span class="comment"># 所有数都填完了</span></span><br><span class="line">            <span class="keyword">if</span> first == n:  </span><br><span class="line">                res.append(nums[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(first, n):</span><br><span class="line">                <span class="comment"># 动态维护数组</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">                <span class="comment"># 继续递归填下一个数</span></span><br><span class="line">                backtrack(first + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销操作</span></span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, tmp</span>):</span>  <span class="comment"># temp为临时列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 已经选完所有的元素了，可以结束</span></span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="comment"># backtrack函数，确定好递归的终点和当前一步转移到下一步的递归的写法，然后从起点开始调用这个递归函数就行了。</span></span><br><span class="line">                <span class="comment"># nums[:i] + nums[i+1:] 对nums当中除了第i个数之外的数进行遍历</span></span><br><span class="line">                backtrack(nums[:i] + nums[i+<span class="number">1</span>:], tmp + [nums[i]])</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]  <span class="comment"># 记录那些元素已经访问</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">numbers, result, cur, visit</span>):</span></span><br><span class="line">            <span class="keyword">if</span> len(cur) == len(numbers):</span><br><span class="line">                result.append(cur[:])  <span class="comment"># 这里记得用cur[:]或拷贝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">                <span class="keyword">if</span> visit[i]:  <span class="comment"># 如果已经访问过某元素，直接跳过进下一个元素</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(numbers[i])</span><br><span class="line">                visit[i] = <span class="literal">True</span>  <span class="comment"># 将访问过的元素标记</span></span><br><span class="line">                dfs(numbers, result, cur, visit)</span><br><span class="line">                cur.pop()  <span class="comment"># 恢复到之前状态</span></span><br><span class="line">                visit[i] = <span class="literal">False</span>  <span class="comment"># 恢复到之前状态</span></span><br><span class="line"></span><br><span class="line">        dfs(nums, res, [], visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<p>递归</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:  <span class="comment"># 递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            res_nums = nums[:idx] + nums[idx + <span class="number">1</span>:]  <span class="comment"># 确定剩余元素</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.permute(res_nums):  </span><br><span class="line">                res.append([num] + j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>


<h2 id="组数总和"><a href="#组数总和" class="headerlink" title="组数总和"></a>组数总和</h2><p><strong>给定一个无重复元素的数组&nbsp;candidates&nbsp;和一个目标数&nbsp;target&nbsp;，找出&nbsp;candidates&nbsp;中所有可以使数字和为&nbsp;target&nbsp;的组合。candidates&nbsp;中的数字可以无限制重复被选取。</strong></p>
<p>说明：</p>
<ul>
<li>所有数字（包括&nbsp;target）都是正整数。</li>
<li>解集不能包含重复的组合。&nbsp;<br>示例&nbsp;1：<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
示例&nbsp;2：<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">&nbsp; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">&nbsp; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">&nbsp; [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>思路分析：根据示例 1：输入: candidates = [2, 3, 6, 7]，target = 7。</p>
<p>候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；<br>同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。</p>
<p>先画出树形图，然后编码实现。</p>
<h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h2><p>**序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。**</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。<br>不能有任何辅助信息帮助完成序列化和反序列化。<br>LeetCode的测试方式是事先提供一个二叉树，然后跑一下你的序列化代码，然后将你序列化的返回的字符串作为反序列化的输入，比较还原的二叉树和原始二叉树的序列化结果是否一致，说明你的方法就对了。你事先把结果保存了，比如你在序列化的时候如果保存了 root 为类的成员，<br>然后在反序列化中直接返回存储的 root，<br>这样题目就没有意义了，防止你使用作弊方式来通过测试，</p>
<p>DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。<br>根据根节点、左节点和右节点之间的相对顺序，<br>可以进一步将DFS策略区分为：先序遍历、中序遍历、后序遍历</p>
<p>示例: </p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">你可以将以下二叉树：</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     <span class="string">/</span> <span class="string">\</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      <span class="string">/</span>   <span class="string">\</span></span><br><span class="line">     <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">    <span class="string">/</span> <span class="string">\</span>   <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="string">X</span>   <span class="string">X</span>  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">        <span class="string">/</span> <span class="string">\</span>  <span class="string">/</span> <span class="string">\</span></span><br><span class="line">       <span class="string">X</span>   <span class="string">X</span> <span class="string">X</span>  <span class="string">X</span>       </span><br><span class="line"><span class="string">序列化为</span> <span class="string">"[1,2,None,None,3,4,None,None,5,None,None]"</span></span><br><span class="line"><span class="string">None,None,</span> <span class="string">是用来标记缺少左、右子节点</span></span><br><span class="line"><span class="string">遇到</span> <span class="string">None</span> <span class="string">节点也要翻译成一个符号，反序列化时才知道这里对应</span> <span class="string">None。</span></span><br><span class="line"><span class="string">为使反序列化可行，考虑将越过叶节点后的</span> <span class="literal">null</span> <span class="string">也看作是节点。</span></span><br><span class="line"></span><br><span class="line"><span class="string">在此基础上，对于列表中任意某节点</span> <span class="string">node</span> <span class="string">，</span></span><br><span class="line"><span class="string">其左子节点</span> <span class="string">node.left</span> <span class="string">和右子节点</span> <span class="string">node.right</span> <span class="string">在序列中的位置都是</span> <span class="string">唯一确定</span> <span class="string">的。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>递归遍历一棵树，只需关注当前的根节点就好，它的子树的遍历交给递归完成：</p>
<ul>
<li>“serialize函数，请帮我序列化我的左右子树，我等你的返回结果，再追加到我身上。”</li>
</ul>
</li>
<li><p>选择前序遍历是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。<br>先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。</p>
</li>
</ul>
<p>何反序列化呢？<br>前序遍历的序列化后的字符串呈现这样的排列：<br>“根|(根|(根|左|右)|(根|左|右))|(根|(根|左|右)|(根|左|右))”<br>序列化得到的字符串序列，通过指定分隔符逗号，对字符串进行切片，返回分割后的字符串列表，转化为数组，先序遍历的元素列表<br>然后从左向右遍历dataList列表，依次弹出 dataList 数组的首项，用它构建当前子树的根节点，</p>
<ul>
<li>如果当前的元素(字符)为 ‘X’ ，返回 None，</li>
<li>如果它不为 ‘X’，则为它创建节点，并递归调用 buildTree 构建左右子树，当前子树构建完毕，返回当前子树 </li>
</ul>
<p>时间复杂度O(n)：在序列化和反序列化函数中，我们只访问每个节点一次，其中 n 是节点数，即树的大小。<br>空间复杂度O(n)：在序列化和反序列化函数中，我们递归会使用栈空间</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span> <span class="comment"># 要求转化成字符串格式</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="comment"># 遇到None节点，“翻译”成X                </span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'null,'</span>  <span class="comment"># 字符串类型</span></span><br><span class="line">            <span class="comment"># if root:</span></span><br><span class="line">            <span class="comment"># 左子树的序列化的字符串</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            <span class="comment"># 右子树的序列化的字符串</span></span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            <span class="comment"># 按 根|左|右 顺序拼接</span></span><br><span class="line">            <span class="keyword">return</span> str(root.val) + <span class="string">','</span> + left + right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># 由前序遍历的list，由序列化字符串转成，返回这棵树</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">data</span>):</span></span><br><span class="line">            <span class="comment"># 输入为序列化字符串转成的 list 数组</span></span><br><span class="line">            val = data.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'null'</span>:</span><br><span class="line">                <span class="comment"># 是X，就返回None节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 不是X，则创建节点</span></span><br><span class="line">            node = TreeNode(val)  <span class="comment"># 实例化一个节点</span></span><br><span class="line">            node.left = dfs(data)  <span class="comment"># 构建左子树</span></span><br><span class="line">            node.right = dfs(data)  <span class="comment"># 构建右子树</span></span><br><span class="line">            <span class="keyword">return</span> node  <span class="comment"># 返回当前构建好的子树</span></span><br><span class="line"></span><br><span class="line">        dataList = data.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(dataList)  <span class="comment"># 构建的入口</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然序列化的时候结尾会多出一个逗号，然后反序列化split列表会处理这个逗号，然后正确地建树。最后会多出一个空字符串，但是并没有影响，反序列化的时候就是序列化方式并不唯一，是自己制定的，只要你能按照你序列化的规则再反序列化把树正确地建出来就行。</p>
<p>序列化</p>
<figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = <span class="number">2</span></span><br><span class="line">left = dfs(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line"></span><br><span class="line">root = <span class="number">1</span></span><br><span class="line">root =<span class="built_in"> root</span>.right = <span class="number">3</span></span><br><span class="line">right = dfs(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = <span class="number">4</span></span><br><span class="line">left = dfs(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">回到上一层</span><br><span class="line">root = <span class="number">3</span></span><br><span class="line">root =<span class="built_in"> root</span>.right = <span class="number">5</span></span><br><span class="line">right = dfs(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.left = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br><span class="line"></span><br><span class="line">root =<span class="built_in"> root</span>.right = None</span><br><span class="line"><span class="keyword">return</span> <span class="string">'X'</span></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">'X,'</span></span><br><span class="line">        leftserilized = self.serialize(root.left)</span><br><span class="line">        rightserilized = self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> str(root.val) + <span class="string">','</span> + leftserilized + rightserilized</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        dataList = data.split(<span class="string">','</span>)</span><br><span class="line">        root = self.buildTree(dataList)</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        val = data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">'X'</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        node.left = self.buildTree(data)</span><br><span class="line">        node.right = self.buildTree(data)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></tbody></table></figure>

<p>法三，最快，击败99%</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(str(node.val))</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(<span class="string">"#"</span>)</span><br><span class="line"></span><br><span class="line">        vals = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(vals)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            v = next(vals)</span><br><span class="line">            <span class="keyword">if</span> v == <span class="string">"#"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(int(v))</span><br><span class="line">            node.left = dfs()</span><br><span class="line">            node.right = dfs()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        vals = iter(data.split(<span class="string">","</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs()</span><br></pre></td></tr></tbody></table></figure>

<p>BFS 可以按照层次的顺序从上到下遍历所有的节点 利用队列<br>示例: </p>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      /   \</span><br><span class="line">     <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">    / \   /  \</span><br><span class="line">   X   X  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">        / \  / \</span><br><span class="line">       X   X X  X       </span><br><span class="line">序列化为字符串 <span class="string">"[1,2,3,X,X,4,5,X,X,X,X]"</span></span><br><span class="line">X,X, 是用来标记缺少左、右子节点</span><br><span class="line">遇到越过叶节点的 None 节点也要翻译成一个符号，反序列化时才知道这里对应 None。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>算法流程：</p>
<ol>
<li>特例处理： 若 root 为空，则直接返回空列表 “[]” ；</li>
<li>初始化： 队列 queue （包含根节点 root ）；序列化列表 res ；</li>
<li>层序遍历： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>若 node 不为空：<ol>
<li>将它的值推入一个数组 res ，打印字符串 node.val 让子节点 None 也入列，，</li>
<li>将左、右子节点入列 queue ；</li>
</ol>
</li>
<li>否则（若 node 为空）：将 ‘null’ 推入 res 数组，打印字符串 “null” ；</li>
</ol>
</li>
<li>返回值： 拼接列表（用 ‘,’ 隔开，首尾添加中括号）。将它转成字符串，就是序列化字符串。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N + 1 个 null ，总体复杂度为 O(2N + 1) = O(N) 。<br>空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储 (N + 1)/2 个节点（或 N+1 个 null），使用 O(N) ；列表 res 使用 O(N) 。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>除了第一个是根节点的值，其他节点值都是成对的，对应左右子节点。<br>我们用一个指针从第二项开始扫描，每次考察两个节点值。</p>
<p>起初用根节点值构建根节点，并让它入列。<br>让节点出列，考察出列的节点，指针指向的字符是它的左子节点，指针右边的字符是它的右子节点。<br>如果子节点值不为 ‘X’，则为它创建节点，并认父亲，并作为未来的父亲入列。<br>如果子节点值为 ‘X’，什么都不用做。<br>所有的父节点（真实节点）都会在队列里走一遍。</p>
<p>基于本文一开始分析的 “ node, node.left, node.right ” 在序列化列表中的位置关系，可实现反序列化。</p>
<p>利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</p>
<p>算法流程：</p>
<ol>
<li>特例处理： 若 data 为空，直接返回 null ；</li>
<li>初始化： 序列化列表 vals （先去掉首尾中括号，再用逗号隔开），<br>指针 i = 1 ，根节点 root （值为 vals[0] ），队列 queue（包含 root ）；</li>
<li>按层构建： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>构建 node 的左子节点：node.left 的值为 vals[i] ，并将 node.left 入队；</li>
<li>执行 i+=1 ；</li>
<li>构建 node 的右子节点：node.right 的值为 vals[i] ，并将 node.right 入队；</li>
<li>执行 i+=1 ；</li>
</ol>
</li>
<li>返回值： 返回根节点 root 即可。</li>
</ol>
<p>时间复杂度 O(N) ： N 为二叉树的节点数，按层构建二叉树需要遍历整个 vals ，其长度最大为 2N+1 。<br>空间复杂度 O(N) ： 最差情况下，假如是一颗满二叉树，最后一排空节点个数为2N+1/2，队列 queue 同时存储 (N + 1)/2 个节点，因此使用 O(N) 额外空间。</p>
<p>如果想在去掉多余的null上实现可逆，可以尝试在序列化的最后加一个while loop去掉 null，然后反序列化的时候把输入的‘data’作为queue 来做后续操作（可以节省因为子节点过多而多花费的判断null的时间）</p>
<p>序列化</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">queue = [1]</span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">res = [1]</span><br><span class="line">queue = [2, 3]</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2 </span><br><span class="line">res = [1, 2]</span><br><span class="line">queue = [3, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = 3 </span><br><span class="line">res = [1, 2, 3]</span><br><span class="line">queue = [None, None, 4, 5]</span><br><span class="line"></span><br><span class="line">queue = [None, 4, 5]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, None] </span><br><span class="line"></span><br><span class="line">queue = [4, 5]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, None, None] </span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4] </span><br><span class="line">queue = [5, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = 5</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5] </span><br><span class="line">queue = [None, None, None, None]</span><br><span class="line"></span><br><span class="line">queue = [None, None, None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = [None, None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = [None]</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>] </span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = None</span><br><span class="line">res = [1, 2, 3, <span class="literal">null</span>, <span class="literal">null</span>, 4, 5, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>] </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">','</span>.join(res) + <span class="string">']'</span></span><br><span class="line">        <span class="comment"># res.append(node.val + ","); </span></span><br><span class="line">        <span class="comment"># 可以优化成 res.append(node.val).append(",")。因为拼接字符串可能增大消耗。</span></span><br><span class="line">        <span class="comment"># +号就是把字符串拼接起来的意思，因为中括号是字符串类型，所以要加一个' ', </span></span><br><span class="line">        <span class="comment"># 就和你输出'hello world'一样，输出结果其实并没有' '，你跑一下结果就知道了，就是[1,2,3,null,null,4,5]，那个题目里的引号只是告诉你结果是引号里的东西(是字符串类型，而不是数组类型)，结果就是那串字符 [1,2,3,null,null,4,5] 并不是结果要带引号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> data==<span class="string">'[]'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 去除第一个和最后一个字符串，也就是去掉两个单括号</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        <span class="comment"># TreeNode 的 val 变量是 int 类型</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>]))  <span class="comment"># 实例化一个节点</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                <span class="comment"># 构建左子树</span></span><br><span class="line">                node.left = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                <span class="comment"># 构建右子树</span></span><br><span class="line">                node.right = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>

<p>反序列化</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">'[1, 2, 3, null, null, 4, 5, null, null, null, null]'</span> </span><br><span class="line">print(data, type(data))</span><br><span class="line"><span class="comment"># [1, 2, 3, null, null, 4, 5, null, null, null, null] &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>], type(data[<span class="number">1</span>:<span class="number">-1</span>]))</span><br><span class="line"><span class="comment"># 1, 2, 3, null, null, 4, 5, null, null, null, null &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), type(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>)))</span><br><span class="line"><span class="comment"># ['1', ' 2', ' 3', ' null', ' null', ' 4', ' 5', ' null', ' null', ' null', ' null'] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">'[1,2,3,null,null,4,5,null,null,null,null]'</span> </span><br><span class="line">print(data, type(data))</span><br><span class="line"><span class="comment"># [1,2,3,null,null,4,5,null,null,null,null] &lt;class 'str'&gt; </span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>], type(data[<span class="number">1</span>:<span class="number">-1</span>]))</span><br><span class="line"><span class="comment"># 1,2,3,null,null,4,5,null,null,null,null &lt;class 'str'&gt;</span></span><br><span class="line">print(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), type(data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>)))</span><br><span class="line"><span class="comment"># ['1', '2', '3', 'null', 'null', '4', '5', 'null', 'null', 'null', 'null'] &lt;class 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">a = [<span class="string">'1'</span>, <span class="string">' 2'</span>, <span class="string">' 3'</span>]</span><br><span class="line">b = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">print(type(a[<span class="number">2</span>]), type(b[<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># &lt;class 'str'&gt; &lt;class 'str'&gt;</span></span><br><span class="line">print(a[<span class="number">2</span>], b[<span class="number">2</span>], a[<span class="number">2</span>] == b[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 3 3 False</span></span><br><span class="line">print(a[<span class="number">0</span>], b[<span class="number">0</span>], a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 1 1 True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">vals = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>, <span class="string">'null'</span>]</span><br><span class="line">type(vals) = &lt;class <span class="string">'list'</span>&gt;</span><br><span class="line"></span><br><span class="line">root = = TreeNode(int(vals[0])) = 1</span><br><span class="line">queue = [1]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">vals[i] 都是 str 类型 i初始值为1</span><br><span class="line">vals[i] = vals[1] = <span class="string">'2'</span></span><br><span class="line">node.left = 2 </span><br><span class="line">queue = [2]</span><br><span class="line">i = 2</span><br><span class="line">vals[i] = vals[2] = <span class="string">'3'</span></span><br><span class="line">node.right = 3</span><br><span class="line">queue = [2, 3]</span><br><span class="line">i = 3</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2</span><br><span class="line">vals[i] = vals[3] = <span class="string">'null'</span></span><br><span class="line">i = 4</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 5</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 3</span><br><span class="line">vals[i] = vals[5] = <span class="string">'4'</span></span><br><span class="line">node.left = 4</span><br><span class="line">queue = [4]</span><br><span class="line">i = 6</span><br><span class="line">vals[i] = vals[6] = <span class="string">'5'</span></span><br><span class="line">node.right = 5</span><br><span class="line">queue = [4，5]</span><br><span class="line">i = 7</span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">vals[i] = vals[7] = <span class="string">'null'</span></span><br><span class="line">i = 8</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 9</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 5</span><br><span class="line">vals[i] = vals[9] = <span class="string">'null'</span></span><br><span class="line">i = 10</span><br><span class="line">vals[i] = vals[4] = <span class="string">'null'</span></span><br><span class="line">i = 11</span><br><span class="line"></span><br><span class="line">queue = [] queue为空，结束循环</span><br><span class="line">空子树不用赋值</span><br></pre></td></tr></tbody></table></figure>


<p>法二</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res += str(node.val) + <span class="string">','</span></span><br><span class="line">                queue.append(node.left)  <span class="comment"># 不管是不是None节点都入列</span></span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 是None节点</span></span><br><span class="line">                res += <span class="string">'X,'</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        data = data.split(<span class="string">','</span>)</span><br><span class="line">        root = TreeNode(data.pop(<span class="number">0</span>))</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                val = data.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'X'</span>:</span><br><span class="line">                    node.left = TreeNode(val)</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                val = data.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> val != <span class="string">'X'</span>:</span><br><span class="line">                    node.right = TreeNode(val)</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>


<p>反序列化</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">data = [1,2,3,None,None,4,5,None,None,None,None]</span><br><span class="line"></span><br><span class="line">data = [2,3,None,None,4,5,None,None,None,None]</span><br><span class="line">root = 1</span><br><span class="line">queue = [1]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 1</span><br><span class="line">data = [3,None,None,4,5,None,None,None,None]</span><br><span class="line">val = 2</span><br><span class="line">queue = [2]</span><br><span class="line"></span><br><span class="line">data = [None,None,4,5,None,None,None,None]</span><br><span class="line">val = 3</span><br><span class="line">queue = [2, 3]</span><br><span class="line"></span><br><span class="line">queue = [3]</span><br><span class="line">node = 2</span><br><span class="line">data = [None,4,5,None,None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [3]</span><br><span class="line"></span><br><span class="line">data = [4,5,None,None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [3]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 3</span><br><span class="line">data = [5,None,None,None,None]</span><br><span class="line">val = 4</span><br><span class="line">queue = [4]</span><br><span class="line"></span><br><span class="line">data = [None,None,None,None]</span><br><span class="line">val = 5</span><br><span class="line">queue = [4, 5]</span><br><span class="line"></span><br><span class="line">queue = [5]</span><br><span class="line">node = 4</span><br><span class="line">data = [None,None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [5]</span><br><span class="line"></span><br><span class="line">data = [None,None]</span><br><span class="line">val = None</span><br><span class="line">queue = [5]</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">node = 5</span><br><span class="line">data = [None]</span><br><span class="line">val = None</span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">val = None</span><br><span class="line">queue = [] queue为空，结束循环</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：</p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-attr">[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span></span><br><span class="line">输出：<span class="selector-attr">[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例 2：</p>
<figure class="highlight smalltalk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="comment">"H"</span>,<span class="comment">"a"</span>,<span class="comment">"n"</span>,<span class="comment">"n"</span>,<span class="comment">"a"</span>,<span class="comment">"h"</span>]</span><br><span class="line">输出：[<span class="comment">"h"</span>,<span class="comment">"a"</span>,<span class="comment">"n"</span>,<span class="comment">"n"</span>,<span class="comment">"a"</span>,<span class="comment">"H"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>（1）使用 list 本身的reverse() 方法</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reversed(s)        <span class="comment"># Python内置reverse()函数可以反转一个可迭代序列</span></span><br><span class="line">&lt;list_reverseiterator object at <span class="number">0x0000014C63AF5CF8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed(s))  <span class="comment"># 强转成list</span></span><br><span class="line">[<span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s                  <span class="comment"># s本身并没有修改</span></span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.reverse()        <span class="comment"># 使用list本身的reverse方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s                  <span class="comment"># s被改为倒序</span></span><br><span class="line">[<span class="string">"o"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"e"</span>,<span class="string">"h"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>（2）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```s[:]```浅拷贝 表示数组中所有子模块，</span><br><span class="line">```s[:]=s[::-1]```表示将原数组反转后赋值给s中每一个对应的位置</span><br><span class="line">```s=s[::-1]```表示将s反转后赋值给新的对象s（可以通过id函数查看内存地址），与题意原地修改不符。</span><br><span class="line">```py</span><br><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        """</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        """</span><br><span class="line">        s[:]=s[::-1]</span><br></pre></td></tr></tbody></table></figure>

<p>（3）双指针<br>思路与算法<br>对于长度为 N 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 s[0] s[1] s[2] … s[N - 1]，那么反转后字符数组为 s[N - 1] s[N - 2] … s[0]。比较反转前后下标变化很容易得出 s[i] 的字符与 s[N - 1 - i] 的字符发生了交换的规律</p>
<ul>
<li>初始化：left 指向数组第一个元素，right 指向数组最后一个元素，</li>
<li>步骤：<ul>
<li>当 left &lt; right：<ul>
<li>把 left 和 right 指向的元素交换一下，交换s[left]和s[right]对应元素，</li>
<li>left 指针后移，right 指针前移，left+=1,right-=1，</li>
<li>再把它两个交换，以此类推，</li>
</ul>
</li>
<li>当 left &gt;= right<br>直到 left 和 right 相遇指向同一个元素，这样就得到了一个倒序的序列。</li>
</ul>
</li>
<li>时间复杂度：O(N)，其中 N 为字符数组的长度。一共执行了 N/2 次的交换。</li>
<li>空间复杂度：O(1)。只使用了常数空间来存放若干变量。</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[str]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        right = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><p><strong>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</strong><br>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>示例 1:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">-121</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从左向右读,</span> <span class="string">为</span> <span class="number">-121</span> <span class="string">。</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">121</span><span class="bullet">-</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></tbody></table></figure>

<p>示例 3:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="number">10</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">解释:</span> <span class="string">从右向左读,</span> <span class="string">为</span> <span class="number">01</span> <span class="string">。因此它不是一个回文数。</span></span><br></pre></td></tr></tbody></table></figure>

<p>法一：<br>思路：<br>首先，我们应该处理一些临界情况。</p>
<ul>
<li>负数都不可能是回文，直接返回False，如：’-1 ‘ 不是回文，因为 - 不等于 1。</li>
<li>如果整数的最后一位是 0、能被10整除，为了使该数字为回文，则其第一位数字也应该是 0，只有 0 满足这一属性</li>
<li>除了 0 以外，正整数最后一位个位是 0、能被10整除，那它不是回文数，因为最高位首位肯定不是 0 。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</li>
</ul>
<p>流程：<br>判断 x 是否为负数，如果是负数直接返回；<br>反转 x , 如果反转之后的值与原来的值不同直接返回 false ；<br>如果不为负数，同时与反转后的值相等则返回 true</p>
<p><strong>不将整数转为字符串，将数字本身反转，然后将反转后的数字与原始数字进行比较</strong>，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。如果真是回文，是不可能溢出的；若非回文，溢出就会成为负数，自然也就跟原数不相等了</p>
<p>为了避免数字反转可能导致的溢出问题，考虑<strong>只反转 int 数字的后一半</strong>，毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，<br>要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。<br>如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p>
<p>如何知道反转数字的位数已经达到原始数字位数的一半？<br>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，<br>所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p>
<p>步骤</p>
<ul>
<li>每次进行取余操作 %10 ，取出最低的数字：y = x % 10</li>
<li>将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y</li>
<li>每取一个最低位数字，x 都要自除以 10</li>
<li>判断 x 是不是小于等于 revertNum ，当它小于的时候，说明数字已经对半或者过半了</li>
<li>最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将revertNum除以 10 以后应该和 x 相等。</li>
</ul>
<p>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10<br>空间复杂度：O(1)。我们只需要整型常数空间存放若干变量。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 特殊情况：</span></span><br><span class="line">        <span class="comment"># 负数不是回文数</span></span><br><span class="line">        <span class="comment"># 如果数字的最后一位是 0、能被10整除，为了使该数字为回文，则其第一位数字也应该是 0，只有 0 满足这一属性</span></span><br><span class="line">        <span class="comment"># 正数最后一位是 0、能被10整除，那它不是回文数，因为首位肯定不是 0</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        revertedNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; revertedNumber:</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="comment"># 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment"># 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment"># 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber <span class="keyword">or</span> x == revertedNumber // <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    obj = Solution()</span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(12321))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(123321))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(-1))  # False</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(0))  # True</span></span><br><span class="line">    <span class="comment"># print(obj.isPalindrome(6))  # True</span></span><br><span class="line">    print(obj.isPalindrome(<span class="number">10</span>))  <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure>

<p>x = 12321 &gt; 0 = revertedNumber 数字长度为奇数<br>revertedNumber = revertedNumber * 10 + x % 10<br>revertedNumber = 0 * 10 + 12321 % 10 = 1<br>x = x // 10 = 1232 &gt; revertedNumber<br>revertedNumber = 1 * 10 + 1232 % 10 = 12<br>x = x // 10 = 123 &gt; revertedNumber<br>revertedNumber = 12 * 10 + 123 % 10 = 123<br>x = x // 10 = 12 &lt; revertedNumber<br>x = 12 = revertedNumber // 10 = 123 // 10<br>return True</p>
<p>x = 123321 &gt; 0 = revertedNumber 数字长度为偶数<br>revertedNumber = revertedNumber * 10 + x % 10<br>revertedNumber = 0 * 10 + 123321 % 10 = 1<br>x = x // 10 = 12332 &gt; revertedNumber<br>revertedNumber = 1 * 10 + 12332 % 10 = 12<br>x = x // 10 = 1233 &gt; revertedNumber<br>revertedNumber = 12 * 10 + 1233 % 10 = 123<br>x = x // 10 = 123 = revertedNumber<br>return True</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="comment">// 特殊情况：</span></span><br><span class="line">    <span class="comment">// 负数不是回文数</span></span><br><span class="line">    <span class="comment">// 如果数字的最后一位是 0、能被10整除，为了使该数字为回文，则其第一位数字也应该是 0，只有 0 满足这一属性</span></span><br><span class="line">    <span class="comment">// 正数最后一位是 0、能被10整除，那它不是回文数，因为首位肯定不是 0</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x%<span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    revertedNumber := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x &gt; revertedNumber {</span><br><span class="line">        revertedNumber = revertedNumber*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">    <span class="comment">// 例如，当输入为 12321 时，在 for 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">    <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">    <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法二：<br>考虑大于等于 0 的时候，将整数转为字符串，需要额外的非常量空间来创建问题描述中所不允许的字符串。</p>
<p>定义两个指针一个指向第一个元素的首指针和一个指向末尾的尾指针，然后首指针后移，尾指针前移作对比，如果中间有不相等的就返回False，如果没有直到首尾指针相遇说明是一个回文数。</p>
<p>时间复杂度: O(N)<br>空间复杂度: O(N)</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>: <span class="comment"># 排除小于0的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> x != int(str(x)[::<span class="number">-1</span>]): <span class="comment"># 通过字符串进行反转，对比数字是否相等就行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> { <span class="comment">// 排除小于0的数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    xStr := strconv.Itoa(x)</span><br><span class="line">    xStrReverse := <span class="built_in">make</span>([]<span class="keyword">rune</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> xStr {</span><br><span class="line">        xStrReverse = <span class="built_in">append</span>(xStrReverse, <span class="keyword">rune</span>(xStr[<span class="built_in">len</span>(xStr)<span class="number">-1</span>-i]))</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(xStr); i += <span class="number">1</span> { <span class="comment">// 通过字符串进行反转，对比数字是否相等就行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">rune</span>(xStr[i]) != xStrReverse[i] {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 负数肯定不是回文数</span></span><br><span class="line">        s = str(x)        <span class="comment"># 把x转换成str</span></span><br><span class="line">        beg, end = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> beg &lt; end:          <span class="comment"># s是个位数的时候,end = 0不会执行到 while里</span></span><br><span class="line">            <span class="keyword">if</span> s[beg] == s[end]:</span><br><span class="line">                beg += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.isPalindrome(<span class="number">121</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">    print(s.isPalindrome(<span class="number">-1</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">    print(s.isPalindrome(<span class="number">1</span>) <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (str(x) == str(x)[::<span class="number">-1</span>])</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (x &gt;= <span class="number">0</span>) <span class="keyword">and</span> (x == int(str(x)[::<span class="number">-1</span>]))</span><br></pre></td></tr></tbody></table></figure>


<p>考虑只反转 int 数字的一半，判断前一半和后一半</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        s = str(x)</span><br><span class="line">        l = len(s)</span><br><span class="line">        h = l//<span class="number">2</span>  <span class="comment"># 除以2后向下取整</span></span><br><span class="line">        <span class="keyword">return</span> s[:h] == str(x)[<span class="number">-1</span>:-h<span class="number">-1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>s = ‘12321’<br>l = 5<br>h = 2<br>s[:h] = s[:2] = ‘12’<br>str(x)[-1:-h-1:-1] = str(x)[-1:-3:-1] = ‘12’</p>
<p>法三 全部反转</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 负数肯定不是palindrome</span></span><br><span class="line">        <span class="comment"># 如果一个数字是一个正数，并且能被10整除，那它肯定也不是palindrome，因为首位肯定不是0</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">10</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rev, y = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> y == rev</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="comment">// 负数肯定不是palindrome</span></span><br><span class="line">    <span class="comment">// 如果一个数字是一个正数，并且能被10整除，那它肯定也不是palindrome，因为首位肯定不是 0</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x%<span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    rev, y := <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">for</span> x &gt; <span class="number">0</span> {</span><br><span class="line">        rev = rev*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> y == rev</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>x = 123321 &gt; 0 = revertedNumber 数字长度为偶数<br>y = 123321<br>revertedNumber = revertedNumber * 10 + x % 10<br>revertedNumber = 0 * 10 + 123321 % 10 = 1<br>x = x // 10 = 12332 &gt; 0<br>revertedNumber = 1 * 10 + 12332 % 10 = 12<br>x = x // 10 = 1233 &gt; 0<br>revertedNumber = 12 * 10 + 1233 % 10 = 123<br>x = x // 10 = 123 &gt; 0<br>revertedNumber = 123 * 10 + 123 % 10 = 1233<br>x = x // 10 = 12 &gt; 0<br>revertedNumber = 1233 * 10 + 12 % 10 = 12332<br>x = x // 10 = 1 &gt; 0<br>revertedNumber = 12332 * 10 + 1 % 10 = 123321 = y<br>return True</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag"># 剑指offer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/jian-zhi-offer1-24-ti/" rel="prev" title="剑指offer1~24题">
                  <i class="fa fa-chevron-left"></i> 剑指offer1~24题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/21/liu-da-ji-ben-pai-xu/" rel="next" title="六大基本排序">
                  六大基本排序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">外心人D</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
